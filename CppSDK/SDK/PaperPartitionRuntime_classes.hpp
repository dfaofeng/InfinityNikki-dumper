#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PaperPartitionRuntime

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PaperPartitionRuntime_structs.hpp"


namespace SDK
{

// Class PaperPartitionRuntime.PaperPartition
// 0x06B8 (0x06E0 - 0x0028)
class UPaperPartition final : public UPaperWorldPartition
{
public:
	uint8                                         Pad_28[0x468];                                     // 0x0028(0x0468)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, int32>                   ReferenceHash;                                     // 0x0490(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ReferencedObjects;                                 // 0x04E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x1F0];                                    // 0x04F0(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartition">();
	}
	static class UPaperPartition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartition>();
	}
};
static_assert(alignof(UPaperPartition) == 0x000008, "Wrong alignment on UPaperPartition");
static_assert(sizeof(UPaperPartition) == 0x0006E0, "Wrong size on UPaperPartition");
static_assert(offsetof(UPaperPartition, ReferenceHash) == 0x000490, "Member 'UPaperPartition::ReferenceHash' has a wrong offset!");
static_assert(offsetof(UPaperPartition, ReferencedObjects) == 0x0004E0, "Member 'UPaperPartition::ReferencedObjects' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionStreamer
// 0x0168 (0x0190 - 0x0028)
class UPaperPartitionStreamer : public UObject
{
public:
	uint8                                         Pad_28[0x168];                                     // 0x0028(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionStreamer">();
	}
	static class UPaperPartitionStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionStreamer>();
	}
};
static_assert(alignof(UPaperPartitionStreamer) == 0x000008, "Wrong alignment on UPaperPartitionStreamer");
static_assert(sizeof(UPaperPartitionStreamer) == 0x000190, "Wrong size on UPaperPartitionStreamer");

// Class PaperPartitionRuntime.PaperPartitionCollisionStreamer
// 0x0100 (0x0290 - 0x0190)
class UPaperPartitionCollisionStreamer final : public UPaperPartitionStreamer
{
public:
	uint8                                         Pad_190[0x100];                                    // 0x0190(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionCollisionStreamer">();
	}
	static class UPaperPartitionCollisionStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionCollisionStreamer>();
	}
};
static_assert(alignof(UPaperPartitionCollisionStreamer) == 0x000008, "Wrong alignment on UPaperPartitionCollisionStreamer");
static_assert(sizeof(UPaperPartitionCollisionStreamer) == 0x000290, "Wrong size on UPaperPartitionCollisionStreamer");

// Class PaperPartitionRuntime.PaperPartitionMeshStreamer
// 0x0000 (0x0190 - 0x0190)
class UPaperPartitionMeshStreamer : public UPaperPartitionStreamer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionMeshStreamer">();
	}
	static class UPaperPartitionMeshStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionMeshStreamer>();
	}
};
static_assert(alignof(UPaperPartitionMeshStreamer) == 0x000008, "Wrong alignment on UPaperPartitionMeshStreamer");
static_assert(sizeof(UPaperPartitionMeshStreamer) == 0x000190, "Wrong size on UPaperPartitionMeshStreamer");

// Class PaperPartitionRuntime.PaperPartitionMicroStreamer
// 0x0000 (0x0190 - 0x0190)
class UPaperPartitionMicroStreamer final : public UPaperPartitionMeshStreamer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionMicroStreamer">();
	}
	static class UPaperPartitionMicroStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionMicroStreamer>();
	}
};
static_assert(alignof(UPaperPartitionMicroStreamer) == 0x000008, "Wrong alignment on UPaperPartitionMicroStreamer");
static_assert(sizeof(UPaperPartitionMicroStreamer) == 0x000190, "Wrong size on UPaperPartitionMicroStreamer");

// Class PaperPartitionRuntime.PaperPartitionMiscStreamer
// 0x0000 (0x0190 - 0x0190)
class UPaperPartitionMiscStreamer final : public UPaperPartitionStreamer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionMiscStreamer">();
	}
	static class UPaperPartitionMiscStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionMiscStreamer>();
	}
};
static_assert(alignof(UPaperPartitionMiscStreamer) == 0x000008, "Wrong alignment on UPaperPartitionMiscStreamer");
static_assert(sizeof(UPaperPartitionMiscStreamer) == 0x000190, "Wrong size on UPaperPartitionMiscStreamer");

// Class PaperPartitionRuntime.PaperPartitionSettings
// 0x0118 (0x0150 - 0x0038)
class UPaperPartitionSettings final : public UDeveloperSettings
{
public:
	float                                         GlobalDensityScaleForBuild;                        // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SplitMeshLimitCellNum;                             // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         RemapLayers;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class FString                                 BigWorldRootPath;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class FString>            BigWorldIterativePath;                             // 0x0060(0x0050)(Edit, Config, NativeAccessSpecifierPrivate)
	int32                                         StreamingCellSizeXY;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelStreamingRange;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MicroMeshScreenSize;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VastMeshScreenSize;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 VastStreamingFlag;                                 // 0x00C0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         CollisionCellRelativedPaths;                       // 0x00D0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class FString                                 OFPASourcePackagePath;                             // 0x00E0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         DeferConstructionFlags;                            // 0x00F0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           OFPAIgnoreClass;                                   // 0x0100(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           SplitIgnoreClass;                                  // 0x0110(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           SublevelIgnoreClass;                               // 0x0120(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class FString>                         PlatformList;                                      // 0x0130(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<class FString>                         AvoidDetachLayers;                                 // 0x0140(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionSettings">();
	}
	static class UPaperPartitionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionSettings>();
	}
};
static_assert(alignof(UPaperPartitionSettings) == 0x000008, "Wrong alignment on UPaperPartitionSettings");
static_assert(sizeof(UPaperPartitionSettings) == 0x000150, "Wrong size on UPaperPartitionSettings");
static_assert(offsetof(UPaperPartitionSettings, GlobalDensityScaleForBuild) == 0x000038, "Member 'UPaperPartitionSettings::GlobalDensityScaleForBuild' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, SplitMeshLimitCellNum) == 0x00003C, "Member 'UPaperPartitionSettings::SplitMeshLimitCellNum' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, RemapLayers) == 0x000040, "Member 'UPaperPartitionSettings::RemapLayers' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, BigWorldRootPath) == 0x000050, "Member 'UPaperPartitionSettings::BigWorldRootPath' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, BigWorldIterativePath) == 0x000060, "Member 'UPaperPartitionSettings::BigWorldIterativePath' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, StreamingCellSizeXY) == 0x0000B0, "Member 'UPaperPartitionSettings::StreamingCellSizeXY' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, LevelStreamingRange) == 0x0000B4, "Member 'UPaperPartitionSettings::LevelStreamingRange' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, MicroMeshScreenSize) == 0x0000B8, "Member 'UPaperPartitionSettings::MicroMeshScreenSize' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, VastMeshScreenSize) == 0x0000BC, "Member 'UPaperPartitionSettings::VastMeshScreenSize' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, VastStreamingFlag) == 0x0000C0, "Member 'UPaperPartitionSettings::VastStreamingFlag' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, CollisionCellRelativedPaths) == 0x0000D0, "Member 'UPaperPartitionSettings::CollisionCellRelativedPaths' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, OFPASourcePackagePath) == 0x0000E0, "Member 'UPaperPartitionSettings::OFPASourcePackagePath' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, DeferConstructionFlags) == 0x0000F0, "Member 'UPaperPartitionSettings::DeferConstructionFlags' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, OFPAIgnoreClass) == 0x000100, "Member 'UPaperPartitionSettings::OFPAIgnoreClass' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, SplitIgnoreClass) == 0x000110, "Member 'UPaperPartitionSettings::SplitIgnoreClass' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, SublevelIgnoreClass) == 0x000120, "Member 'UPaperPartitionSettings::SublevelIgnoreClass' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, PlatformList) == 0x000130, "Member 'UPaperPartitionSettings::PlatformList' has a wrong offset!");
static_assert(offsetof(UPaperPartitionSettings, AvoidDetachLayers) == 0x000140, "Member 'UPaperPartitionSettings::AvoidDetachLayers' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionLevelInfo
// 0x02D0 (0x02F8 - 0x0028)
class UPaperPartitionLevelInfo final : public UAssetUserData
{
public:
	struct FBox                                   LevelBounds;                                       // 0x0028(0x0038)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FBox>              MeshBoundsInfo;                                    // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, struct FBox>              ISMBoundsInfo;                                     // 0x00B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVector>           MiscActorPathAndLoacation;                         // 0x0100(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     MiscActorRelativeCollisionMap;                     // 0x0150(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<class UPaperPartitionStreamingCell*>   StreamingCells;                                    // 0x01A0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    CellNameToIndex;                                   // 0x01B0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FIntPoint, int32>                 CellCoordStackedInfo;                              // 0x0200(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<struct FIntPoint, struct FPPCollisionCellLevelInfos> CellCoordStackedLevelInfo;             // 0x0250(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class USceneComponent*, struct FPPSocketInfos> SocketComponentMap;                          // 0x02A0(0x0050)(Edit, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bEnhanceLevel;                                     // 0x02F0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionLevelInfo">();
	}
	static class UPaperPartitionLevelInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionLevelInfo>();
	}
};
static_assert(alignof(UPaperPartitionLevelInfo) == 0x000008, "Wrong alignment on UPaperPartitionLevelInfo");
static_assert(sizeof(UPaperPartitionLevelInfo) == 0x0002F8, "Wrong size on UPaperPartitionLevelInfo");
static_assert(offsetof(UPaperPartitionLevelInfo, LevelBounds) == 0x000028, "Member 'UPaperPartitionLevelInfo::LevelBounds' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, MeshBoundsInfo) == 0x000060, "Member 'UPaperPartitionLevelInfo::MeshBoundsInfo' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, ISMBoundsInfo) == 0x0000B0, "Member 'UPaperPartitionLevelInfo::ISMBoundsInfo' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, MiscActorPathAndLoacation) == 0x000100, "Member 'UPaperPartitionLevelInfo::MiscActorPathAndLoacation' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, MiscActorRelativeCollisionMap) == 0x000150, "Member 'UPaperPartitionLevelInfo::MiscActorRelativeCollisionMap' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, StreamingCells) == 0x0001A0, "Member 'UPaperPartitionLevelInfo::StreamingCells' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, CellNameToIndex) == 0x0001B0, "Member 'UPaperPartitionLevelInfo::CellNameToIndex' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, CellCoordStackedInfo) == 0x000200, "Member 'UPaperPartitionLevelInfo::CellCoordStackedInfo' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, CellCoordStackedLevelInfo) == 0x000250, "Member 'UPaperPartitionLevelInfo::CellCoordStackedLevelInfo' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, SocketComponentMap) == 0x0002A0, "Member 'UPaperPartitionLevelInfo::SocketComponentMap' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelInfo, bEnhanceLevel) == 0x0002F0, "Member 'UPaperPartitionLevelInfo::bEnhanceLevel' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionLevelPreprocess
// 0x0158 (0x0180 - 0x0028)
class UPaperPartitionLevelPreprocess final : public UAssetUserData
{
public:
	bool                                          IsEnHanceLevel;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FPPSubLevelActorReferenceInfos> ActorReferenceInfo;                   // 0x0030(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<class FString>                         RelativedSublevelPaths;                            // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, class FString>   RelativedPhys;                                     // 0x0090(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, class FString>   RelativedOFPA;                                     // 0x00E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, class FString>   RelativedStaticMesh;                               // 0x0130(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionLevelPreprocess">();
	}
	static class UPaperPartitionLevelPreprocess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionLevelPreprocess>();
	}
};
static_assert(alignof(UPaperPartitionLevelPreprocess) == 0x000008, "Wrong alignment on UPaperPartitionLevelPreprocess");
static_assert(sizeof(UPaperPartitionLevelPreprocess) == 0x000180, "Wrong size on UPaperPartitionLevelPreprocess");
static_assert(offsetof(UPaperPartitionLevelPreprocess, IsEnHanceLevel) == 0x000028, "Member 'UPaperPartitionLevelPreprocess::IsEnHanceLevel' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelPreprocess, ActorReferenceInfo) == 0x000030, "Member 'UPaperPartitionLevelPreprocess::ActorReferenceInfo' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelPreprocess, RelativedSublevelPaths) == 0x000080, "Member 'UPaperPartitionLevelPreprocess::RelativedSublevelPaths' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelPreprocess, RelativedPhys) == 0x000090, "Member 'UPaperPartitionLevelPreprocess::RelativedPhys' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelPreprocess, RelativedOFPA) == 0x0000E0, "Member 'UPaperPartitionLevelPreprocess::RelativedOFPA' has a wrong offset!");
static_assert(offsetof(UPaperPartitionLevelPreprocess, RelativedStaticMesh) == 0x000130, "Member 'UPaperPartitionLevelPreprocess::RelativedStaticMesh' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionVastStreamingInfo
// 0x0060 (0x0088 - 0x0028)
class UPaperPartitionVastStreamingInfo final : public UAssetUserData
{
public:
	TArray<struct FPPVastStreamingActor>          VastStreamingActors;                               // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FName>              VastActorOriMap;                                   // 0x0038(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionVastStreamingInfo">();
	}
	static class UPaperPartitionVastStreamingInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionVastStreamingInfo>();
	}
};
static_assert(alignof(UPaperPartitionVastStreamingInfo) == 0x000008, "Wrong alignment on UPaperPartitionVastStreamingInfo");
static_assert(sizeof(UPaperPartitionVastStreamingInfo) == 0x000088, "Wrong size on UPaperPartitionVastStreamingInfo");
static_assert(offsetof(UPaperPartitionVastStreamingInfo, VastStreamingActors) == 0x000028, "Member 'UPaperPartitionVastStreamingInfo::VastStreamingActors' has a wrong offset!");
static_assert(offsetof(UPaperPartitionVastStreamingInfo, VastActorOriMap) == 0x000038, "Member 'UPaperPartitionVastStreamingInfo::VastActorOriMap' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionActorProxy
// 0x0170 (0x0198 - 0x0028)
class UPaperPartitionActorProxy final : public UObject
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MiscActorSoftPath;                                 // 0x0030(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           Components;                                        // 0x0050(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UInstancedStaticMeshComponent*, class FString> InstanceComponents;                    // 0x0060(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0xE0];                                      // 0x00B0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	EPPActorType                                  ActorType;                                         // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionActorProxy">();
	}
	static class UPaperPartitionActorProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionActorProxy>();
	}
};
static_assert(alignof(UPaperPartitionActorProxy) == 0x000008, "Wrong alignment on UPaperPartitionActorProxy");
static_assert(sizeof(UPaperPartitionActorProxy) == 0x000198, "Wrong size on UPaperPartitionActorProxy");
static_assert(offsetof(UPaperPartitionActorProxy, Actor) == 0x000028, "Member 'UPaperPartitionActorProxy::Actor' has a wrong offset!");
static_assert(offsetof(UPaperPartitionActorProxy, MiscActorSoftPath) == 0x000030, "Member 'UPaperPartitionActorProxy::MiscActorSoftPath' has a wrong offset!");
static_assert(offsetof(UPaperPartitionActorProxy, Components) == 0x000050, "Member 'UPaperPartitionActorProxy::Components' has a wrong offset!");
static_assert(offsetof(UPaperPartitionActorProxy, InstanceComponents) == 0x000060, "Member 'UPaperPartitionActorProxy::InstanceComponents' has a wrong offset!");
static_assert(offsetof(UPaperPartitionActorProxy, ActorType) == 0x000190, "Member 'UPaperPartitionActorProxy::ActorType' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionStreamingCell
// 0x0100 (0x0128 - 0x0028)
class UPaperPartitionStreamingCell final : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              XYCoord;                                           // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 CellRange;                                         // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UPaperPartitionActorProxy*>      PartitionActors;                                   // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x58];                                      // 0x00D0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionStreamingCell">();
	}
	static class UPaperPartitionStreamingCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionStreamingCell>();
	}
};
static_assert(alignof(UPaperPartitionStreamingCell) == 0x000008, "Wrong alignment on UPaperPartitionStreamingCell");
static_assert(sizeof(UPaperPartitionStreamingCell) == 0x000128, "Wrong size on UPaperPartitionStreamingCell");
static_assert(offsetof(UPaperPartitionStreamingCell, XYCoord) == 0x0000A8, "Member 'UPaperPartitionStreamingCell::XYCoord' has a wrong offset!");
static_assert(offsetof(UPaperPartitionStreamingCell, CellRange) == 0x0000B0, "Member 'UPaperPartitionStreamingCell::CellRange' has a wrong offset!");
static_assert(offsetof(UPaperPartitionStreamingCell, PartitionActors) == 0x0000C0, "Member 'UPaperPartitionStreamingCell::PartitionActors' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionSubsystem
// 0x0218 (0x0248 - 0x0030)
class UPaperPartitionSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x210];                                     // 0x0030(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperPartition*                        PaperPartition;                                    // 0x0240(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionSubsystem">();
	}
	static class UPaperPartitionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionSubsystem>();
	}
};
static_assert(alignof(UPaperPartitionSubsystem) == 0x000008, "Wrong alignment on UPaperPartitionSubsystem");
static_assert(sizeof(UPaperPartitionSubsystem) == 0x000248, "Wrong size on UPaperPartitionSubsystem");
static_assert(offsetof(UPaperPartitionSubsystem, PaperPartition) == 0x000240, "Member 'UPaperPartitionSubsystem::PaperPartition' has a wrong offset!");

// Class PaperPartitionRuntime.PaperPartitionVastLevelStreamer
// 0x00C8 (0x00F0 - 0x0028)
class UPaperPartitionVastLevelStreamer final : public UObject
{
public:
	uint8                                         Pad_28[0xC8];                                      // 0x0028(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionVastLevelStreamer">();
	}
	static class UPaperPartitionVastLevelStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionVastLevelStreamer>();
	}
};
static_assert(alignof(UPaperPartitionVastLevelStreamer) == 0x000008, "Wrong alignment on UPaperPartitionVastLevelStreamer");
static_assert(sizeof(UPaperPartitionVastLevelStreamer) == 0x0000F0, "Wrong size on UPaperPartitionVastLevelStreamer");

// Class PaperPartitionRuntime.PaperPartitionVastStreamer
// 0x0000 (0x0190 - 0x0190)
class UPaperPartitionVastStreamer final : public UPaperPartitionMeshStreamer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPartitionVastStreamer">();
	}
	static class UPaperPartitionVastStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPartitionVastStreamer>();
	}
};
static_assert(alignof(UPaperPartitionVastStreamer) == 0x000008, "Wrong alignment on UPaperPartitionVastStreamer");
static_assert(sizeof(UPaperPartitionVastStreamer) == 0x000190, "Wrong size on UPaperPartitionVastStreamer");

}

