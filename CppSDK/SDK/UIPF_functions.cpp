#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UIPF

#include "Basic.hpp"

#include "UIPF_classes.hpp"
#include "UIPF_parameters.hpp"


namespace SDK
{

// Function UIPF.UIPFActor.DelayPhysEnabled
// (Final, Native, Public)

void AUIPFActor::DelayPhysEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "DelayPhysEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.Init
// (Final, Native, Public)
// Parameters:
// bool                                    bFromManual                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFActor::Init(bool bFromManual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "Init");

	Params::UIPFActor_Init Parms{};

	Parms.bFromManual = bFromManual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.SkeletonSleep
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              Comp                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             bone                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFActor::SkeletonSleep(class UPrimitiveComponent* Comp, class FName bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "SkeletonSleep");

	Params::UIPFActor_SkeletonSleep Parms{};

	Parms.Comp = Comp;
	Parms.bone = bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.TrySleep
// (Final, Native, Public)

void AUIPFActor::TrySleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "TrySleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFActor.UpdateTransition
// (Native, Protected)

void AUIPFActor::UpdateTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFActor", "UpdateTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFImpulse.InitializeImpulse
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ImpulseRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsingTruePhys                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsingShaderInt                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFImpulse::InitializeImpulse(float ImpulseRadius, bool UsingTruePhys, bool UsingShaderInt, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFImpulse", "InitializeImpulse");

	Params::UIPFImpulse_InitializeImpulse Parms{};

	Parms.ImpulseRadius = ImpulseRadius;
	Parms.UsingTruePhys = UsingTruePhys;
	Parms.UsingShaderInt = UsingShaderInt;
	Parms.ImpulseStrength = ImpulseStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFInteractor.GetCustomLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UUIPFInteractor::GetCustomLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "GetCustomLocation");

	Params::UIPFInteractor_GetCustomLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UIPF.UIPFInteractor.GetCustomVelocity
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UUIPFInteractor::GetCustomVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "GetCustomVelocity");

	Params::UIPFInteractor_GetCustomVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UIPF.UIPFInteractor.GetUIPFManagerToRegister
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AUIPFManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AUIPFManager* UUIPFInteractor::GetUIPFManagerToRegister()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "GetUIPFManagerToRegister");

	Params::UIPFInteractor_GetUIPFManagerToRegister Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UIPF.UIPFInteractor.ManuallyActivateFoliage
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    WithImpulse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UUIPFInteractor::ManuallyActivateFoliage(bool WithImpulse, float ImpulseStrength, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "ManuallyActivateFoliage");

	Params::UIPFInteractor_ManuallyActivateFoliage Parms{};

	Parms.WithImpulse = WithImpulse;
	Parms.ImpulseStrength = ImpulseStrength;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFInteractor.OnDeactivationEndOverlap
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIPFInteractor::OnDeactivationEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "OnDeactivationEndOverlap");

	Params::UIPFInteractor_OnDeactivationEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFInteractor.PhysCheck
// (Native, Protected)

void UUIPFInteractor::PhysCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFInteractor", "PhysCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.SetGlobalUIPFInteractive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::SetGlobalUIPFInteractive(class UObject* WorldContextObject, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIPFManager", "SetGlobalUIPFInteractive");

	Params::UIPFManager_SetGlobalUIPFInteractive Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.DrawUIPFMaterialtoRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::DrawUIPFMaterialtoRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "DrawUIPFMaterialtoRenderTarget");

	Params::UIPFManager_DrawUIPFMaterialtoRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.FoliageForceAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Interactor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   fStrength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   fSizePercent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsImpulse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TypeIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RingRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawVelDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::FoliageForceAtLocation(class UObject* Interactor, float fStrength, float fSizePercent, const struct FVector& HitLocation, const struct FVector& HitDirection, bool bIsImpulse, float TypeIndex, float RingRadius, bool bDrawVelDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "FoliageForceAtLocation");

	Params::UIPFManager_FoliageForceAtLocation Parms{};

	Parms.Interactor = Interactor;
	Parms.fStrength = fStrength;
	Parms.fSizePercent = fSizePercent;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitDirection = std::move(HitDirection);
	Parms.bIsImpulse = bIsImpulse;
	Parms.TypeIndex = TypeIndex;
	Parms.RingRadius = RingRadius;
	Parms.bDrawVelDirection = bDrawVelDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.ForceAppliedAtLocation
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   Loc                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::ForceAppliedAtLocation(const struct FVector& Loc, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "ForceAppliedAtLocation");

	Params::UIPFManager_ForceAppliedAtLocation Parms{};

	Parms.Loc = std::move(Loc);
	Parms.Strength = Strength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UIPF.UIPFManager.ImpulseAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseDiameter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::ImpulseAtLocation(const struct FVector& Location, float ImpulseDiameter, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "ImpulseAtLocation");

	Params::UIPFManager_ImpulseAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.ImpulseDiameter = ImpulseDiameter;
	Parms.ImpulseStrength = ImpulseStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.InitializeRenderTargetsOnLoaded
// (Final, Native, Public, BlueprintCallable)

void AUIPFManager::InitializeRenderTargetsOnLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "InitializeRenderTargetsOnLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UIPF.UIPFManager.UpdateInteractorLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InteractorID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUIPFManager::UpdateInteractorLocation(int32 InteractorID, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPFManager", "UpdateInteractorLocation");

	Params::UIPFManager_UpdateInteractorLocation Parms{};

	Parms.InteractorID = InteractorID;
	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

