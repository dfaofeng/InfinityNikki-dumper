#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: X6Animation

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "X6Animation_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NikkiPhysics_structs.hpp"


namespace SDK
{

// Class X6Animation.AnimDistanceMatchingLibraryEx
// 0x0000 (0x0028 - 0x0028)
class UAnimDistanceMatchingLibraryEx final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimDistanceMatchingLibraryEx">();
	}
	static class UAnimDistanceMatchingLibraryEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimDistanceMatchingLibraryEx>();
	}
};
static_assert(alignof(UAnimDistanceMatchingLibraryEx) == 0x000008, "Wrong alignment on UAnimDistanceMatchingLibraryEx");
static_assert(sizeof(UAnimDistanceMatchingLibraryEx) == 0x000028, "Wrong size on UAnimDistanceMatchingLibraryEx");

// Class X6Animation.X6ActionBlendData
// 0x0068 (0x0090 - 0x0028)
class UX6ActionBlendData final : public UObject
{
public:
	float                                         BlendInTime;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6ActionBlendIKType                          IKType;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditiveAlpha;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayBlendProfile*                 AdditiveBlendMask;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayBlendProfile*                 AuthoredBlendMask;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIgnoreAction;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomizeBonesAndCurves;                          // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IKCurveName;                                       // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftHandSourceBone;                                // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightHandSourceBone;                               // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBone;                                        // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreLeftArmActionCurveName;                      // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreRightArmActionCurveName;                     // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdvancedBlendSettings;                      // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayBlendProfile*                 X6BlendInProfile;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayBlendProfile*                 X6BlendOutProfile;                                 // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ActionBlendData">();
	}
	static class UX6ActionBlendData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ActionBlendData>();
	}
};
static_assert(alignof(UX6ActionBlendData) == 0x000008, "Wrong alignment on UX6ActionBlendData");
static_assert(sizeof(UX6ActionBlendData) == 0x000090, "Wrong size on UX6ActionBlendData");
static_assert(offsetof(UX6ActionBlendData, BlendInTime) == 0x000028, "Member 'UX6ActionBlendData::BlendInTime' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, BlendOutTime) == 0x00002C, "Member 'UX6ActionBlendData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, IKType) == 0x000030, "Member 'UX6ActionBlendData::IKType' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, AdditiveAlpha) == 0x000034, "Member 'UX6ActionBlendData::AdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, AdditiveBlendMask) == 0x000038, "Member 'UX6ActionBlendData::AdditiveBlendMask' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, AuthoredBlendMask) == 0x000040, "Member 'UX6ActionBlendData::AuthoredBlendMask' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, bEnableIgnoreAction) == 0x000048, "Member 'UX6ActionBlendData::bEnableIgnoreAction' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, bCustomizeBonesAndCurves) == 0x000049, "Member 'UX6ActionBlendData::bCustomizeBonesAndCurves' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, IKCurveName) == 0x00004C, "Member 'UX6ActionBlendData::IKCurveName' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, LeftHandSourceBone) == 0x000054, "Member 'UX6ActionBlendData::LeftHandSourceBone' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, RightHandSourceBone) == 0x00005C, "Member 'UX6ActionBlendData::RightHandSourceBone' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, TargetBone) == 0x000064, "Member 'UX6ActionBlendData::TargetBone' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, IgnoreLeftArmActionCurveName) == 0x00006C, "Member 'UX6ActionBlendData::IgnoreLeftArmActionCurveName' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, IgnoreRightArmActionCurveName) == 0x000074, "Member 'UX6ActionBlendData::IgnoreRightArmActionCurveName' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, bEnableAdvancedBlendSettings) == 0x00007C, "Member 'UX6ActionBlendData::bEnableAdvancedBlendSettings' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, X6BlendInProfile) == 0x000080, "Member 'UX6ActionBlendData::X6BlendInProfile' has a wrong offset!");
static_assert(offsetof(UX6ActionBlendData, X6BlendOutProfile) == 0x000088, "Member 'UX6ActionBlendData::X6BlendOutProfile' has a wrong offset!");

// Class X6Animation.X6ActionBlendUserData
// 0x0008 (0x0030 - 0x0028)
class UX6ActionBlendUserData final : public UAssetUserData
{
public:
	class UX6ActionBlendData*                     BlendData;                                         // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ActionBlendUserData">();
	}
	static class UX6ActionBlendUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ActionBlendUserData>();
	}
};
static_assert(alignof(UX6ActionBlendUserData) == 0x000008, "Wrong alignment on UX6ActionBlendUserData");
static_assert(sizeof(UX6ActionBlendUserData) == 0x000030, "Wrong size on UX6ActionBlendUserData");
static_assert(offsetof(UX6ActionBlendUserData, BlendData) == 0x000028, "Member 'UX6ActionBlendUserData::BlendData' has a wrong offset!");

// Class X6Animation.X6OverlayData
// 0x0048 (0x0078 - 0x0030)
class UX6OverlayData final : public UPrimaryDataAsset
{
public:
	class UAnimSequence*                          OverlayAnim;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncOverlayAnim;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BaseAnim;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FX6OverlayBlendData>            PerBoneData;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableAdvancedSettings;                           // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendInFullBody;                                  // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendOutFullBody;                                 // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayBlendProfile*                 X6BlendInProfile;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayBlendProfile*                 X6BlendOutProfile;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6OverlayData">();
	}
	static class UX6OverlayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6OverlayData>();
	}
};
static_assert(alignof(UX6OverlayData) == 0x000008, "Wrong alignment on UX6OverlayData");
static_assert(sizeof(UX6OverlayData) == 0x000078, "Wrong size on UX6OverlayData");
static_assert(offsetof(UX6OverlayData, OverlayAnim) == 0x000030, "Member 'UX6OverlayData::OverlayAnim' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, bSyncOverlayAnim) == 0x000038, "Member 'UX6OverlayData::bSyncOverlayAnim' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, BaseAnim) == 0x000040, "Member 'UX6OverlayData::BaseAnim' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, BlendTime) == 0x000048, "Member 'UX6OverlayData::BlendTime' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, BlendOutTime) == 0x00004C, "Member 'UX6OverlayData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, PerBoneData) == 0x000050, "Member 'UX6OverlayData::PerBoneData' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, bEnableAdvancedSettings) == 0x000060, "Member 'UX6OverlayData::bEnableAdvancedSettings' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, bBlendInFullBody) == 0x000061, "Member 'UX6OverlayData::bBlendInFullBody' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, bBlendOutFullBody) == 0x000062, "Member 'UX6OverlayData::bBlendOutFullBody' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, X6BlendInProfile) == 0x000068, "Member 'UX6OverlayData::X6BlendInProfile' has a wrong offset!");
static_assert(offsetof(UX6OverlayData, X6BlendOutProfile) == 0x000070, "Member 'UX6OverlayData::X6BlendOutProfile' has a wrong offset!");

// Class X6Animation.X6OverlayCustomModeData
// 0x0030 (0x0060 - 0x0030)
class UX6OverlayCustomModeData final : public UPrimaryDataAsset
{
public:
	float                                         BlendTime;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FX6OverlayBlendData>            PerBoneData;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableAdvancedSettings;                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayBlendProfile*                 X6BlendInProfile;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayBlendProfile*                 X6BlendOutProfile;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6OverlayCustomModeData">();
	}
	static class UX6OverlayCustomModeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6OverlayCustomModeData>();
	}
};
static_assert(alignof(UX6OverlayCustomModeData) == 0x000008, "Wrong alignment on UX6OverlayCustomModeData");
static_assert(sizeof(UX6OverlayCustomModeData) == 0x000060, "Wrong size on UX6OverlayCustomModeData");
static_assert(offsetof(UX6OverlayCustomModeData, BlendTime) == 0x000030, "Member 'UX6OverlayCustomModeData::BlendTime' has a wrong offset!");
static_assert(offsetof(UX6OverlayCustomModeData, BlendOutTime) == 0x000034, "Member 'UX6OverlayCustomModeData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UX6OverlayCustomModeData, PerBoneData) == 0x000038, "Member 'UX6OverlayCustomModeData::PerBoneData' has a wrong offset!");
static_assert(offsetof(UX6OverlayCustomModeData, bEnableAdvancedSettings) == 0x000048, "Member 'UX6OverlayCustomModeData::bEnableAdvancedSettings' has a wrong offset!");
static_assert(offsetof(UX6OverlayCustomModeData, X6BlendInProfile) == 0x000050, "Member 'UX6OverlayCustomModeData::X6BlendInProfile' has a wrong offset!");
static_assert(offsetof(UX6OverlayCustomModeData, X6BlendOutProfile) == 0x000058, "Member 'UX6OverlayCustomModeData::X6BlendOutProfile' has a wrong offset!");

// Class X6Animation.X6OverlayBlendProfile
// 0x0028 (0x0058 - 0x0030)
class UX6OverlayBlendProfile final : public UPrimaryDataAsset
{
public:
	class USkeleton*                              SourceSkeleton;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FX6OverlayBlendProfilePerBoneInfo> BlendInfos;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlendProfile*                          BakedBlendProfile;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendProfile*                          BakedBlendMask;                                    // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6OverlayBlendProfile">();
	}
	static class UX6OverlayBlendProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6OverlayBlendProfile>();
	}
};
static_assert(alignof(UX6OverlayBlendProfile) == 0x000008, "Wrong alignment on UX6OverlayBlendProfile");
static_assert(sizeof(UX6OverlayBlendProfile) == 0x000058, "Wrong size on UX6OverlayBlendProfile");
static_assert(offsetof(UX6OverlayBlendProfile, SourceSkeleton) == 0x000030, "Member 'UX6OverlayBlendProfile::SourceSkeleton' has a wrong offset!");
static_assert(offsetof(UX6OverlayBlendProfile, BlendInfos) == 0x000038, "Member 'UX6OverlayBlendProfile::BlendInfos' has a wrong offset!");
static_assert(offsetof(UX6OverlayBlendProfile, BakedBlendProfile) == 0x000048, "Member 'UX6OverlayBlendProfile::BakedBlendProfile' has a wrong offset!");
static_assert(offsetof(UX6OverlayBlendProfile, BakedBlendMask) == 0x000050, "Member 'UX6OverlayBlendProfile::BakedBlendMask' has a wrong offset!");

// Class X6Animation.X6OverlayFrameSettings
// 0x0018 (0x0040 - 0x0028)
class UX6OverlayFrameSettings final : public UObject
{
public:
	bool                                          bDeactivateThisFrame;                              // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BlendProfileName;                                  // 0x002C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayBlendProfile*                 X6BlendProfile;                                    // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6OverlayFrameSettings">();
	}
	static class UX6OverlayFrameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6OverlayFrameSettings>();
	}
};
static_assert(alignof(UX6OverlayFrameSettings) == 0x000008, "Wrong alignment on UX6OverlayFrameSettings");
static_assert(sizeof(UX6OverlayFrameSettings) == 0x000040, "Wrong size on UX6OverlayFrameSettings");
static_assert(offsetof(UX6OverlayFrameSettings, bDeactivateThisFrame) == 0x000028, "Member 'UX6OverlayFrameSettings::bDeactivateThisFrame' has a wrong offset!");
static_assert(offsetof(UX6OverlayFrameSettings, BlendProfileName) == 0x00002C, "Member 'UX6OverlayFrameSettings::BlendProfileName' has a wrong offset!");
static_assert(offsetof(UX6OverlayFrameSettings, X6BlendProfile) == 0x000038, "Member 'UX6OverlayFrameSettings::X6BlendProfile' has a wrong offset!");

// Class X6Animation.AnimNotifyState_MirrorRootMotion
// 0x0018 (0x0048 - 0x0030)
class UAnimNotifyState_MirrorRootMotion final : public UAnimNotifyState
{
public:
	struct FVector                                Scale;                                             // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MirrorRootMotion">();
	}
	static class UAnimNotifyState_MirrorRootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MirrorRootMotion>();
	}
};
static_assert(alignof(UAnimNotifyState_MirrorRootMotion) == 0x000008, "Wrong alignment on UAnimNotifyState_MirrorRootMotion");
static_assert(sizeof(UAnimNotifyState_MirrorRootMotion) == 0x000048, "Wrong size on UAnimNotifyState_MirrorRootMotion");
static_assert(offsetof(UAnimNotifyState_MirrorRootMotion, Scale) == 0x000030, "Member 'UAnimNotifyState_MirrorRootMotion::Scale' has a wrong offset!");

// Class X6Animation.ANS_LocoCannotInterupt
// 0x0008 (0x0038 - 0x0030)
class UANS_LocoCannotInterupt : public UAnimNotifyState
{
public:
	class FName                                   AnimTag;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_LocoCannotInterupt">();
	}
	static class UANS_LocoCannotInterupt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_LocoCannotInterupt>();
	}
};
static_assert(alignof(UANS_LocoCannotInterupt) == 0x000008, "Wrong alignment on UANS_LocoCannotInterupt");
static_assert(sizeof(UANS_LocoCannotInterupt) == 0x000038, "Wrong size on UANS_LocoCannotInterupt");
static_assert(offsetof(UANS_LocoCannotInterupt, AnimTag) == 0x000030, "Member 'UANS_LocoCannotInterupt::AnimTag' has a wrong offset!");

// Class X6Animation.ANS_LocoStartExitAnimType
// 0x0008 (0x0038 - 0x0030)
class UANS_LocoStartExitAnimType : public UAnimNotifyState
{
public:
	ELocoExitAnimType                             LocoExitAnimType;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_LocoStartExitAnimType">();
	}
	static class UANS_LocoStartExitAnimType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_LocoStartExitAnimType>();
	}
};
static_assert(alignof(UANS_LocoStartExitAnimType) == 0x000008, "Wrong alignment on UANS_LocoStartExitAnimType");
static_assert(sizeof(UANS_LocoStartExitAnimType) == 0x000038, "Wrong size on UANS_LocoStartExitAnimType");
static_assert(offsetof(UANS_LocoStartExitAnimType, LocoExitAnimType) == 0x000030, "Member 'UANS_LocoStartExitAnimType::LocoExitAnimType' has a wrong offset!");

// Class X6Animation.ANS_MantleRootMotionControl
// 0x0010 (0x0040 - 0x0030)
class UANS_MantleRootMotionControl final : public UAnimNotifyState
{
public:
	bool                                          bEnableRootMotion;                                 // 0x0030(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              LinkedAnimInstanceCLS;                             // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckEnableRootMotionConditionBP(class USkeletalMeshComponent* SkelMeshComponent, class UAnimSequenceBase* SequenceAsset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_MantleRootMotionControl">();
	}
	static class UANS_MantleRootMotionControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_MantleRootMotionControl>();
	}
};
static_assert(alignof(UANS_MantleRootMotionControl) == 0x000008, "Wrong alignment on UANS_MantleRootMotionControl");
static_assert(sizeof(UANS_MantleRootMotionControl) == 0x000040, "Wrong size on UANS_MantleRootMotionControl");
static_assert(offsetof(UANS_MantleRootMotionControl, bEnableRootMotion) == 0x000030, "Member 'UANS_MantleRootMotionControl::bEnableRootMotion' has a wrong offset!");
static_assert(offsetof(UANS_MantleRootMotionControl, LinkedAnimInstanceCLS) == 0x000038, "Member 'UANS_MantleRootMotionControl::LinkedAnimInstanceCLS' has a wrong offset!");

// Class X6Animation.ANS_SeqPlayerDisableRootMotion
// 0x0008 (0x0038 - 0x0030)
class UANS_SeqPlayerDisableRootMotion : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x1];                                       // 0x0030(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bChangeForceLock;                                  // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_SeqPlayerDisableRootMotion">();
	}
	static class UANS_SeqPlayerDisableRootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_SeqPlayerDisableRootMotion>();
	}
};
static_assert(alignof(UANS_SeqPlayerDisableRootMotion) == 0x000008, "Wrong alignment on UANS_SeqPlayerDisableRootMotion");
static_assert(sizeof(UANS_SeqPlayerDisableRootMotion) == 0x000038, "Wrong size on UANS_SeqPlayerDisableRootMotion");
static_assert(offsetof(UANS_SeqPlayerDisableRootMotion, bChangeForceLock) == 0x000031, "Member 'UANS_SeqPlayerDisableRootMotion::bChangeForceLock' has a wrong offset!");

// Class X6Animation.ContextualAnimationSystem
// 0x0090 (0x00B8 - 0x0028)
class UContextualAnimationSystem final : public UObject
{
public:
	bool                                          IsInAnyContextual;                                 // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentID;                                         // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FContextualData                        CurrentContextualStateData;                        // 0x0030(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMap<uint8, struct FContextualInstance>       MapCurrentContextualStateData;                     // 0x0058(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bEnableContextual;                                 // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0xF];                                       // 0x00A9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddContextual(uint8 ID, const struct FContextualData& InContextualData);
	void DisableContextualAnimation(uint8 ID);
	void EnableContextualAnimation(uint8 ID);
	bool IsCurrentContextualAnimiationPlaying();
	void OnContextualEnd();
	void OnContextualEndByID(uint8 ID);
	void RemoveContextual(uint8 ID);
	void ResumeContextualAnimation(uint8 ID);
	void SetContextualAnimationEnable(uint8 ID, bool bEnable);
	void SetContextualSystemEnable(bool bEnable);
	void SuspendContextualAnimation(uint8 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimationSystem">();
	}
	static class UContextualAnimationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimationSystem>();
	}
};
static_assert(alignof(UContextualAnimationSystem) == 0x000008, "Wrong alignment on UContextualAnimationSystem");
static_assert(sizeof(UContextualAnimationSystem) == 0x0000B8, "Wrong size on UContextualAnimationSystem");
static_assert(offsetof(UContextualAnimationSystem, IsInAnyContextual) == 0x000028, "Member 'UContextualAnimationSystem::IsInAnyContextual' has a wrong offset!");
static_assert(offsetof(UContextualAnimationSystem, CurrentID) == 0x000029, "Member 'UContextualAnimationSystem::CurrentID' has a wrong offset!");
static_assert(offsetof(UContextualAnimationSystem, CurrentContextualStateData) == 0x000030, "Member 'UContextualAnimationSystem::CurrentContextualStateData' has a wrong offset!");
static_assert(offsetof(UContextualAnimationSystem, MapCurrentContextualStateData) == 0x000058, "Member 'UContextualAnimationSystem::MapCurrentContextualStateData' has a wrong offset!");
static_assert(offsetof(UContextualAnimationSystem, bEnableContextual) == 0x0000A8, "Member 'UContextualAnimationSystem::bEnableContextual' has a wrong offset!");

// Class X6Animation.PlayerLocomotionAnimInstance
// 0x0120 (0x04F0 - 0x03D0)
class UPlayerLocomotionAnimInstance : public UAnimInstance
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableContextualSystem;                           // 0x03D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UContextualAnimationSystem*             ContextualSystem;                                  // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELocomotionGait PrevGait, ELocomotionGait NewGait)> OnGaitChanged; // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELocomotionGait PrevGait, ELocomotionGait NewGait)> OnAllowGaitChanged; // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EMovementMode PrevMode, EMovementMode NewMode)> OnMovementModeChanged; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool PrevHasMovementInput, bool NewHasMovementInput)> OnMovementInputChanged; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x1];                                      // 0x0420(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ELocomotionGait                               AllowGait;                                         // 0x0421(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               PrevAllowGait;                                     // 0x0422(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               LastAllowGait;                                     // 0x0423(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               StartAllowGait;                                    // 0x0424(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x0425(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0426(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 LastMovementMode;                                  // 0x0427(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0428(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrevVelocity;                                      // 0x0440(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x0458(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementInput;                                     // 0x0470(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreMovementInput;                                  // 0x0488(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x04A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementInput;                                  // 0x04A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheDeltaSeconds;                                 // 0x04A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputAmount;                               // 0x04AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevMovementInputAmount;                           // 0x04B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle;                                         // 0x04B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAngle;                                        // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasMovementInput;                                  // 0x04BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPivot;                                          // 0x04BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSlope;                                        // 0x04BE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnning;                                       // 0x04BF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CannotInterupt;                                    // 0x04C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinEnterSlopeState;                                // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIsTurning;                                      // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterPivotValue;                                   // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionType                               LocomotionStateType;                               // 0x04D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocoExitAnimType                             LocoExitAnimType;                                  // 0x04D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransToRightFoot;                                 // 0x04D2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGaitChanged;                                 // 0x04D3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GaitBlendAlpha;                                    // 0x04D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkBlendAlpha;                                    // 0x04D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JogBlendAlpha;                                     // 0x04DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ComponentsPrepareFinished;                         // 0x04E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintCustomLateUpdate(float DeltaSeconds);
	void BlueprintCustomPreUpdate(float DeltaSeconds);
	void BlueprintCustomUpdate(float DeltaSeconds);
	void DeterminTransToRightFoot(bool* bTranstoRight);
	void SetLocomotionLogicStates(ELocomotionGait InAllowGait);
	void SetLocomotionType(ELocomotionType LocomotionType);
	void UpdateLocomotionLogicValues(const struct FVector& InVelocity, const struct FVector& InMovementInput, float InMaxAcceleration, float InTurnAngle, float InSlopeAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLocomotionAnimInstance">();
	}
	static class UPlayerLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLocomotionAnimInstance>();
	}
};
static_assert(alignof(UPlayerLocomotionAnimInstance) == 0x000010, "Wrong alignment on UPlayerLocomotionAnimInstance");
static_assert(sizeof(UPlayerLocomotionAnimInstance) == 0x0004F0, "Wrong size on UPlayerLocomotionAnimInstance");
static_assert(offsetof(UPlayerLocomotionAnimInstance, CharacterMovementComponent) == 0x0003C8, "Member 'UPlayerLocomotionAnimInstance::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, bEnableContextualSystem) == 0x0003D0, "Member 'UPlayerLocomotionAnimInstance::bEnableContextualSystem' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, ContextualSystem) == 0x0003D8, "Member 'UPlayerLocomotionAnimInstance::ContextualSystem' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, OnGaitChanged) == 0x0003E0, "Member 'UPlayerLocomotionAnimInstance::OnGaitChanged' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, OnAllowGaitChanged) == 0x0003F0, "Member 'UPlayerLocomotionAnimInstance::OnAllowGaitChanged' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, OnMovementModeChanged) == 0x000400, "Member 'UPlayerLocomotionAnimInstance::OnMovementModeChanged' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, OnMovementInputChanged) == 0x000410, "Member 'UPlayerLocomotionAnimInstance::OnMovementInputChanged' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, AllowGait) == 0x000421, "Member 'UPlayerLocomotionAnimInstance::AllowGait' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, PrevAllowGait) == 0x000422, "Member 'UPlayerLocomotionAnimInstance::PrevAllowGait' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, LastAllowGait) == 0x000423, "Member 'UPlayerLocomotionAnimInstance::LastAllowGait' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, StartAllowGait) == 0x000424, "Member 'UPlayerLocomotionAnimInstance::StartAllowGait' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, MovementMode) == 0x000425, "Member 'UPlayerLocomotionAnimInstance::MovementMode' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, PrevMovementMode) == 0x000426, "Member 'UPlayerLocomotionAnimInstance::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, LastMovementMode) == 0x000427, "Member 'UPlayerLocomotionAnimInstance::LastMovementMode' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, Velocity) == 0x000428, "Member 'UPlayerLocomotionAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, PrevVelocity) == 0x000440, "Member 'UPlayerLocomotionAnimInstance::PrevVelocity' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, Acceleration) == 0x000458, "Member 'UPlayerLocomotionAnimInstance::Acceleration' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, MovementInput) == 0x000470, "Member 'UPlayerLocomotionAnimInstance::MovementInput' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, PreMovementInput) == 0x000488, "Member 'UPlayerLocomotionAnimInstance::PreMovementInput' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, Speed) == 0x0004A0, "Member 'UPlayerLocomotionAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, MaxMovementInput) == 0x0004A4, "Member 'UPlayerLocomotionAnimInstance::MaxMovementInput' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, CacheDeltaSeconds) == 0x0004A8, "Member 'UPlayerLocomotionAnimInstance::CacheDeltaSeconds' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, MovementInputAmount) == 0x0004AC, "Member 'UPlayerLocomotionAnimInstance::MovementInputAmount' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, PrevMovementInputAmount) == 0x0004B0, "Member 'UPlayerLocomotionAnimInstance::PrevMovementInputAmount' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, TurnAngle) == 0x0004B4, "Member 'UPlayerLocomotionAnimInstance::TurnAngle' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, SlopeAngle) == 0x0004B8, "Member 'UPlayerLocomotionAnimInstance::SlopeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, HasMovementInput) == 0x0004BC, "Member 'UPlayerLocomotionAnimInstance::HasMovementInput' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, bIsPivot) == 0x0004BD, "Member 'UPlayerLocomotionAnimInstance::bIsPivot' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, bIsInSlope) == 0x0004BE, "Member 'UPlayerLocomotionAnimInstance::bIsInSlope' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, bIsTurnning) == 0x0004BF, "Member 'UPlayerLocomotionAnimInstance::bIsTurnning' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, CannotInterupt) == 0x0004C0, "Member 'UPlayerLocomotionAnimInstance::CannotInterupt' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, MinEnterSlopeState) == 0x0004C4, "Member 'UPlayerLocomotionAnimInstance::MinEnterSlopeState' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, MinIsTurning) == 0x0004C8, "Member 'UPlayerLocomotionAnimInstance::MinIsTurning' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, EnterPivotValue) == 0x0004CC, "Member 'UPlayerLocomotionAnimInstance::EnterPivotValue' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, LocomotionStateType) == 0x0004D0, "Member 'UPlayerLocomotionAnimInstance::LocomotionStateType' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, LocoExitAnimType) == 0x0004D1, "Member 'UPlayerLocomotionAnimInstance::LocoExitAnimType' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, bTransToRightFoot) == 0x0004D2, "Member 'UPlayerLocomotionAnimInstance::bTransToRightFoot' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, bAllowGaitChanged) == 0x0004D3, "Member 'UPlayerLocomotionAnimInstance::bAllowGaitChanged' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, GaitBlendAlpha) == 0x0004D4, "Member 'UPlayerLocomotionAnimInstance::GaitBlendAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, WalkBlendAlpha) == 0x0004D8, "Member 'UPlayerLocomotionAnimInstance::WalkBlendAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, JogBlendAlpha) == 0x0004DC, "Member 'UPlayerLocomotionAnimInstance::JogBlendAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionAnimInstance, ComponentsPrepareFinished) == 0x0004E8, "Member 'UPlayerLocomotionAnimInstance::ComponentsPrepareFinished' has a wrong offset!");

// Class X6Animation.NikkiGroundAnimInstance
// 0x0100 (0x05F0 - 0x04F0)
class UNikkiGroundAnimInstance : public UPlayerLocomotionAnimInstance
{
public:
	struct FNikkiTransitionGait                   NikkiTransitionGait;                               // 0x04F0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FActorSpeedToAnimation                 ActorSpeedToAnimation;                             // 0x0510(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsTurnRight;                                       // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForward;                                         // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTurnLeft;                                        // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForwardFoward;                                   // 0x0553(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForward45m;                                      // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForward45p;                                      // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRight180p;                                       // 0x0556(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRight90p;                                        // 0x0557(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLeft180m;                                        // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLeft90m;                                         // 0x0559(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAnimBlendAlpha;                               // 0x055C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPoseBlendAlpha;                               // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTurnAngle;                                    // 0x0564(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreezeStartTurnAngle;                              // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSpeed;                                        // 0x056C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAnimTimeRecord;                               // 0x0570(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInPreDetectStop;                                 // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreStopConfigTime;                                 // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x14];                                     // 0x057C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMovementInputLockTimeConfigTime;              // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMovementInput;                                // 0x0598(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartMachineName;                                  // 0x059C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               StartGait;                                         // 0x05A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGroundMainState                    LocomotionAnimState;                               // 0x05A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGroundIdleState                    LocomotionIdleState;                               // 0x05A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForbidTransitionToMoveState;                       // 0x05A7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A8[0x4];                                      // 0x05A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsJogGait;                                        // 0x05AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWalkFastGait;                                   // 0x05AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprintGait;                                     // 0x05AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               ActualGait;                                        // 0x05AF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               PrevActualGait;                                    // 0x05B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMoving;                                       // 0x05B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartMoving;                                      // 0x05B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpToMoving;                                     // 0x05B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRuningIntoWall;                                 // 0x05B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B5[0x3];                                      // 0x05B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootSpeed;                                         // 0x05B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                L_Hand_Bone_Location;                              // 0x05C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                R_Hand_Bone_Location;                              // 0x05D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_UpdateActualGait();
	void DetermineStartGait();
	void NotifyTransitionToPivot();
	void PopForbidTransitionToMove();
	void PushForbidTransitionToMove();
	void SetAllowSpeed(float InAllowWalkSpeed, float InAllowRunSpeed, float InAllowSprintSpeed);
	void SetAnimBenchmarkSpeed(float InAnimationSprintSpeed, float InAnimationRunSpeed, float InAnimationWalkSpeed, float InAnimationWalkSlowSpeed);
	void SetAnimMainState(ELocomotionGroundMainState MainState, bool bEnter);
	void SetBoardSpeed(float InAllowWalkSlowSpeed, float InCurrentMaxSpeed, float InCurrentConfigAllowSpeed);
	void SetIdleState(ELocomotionGroundIdleState IdleState);
	void UpdateStartTurnParams();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NikkiGroundAnimInstance">();
	}
	static class UNikkiGroundAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNikkiGroundAnimInstance>();
	}
};
static_assert(alignof(UNikkiGroundAnimInstance) == 0x000010, "Wrong alignment on UNikkiGroundAnimInstance");
static_assert(sizeof(UNikkiGroundAnimInstance) == 0x0005F0, "Wrong size on UNikkiGroundAnimInstance");
static_assert(offsetof(UNikkiGroundAnimInstance, NikkiTransitionGait) == 0x0004F0, "Member 'UNikkiGroundAnimInstance::NikkiTransitionGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, ActorSpeedToAnimation) == 0x000510, "Member 'UNikkiGroundAnimInstance::ActorSpeedToAnimation' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsTurnRight) == 0x000550, "Member 'UNikkiGroundAnimInstance::IsTurnRight' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsForward) == 0x000551, "Member 'UNikkiGroundAnimInstance::IsForward' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsTurnLeft) == 0x000552, "Member 'UNikkiGroundAnimInstance::IsTurnLeft' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsForwardFoward) == 0x000553, "Member 'UNikkiGroundAnimInstance::IsForwardFoward' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsForward45m) == 0x000554, "Member 'UNikkiGroundAnimInstance::IsForward45m' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsForward45p) == 0x000555, "Member 'UNikkiGroundAnimInstance::IsForward45p' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsRight180p) == 0x000556, "Member 'UNikkiGroundAnimInstance::IsRight180p' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsRight90p) == 0x000557, "Member 'UNikkiGroundAnimInstance::IsRight90p' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsLeft180m) == 0x000558, "Member 'UNikkiGroundAnimInstance::IsLeft180m' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsLeft90m) == 0x000559, "Member 'UNikkiGroundAnimInstance::IsLeft90m' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartAnimBlendAlpha) == 0x00055C, "Member 'UNikkiGroundAnimInstance::StartAnimBlendAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartPoseBlendAlpha) == 0x000560, "Member 'UNikkiGroundAnimInstance::StartPoseBlendAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartTurnAngle) == 0x000564, "Member 'UNikkiGroundAnimInstance::StartTurnAngle' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, FreezeStartTurnAngle) == 0x000568, "Member 'UNikkiGroundAnimInstance::FreezeStartTurnAngle' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartSpeed) == 0x00056C, "Member 'UNikkiGroundAnimInstance::StartSpeed' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartAnimTimeRecord) == 0x000570, "Member 'UNikkiGroundAnimInstance::StartAnimTimeRecord' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, IsInPreDetectStop) == 0x000574, "Member 'UNikkiGroundAnimInstance::IsInPreDetectStop' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, PreStopConfigTime) == 0x000578, "Member 'UNikkiGroundAnimInstance::PreStopConfigTime' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartMovementInputLockTimeConfigTime) == 0x000590, "Member 'UNikkiGroundAnimInstance::StartMovementInputLockTimeConfigTime' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartMovementInput) == 0x000598, "Member 'UNikkiGroundAnimInstance::StartMovementInput' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartMachineName) == 0x00059C, "Member 'UNikkiGroundAnimInstance::StartMachineName' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, StartGait) == 0x0005A4, "Member 'UNikkiGroundAnimInstance::StartGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, LocomotionAnimState) == 0x0005A5, "Member 'UNikkiGroundAnimInstance::LocomotionAnimState' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, LocomotionIdleState) == 0x0005A6, "Member 'UNikkiGroundAnimInstance::LocomotionIdleState' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, ForbidTransitionToMoveState) == 0x0005A7, "Member 'UNikkiGroundAnimInstance::ForbidTransitionToMoveState' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bIsJogGait) == 0x0005AC, "Member 'UNikkiGroundAnimInstance::bIsJogGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bIsWalkFastGait) == 0x0005AD, "Member 'UNikkiGroundAnimInstance::bIsWalkFastGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bIsSprintGait) == 0x0005AE, "Member 'UNikkiGroundAnimInstance::bIsSprintGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, ActualGait) == 0x0005AF, "Member 'UNikkiGroundAnimInstance::ActualGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, PrevActualGait) == 0x0005B0, "Member 'UNikkiGroundAnimInstance::PrevActualGait' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bStopMoving) == 0x0005B1, "Member 'UNikkiGroundAnimInstance::bStopMoving' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bStartMoving) == 0x0005B2, "Member 'UNikkiGroundAnimInstance::bStartMoving' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bJumpToMoving) == 0x0005B3, "Member 'UNikkiGroundAnimInstance::bJumpToMoving' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, bIsRuningIntoWall) == 0x0005B4, "Member 'UNikkiGroundAnimInstance::bIsRuningIntoWall' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, RootSpeed) == 0x0005B8, "Member 'UNikkiGroundAnimInstance::RootSpeed' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, L_Hand_Bone_Location) == 0x0005C0, "Member 'UNikkiGroundAnimInstance::L_Hand_Bone_Location' has a wrong offset!");
static_assert(offsetof(UNikkiGroundAnimInstance, R_Hand_Bone_Location) == 0x0005D8, "Member 'UNikkiGroundAnimInstance::R_Hand_Bone_Location' has a wrong offset!");

// Class X6Animation.X6AnimationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6AnimationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeMontageSegmentRange(class UAnimMontage** InOutMontage, float TrimStartTime, float TrimEndTime, int32 TrackIndex, int32 SegmentIndex);
	static void ClearAllInertialization(const struct FAnimUpdateContext& Context, bool bIncludeLinkedAniminstance);
	static void ClearAllInertializationOfThisAniminstance(class UAnimInstance* AnimInstance, bool bIncludeLinkedAniminstance);
	static void ClearInertializationBeforeThisNode(const struct FAnimUpdateContext& Context);
	static void CreatePoseSnapshotOfAnimInstance(class UAnimInstance* AnimInstance, const class FString& LocalTransforms, struct FPoseSnapshot* PoseSnapshot);
	static void ForceConsiderInertializationDeficitThisFrame(const struct FAnimUpdateContext& Context);
	static void ForceIgnoreInertializationDeficitThisFrame(const struct FAnimUpdateContext& Context);
	static void ForceToStopSlotAnimation(class UAnimInstance* AnimInstance, float InBlendOutTime, class FName SlotNodeName);
	static TArray<class UAnimSequenceBase*> GetAnimationSequencesBySlotNameInAnimMontage(class UAnimMontage* AnimMontage, const class FName& SlotNodeName);
	static TArray<class UAnimSequenceBase*> GetAnimationSequencesInTargetSlot(class UAnimInstance* AnimInstance, const class FName& SlotNodeName);
	static void GetLinkedAnimLayersInstanceByClass(class UAnimInstance* AnimInstance, TSubclassOf<class UAnimInstance> InClass, TArray<class UAnimInstance*>* OutLinkedInstances);
	static bool GetMontagePositionAndTotalLengthBySlotNameInAnimInstance(class UAnimInstance* AnimInstance, const class FName& SlotNodeName, float* OutCurPosition, float* OutTotalLength);
	static class FString GetPoseDataFromCurrentPose(class UAnimInstance* AnimInstance);
	static bool IsAnimSequenceValidCurveName(class UAnimSequenceBase* InAnimSequence, class FName InCurveName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimationFunctionLibrary">();
	}
	static class UX6AnimationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimationFunctionLibrary>();
	}
};
static_assert(alignof(UX6AnimationFunctionLibrary) == 0x000008, "Wrong alignment on UX6AnimationFunctionLibrary");
static_assert(sizeof(UX6AnimationFunctionLibrary) == 0x000028, "Wrong size on UX6AnimationFunctionLibrary");

// Class X6Animation.X6ClothAnimInstance
// 0x0040 (0x0410 - 0x03D0)
#pragma pack(push, 0x1)
class alignas(0x10) UX6ClothAnimInstance : public UAnimInstance
{
public:
	bool                                          bPhysicsInModelSpace;                              // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENikki_SimSpaceType                           RuntimeRefSpace;                                   // 0x03C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBlendAnimPose;                              // 0x03CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CB[0x5];                                      // 0x03CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UNikkiGroundAnimInstance*               NikkiGroundAnimInstance;                           // 0x03D0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGroundMainState                    LocomotionAnimState;                               // 0x03D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGroundIdleState                    LocomotionIdleState;                               // 0x03D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               PrevActualGait;                                    // 0x03DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               ActualGait;                                        // 0x03DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasMovementInput;                                  // 0x03DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSlope;                                        // 0x03DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurning;                                        // 0x03DE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DF[0x1];                                      // 0x03DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSpeed;                                        // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x24];                                     // 0x03E4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddClothExternalAcc(const struct FVector& InClothExternalAcc, float InClothExternalAccDuration);
	void ConsumeClothExternalAcc(struct FClothExternalData* OutClothExternalData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ClothAnimInstance">();
	}
	static class UX6ClothAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ClothAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UX6ClothAnimInstance) == 0x000010, "Wrong alignment on UX6ClothAnimInstance");
static_assert(sizeof(UX6ClothAnimInstance) == 0x000410, "Wrong size on UX6ClothAnimInstance");
static_assert(offsetof(UX6ClothAnimInstance, bPhysicsInModelSpace) == 0x0003C8, "Member 'UX6ClothAnimInstance::bPhysicsInModelSpace' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, RuntimeRefSpace) == 0x0003C9, "Member 'UX6ClothAnimInstance::RuntimeRefSpace' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, bEnableBlendAnimPose) == 0x0003CA, "Member 'UX6ClothAnimInstance::bEnableBlendAnimPose' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, NikkiGroundAnimInstance) == 0x0003D0, "Member 'UX6ClothAnimInstance::NikkiGroundAnimInstance' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, LocomotionAnimState) == 0x0003D8, "Member 'UX6ClothAnimInstance::LocomotionAnimState' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, LocomotionIdleState) == 0x0003D9, "Member 'UX6ClothAnimInstance::LocomotionIdleState' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, PrevActualGait) == 0x0003DA, "Member 'UX6ClothAnimInstance::PrevActualGait' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, ActualGait) == 0x0003DB, "Member 'UX6ClothAnimInstance::ActualGait' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, HasMovementInput) == 0x0003DC, "Member 'UX6ClothAnimInstance::HasMovementInput' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, bIsInSlope) == 0x0003DD, "Member 'UX6ClothAnimInstance::bIsInSlope' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, bIsTurning) == 0x0003DE, "Member 'UX6ClothAnimInstance::bIsTurning' has a wrong offset!");
static_assert(offsetof(UX6ClothAnimInstance, StartSpeed) == 0x0003E0, "Member 'UX6ClothAnimInstance::StartSpeed' has a wrong offset!");

// Class X6Animation.X6DistanceMatchMetaData
// 0x0008 (0x0030 - 0x0028)
class UX6DistanceMatchMetaData final : public UAnimMetaData
{
public:
	float                                         MinDistanceMatchTime;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceMatchTime;                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6DistanceMatchMetaData">();
	}
	static class UX6DistanceMatchMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6DistanceMatchMetaData>();
	}
};
static_assert(alignof(UX6DistanceMatchMetaData) == 0x000008, "Wrong alignment on UX6DistanceMatchMetaData");
static_assert(sizeof(UX6DistanceMatchMetaData) == 0x000030, "Wrong size on UX6DistanceMatchMetaData");
static_assert(offsetof(UX6DistanceMatchMetaData, MinDistanceMatchTime) == 0x000028, "Member 'UX6DistanceMatchMetaData::MinDistanceMatchTime' has a wrong offset!");
static_assert(offsetof(UX6DistanceMatchMetaData, MaxDistanceMatchTime) == 0x00002C, "Member 'UX6DistanceMatchMetaData::MaxDistanceMatchTime' has a wrong offset!");

// Class X6Animation.X6PlayerAnimInstance
// 0x0000 (0x03D0 - 0x03D0)
#pragma pack(push, 0x1)
class alignas(0x10) UX6PlayerAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PlayerAnimInstance">();
	}
	static class UX6PlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PlayerAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UX6PlayerAnimInstance) == 0x000010, "Wrong alignment on UX6PlayerAnimInstance");
static_assert(sizeof(UX6PlayerAnimInstance) == 0x0003D0, "Wrong size on UX6PlayerAnimInstance");

// Class X6Animation.PoseMatchMetaData
// 0x0070 (0x0098 - 0x0028)
class UPoseMatchMetaData final : public UAnimMetaData
{
public:
	TMap<class FName, struct FPoseMatchData>      BoneMovingData;                                    // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<float>                                 RecordTimes;                                       // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         DataCount;                                         // 0x0088(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrendMismatchCostBias;                             // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationCostWeight;                                // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityCostWeight;                                // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseMatchMetaData">();
	}
	static class UPoseMatchMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoseMatchMetaData>();
	}
};
static_assert(alignof(UPoseMatchMetaData) == 0x000008, "Wrong alignment on UPoseMatchMetaData");
static_assert(sizeof(UPoseMatchMetaData) == 0x000098, "Wrong size on UPoseMatchMetaData");
static_assert(offsetof(UPoseMatchMetaData, BoneMovingData) == 0x000028, "Member 'UPoseMatchMetaData::BoneMovingData' has a wrong offset!");
static_assert(offsetof(UPoseMatchMetaData, RecordTimes) == 0x000078, "Member 'UPoseMatchMetaData::RecordTimes' has a wrong offset!");
static_assert(offsetof(UPoseMatchMetaData, DataCount) == 0x000088, "Member 'UPoseMatchMetaData::DataCount' has a wrong offset!");
static_assert(offsetof(UPoseMatchMetaData, TrendMismatchCostBias) == 0x00008C, "Member 'UPoseMatchMetaData::TrendMismatchCostBias' has a wrong offset!");
static_assert(offsetof(UPoseMatchMetaData, LocationCostWeight) == 0x000090, "Member 'UPoseMatchMetaData::LocationCostWeight' has a wrong offset!");
static_assert(offsetof(UPoseMatchMetaData, VelocityCostWeight) == 0x000094, "Member 'UPoseMatchMetaData::VelocityCostWeight' has a wrong offset!");

// Class X6Animation.X6PoseMatch
// 0x0000 (0x0028 - 0x0028)
class UX6PoseMatch final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PoseMatch">();
	}
	static class UX6PoseMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PoseMatch>();
	}
};
static_assert(alignof(UX6PoseMatch) == 0x000008, "Wrong alignment on UX6PoseMatch");
static_assert(sizeof(UX6PoseMatch) == 0x000028, "Wrong size on UX6PoseMatch");

// Class X6Animation.X6PlayMontageCallbackProxy
// 0x0080 (0x00A8 - 0x0028)
class UX6PlayMontageCallbackProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void(class FName NotifyName)> OnCompleted;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnBlendOut;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnInterrupted;                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyBegin;                            // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyEnd;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6PlayMontageCallbackProxy* CreateProxyObjectForPlayMontage(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, class FName StartingSection, bool bMirror, float AnimRootMotionTranslationScale, bool bReplicate, bool bPlayWithShadow);
	static class UX6PlayMontageCallbackProxy* CreateProxyObjectForPlayMontageWithParam(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, bool bReplicate, bool bPlayWithShadow, const struct FX6PlayMontageParams& MontageParams);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PlayMontageCallbackProxy">();
	}
	static class UX6PlayMontageCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PlayMontageCallbackProxy>();
	}
};
static_assert(alignof(UX6PlayMontageCallbackProxy) == 0x000008, "Wrong alignment on UX6PlayMontageCallbackProxy");
static_assert(sizeof(UX6PlayMontageCallbackProxy) == 0x0000A8, "Wrong size on UX6PlayMontageCallbackProxy");
static_assert(offsetof(UX6PlayMontageCallbackProxy, OnCompleted) == 0x000028, "Member 'UX6PlayMontageCallbackProxy::OnCompleted' has a wrong offset!");
static_assert(offsetof(UX6PlayMontageCallbackProxy, OnBlendOut) == 0x000038, "Member 'UX6PlayMontageCallbackProxy::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UX6PlayMontageCallbackProxy, OnInterrupted) == 0x000048, "Member 'UX6PlayMontageCallbackProxy::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UX6PlayMontageCallbackProxy, OnNotifyBegin) == 0x000058, "Member 'UX6PlayMontageCallbackProxy::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UX6PlayMontageCallbackProxy, OnNotifyEnd) == 0x000068, "Member 'UX6PlayMontageCallbackProxy::OnNotifyEnd' has a wrong offset!");

// Class X6Animation.X6SequencePlayerLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6SequencePlayerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearCachedBlendWeight(const struct FX6SequencePlayerReference& SequencePlayer);
	static float ComputePlayRateFromDuration(const struct FX6SequencePlayerReference& SequencePlayer, float Duration);
	static void ConvertToSequencePlayerPure(const struct FAnimNodeReference& Node, struct FX6SequencePlayerReference* SequencePlayer, bool* Result);
	static struct FX6OverlayBlendReference ConvertToX6OverlayBlend(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result);
	static struct FX6SequencePlayerReference ConvertToX6SequencePlayer(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result);
	static struct FX6StylizedOverlayBlendReference ConvertToX6StylizedOverlayBlend(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result);
	static struct FX6OverlayBlendReference DeactivateBlendThisFrame(const struct FX6OverlayBlendReference& OverlayBlend, float Time);
	static struct FX6StylizedOverlayBlendReference DeactivateStylizedBlendThisFrame(const struct FX6StylizedOverlayBlendReference& OverlayBlend, float Time);
	static float GetAccumulatedTime(const struct FX6SequencePlayerReference& SequencePlayer);
	static float GetAnimTimeRemaining(const struct FX6SequencePlayerReference& SequencePlayer);
	static float GetAnimTimeRemainingFraction(const struct FX6SequencePlayerReference& SequencePlayer);
	static float GetCachedBlendWeight(const struct FX6SequencePlayerReference& SequencePlayer);
	static bool GetIsMirroredByPoseMatch(const struct FX6SequencePlayerReference& SequencePlayer);
	static bool GetLoopAnimation(const struct FX6SequencePlayerReference& SequencePlayer);
	static float GetPlayRate(const struct FX6SequencePlayerReference& SequencePlayer);
	static struct FX6SequencePlayerReference GetSequence(const struct FX6SequencePlayerReference& SequencePlayer, class UAnimSequenceBase*& SequenceBase);
	static class UAnimSequenceBase* GetSequencePure(const struct FX6SequencePlayerReference& SequencePlayer, EAnimNodeReferenceConversionResult* Result);
	static float GetStartPosition(const struct FX6SequencePlayerReference& SequencePlayer);
	static bool IsEnableRootMotion(const struct FX6SequencePlayerReference& SequencePlayer);
	static struct FX6SequencePlayerReference SetAccumulatedTime(const struct FX6SequencePlayerReference& SequencePlayer, float Time);
	static struct FX6SequencePlayerReference SetDistanceToMatch(const struct FX6SequencePlayerReference& SequencePlayer, const float DistanceToMatch);
	static void SetEnableRootMotion(const struct FX6SequencePlayerReference& SequencePlayer, bool bEnableRootMotion);
	static void SetMirror(const struct FX6SequencePlayerReference& SequencePlayer, bool bMirror);
	static struct FX6SequencePlayerReference SetPlayRate(const struct FX6SequencePlayerReference& SequencePlayer, float PlayRate);
	static struct FX6SequencePlayerReference SetSequence(const struct FX6SequencePlayerReference& SequencePlayer, class UAnimSequenceBase* Sequence);
	static struct FX6SequencePlayerReference SetSequenceWithInertialBlending(const struct FAnimUpdateContext& UpdateContext, const struct FX6SequencePlayerReference& SequencePlayer, class UAnimSequenceBase* Sequence, float BlendTime);
	static struct FX6SequencePlayerReference SetStartPosition(const struct FX6SequencePlayerReference& SequencePlayer, float StartPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SequencePlayerLibrary">();
	}
	static class UX6SequencePlayerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SequencePlayerLibrary>();
	}
};
static_assert(alignof(UX6SequencePlayerLibrary) == 0x000008, "Wrong alignment on UX6SequencePlayerLibrary");
static_assert(sizeof(UX6SequencePlayerLibrary) == 0x000028, "Wrong size on UX6SequencePlayerLibrary");

}

