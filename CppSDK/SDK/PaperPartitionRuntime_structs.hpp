#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PaperPartitionRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum PaperPartitionRuntime.ELoadStateCheckType
// NumValues: 0x0007
enum class ELoadStateCheckType : uint8
{
	Mesh                                     = 1,
	Collision                                = 2,
	MiscActor                                = 4,
	MicroActor                               = 8,
	VastActor                                = 16,
	MaxLoad                                  = 17,
	ELoadStateCheckType_MAX                  = 18,
};

// Enum PaperPartitionRuntime.FPPSubLevelActorType
// NumValues: 0x0004
enum class EFPPSubLevelActorType : uint32
{
	NormalActor                              = 0,
	InstancedActor                           = 1,
	MiscActor                                = 2,
	FPPSubLevelActorType_MAX                 = 3,
};

// Enum PaperPartitionRuntime.EProcessState
// NumValues: 0x0004
enum class EProcessState : uint8
{
	None                                     = 0,
	Pending                                  = 1,
	Complete                                 = 2,
	EProcessState_MAX                        = 3,
};

// Enum PaperPartitionRuntime.EPPActorType
// NumValues: 0x0005
enum class EPPActorType : uint32
{
	SMActor                                  = 0,
	MiscActor                                = 1,
	MicroActor                               = 2,
	VastActor                                = 3,
	EPPActorType_MAX                         = 4,
};

// Enum PaperPartitionRuntime.ECellActiveState
// NumValues: 0x0004
enum class ECellActiveState : uint8
{
	InActive                                 = 0,
	Activing                                 = 1,
	Activated                                = 2,
	ECellActiveState_MAX                     = 3,
};

// Enum PaperPartitionRuntime.EStreamingMode
// NumValues: 0x0004
enum class EStreamingMode : uint8
{
	Boost                                    = 0,
	Smooth                                   = 1,
	Flush                                    = 2,
	EStreamingMode_MAX                       = 3,
};

// Enum PaperPartitionRuntime.EPPCellType
// NumValues: 0x0003
enum class EPPCellType : uint8
{
	Base                                     = 0,
	Binding                                  = 1,
	EPPCellType_MAX                          = 2,
};

// Enum PaperPartitionRuntime.FPPVastLevelAsyncLoadState
// NumValues: 0x0004
enum class EFPPVastLevelAsyncLoadState : uint8
{
	Prepare                                  = 0,
	Loading                                  = 1,
	Complete                                 = 2,
	FPPVastLevelAsyncLoadState_MAX           = 3,
};

// ScriptStruct PaperPartitionRuntime.PPCollisionCellLevelInfos
// 0x0010 (0x0010 - 0x0000)
struct FPPCollisionCellLevelInfos final
{
public:
	TArray<class FString>                         LevelsInfo;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPPCollisionCellLevelInfos) == 0x000008, "Wrong alignment on FPPCollisionCellLevelInfos");
static_assert(sizeof(FPPCollisionCellLevelInfos) == 0x000010, "Wrong size on FPPCollisionCellLevelInfos");
static_assert(offsetof(FPPCollisionCellLevelInfos, LevelsInfo) == 0x000000, "Member 'FPPCollisionCellLevelInfos::LevelsInfo' has a wrong offset!");

// ScriptStruct PaperPartitionRuntime.PPSocketInfo
// 0x0050 (0x0050 - 0x0000)
struct FPPSocketInfo final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPPSocketInfo) == 0x000008, "Wrong alignment on FPPSocketInfo");
static_assert(sizeof(FPPSocketInfo) == 0x000050, "Wrong size on FPPSocketInfo");
static_assert(offsetof(FPPSocketInfo, SocketName) == 0x000000, "Member 'FPPSocketInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FPPSocketInfo, RelativeLocation) == 0x000008, "Member 'FPPSocketInfo::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FPPSocketInfo, RelativeRotation) == 0x000020, "Member 'FPPSocketInfo::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FPPSocketInfo, RelativeScale) == 0x000038, "Member 'FPPSocketInfo::RelativeScale' has a wrong offset!");

// ScriptStruct PaperPartitionRuntime.PPSocketInfos
// 0x0010 (0x0010 - 0x0000)
struct FPPSocketInfos final
{
public:
	TArray<struct FPPSocketInfo>                  SocketInfos;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPPSocketInfos) == 0x000008, "Wrong alignment on FPPSocketInfos");
static_assert(sizeof(FPPSocketInfos) == 0x000010, "Wrong size on FPPSocketInfos");
static_assert(offsetof(FPPSocketInfos, SocketInfos) == 0x000000, "Member 'FPPSocketInfos::SocketInfos' has a wrong offset!");

// ScriptStruct PaperPartitionRuntime.PPSubLevelActorReferenceInfo
// 0x0028 (0x0028 - 0x0000)
struct FPPSubLevelActorReferenceInfo final
{
public:
	class FString                                 LevelPath;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFPPSubLevelActorType                         ActorType;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstancedIndex;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MiscSoftPath;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPPSubLevelActorReferenceInfo) == 0x000008, "Wrong alignment on FPPSubLevelActorReferenceInfo");
static_assert(sizeof(FPPSubLevelActorReferenceInfo) == 0x000028, "Wrong size on FPPSubLevelActorReferenceInfo");
static_assert(offsetof(FPPSubLevelActorReferenceInfo, LevelPath) == 0x000000, "Member 'FPPSubLevelActorReferenceInfo::LevelPath' has a wrong offset!");
static_assert(offsetof(FPPSubLevelActorReferenceInfo, ActorType) == 0x000010, "Member 'FPPSubLevelActorReferenceInfo::ActorType' has a wrong offset!");
static_assert(offsetof(FPPSubLevelActorReferenceInfo, InstancedIndex) == 0x000014, "Member 'FPPSubLevelActorReferenceInfo::InstancedIndex' has a wrong offset!");
static_assert(offsetof(FPPSubLevelActorReferenceInfo, MiscSoftPath) == 0x000018, "Member 'FPPSubLevelActorReferenceInfo::MiscSoftPath' has a wrong offset!");

// ScriptStruct PaperPartitionRuntime.PPSubLevelActorReferenceInfos
// 0x0010 (0x0010 - 0x0000)
struct FPPSubLevelActorReferenceInfos final
{
public:
	TArray<struct FPPSubLevelActorReferenceInfo>  ReferenceInfos;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPPSubLevelActorReferenceInfos) == 0x000008, "Wrong alignment on FPPSubLevelActorReferenceInfos");
static_assert(sizeof(FPPSubLevelActorReferenceInfos) == 0x000010, "Wrong size on FPPSubLevelActorReferenceInfos");
static_assert(offsetof(FPPSubLevelActorReferenceInfos, ReferenceInfos) == 0x000000, "Member 'FPPSubLevelActorReferenceInfos::ReferenceInfos' has a wrong offset!");

// ScriptStruct PaperPartitionRuntime.PPVastStreamingActor
// 0x00A8 (0x00A8 - 0x0000)
struct FPPVastStreamingActor final
{
public:
	struct FSoftObjectPath                        ActorPath;                                         // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorLocation;                                     // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ActorBounds;                                       // 0x0038(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StreamingDistance;                                 // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OriLevelName;                                      // 0x0074(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorldTag;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPPVastStreamingActor) == 0x000008, "Wrong alignment on FPPVastStreamingActor");
static_assert(sizeof(FPPVastStreamingActor) == 0x0000A8, "Wrong size on FPPVastStreamingActor");
static_assert(offsetof(FPPVastStreamingActor, ActorPath) == 0x000000, "Member 'FPPVastStreamingActor::ActorPath' has a wrong offset!");
static_assert(offsetof(FPPVastStreamingActor, ActorLocation) == 0x000020, "Member 'FPPVastStreamingActor::ActorLocation' has a wrong offset!");
static_assert(offsetof(FPPVastStreamingActor, ActorBounds) == 0x000038, "Member 'FPPVastStreamingActor::ActorBounds' has a wrong offset!");
static_assert(offsetof(FPPVastStreamingActor, StreamingDistance) == 0x000070, "Member 'FPPVastStreamingActor::StreamingDistance' has a wrong offset!");
static_assert(offsetof(FPPVastStreamingActor, OriLevelName) == 0x000074, "Member 'FPPVastStreamingActor::OriLevelName' has a wrong offset!");
static_assert(offsetof(FPPVastStreamingActor, WorldTag) == 0x000080, "Member 'FPPVastStreamingActor::WorldTag' has a wrong offset!");

}

