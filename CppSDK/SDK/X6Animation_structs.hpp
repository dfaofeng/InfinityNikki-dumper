#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: X6Animation

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "ControlRig_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimationCore_structs.hpp"


namespace SDK
{

// Enum X6Animation.ELocomotionGait
// NumValues: 0x0006
enum class ELocomotionGait : uint8
{
	LMG_TYPE1                                = 0,
	LMG_TYPE2                                = 1,
	LMG_WalkFast                             = 2,
	LMG_Jog                                  = 3,
	LMG_Sprint                               = 4,
	LMG_MAX                                  = 5,
};

// Enum X6Animation.ELocomotionType
// NumValues: 0x0004
enum class ELocomotionType : uint8
{
	ELT_NONE                                 = 0,
	ELT_GROUND_NORMAL                        = 1,
	ELT_INAIR_NORMAL                         = 2,
	ELT_MAX                                  = 3,
};

// Enum X6Animation.ELocoExitAnimType
// NumValues: 0x0008
enum class ELocoExitAnimType : uint8
{
	LEAT_TYPE1                               = 0,
	LEAT_TYPE2                               = 1,
	LEAT_TYPE3                               = 2,
	LEAT_TYPE4                               = 3,
	LEAT_TYPE5                               = 4,
	LEAT_TYPE6                               = 5,
	LEAT_TYPE7                               = 6,
	LEAT_MAX                                 = 7,
};

// Enum X6Animation.EX6ActionBlendType
// NumValues: 0x0003
enum class EX6ActionBlendType : uint8
{
	Default                                  = 0,
	CustomMode                               = 1,
	EX6ActionBlendType_MAX                   = 2,
};

// Enum X6Animation.EX6ActionBlendIKType
// NumValues: 0x0004
enum class EX6ActionBlendIKType : uint8
{
	None                                     = 0,
	LeftHandAuthority                        = 1,
	RightHandAuthority                       = 2,
	EX6ActionBlendIKType_MAX                 = 3,
};

// Enum X6Animation.EX6OverlayBlendType
// NumValues: 0x0003
enum class EX6OverlayBlendType : uint8
{
	Default                                  = 0,
	CustomMode                               = 1,
	EX6OverlayBlendType_MAX                  = 2,
};

// Enum X6Animation.EX6PoseBlendNodeMode
// NumValues: 0x0004
enum class EX6PoseBlendNodeMode : uint8
{
	Normal                                   = 0,
	EvaluateMontage                          = 1,
	EvaluateAnimSequence                     = 2,
	EX6PoseBlendNodeMode_MAX                 = 3,
};

// Enum X6Animation.EX6SequenceTimeControlType
// NumValues: 0x0007
enum class EX6SequenceTimeControlType : uint8
{
	EX6STCT_None                             = 0,
	EX6STCT_DISTANCE_MATCH                   = 1,
	EX6STCT_SET                              = 2,
	EX6STCT_POSE_MATCH                       = 3,
	EX6STCT_MATCH_FOOT                       = 4,
	EX6STCT_MATCH_CURVE                      = 5,
	EX6STCT_MAX                              = 6,
};

// Enum X6Animation.EX6StateMachineMarkerType
// NumValues: 0x0003
enum class EX6StateMachineMarkerType : uint8
{
	Auto                                     = 0,
	Manual                                   = 1,
	EX6StateMachineMarkerType_MAX            = 2,
};

// Enum X6Animation.EContextualPlayType
// NumValues: 0x0003
enum class EContextualPlayType : uint8
{
	ECST_CONTINUOUS                          = 0,
	ECST_ONCE                                = 1,
	ECST_MAX                                 = 2,
};

// Enum X6Animation.EContextualType
// NumValues: 0x0005
enum class EContextualType : uint8
{
	ECT_NONE                                 = 0,
	ECT_WEATHER                              = 1,
	ECT_ENVIRONMENT                          = 2,
	ECT_IDLE                                 = 3,
	ECT_MAX                                  = 4,
};

// Enum X6Animation.ENativePlayerLocomotionType
// NumValues: 0x0005
enum class ENativePlayerLocomotionType : uint8
{
	EMovementType_None                       = 0,
	EMovementType_Walking                    = 1,
	EMovementType_Running                    = 2,
	EMovementType_Sprinting                  = 3,
	EMovementType_Max                        = 4,
};

// Enum X6Animation.ENativePlayerFloatingJumpStage
// NumValues: 0x0008
enum class ENativePlayerFloatingJumpStage : uint8
{
	OnLand                                   = 0,
	Jump                                     = 1,
	Fly                                      = 2,
	Fall                                     = 3,
	Crash                                    = 4,
	SlowFall                                 = 5,
	Float                                    = 6,
	ENativePlayerFloatingJumpStage_MAX       = 7,
};

// Enum X6Animation.ELocomotionGroundMainState
// NumValues: 0x0006
enum class ELocomotionGroundMainState : uint8
{
	ELMGMS_NOT_MOVING                        = 0,
	ELMGMS_START                             = 1,
	ELMGMS_PIVOT                             = 2,
	ELMGMS_STOP                              = 3,
	ELMGMS_MOVING                            = 4,
	ELMGMS_MAX                               = 5,
};

// Enum X6Animation.ELocomotionGroundIdleState
// NumValues: 0x0004
enum class ELocomotionGroundIdleState : uint8
{
	ELGIS_NOTIDLE                            = 0,
	ELGIS_DEFAULT_IDLE                       = 1,
	ELGIS_CONTEXTURE_IDLE                    = 2,
	ELGIS_MAX                                = 3,
};

// Enum X6Animation.EX6AnimTagGait
// NumValues: 0x0006
enum class EX6AnimTagGait : uint8
{
	EX6ATG_IDLE                              = 0,
	EX6ATG_Walk                              = 1,
	EX6ATG_JOG                               = 2,
	EX6ATG_SPRINT                            = 3,
	EX6ATG_PRESERVE1                         = 4,
	EX6ATG_MAX                               = 5,
};

// Enum X6Animation.ECopyMotion_Component
// NumValues: 0x0005
enum class ECopyMotion_Component : uint8
{
	TranslationX                             = 0,
	TranslationY                             = 1,
	TranslationZ                             = 2,
	RotationAngle                            = 3,
	ECopyMotion_MAX                          = 4,
};

// ScriptStruct X6Animation.AnimNode_MirrorForPoseMatch
// 0x0000 (0x0048 - 0x0048)
struct FAnimNode_MirrorForPoseMatch final : public FAnimNode_Mirror
{
};
static_assert(alignof(FAnimNode_MirrorForPoseMatch) == 0x000008, "Wrong alignment on FAnimNode_MirrorForPoseMatch");
static_assert(sizeof(FAnimNode_MirrorForPoseMatch) == 0x000048, "Wrong size on FAnimNode_MirrorForPoseMatch");

// ScriptStruct X6Animation.AnimNode_SequencePlayerIgnorePose
// 0x0008 (0x0048 - 0x0040)
struct FAnimNode_SequencePlayerIgnorePose final : public FAnimNode_SequencePlayerBase
{
public:
	class UAnimSequenceBase*                      Sequence;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_SequencePlayerIgnorePose) == 0x000008, "Wrong alignment on FAnimNode_SequencePlayerIgnorePose");
static_assert(sizeof(FAnimNode_SequencePlayerIgnorePose) == 0x000048, "Wrong size on FAnimNode_SequencePlayerIgnorePose");
static_assert(offsetof(FAnimNode_SequencePlayerIgnorePose, Sequence) == 0x000040, "Member 'FAnimNode_SequencePlayerIgnorePose::Sequence' has a wrong offset!");

// ScriptStruct X6Animation.X6OverlayCurveData
// 0x0018 (0x0018 - 0x0000)
struct FX6OverlayCurveData final
{
public:
	bool                                          bUseCurve;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AlphaCurve;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         alpha;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6OverlayCurveData) == 0x000008, "Wrong alignment on FX6OverlayCurveData");
static_assert(sizeof(FX6OverlayCurveData) == 0x000018, "Wrong size on FX6OverlayCurveData");
static_assert(offsetof(FX6OverlayCurveData, bUseCurve) == 0x000000, "Member 'FX6OverlayCurveData::bUseCurve' has a wrong offset!");
static_assert(offsetof(FX6OverlayCurveData, AlphaCurve) == 0x000008, "Member 'FX6OverlayCurveData::AlphaCurve' has a wrong offset!");
static_assert(offsetof(FX6OverlayCurveData, alpha) == 0x000010, "Member 'FX6OverlayCurveData::alpha' has a wrong offset!");

// ScriptStruct X6Animation.X6OverlayPerBoneBlendWeights
// 0x0058 (0x0058 - 0x0000)
struct FX6OverlayPerBoneBlendWeights final
{
public:
	TArray<struct FPerBoneBlendWeight>            PerBoneBlendWeights;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPerBoneBlendWeight>            DesiredBoneBlendWeights;                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceAdditive;                                // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceRotationBlend;                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootMSpaceRotationBlend;                          // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6OverlayCurveData                    MotionAlphaData;                                   // 0x0028(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FX6OverlayCurveData                    OverlayAlphaData;                                  // 0x0040(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6OverlayPerBoneBlendWeights) == 0x000008, "Wrong alignment on FX6OverlayPerBoneBlendWeights");
static_assert(sizeof(FX6OverlayPerBoneBlendWeights) == 0x000058, "Wrong size on FX6OverlayPerBoneBlendWeights");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, PerBoneBlendWeights) == 0x000000, "Member 'FX6OverlayPerBoneBlendWeights::PerBoneBlendWeights' has a wrong offset!");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, DesiredBoneBlendWeights) == 0x000010, "Member 'FX6OverlayPerBoneBlendWeights::DesiredBoneBlendWeights' has a wrong offset!");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, bMeshSpaceAdditive) == 0x000020, "Member 'FX6OverlayPerBoneBlendWeights::bMeshSpaceAdditive' has a wrong offset!");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, bMeshSpaceRotationBlend) == 0x000021, "Member 'FX6OverlayPerBoneBlendWeights::bMeshSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, bRootMSpaceRotationBlend) == 0x000022, "Member 'FX6OverlayPerBoneBlendWeights::bRootMSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, MotionAlphaData) == 0x000028, "Member 'FX6OverlayPerBoneBlendWeights::MotionAlphaData' has a wrong offset!");
static_assert(offsetof(FX6OverlayPerBoneBlendWeights, OverlayAlphaData) == 0x000040, "Member 'FX6OverlayPerBoneBlendWeights::OverlayAlphaData' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6ActionBlend
// 0x0300 (0x0310 - 0x0010)
struct FAnimNode_X6ActionBlend final : public FAnimNode_Base
{
public:
	EX6ActionBlendType                            ActionBlendType;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseLink                              InputPose;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ActionMontage;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6ActionBlendData*                     BlendData;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BasicSlotName;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdditiveSlotName;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CacheActionMontage;                                // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UX6ActionBlendData*                     CacheBlendData;                                    // 0x0050(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FX6OverlayPerBoneBlendWeights          AdditivePerBoneWeights;                            // 0x0058(0x0058)(NativeAccessSpecifierPrivate)
	struct FX6OverlayPerBoneBlendWeights          AuthoredPerBoneWeights;                            // 0x00B0(0x0058)(NativeAccessSpecifierPrivate)
	bool                                          bCacheOverlayChanged;                              // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SkeletonGuid;                                      // 0x010C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x011C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x44];                                     // 0x012C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMirror;                                           // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x0178(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x78];                                     // 0x0180(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         LeftHandSourceBone;                                // 0x01F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHandSourceBone;                               // 0x0208(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x0218(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x30];                                     // 0x0228(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInertializationRequest>        RequestQueue;                                      // 0x0258(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0xA0];                                     // 0x0268(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableNodeWithBlend;                             // 0x0309(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6ActionBlend) == 0x000008, "Wrong alignment on FAnimNode_X6ActionBlend");
static_assert(sizeof(FAnimNode_X6ActionBlend) == 0x000310, "Wrong size on FAnimNode_X6ActionBlend");
static_assert(offsetof(FAnimNode_X6ActionBlend, ActionBlendType) == 0x000010, "Member 'FAnimNode_X6ActionBlend::ActionBlendType' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, InputPose) == 0x000018, "Member 'FAnimNode_X6ActionBlend::InputPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, ActionMontage) == 0x000028, "Member 'FAnimNode_X6ActionBlend::ActionMontage' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, BlendData) == 0x000030, "Member 'FAnimNode_X6ActionBlend::BlendData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, BasicSlotName) == 0x000038, "Member 'FAnimNode_X6ActionBlend::BasicSlotName' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, AdditiveSlotName) == 0x000040, "Member 'FAnimNode_X6ActionBlend::AdditiveSlotName' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, CacheActionMontage) == 0x000048, "Member 'FAnimNode_X6ActionBlend::CacheActionMontage' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, CacheBlendData) == 0x000050, "Member 'FAnimNode_X6ActionBlend::CacheBlendData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, AdditivePerBoneWeights) == 0x000058, "Member 'FAnimNode_X6ActionBlend::AdditivePerBoneWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, AuthoredPerBoneWeights) == 0x0000B0, "Member 'FAnimNode_X6ActionBlend::AuthoredPerBoneWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, bCacheOverlayChanged) == 0x000108, "Member 'FAnimNode_X6ActionBlend::bCacheOverlayChanged' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, SkeletonGuid) == 0x00010C, "Member 'FAnimNode_X6ActionBlend::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, VirtualBoneGuid) == 0x00011C, "Member 'FAnimNode_X6ActionBlend::VirtualBoneGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, bMirror) == 0x000170, "Member 'FAnimNode_X6ActionBlend::bMirror' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, MirrorDataTable) == 0x000178, "Member 'FAnimNode_X6ActionBlend::MirrorDataTable' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, LeftHandSourceBone) == 0x0001F8, "Member 'FAnimNode_X6ActionBlend::LeftHandSourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, RightHandSourceBone) == 0x000208, "Member 'FAnimNode_X6ActionBlend::RightHandSourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, TargetBone) == 0x000218, "Member 'FAnimNode_X6ActionBlend::TargetBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, RequestQueue) == 0x000258, "Member 'FAnimNode_X6ActionBlend::RequestQueue' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, bEnabled) == 0x000308, "Member 'FAnimNode_X6ActionBlend::bEnabled' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6ActionBlend, bDisableNodeWithBlend) == 0x000309, "Member 'FAnimNode_X6ActionBlend::bDisableNodeWithBlend' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6AimOffsetLookAt
// 0x0030 (0x0210 - 0x01E0)
struct FAnimNode_X6AimOffsetLookAt final : public FAnimNode_AimOffsetLookAt
{
public:
	struct FVector2D                              AimOffsetDeadZone;                                 // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleAlpha;                                        // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bX6EnableCustomSmoothingTime;                      // 0x01F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         X6CustomSmoothingTime;                             // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            LastBlendSpace;                                    // 0x0200(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6AimOffsetLookAt) == 0x000010, "Wrong alignment on FAnimNode_X6AimOffsetLookAt");
static_assert(sizeof(FAnimNode_X6AimOffsetLookAt) == 0x000210, "Wrong size on FAnimNode_X6AimOffsetLookAt");
static_assert(offsetof(FAnimNode_X6AimOffsetLookAt, AimOffsetDeadZone) == 0x0001E0, "Member 'FAnimNode_X6AimOffsetLookAt::AimOffsetDeadZone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6AimOffsetLookAt, AngleAlpha) == 0x0001F0, "Member 'FAnimNode_X6AimOffsetLookAt::AngleAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6AimOffsetLookAt, bX6EnableCustomSmoothingTime) == 0x0001F4, "Member 'FAnimNode_X6AimOffsetLookAt::bX6EnableCustomSmoothingTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6AimOffsetLookAt, X6CustomSmoothingTime) == 0x0001F8, "Member 'FAnimNode_X6AimOffsetLookAt::X6CustomSmoothingTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6AimOffsetLookAt, LastBlendSpace) == 0x000200, "Member 'FAnimNode_X6AimOffsetLookAt::LastBlendSpace' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6EyeLookAt
// 0x01A0 (0x01B0 - 0x0010)
struct alignas(0x10) FAnimNode_X6EyeLookAt final : public FAnimNode_Base
{
public:
	struct FPoseLink                              InputPose;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         alpha;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeMotionSpeed;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TwoEyesRotatorOffset;                              // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAimOffsetWithEyeMotion;                           // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipUpdateLookAtTarget;                           // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEyeRotationBaseOnReference;                       // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             EyeMotionSpace;                                    // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         L_EyeBone;                                         // 0x0044(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               L_EyeRotation;                                     // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         R_EyeBone;                                         // 0x0070(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               R_EyeRotation;                                     // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x118];                                     // 0x0098(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6EyeLookAt) == 0x000010, "Wrong alignment on FAnimNode_X6EyeLookAt");
static_assert(sizeof(FAnimNode_X6EyeLookAt) == 0x0001B0, "Wrong size on FAnimNode_X6EyeLookAt");
static_assert(offsetof(FAnimNode_X6EyeLookAt, InputPose) == 0x000010, "Member 'FAnimNode_X6EyeLookAt::InputPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, alpha) == 0x000020, "Member 'FAnimNode_X6EyeLookAt::alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, EyeMotionSpeed) == 0x000024, "Member 'FAnimNode_X6EyeLookAt::EyeMotionSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, TwoEyesRotatorOffset) == 0x000028, "Member 'FAnimNode_X6EyeLookAt::TwoEyesRotatorOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, bAimOffsetWithEyeMotion) == 0x000040, "Member 'FAnimNode_X6EyeLookAt::bAimOffsetWithEyeMotion' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, bSkipUpdateLookAtTarget) == 0x000041, "Member 'FAnimNode_X6EyeLookAt::bSkipUpdateLookAtTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, bEyeRotationBaseOnReference) == 0x000042, "Member 'FAnimNode_X6EyeLookAt::bEyeRotationBaseOnReference' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, EyeMotionSpace) == 0x000043, "Member 'FAnimNode_X6EyeLookAt::EyeMotionSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, L_EyeBone) == 0x000044, "Member 'FAnimNode_X6EyeLookAt::L_EyeBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, L_EyeRotation) == 0x000058, "Member 'FAnimNode_X6EyeLookAt::L_EyeRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, R_EyeBone) == 0x000070, "Member 'FAnimNode_X6EyeLookAt::R_EyeBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6EyeLookAt, R_EyeRotation) == 0x000080, "Member 'FAnimNode_X6EyeLookAt::R_EyeRotation' has a wrong offset!");

// ScriptStruct X6Animation.IgnoreBlendPose
// 0x0010 (0x0010 - 0x0000)
struct FIgnoreBlendPose final
{
public:
	TArray<class FName>                           IgnoreBoneNames;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIgnoreBlendPose) == 0x000008, "Wrong alignment on FIgnoreBlendPose");
static_assert(sizeof(FIgnoreBlendPose) == 0x000010, "Wrong size on FIgnoreBlendPose");
static_assert(offsetof(FIgnoreBlendPose, IgnoreBoneNames) == 0x000000, "Member 'FIgnoreBlendPose::IgnoreBoneNames' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6LayeredBoneBlend
// 0x00F8 (0x0108 - 0x0010)
struct FAnimNode_X6LayeredBoneBlend final : public FAnimNode_Base
{
public:
	int32                                         DesiredBlendPoseNum;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           X6BlendIgnoreBoneNames;                            // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              BasePose;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FPoseLink>                      BlendPoses;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	ELayeredBoneBlendMode                         BlendMode;                                         // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBlendProfile*>                  BlendMasks;                                        // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FInputBlendPose>                LayerSetup;                                        // 0x0060(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BlendWeights;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceRotationBlend;                           // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceScaleBlend;                              // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurveBlendOption                             CurveBlendOption;                                  // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendRootMotionBasedOnRootBone;                   // 0x0083(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerBoneBlendWeight>            PerBoneBlendWeights;                               // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  SkeletonGuid;                                      // 0x00A0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x00B0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x48];                                      // 0x00C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6LayeredBoneBlend) == 0x000008, "Wrong alignment on FAnimNode_X6LayeredBoneBlend");
static_assert(sizeof(FAnimNode_X6LayeredBoneBlend) == 0x000108, "Wrong size on FAnimNode_X6LayeredBoneBlend");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, DesiredBlendPoseNum) == 0x000010, "Member 'FAnimNode_X6LayeredBoneBlend::DesiredBlendPoseNum' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, X6BlendIgnoreBoneNames) == 0x000018, "Member 'FAnimNode_X6LayeredBoneBlend::X6BlendIgnoreBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, BasePose) == 0x000028, "Member 'FAnimNode_X6LayeredBoneBlend::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, BlendPoses) == 0x000038, "Member 'FAnimNode_X6LayeredBoneBlend::BlendPoses' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, BlendMode) == 0x000048, "Member 'FAnimNode_X6LayeredBoneBlend::BlendMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, BlendMasks) == 0x000050, "Member 'FAnimNode_X6LayeredBoneBlend::BlendMasks' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, LayerSetup) == 0x000060, "Member 'FAnimNode_X6LayeredBoneBlend::LayerSetup' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, BlendWeights) == 0x000070, "Member 'FAnimNode_X6LayeredBoneBlend::BlendWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, bMeshSpaceRotationBlend) == 0x000080, "Member 'FAnimNode_X6LayeredBoneBlend::bMeshSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, bMeshSpaceScaleBlend) == 0x000081, "Member 'FAnimNode_X6LayeredBoneBlend::bMeshSpaceScaleBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, CurveBlendOption) == 0x000082, "Member 'FAnimNode_X6LayeredBoneBlend::CurveBlendOption' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, bBlendRootMotionBasedOnRootBone) == 0x000083, "Member 'FAnimNode_X6LayeredBoneBlend::bBlendRootMotionBasedOnRootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, LODThreshold) == 0x000088, "Member 'FAnimNode_X6LayeredBoneBlend::LODThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, PerBoneBlendWeights) == 0x000090, "Member 'FAnimNode_X6LayeredBoneBlend::PerBoneBlendWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, SkeletonGuid) == 0x0000A0, "Member 'FAnimNode_X6LayeredBoneBlend::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LayeredBoneBlend, VirtualBoneGuid) == 0x0000B0, "Member 'FAnimNode_X6LayeredBoneBlend::VirtualBoneGuid' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6Mirror
// 0x0000 (0x0048 - 0x0048)
struct FAnimNode_X6Mirror final : public FAnimNode_Mirror
{
};
static_assert(alignof(FAnimNode_X6Mirror) == 0x000008, "Wrong alignment on FAnimNode_X6Mirror");
static_assert(sizeof(FAnimNode_X6Mirror) == 0x000048, "Wrong size on FAnimNode_X6Mirror");

// ScriptStruct X6Animation.X6OverlayBlendData
// 0x0048 (0x0048 - 0x0000)
struct FX6OverlayBlendData final
{
public:
	TArray<struct FBranchFilter>                  LayerSetup;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceAdditive;                                // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceRotationBlend;                           // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootMSpaceRotationBlend;                          // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6OverlayCurveData                    MotionAlphaData;                                   // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FX6OverlayCurveData                    OverlayAlphaData;                                  // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6OverlayBlendData) == 0x000008, "Wrong alignment on FX6OverlayBlendData");
static_assert(sizeof(FX6OverlayBlendData) == 0x000048, "Wrong size on FX6OverlayBlendData");
static_assert(offsetof(FX6OverlayBlendData, LayerSetup) == 0x000000, "Member 'FX6OverlayBlendData::LayerSetup' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendData, bMeshSpaceAdditive) == 0x000010, "Member 'FX6OverlayBlendData::bMeshSpaceAdditive' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendData, bMeshSpaceRotationBlend) == 0x000011, "Member 'FX6OverlayBlendData::bMeshSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendData, bRootMSpaceRotationBlend) == 0x000012, "Member 'FX6OverlayBlendData::bRootMSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendData, MotionAlphaData) == 0x000018, "Member 'FX6OverlayBlendData::MotionAlphaData' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendData, OverlayAlphaData) == 0x000030, "Member 'FX6OverlayBlendData::OverlayAlphaData' has a wrong offset!");

// ScriptStruct X6Animation.X6OverlayBlendProfilePerBoneInfo
// 0x0010 (0x0010 - 0x0000)
struct FX6OverlayBlendProfilePerBoneInfo final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecurse;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6OverlayBlendProfilePerBoneInfo) == 0x000004, "Wrong alignment on FX6OverlayBlendProfilePerBoneInfo");
static_assert(sizeof(FX6OverlayBlendProfilePerBoneInfo) == 0x000010, "Wrong size on FX6OverlayBlendProfilePerBoneInfo");
static_assert(offsetof(FX6OverlayBlendProfilePerBoneInfo, BoneName) == 0x000000, "Member 'FX6OverlayBlendProfilePerBoneInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendProfilePerBoneInfo, Scale) == 0x000008, "Member 'FX6OverlayBlendProfilePerBoneInfo::Scale' has a wrong offset!");
static_assert(offsetof(FX6OverlayBlendProfilePerBoneInfo, bRecurse) == 0x00000C, "Member 'FX6OverlayBlendProfilePerBoneInfo::bRecurse' has a wrong offset!");

// ScriptStruct X6Animation.X6InertialBlendInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FX6InertialBlendInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6InertialBlendInfo) == 0x000008, "Wrong alignment on FX6InertialBlendInfo");
static_assert(sizeof(FX6InertialBlendInfo) == 0x000018, "Wrong size on FX6InertialBlendInfo");

// ScriptStruct X6Animation.X6InertializationPose
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x10) FX6InertializationPose final
{
public:
	uint8                                         Pad_0[0xC0];                                       // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6InertializationPose) == 0x000010, "Wrong alignment on FX6InertializationPose");
static_assert(sizeof(FX6InertializationPose) == 0x0000C0, "Wrong size on FX6InertializationPose");

// ScriptStruct X6Animation.X6InertializationPoseDiff
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FX6InertializationPoseDiff final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6InertializationPoseDiff) == 0x000008, "Wrong alignment on FX6InertializationPoseDiff");
static_assert(sizeof(FX6InertializationPoseDiff) == 0x000028, "Wrong size on FX6InertializationPoseDiff");

// ScriptStruct X6Animation.AnimNode_X6OverlayBlend
// 0x0248 (0x0258 - 0x0010)
struct FAnimNode_X6OverlayBlend final : public FAnimNode_Base
{
public:
	EX6OverlayBlendType                           OverlayType;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseLink                              LocomotionPose;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              BasePose;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              OverlayPose;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayData*                         OverlayData;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayCustomModeData*               OverlayCustomModeData;                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayFrameSettings*                FrameSettings;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlayAnimInternalTimeAccumulator;                // 0x0068(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayData*                         CachedOverlayData;                                 // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6OverlayCustomModeData*               CachedOverlayCustomModeData;                       // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FX6OverlayPerBoneBlendWeights>  PerBoneWeights;                                    // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bCacheOverlayChanged;                              // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SkeletonGuid;                                      // 0x00B4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x00C4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x20];                                      // 0x00D4(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableManualMirror;                               // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualMirror;                                     // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0xA0];                                     // 0x0100(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInertializationRequest>        RequestQueue;                                      // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0xA0];                                     // 0x01B0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableNodeWithBlend;                             // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6OverlayBlend) == 0x000008, "Wrong alignment on FAnimNode_X6OverlayBlend");
static_assert(sizeof(FAnimNode_X6OverlayBlend) == 0x000258, "Wrong size on FAnimNode_X6OverlayBlend");
static_assert(offsetof(FAnimNode_X6OverlayBlend, OverlayType) == 0x000010, "Member 'FAnimNode_X6OverlayBlend::OverlayType' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, LocomotionPose) == 0x000018, "Member 'FAnimNode_X6OverlayBlend::LocomotionPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, BasePose) == 0x000028, "Member 'FAnimNode_X6OverlayBlend::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, OverlayPose) == 0x000038, "Member 'FAnimNode_X6OverlayBlend::OverlayPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, LODThreshold) == 0x000048, "Member 'FAnimNode_X6OverlayBlend::LODThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, OverlayData) == 0x000050, "Member 'FAnimNode_X6OverlayBlend::OverlayData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, OverlayCustomModeData) == 0x000058, "Member 'FAnimNode_X6OverlayBlend::OverlayCustomModeData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, FrameSettings) == 0x000060, "Member 'FAnimNode_X6OverlayBlend::FrameSettings' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, OverlayAnimInternalTimeAccumulator) == 0x000068, "Member 'FAnimNode_X6OverlayBlend::OverlayAnimInternalTimeAccumulator' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, CachedOverlayData) == 0x000070, "Member 'FAnimNode_X6OverlayBlend::CachedOverlayData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, CachedOverlayCustomModeData) == 0x000078, "Member 'FAnimNode_X6OverlayBlend::CachedOverlayCustomModeData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, PerBoneWeights) == 0x0000A0, "Member 'FAnimNode_X6OverlayBlend::PerBoneWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, bCacheOverlayChanged) == 0x0000B0, "Member 'FAnimNode_X6OverlayBlend::bCacheOverlayChanged' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, SkeletonGuid) == 0x0000B4, "Member 'FAnimNode_X6OverlayBlend::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, VirtualBoneGuid) == 0x0000C4, "Member 'FAnimNode_X6OverlayBlend::VirtualBoneGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, bEnableManualMirror) == 0x0000F4, "Member 'FAnimNode_X6OverlayBlend::bEnableManualMirror' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, bManualMirror) == 0x0000F5, "Member 'FAnimNode_X6OverlayBlend::bManualMirror' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, MirrorDataTable) == 0x0000F8, "Member 'FAnimNode_X6OverlayBlend::MirrorDataTable' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, RequestQueue) == 0x0001A0, "Member 'FAnimNode_X6OverlayBlend::RequestQueue' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, bEnabled) == 0x000250, "Member 'FAnimNode_X6OverlayBlend::bEnabled' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6OverlayBlend, bDisableNodeWithBlend) == 0x000251, "Member 'FAnimNode_X6OverlayBlend::bDisableNodeWithBlend' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6PoseBlendNode
// 0x0088 (0x0120 - 0x0098)
struct FAnimNode_X6PoseBlendNode final : public FAnimNode_PoseHandler
{
public:
	struct FPoseLink                              Source;                                            // 0x0098(0x0010)(Edit, BlueprintVisible, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	EX6PoseBlendNodeMode                          PoseBlendMode;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetCurveValueBeforePoseExtract;                 // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeCurveAfterPoseExtract;                     // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x3D];                                      // 0x00AB(0x003D)(Fixing Size After Last Property [ Dumper-7 ])
	EAlphaBlendOption                             BlendOption;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUpdateSourcePose;                           // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x1F];                                     // 0x0101(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6PoseBlendNode) == 0x000008, "Wrong alignment on FAnimNode_X6PoseBlendNode");
static_assert(sizeof(FAnimNode_X6PoseBlendNode) == 0x000120, "Wrong size on FAnimNode_X6PoseBlendNode");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, Source) == 0x000098, "Member 'FAnimNode_X6PoseBlendNode::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, PoseBlendMode) == 0x0000A8, "Member 'FAnimNode_X6PoseBlendNode::PoseBlendMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, bResetCurveValueBeforePoseExtract) == 0x0000A9, "Member 'FAnimNode_X6PoseBlendNode::bResetCurveValueBeforePoseExtract' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, bConsumeCurveAfterPoseExtract) == 0x0000AA, "Member 'FAnimNode_X6PoseBlendNode::bConsumeCurveAfterPoseExtract' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, BlendOption) == 0x0000E8, "Member 'FAnimNode_X6PoseBlendNode::BlendOption' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, CustomCurve) == 0x0000F0, "Member 'FAnimNode_X6PoseBlendNode::CustomCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, SlotName) == 0x0000F8, "Member 'FAnimNode_X6PoseBlendNode::SlotName' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseBlendNode, bAlwaysUpdateSourcePose) == 0x000100, "Member 'FAnimNode_X6PoseBlendNode::bAlwaysUpdateSourcePose' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6RootMotionWeightNormalizer
// 0x0018 (0x0028 - 0x0010)
struct FAnimNode_X6RootMotionWeightNormalizer final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6RootMotionWeightNormalizer) == 0x000008, "Wrong alignment on FAnimNode_X6RootMotionWeightNormalizer");
static_assert(sizeof(FAnimNode_X6RootMotionWeightNormalizer) == 0x000028, "Wrong size on FAnimNode_X6RootMotionWeightNormalizer");
static_assert(offsetof(FAnimNode_X6RootMotionWeightNormalizer, Source) == 0x000010, "Member 'FAnimNode_X6RootMotionWeightNormalizer::Source' has a wrong offset!");

// ScriptStruct X6Animation.MatchSequences
// 0x0010 (0x0010 - 0x0000)
struct FMatchSequences final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirror;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchSequences) == 0x000008, "Wrong alignment on FMatchSequences");
static_assert(sizeof(FMatchSequences) == 0x000010, "Wrong size on FMatchSequences");
static_assert(offsetof(FMatchSequences, AnimSequence) == 0x000000, "Member 'FMatchSequences::AnimSequence' has a wrong offset!");
static_assert(offsetof(FMatchSequences, bMirror) == 0x000008, "Member 'FMatchSequences::bMirror' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6SequencePlayer
// 0x00C8 (0x0108 - 0x0040)
struct FAnimNode_X6SequencePlayer final : public FAnimNode_SequencePlayerBase
{
public:
	class UAnimSequenceBase*                      TargetSequence;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Sequence;                                          // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSequence;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyEvaluateCurve;                                // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InertializeTimeUpdateSequence;                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFullRootMotionWeight;                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFixedPlayRateBySpeed;                             // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedToMatch;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchFoot;                                        // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderTrend;                                    // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PredictLocationSeconds;                            // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6SequenceTimeControlType                    SequenceTimeControl;                               // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToMatch;                                   // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMirrored;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchSequences>                MatchSequences;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         BeginMatchFrame;                                   // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveValueToMatch;                                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveNameToMatch;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartCurveMatchFrame;                              // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndCurveMatchFrame;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisablePrint;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTransition;                                     // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootmotionOn;                                     // 0x0102(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootmotionOff;                                    // 0x0103(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6SequencePlayer) == 0x000008, "Wrong alignment on FAnimNode_X6SequencePlayer");
static_assert(sizeof(FAnimNode_X6SequencePlayer) == 0x000108, "Wrong size on FAnimNode_X6SequencePlayer");
static_assert(offsetof(FAnimNode_X6SequencePlayer, TargetSequence) == 0x000040, "Member 'FAnimNode_X6SequencePlayer::TargetSequence' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, Sequence) == 0x000048, "Member 'FAnimNode_X6SequencePlayer::Sequence' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bUpdateSequence) == 0x000050, "Member 'FAnimNode_X6SequencePlayer::bUpdateSequence' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bOnlyEvaluateCurve) == 0x000051, "Member 'FAnimNode_X6SequencePlayer::bOnlyEvaluateCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, InertializeTimeUpdateSequence) == 0x000054, "Member 'FAnimNode_X6SequencePlayer::InertializeTimeUpdateSequence' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bForceFullRootMotionWeight) == 0x000058, "Member 'FAnimNode_X6SequencePlayer::bForceFullRootMotionWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bFixedPlayRateBySpeed) == 0x000060, "Member 'FAnimNode_X6SequencePlayer::bFixedPlayRateBySpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, SpeedToMatch) == 0x000064, "Member 'FAnimNode_X6SequencePlayer::SpeedToMatch' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bMatchFoot) == 0x000068, "Member 'FAnimNode_X6SequencePlayer::bMatchFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bConsiderTrend) == 0x000069, "Member 'FAnimNode_X6SequencePlayer::bConsiderTrend' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, PredictLocationSeconds) == 0x00006C, "Member 'FAnimNode_X6SequencePlayer::PredictLocationSeconds' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, SequenceTimeControl) == 0x000070, "Member 'FAnimNode_X6SequencePlayer::SequenceTimeControl' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, DistanceToMatch) == 0x000074, "Member 'FAnimNode_X6SequencePlayer::DistanceToMatch' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bCanMirrored) == 0x000078, "Member 'FAnimNode_X6SequencePlayer::bCanMirrored' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, MatchSequences) == 0x000080, "Member 'FAnimNode_X6SequencePlayer::MatchSequences' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, BeginMatchFrame) == 0x000090, "Member 'FAnimNode_X6SequencePlayer::BeginMatchFrame' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, CurveValueToMatch) == 0x000094, "Member 'FAnimNode_X6SequencePlayer::CurveValueToMatch' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, CurveNameToMatch) == 0x000098, "Member 'FAnimNode_X6SequencePlayer::CurveNameToMatch' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, StartCurveMatchFrame) == 0x0000A0, "Member 'FAnimNode_X6SequencePlayer::StartCurveMatchFrame' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, EndCurveMatchFrame) == 0x0000A4, "Member 'FAnimNode_X6SequencePlayer::EndCurveMatchFrame' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bDisablePrint) == 0x000100, "Member 'FAnimNode_X6SequencePlayer::bDisablePrint' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bIsTransition) == 0x000101, "Member 'FAnimNode_X6SequencePlayer::bIsTransition' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bRootmotionOn) == 0x000102, "Member 'FAnimNode_X6SequencePlayer::bRootmotionOn' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6SequencePlayer, bRootmotionOff) == 0x000103, "Member 'FAnimNode_X6SequencePlayer::bRootmotionOff' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6StateMachineMarker
// 0x0080 (0x0090 - 0x0010)
struct FAnimNode_X6StateMachineMarker final : public FAnimNode_Base
{
public:
	struct FPoseLink                              InputPose;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentStateMachineTag;                            // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGameplayTag>        ParentTagsAndStateNames;                           // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EX6StateMachineMarkerType                     MarkerType;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentStateName;                                  // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_X6StateMachineMarker) == 0x000008, "Wrong alignment on FAnimNode_X6StateMachineMarker");
static_assert(sizeof(FAnimNode_X6StateMachineMarker) == 0x000090, "Wrong size on FAnimNode_X6StateMachineMarker");
static_assert(offsetof(FAnimNode_X6StateMachineMarker, InputPose) == 0x000010, "Member 'FAnimNode_X6StateMachineMarker::InputPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StateMachineMarker, CurrentStateMachineTag) == 0x000020, "Member 'FAnimNode_X6StateMachineMarker::CurrentStateMachineTag' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StateMachineMarker, ParentTagsAndStateNames) == 0x000028, "Member 'FAnimNode_X6StateMachineMarker::ParentTagsAndStateNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StateMachineMarker, MarkerType) == 0x000078, "Member 'FAnimNode_X6StateMachineMarker::MarkerType' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StateMachineMarker, CurrentStateName) == 0x000080, "Member 'FAnimNode_X6StateMachineMarker::CurrentStateName' has a wrong offset!");

// ScriptStruct X6Animation.X6MarkedStateInfo
// 0x0018 (0x0018 - 0x0000)
struct FX6MarkedStateInfo final
{
public:
	struct FGameplayTag                           StateMachineTag;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           StateName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6MarkedStateInfo) == 0x000008, "Wrong alignment on FX6MarkedStateInfo");
static_assert(sizeof(FX6MarkedStateInfo) == 0x000018, "Wrong size on FX6MarkedStateInfo");
static_assert(offsetof(FX6MarkedStateInfo, StateMachineTag) == 0x000000, "Member 'FX6MarkedStateInfo::StateMachineTag' has a wrong offset!");
static_assert(offsetof(FX6MarkedStateInfo, StateName) == 0x000008, "Member 'FX6MarkedStateInfo::StateName' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6StylizedOverlayBlend
// 0x0258 (0x0268 - 0x0010)
struct FAnimNode_X6StylizedOverlayBlend final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LocomotionPose;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FX6MarkedStateInfo> AnimationStateMap;                          // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UX6OverlayData*> StyleOverlayData;                               // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UX6OverlayData*                         OverlayData;                                       // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6OverlayFrameSettings*                FrameSettings;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CacheAnimStateTag;                                 // 0x00D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          InertialBlendProfile;                              // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlayAnimInternalTimeAccumulator;                // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6OverlayData*                         CachedOverlayData;                                 // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FX6OverlayPerBoneBlendWeights>  PerBoneWeights;                                    // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bCacheOverlayChanged;                              // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SkeletonGuid;                                      // 0x0134(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x0144(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x3];                                      // 0x0154(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableMirror;                                     // 0x0157(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x0158(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x58];                                     // 0x0160(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInertializationRequest>        RequestQueue;                                      // 0x01B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0xA0];                                     // 0x01C8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6StylizedOverlayBlend) == 0x000008, "Wrong alignment on FAnimNode_X6StylizedOverlayBlend");
static_assert(sizeof(FAnimNode_X6StylizedOverlayBlend) == 0x000268, "Wrong size on FAnimNode_X6StylizedOverlayBlend");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, LocomotionPose) == 0x000010, "Member 'FAnimNode_X6StylizedOverlayBlend::LocomotionPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, LODThreshold) == 0x000020, "Member 'FAnimNode_X6StylizedOverlayBlend::LODThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, AnimationStateMap) == 0x000028, "Member 'FAnimNode_X6StylizedOverlayBlend::AnimationStateMap' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, StyleOverlayData) == 0x000078, "Member 'FAnimNode_X6StylizedOverlayBlend::StyleOverlayData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, OverlayData) == 0x0000C8, "Member 'FAnimNode_X6StylizedOverlayBlend::OverlayData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, FrameSettings) == 0x0000D0, "Member 'FAnimNode_X6StylizedOverlayBlend::FrameSettings' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, CacheAnimStateTag) == 0x0000D8, "Member 'FAnimNode_X6StylizedOverlayBlend::CacheAnimStateTag' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, InertialBlendProfile) == 0x0000E8, "Member 'FAnimNode_X6StylizedOverlayBlend::InertialBlendProfile' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, OverlayAnimInternalTimeAccumulator) == 0x0000F0, "Member 'FAnimNode_X6StylizedOverlayBlend::OverlayAnimInternalTimeAccumulator' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, CachedOverlayData) == 0x0000F8, "Member 'FAnimNode_X6StylizedOverlayBlend::CachedOverlayData' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, PerBoneWeights) == 0x000120, "Member 'FAnimNode_X6StylizedOverlayBlend::PerBoneWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, bCacheOverlayChanged) == 0x000130, "Member 'FAnimNode_X6StylizedOverlayBlend::bCacheOverlayChanged' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, SkeletonGuid) == 0x000134, "Member 'FAnimNode_X6StylizedOverlayBlend::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, VirtualBoneGuid) == 0x000144, "Member 'FAnimNode_X6StylizedOverlayBlend::VirtualBoneGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, bEnableMirror) == 0x000157, "Member 'FAnimNode_X6StylizedOverlayBlend::bEnableMirror' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, MirrorDataTable) == 0x000158, "Member 'FAnimNode_X6StylizedOverlayBlend::MirrorDataTable' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6StylizedOverlayBlend, RequestQueue) == 0x0001B8, "Member 'FAnimNode_X6StylizedOverlayBlend::RequestQueue' has a wrong offset!");

// ScriptStruct X6Animation.ContextualData
// 0x0028 (0x0028 - 0x0000)
struct FContextualData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContextualPlayType                           ContextualPlayType;                                // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContextualType                               ContextualType;                                    // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlendLayer;                                     // 0x000B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyBlendTime;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCoolDown;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntervalMin;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMax;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopIntervalTime;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualData) == 0x000008, "Wrong alignment on FContextualData");
static_assert(sizeof(FContextualData) == 0x000028, "Wrong size on FContextualData");
static_assert(offsetof(FContextualData, AnimSequence) == 0x000000, "Member 'FContextualData::AnimSequence' has a wrong offset!");
static_assert(offsetof(FContextualData, Priority) == 0x000008, "Member 'FContextualData::Priority' has a wrong offset!");
static_assert(offsetof(FContextualData, ContextualPlayType) == 0x000009, "Member 'FContextualData::ContextualPlayType' has a wrong offset!");
static_assert(offsetof(FContextualData, ContextualType) == 0x00000A, "Member 'FContextualData::ContextualType' has a wrong offset!");
static_assert(offsetof(FContextualData, bIsBlendLayer) == 0x00000B, "Member 'FContextualData::bIsBlendLayer' has a wrong offset!");
static_assert(offsetof(FContextualData, UpperBodyBlendTime) == 0x00000C, "Member 'FContextualData::UpperBodyBlendTime' has a wrong offset!");
static_assert(offsetof(FContextualData, bNeedCoolDown) == 0x000010, "Member 'FContextualData::bNeedCoolDown' has a wrong offset!");
static_assert(offsetof(FContextualData, IntervalMin) == 0x000014, "Member 'FContextualData::IntervalMin' has a wrong offset!");
static_assert(offsetof(FContextualData, IntervalMax) == 0x000018, "Member 'FContextualData::IntervalMax' has a wrong offset!");
static_assert(offsetof(FContextualData, bLoop) == 0x00001C, "Member 'FContextualData::bLoop' has a wrong offset!");
static_assert(offsetof(FContextualData, LoopIntervalTime) == 0x000020, "Member 'FContextualData::LoopIntervalTime' has a wrong offset!");

// ScriptStruct X6Animation.ContextualInstance
// 0x0048 (0x0048 - 0x0000)
struct FContextualInstance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FContextualData                        ContextualData;                                    // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualInstance) == 0x000008, "Wrong alignment on FContextualInstance");
static_assert(sizeof(FContextualInstance) == 0x000048, "Wrong size on FContextualInstance");
static_assert(offsetof(FContextualInstance, ContextualData) == 0x000008, "Member 'FContextualInstance::ContextualData' has a wrong offset!");

// ScriptStruct X6Animation.FilterQuant_Trans
// 0x0003 (0x0003 - 0x0000)
struct FFilterQuant_Trans final
{
public:
	bool                                          bAbandonX;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbandonY;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbandonZ;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilterQuant_Trans) == 0x000001, "Wrong alignment on FFilterQuant_Trans");
static_assert(sizeof(FFilterQuant_Trans) == 0x000003, "Wrong size on FFilterQuant_Trans");
static_assert(offsetof(FFilterQuant_Trans, bAbandonX) == 0x000000, "Member 'FFilterQuant_Trans::bAbandonX' has a wrong offset!");
static_assert(offsetof(FFilterQuant_Trans, bAbandonY) == 0x000001, "Member 'FFilterQuant_Trans::bAbandonY' has a wrong offset!");
static_assert(offsetof(FFilterQuant_Trans, bAbandonZ) == 0x000002, "Member 'FFilterQuant_Trans::bAbandonZ' has a wrong offset!");

// ScriptStruct X6Animation.FilterQuant_Rot
// 0x0003 (0x0003 - 0x0000)
struct FFilterQuant_Rot final
{
public:
	bool                                          bAbandonPitch;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbandonYaw;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbandonRoll;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilterQuant_Rot) == 0x000001, "Wrong alignment on FFilterQuant_Rot");
static_assert(sizeof(FFilterQuant_Rot) == 0x000003, "Wrong size on FFilterQuant_Rot");
static_assert(offsetof(FFilterQuant_Rot, bAbandonPitch) == 0x000000, "Member 'FFilterQuant_Rot::bAbandonPitch' has a wrong offset!");
static_assert(offsetof(FFilterQuant_Rot, bAbandonYaw) == 0x000001, "Member 'FFilterQuant_Rot::bAbandonYaw' has a wrong offset!");
static_assert(offsetof(FFilterQuant_Rot, bAbandonRoll) == 0x000002, "Member 'FFilterQuant_Rot::bAbandonRoll' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6PoseFilter
// 0x0028 (0x0038 - 0x0010)
struct FAnimNode_X6PoseFilter final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TargetBoneNames;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFilterQuant_Trans                     FilterTrans;                                       // 0x0030(0x0003)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FFilterQuant_Rot                       FilterRot;                                         // 0x0033(0x0003)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6PoseFilter) == 0x000008, "Wrong alignment on FAnimNode_X6PoseFilter");
static_assert(sizeof(FAnimNode_X6PoseFilter) == 0x000038, "Wrong size on FAnimNode_X6PoseFilter");
static_assert(offsetof(FAnimNode_X6PoseFilter, Source) == 0x000010, "Member 'FAnimNode_X6PoseFilter::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseFilter, TargetBoneNames) == 0x000020, "Member 'FAnimNode_X6PoseFilter::TargetBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseFilter, FilterTrans) == 0x000030, "Member 'FAnimNode_X6PoseFilter::FilterTrans' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6PoseFilter, FilterRot) == 0x000033, "Member 'FAnimNode_X6PoseFilter::FilterRot' has a wrong offset!");

// ScriptStruct X6Animation.ActorSpeedToAnimation
// 0x0040 (0x0040 - 0x0000)
struct FActorSpeedToAnimation final
{
public:
	float                                         AnimationWalkSlowSpeed;                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationWalkSpeed;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationRunSpeed;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationSprintSpeed;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedFixedRatioFromAnimationToMovement;            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowWalkSlowSpeed;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowWalkSpeed;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowRunSpeed;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowSprintSpeed;                                  // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMaxSpeed;                                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentConfigAllowSpeed;                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActualSpeedFromCurrentInput;                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorSpeedToAnimation) == 0x000004, "Wrong alignment on FActorSpeedToAnimation");
static_assert(sizeof(FActorSpeedToAnimation) == 0x000040, "Wrong size on FActorSpeedToAnimation");
static_assert(offsetof(FActorSpeedToAnimation, AnimationWalkSlowSpeed) == 0x000000, "Member 'FActorSpeedToAnimation::AnimationWalkSlowSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AnimationWalkSpeed) == 0x000004, "Member 'FActorSpeedToAnimation::AnimationWalkSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AnimationRunSpeed) == 0x000008, "Member 'FActorSpeedToAnimation::AnimationRunSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AnimationSprintSpeed) == 0x00000C, "Member 'FActorSpeedToAnimation::AnimationSprintSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, SpeedFixedRatioFromAnimationToMovement) == 0x000010, "Member 'FActorSpeedToAnimation::SpeedFixedRatioFromAnimationToMovement' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AllowWalkSlowSpeed) == 0x000014, "Member 'FActorSpeedToAnimation::AllowWalkSlowSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AllowWalkSpeed) == 0x000018, "Member 'FActorSpeedToAnimation::AllowWalkSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AllowRunSpeed) == 0x00001C, "Member 'FActorSpeedToAnimation::AllowRunSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, AllowSprintSpeed) == 0x000020, "Member 'FActorSpeedToAnimation::AllowSprintSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, CurrentMaxSpeed) == 0x000024, "Member 'FActorSpeedToAnimation::CurrentMaxSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, CurrentConfigAllowSpeed) == 0x000028, "Member 'FActorSpeedToAnimation::CurrentConfigAllowSpeed' has a wrong offset!");
static_assert(offsetof(FActorSpeedToAnimation, ActualSpeedFromCurrentInput) == 0x000038, "Member 'FActorSpeedToAnimation::ActualSpeedFromCurrentInput' has a wrong offset!");

// ScriptStruct X6Animation.NikkiTransitionGait
// 0x0020 (0x0020 - 0x0000)
struct FNikkiTransitionGait final
{
public:
	float                                         StopGaitHoldTime;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ELocomotionGait                               StopGait;                                          // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               PivotGait;                                         // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GaitToActualGaitJog;                               // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GaitToActualGaitWalk;                              // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNikkiTransitionGait) == 0x000008, "Wrong alignment on FNikkiTransitionGait");
static_assert(sizeof(FNikkiTransitionGait) == 0x000020, "Wrong size on FNikkiTransitionGait");
static_assert(offsetof(FNikkiTransitionGait, StopGaitHoldTime) == 0x000000, "Member 'FNikkiTransitionGait::StopGaitHoldTime' has a wrong offset!");
static_assert(offsetof(FNikkiTransitionGait, StopGait) == 0x000008, "Member 'FNikkiTransitionGait::StopGait' has a wrong offset!");
static_assert(offsetof(FNikkiTransitionGait, PivotGait) == 0x000009, "Member 'FNikkiTransitionGait::PivotGait' has a wrong offset!");
static_assert(offsetof(FNikkiTransitionGait, GaitToActualGaitJog) == 0x000010, "Member 'FNikkiTransitionGait::GaitToActualGaitJog' has a wrong offset!");
static_assert(offsetof(FNikkiTransitionGait, GaitToActualGaitWalk) == 0x000018, "Member 'FNikkiTransitionGait::GaitToActualGaitWalk' has a wrong offset!");

// ScriptStruct X6Animation.PoseMatchCost
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FPoseMatchCost final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoseMatchCost) == 0x000004, "Wrong alignment on FPoseMatchCost");
static_assert(sizeof(FPoseMatchCost) == 0x000008, "Wrong size on FPoseMatchCost");

// ScriptStruct X6Animation.StylizedStartState
// 0x0010 (0x0010 - 0x0000)
struct FStylizedStartState final
{
public:
	bool                                          bUseUpperArm;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Start_Animation;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStylizedStartState) == 0x000008, "Wrong alignment on FStylizedStartState");
static_assert(sizeof(FStylizedStartState) == 0x000010, "Wrong size on FStylizedStartState");
static_assert(offsetof(FStylizedStartState, bUseUpperArm) == 0x000000, "Member 'FStylizedStartState::bUseUpperArm' has a wrong offset!");
static_assert(offsetof(FStylizedStartState, Start_Animation) == 0x000008, "Member 'FStylizedStartState::Start_Animation' has a wrong offset!");

// ScriptStruct X6Animation.StylizedStopState
// 0x0040 (0x0040 - 0x0000)
struct FStylizedStopState final
{
public:
	bool                                          bUseAnimation;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Sprint_Stop_Animation;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Jog_Stop_Animation;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Walk_Stop_Animation;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkSlow_Stop_Animation;                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Jog_StepStop_Animation;                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Walk_StepStop_Animation;                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkSlow_StepStop_Animation;                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStylizedStopState) == 0x000008, "Wrong alignment on FStylizedStopState");
static_assert(sizeof(FStylizedStopState) == 0x000040, "Wrong size on FStylizedStopState");
static_assert(offsetof(FStylizedStopState, bUseAnimation) == 0x000000, "Member 'FStylizedStopState::bUseAnimation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, Sprint_Stop_Animation) == 0x000008, "Member 'FStylizedStopState::Sprint_Stop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, Jog_Stop_Animation) == 0x000010, "Member 'FStylizedStopState::Jog_Stop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, Walk_Stop_Animation) == 0x000018, "Member 'FStylizedStopState::Walk_Stop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, WalkSlow_Stop_Animation) == 0x000020, "Member 'FStylizedStopState::WalkSlow_Stop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, Jog_StepStop_Animation) == 0x000028, "Member 'FStylizedStopState::Jog_StepStop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, Walk_StepStop_Animation) == 0x000030, "Member 'FStylizedStopState::Walk_StepStop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedStopState, WalkSlow_StepStop_Animation) == 0x000038, "Member 'FStylizedStopState::WalkSlow_StepStop_Animation' has a wrong offset!");

// ScriptStruct X6Animation.StylizedLoopState
// 0x0018 (0x0018 - 0x0000)
struct FStylizedLoopState final
{
public:
	class UAnimSequence*                          Loop_Animation;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SlopeWithHeading;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Heading;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStylizedLoopState) == 0x000008, "Wrong alignment on FStylizedLoopState");
static_assert(sizeof(FStylizedLoopState) == 0x000018, "Wrong size on FStylizedLoopState");
static_assert(offsetof(FStylizedLoopState, Loop_Animation) == 0x000000, "Member 'FStylizedLoopState::Loop_Animation' has a wrong offset!");
static_assert(offsetof(FStylizedLoopState, SlopeWithHeading) == 0x000008, "Member 'FStylizedLoopState::SlopeWithHeading' has a wrong offset!");
static_assert(offsetof(FStylizedLoopState, Heading) == 0x000010, "Member 'FStylizedLoopState::Heading' has a wrong offset!");

// ScriptStruct X6Animation.StylizedPivotState
// 0x0001 (0x0001 - 0x0000)
struct FStylizedPivotState final
{
public:
	bool                                          bBlendWithIdleArm;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStylizedPivotState) == 0x000001, "Wrong alignment on FStylizedPivotState");
static_assert(sizeof(FStylizedPivotState) == 0x000001, "Wrong size on FStylizedPivotState");
static_assert(offsetof(FStylizedPivotState, bBlendWithIdleArm) == 0x000000, "Member 'FStylizedPivotState::bBlendWithIdleArm' has a wrong offset!");

// ScriptStruct X6Animation.StylizedSpeedChangingState
// 0x0001 (0x0001 - 0x0000)
struct FStylizedSpeedChangingState final
{
public:
	bool                                          bBlendWithIdleArm;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStylizedSpeedChangingState) == 0x000001, "Wrong alignment on FStylizedSpeedChangingState");
static_assert(sizeof(FStylizedSpeedChangingState) == 0x000001, "Wrong size on FStylizedSpeedChangingState");
static_assert(offsetof(FStylizedSpeedChangingState, bBlendWithIdleArm) == 0x000000, "Member 'FStylizedSpeedChangingState::bBlendWithIdleArm' has a wrong offset!");

// ScriptStruct X6Animation.AnimationStylizedCloth
// 0x00C0 (0x00C8 - 0x0008)
struct FAnimationStylizedCloth final : public FTableRowBase
{
public:
	class UAnimSequence*                          Idle_Animation;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stylized_Idle_Animation;                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStylizedStartState                    StartState;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStylizedLoopState                     WalkSlow_LoopState;                                // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStylizedLoopState                     Walk_LoopState;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStylizedLoopState                     Jog_LoopState;                                     // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStylizedLoopState                     Sprint_LoopState;                                  // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStylizedStopState                     StopState;                                         // 0x0088(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationStylizedCloth) == 0x000008, "Wrong alignment on FAnimationStylizedCloth");
static_assert(sizeof(FAnimationStylizedCloth) == 0x0000C8, "Wrong size on FAnimationStylizedCloth");
static_assert(offsetof(FAnimationStylizedCloth, Idle_Animation) == 0x000008, "Member 'FAnimationStylizedCloth::Idle_Animation' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, Stylized_Idle_Animation) == 0x000010, "Member 'FAnimationStylizedCloth::Stylized_Idle_Animation' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, StartState) == 0x000018, "Member 'FAnimationStylizedCloth::StartState' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, WalkSlow_LoopState) == 0x000028, "Member 'FAnimationStylizedCloth::WalkSlow_LoopState' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, Walk_LoopState) == 0x000040, "Member 'FAnimationStylizedCloth::Walk_LoopState' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, Jog_LoopState) == 0x000058, "Member 'FAnimationStylizedCloth::Jog_LoopState' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, Sprint_LoopState) == 0x000070, "Member 'FAnimationStylizedCloth::Sprint_LoopState' has a wrong offset!");
static_assert(offsetof(FAnimationStylizedCloth, StopState) == 0x000088, "Member 'FAnimationStylizedCloth::StopState' has a wrong offset!");

// ScriptStruct X6Animation.X6LocomotionAnimOverride
// 0x0050 (0x0058 - 0x0008)
struct FX6LocomotionAnimOverride final : public FTableRowBase
{
public:
	TMap<struct FGameplayTag, class UAnimationAsset*> AnimationOverride;                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6LocomotionAnimOverride) == 0x000008, "Wrong alignment on FX6LocomotionAnimOverride");
static_assert(sizeof(FX6LocomotionAnimOverride) == 0x000058, "Wrong size on FX6LocomotionAnimOverride");
static_assert(offsetof(FX6LocomotionAnimOverride, AnimationOverride) == 0x000008, "Member 'FX6LocomotionAnimOverride::AnimationOverride' has a wrong offset!");

// ScriptStruct X6Animation.ClothExternalData
// 0x0020 (0x0020 - 0x0000)
struct FClothExternalData final
{
public:
	struct FVector                                ClothExternalAcc;                                  // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClothExternalAccDuration;                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClothExternalData) == 0x000008, "Wrong alignment on FClothExternalData");
static_assert(sizeof(FClothExternalData) == 0x000020, "Wrong size on FClothExternalData");
static_assert(offsetof(FClothExternalData, ClothExternalAcc) == 0x000000, "Member 'FClothExternalData::ClothExternalAcc' has a wrong offset!");
static_assert(offsetof(FClothExternalData, ClothExternalAccDuration) == 0x000018, "Member 'FClothExternalData::ClothExternalAccDuration' has a wrong offset!");

// ScriptStruct X6Animation.PoseMatchSerachConfig
// 0x0008 (0x0008 - 0x0000)
struct FPoseMatchSerachConfig final
{
public:
	float                                         VelocityWeight;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootSpeedWeight;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseMatchSerachConfig) == 0x000004, "Wrong alignment on FPoseMatchSerachConfig");
static_assert(sizeof(FPoseMatchSerachConfig) == 0x000008, "Wrong size on FPoseMatchSerachConfig");
static_assert(offsetof(FPoseMatchSerachConfig, VelocityWeight) == 0x000000, "Member 'FPoseMatchSerachConfig::VelocityWeight' has a wrong offset!");
static_assert(offsetof(FPoseMatchSerachConfig, RootSpeedWeight) == 0x000004, "Member 'FPoseMatchSerachConfig::RootSpeedWeight' has a wrong offset!");

// ScriptStruct X6Animation.PoseMatchRecorderData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FPoseMatchRecorderData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoseMatchRecorderData) == 0x000008, "Wrong alignment on FPoseMatchRecorderData");
static_assert(sizeof(FPoseMatchRecorderData) == 0x000038, "Wrong size on FPoseMatchRecorderData");

// ScriptStruct X6Animation.PoseMatchData
// 0x0030 (0x0030 - 0x0000)
struct FPoseMatchData final
{
public:
	TArray<struct FTransform>                     BoneTransforms;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        BoneVelocitys;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 Pitch;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseMatchData) == 0x000008, "Wrong alignment on FPoseMatchData");
static_assert(sizeof(FPoseMatchData) == 0x000030, "Wrong size on FPoseMatchData");
static_assert(offsetof(FPoseMatchData, BoneTransforms) == 0x000000, "Member 'FPoseMatchData::BoneTransforms' has a wrong offset!");
static_assert(offsetof(FPoseMatchData, BoneVelocitys) == 0x000010, "Member 'FPoseMatchData::BoneVelocitys' has a wrong offset!");
static_assert(offsetof(FPoseMatchData, Pitch) == 0x000020, "Member 'FPoseMatchData::Pitch' has a wrong offset!");

// ScriptStruct X6Animation.X6RigUnit_HeightfieldReadback
// 0x0080 (0x0088 - 0x0008)
struct FX6RigUnit_HeightfieldReadback final : public FRigUnit
{
public:
	struct FVector                                Position;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutHit;                                            // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutNormal;                                         // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_SphereTrace_WorkData          WorkData;                                          // 0x0050(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6RigUnit_HeightfieldReadback) == 0x000008, "Wrong alignment on FX6RigUnit_HeightfieldReadback");
static_assert(sizeof(FX6RigUnit_HeightfieldReadback) == 0x000088, "Wrong size on FX6RigUnit_HeightfieldReadback");
static_assert(offsetof(FX6RigUnit_HeightfieldReadback, Position) == 0x000008, "Member 'FX6RigUnit_HeightfieldReadback::Position' has a wrong offset!");
static_assert(offsetof(FX6RigUnit_HeightfieldReadback, OutHit) == 0x000020, "Member 'FX6RigUnit_HeightfieldReadback::OutHit' has a wrong offset!");
static_assert(offsetof(FX6RigUnit_HeightfieldReadback, OutNormal) == 0x000038, "Member 'FX6RigUnit_HeightfieldReadback::OutNormal' has a wrong offset!");
static_assert(offsetof(FX6RigUnit_HeightfieldReadback, WorkData) == 0x000050, "Member 'FX6RigUnit_HeightfieldReadback::WorkData' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_HoldDress
// 0x0068 (0x0130 - 0x00C8)
struct FAnimNode_HoldDress final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         JointBone;                                         // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HoldBone;                                          // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EffectorLocation;                                  // 0x00E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffsetZ;                                        // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         ParentBone;                                        // 0x0104(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0118(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_HoldDress) == 0x000008, "Wrong alignment on FAnimNode_HoldDress");
static_assert(sizeof(FAnimNode_HoldDress) == 0x000130, "Wrong size on FAnimNode_HoldDress");
static_assert(offsetof(FAnimNode_HoldDress, JointBone) == 0x0000C8, "Member 'FAnimNode_HoldDress::JointBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_HoldDress, HoldBone) == 0x0000D8, "Member 'FAnimNode_HoldDress::HoldBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_HoldDress, EffectorLocation) == 0x0000E8, "Member 'FAnimNode_HoldDress::EffectorLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_HoldDress, MaxOffsetZ) == 0x000100, "Member 'FAnimNode_HoldDress::MaxOffsetZ' has a wrong offset!");
static_assert(offsetof(FAnimNode_HoldDress, ParentBone) == 0x000104, "Member 'FAnimNode_HoldDress::ParentBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_HoldDress, TargetLocation) == 0x000118, "Member 'FAnimNode_HoldDress::TargetLocation' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_SequencePlayerModifier
// 0x0018 (0x0028 - 0x0010)
struct FAnimNode_SequencePlayerModifier final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PlayRateModifier;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SequencePlayerModifier) == 0x000008, "Wrong alignment on FAnimNode_SequencePlayerModifier");
static_assert(sizeof(FAnimNode_SequencePlayerModifier) == 0x000028, "Wrong size on FAnimNode_SequencePlayerModifier");
static_assert(offsetof(FAnimNode_SequencePlayerModifier, Source) == 0x000010, "Member 'FAnimNode_SequencePlayerModifier::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequencePlayerModifier, PlayRateModifier) == 0x000020, "Member 'FAnimNode_SequencePlayerModifier::PlayRateModifier' has a wrong offset!");

// ScriptStruct X6Animation.X6StateMachineMarkInfo
// 0x0060 (0x0060 - 0x0000)
struct FX6StateMachineMarkInfo final
{
public:
	TMap<class FName, struct FGameplayTag>        ParentTagsAndStateNames;                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	class FName                                   CurrentStateName;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6StateMachineMarkInfo) == 0x000008, "Wrong alignment on FX6StateMachineMarkInfo");
static_assert(sizeof(FX6StateMachineMarkInfo) == 0x000060, "Wrong size on FX6StateMachineMarkInfo");
static_assert(offsetof(FX6StateMachineMarkInfo, ParentTagsAndStateNames) == 0x000000, "Member 'FX6StateMachineMarkInfo::ParentTagsAndStateNames' has a wrong offset!");
static_assert(offsetof(FX6StateMachineMarkInfo, CurrentStateName) == 0x000050, "Member 'FX6StateMachineMarkInfo::CurrentStateName' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6AnimContext
// 0x00B0 (0x00C0 - 0x0010)
struct FAnimNode_X6AnimContext final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FX6StateMachineMarkInfo> StateMachineInfos;                     // 0x0070(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimNode_X6AnimContext) == 0x000008, "Wrong alignment on FAnimNode_X6AnimContext");
static_assert(sizeof(FAnimNode_X6AnimContext) == 0x0000C0, "Wrong size on FAnimNode_X6AnimContext");
static_assert(offsetof(FAnimNode_X6AnimContext, Source) == 0x000010, "Member 'FAnimNode_X6AnimContext::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6AnimContext, StateMachineInfos) == 0x000070, "Member 'FAnimNode_X6AnimContext::StateMachineInfos' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_X6LookAt
// 0x0188 (0x0250 - 0x00C8)
struct FAnimNode_X6LookAt final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         BoneToModify;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneSocketTarget                      LookAtTarget;                                      // 0x00E0(0x0090)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0170(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  LookAt_Axis;                                       // 0x0188(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLookUpAxis;                                    // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAxis                                  LookUp_Axis;                                       // 0x01B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAtClamp;                                       // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTriggerThreashold;                    // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x74];                                     // 0x01DC(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_X6LookAt) == 0x000010, "Wrong alignment on FAnimNode_X6LookAt");
static_assert(sizeof(FAnimNode_X6LookAt) == 0x000250, "Wrong size on FAnimNode_X6LookAt");
static_assert(offsetof(FAnimNode_X6LookAt, BoneToModify) == 0x0000C8, "Member 'FAnimNode_X6LookAt::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, LookAtTarget) == 0x0000E0, "Member 'FAnimNode_X6LookAt::LookAtTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, LookAtLocation) == 0x000170, "Member 'FAnimNode_X6LookAt::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, LookAt_Axis) == 0x000188, "Member 'FAnimNode_X6LookAt::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, bUseLookUpAxis) == 0x0001A8, "Member 'FAnimNode_X6LookAt::bUseLookUpAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, LookUp_Axis) == 0x0001B0, "Member 'FAnimNode_X6LookAt::LookUp_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, LookAtClamp) == 0x0001D0, "Member 'FAnimNode_X6LookAt::LookAtClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, InterpolationTime) == 0x0001D4, "Member 'FAnimNode_X6LookAt::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_X6LookAt, InterpolationTriggerThreashold) == 0x0001D8, "Member 'FAnimNode_X6LookAt::InterpolationTriggerThreashold' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_CopyBoneAdvanced
// 0x0068 (0x0130 - 0x00C8)
struct FAnimNode_CopyBoneAdvanced final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         SourceBone;                                        // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TranslationWeight;                                 // 0x00E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationWeight;                                    // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleWeight;                                       // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             ControlSpace;                                      // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         TranslationSpaceBone;                              // 0x010C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTranslationInCustomBoneSpace;                     // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x011D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E[0x12];                                     // 0x011E(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CopyBoneAdvanced) == 0x000008, "Wrong alignment on FAnimNode_CopyBoneAdvanced");
static_assert(sizeof(FAnimNode_CopyBoneAdvanced) == 0x000130, "Wrong size on FAnimNode_CopyBoneAdvanced");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, SourceBone) == 0x0000C8, "Member 'FAnimNode_CopyBoneAdvanced::SourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, TargetBone) == 0x0000D8, "Member 'FAnimNode_CopyBoneAdvanced::TargetBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, TranslationWeight) == 0x0000E8, "Member 'FAnimNode_CopyBoneAdvanced::TranslationWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, RotationWeight) == 0x000100, "Member 'FAnimNode_CopyBoneAdvanced::RotationWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, ScaleWeight) == 0x000104, "Member 'FAnimNode_CopyBoneAdvanced::ScaleWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, ControlSpace) == 0x000108, "Member 'FAnimNode_CopyBoneAdvanced::ControlSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, TranslationSpaceBone) == 0x00010C, "Member 'FAnimNode_CopyBoneAdvanced::TranslationSpaceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, bTranslationInCustomBoneSpace) == 0x00011C, "Member 'FAnimNode_CopyBoneAdvanced::bTranslationInCustomBoneSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyBoneAdvanced, bPropagateToChildren) == 0x00011D, "Member 'FAnimNode_CopyBoneAdvanced::bPropagateToChildren' has a wrong offset!");

// ScriptStruct X6Animation.AnimNode_CopyMotion
// 0x0148 (0x0210 - 0x00C8)
struct FAnimNode_CopyMotion final : public FAnimNode_SkeletalControlBase
{
public:
	struct FComponentSpacePoseLink                BasePose;                                          // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FComponentSpacePoseLink                BasePoseReference;                                 // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseBasePose;                                      // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PoseHistoryTag;                                    // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         SourceBone;                                        // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToModify;                                      // 0x0108(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         CopySpace;                                         // 0x0118(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ApplySpace;                                        // 0x0128(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TranslationOffset;                                 // 0x0138(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0150(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RotationPivot;                                     // 0x0168(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurvePrefix;                                       // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetCurveName;                                   // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetCurveScale;                                  // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECopyMotion_Component                         TargetCurveComponent;                              // 0x0194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         TargetCurveRotationAxis;                           // 0x0195(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_196[0x2];                                      // 0x0196(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TranslationX_CurveName;                            // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TranslationY_CurveName;                            // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TranslationZ_CurveName;                            // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RotationRoll_CurveName;                            // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RotationPitch_CurveName;                           // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RotationYaw_CurveName;                             // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TranslationScale;                                  // 0x01C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           TranslationRemapCurve;                             // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationScale;                                     // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotationRemapCurve;                                // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CopyMotion) == 0x000008, "Wrong alignment on FAnimNode_CopyMotion");
static_assert(sizeof(FAnimNode_CopyMotion) == 0x000210, "Wrong size on FAnimNode_CopyMotion");
static_assert(offsetof(FAnimNode_CopyMotion, BasePose) == 0x0000C8, "Member 'FAnimNode_CopyMotion::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, BasePoseReference) == 0x0000D8, "Member 'FAnimNode_CopyMotion::BasePoseReference' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, bUseBasePose) == 0x0000E8, "Member 'FAnimNode_CopyMotion::bUseBasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, PoseHistoryTag) == 0x0000EC, "Member 'FAnimNode_CopyMotion::PoseHistoryTag' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, Delay) == 0x0000F4, "Member 'FAnimNode_CopyMotion::Delay' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, SourceBone) == 0x0000F8, "Member 'FAnimNode_CopyMotion::SourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, BoneToModify) == 0x000108, "Member 'FAnimNode_CopyMotion::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, CopySpace) == 0x000118, "Member 'FAnimNode_CopyMotion::CopySpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, ApplySpace) == 0x000128, "Member 'FAnimNode_CopyMotion::ApplySpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TranslationOffset) == 0x000138, "Member 'FAnimNode_CopyMotion::TranslationOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationOffset) == 0x000150, "Member 'FAnimNode_CopyMotion::RotationOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationPivot) == 0x000168, "Member 'FAnimNode_CopyMotion::RotationPivot' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, CurvePrefix) == 0x000180, "Member 'FAnimNode_CopyMotion::CurvePrefix' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TargetCurveName) == 0x000188, "Member 'FAnimNode_CopyMotion::TargetCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TargetCurveScale) == 0x000190, "Member 'FAnimNode_CopyMotion::TargetCurveScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TargetCurveComponent) == 0x000194, "Member 'FAnimNode_CopyMotion::TargetCurveComponent' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TargetCurveRotationAxis) == 0x000195, "Member 'FAnimNode_CopyMotion::TargetCurveRotationAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TranslationX_CurveName) == 0x000198, "Member 'FAnimNode_CopyMotion::TranslationX_CurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TranslationY_CurveName) == 0x0001A0, "Member 'FAnimNode_CopyMotion::TranslationY_CurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TranslationZ_CurveName) == 0x0001A8, "Member 'FAnimNode_CopyMotion::TranslationZ_CurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationRoll_CurveName) == 0x0001B0, "Member 'FAnimNode_CopyMotion::RotationRoll_CurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationPitch_CurveName) == 0x0001B8, "Member 'FAnimNode_CopyMotion::RotationPitch_CurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationYaw_CurveName) == 0x0001C0, "Member 'FAnimNode_CopyMotion::RotationYaw_CurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TranslationScale) == 0x0001C8, "Member 'FAnimNode_CopyMotion::TranslationScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, TranslationRemapCurve) == 0x0001E0, "Member 'FAnimNode_CopyMotion::TranslationRemapCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationScale) == 0x0001E8, "Member 'FAnimNode_CopyMotion::RotationScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_CopyMotion, RotationRemapCurve) == 0x0001F0, "Member 'FAnimNode_CopyMotion::RotationRemapCurve' has a wrong offset!");

// ScriptStruct X6Animation.X6PlayMontageParams
// 0x0018 (0x0018 - 0x0000)
struct FX6PlayMontageParams final
{
public:
	float                                         PlayRate;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingPosition;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartingSection;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirror;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimRootMotionTranslationScale;                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6PlayMontageParams) == 0x000004, "Wrong alignment on FX6PlayMontageParams");
static_assert(sizeof(FX6PlayMontageParams) == 0x000018, "Wrong size on FX6PlayMontageParams");
static_assert(offsetof(FX6PlayMontageParams, PlayRate) == 0x000000, "Member 'FX6PlayMontageParams::PlayRate' has a wrong offset!");
static_assert(offsetof(FX6PlayMontageParams, StartingPosition) == 0x000004, "Member 'FX6PlayMontageParams::StartingPosition' has a wrong offset!");
static_assert(offsetof(FX6PlayMontageParams, StartingSection) == 0x000008, "Member 'FX6PlayMontageParams::StartingSection' has a wrong offset!");
static_assert(offsetof(FX6PlayMontageParams, bMirror) == 0x000010, "Member 'FX6PlayMontageParams::bMirror' has a wrong offset!");
static_assert(offsetof(FX6PlayMontageParams, AnimRootMotionTranslationScale) == 0x000014, "Member 'FX6PlayMontageParams::AnimRootMotionTranslationScale' has a wrong offset!");

// ScriptStruct X6Animation.X6SequencePlayerReference
// 0x0000 (0x0010 - 0x0010)
struct FX6SequencePlayerReference final : public FAnimNodeReference
{
};
static_assert(alignof(FX6SequencePlayerReference) == 0x000008, "Wrong alignment on FX6SequencePlayerReference");
static_assert(sizeof(FX6SequencePlayerReference) == 0x000010, "Wrong size on FX6SequencePlayerReference");

// ScriptStruct X6Animation.X6OverlayBlendReference
// 0x0000 (0x0010 - 0x0010)
struct FX6OverlayBlendReference final : public FAnimNodeReference
{
};
static_assert(alignof(FX6OverlayBlendReference) == 0x000008, "Wrong alignment on FX6OverlayBlendReference");
static_assert(sizeof(FX6OverlayBlendReference) == 0x000010, "Wrong size on FX6OverlayBlendReference");

// ScriptStruct X6Animation.X6StylizedOverlayBlendReference
// 0x0000 (0x0010 - 0x0010)
struct FX6StylizedOverlayBlendReference final : public FAnimNodeReference
{
};
static_assert(alignof(FX6StylizedOverlayBlendReference) == 0x000008, "Wrong alignment on FX6StylizedOverlayBlendReference");
static_assert(sizeof(FX6StylizedOverlayBlendReference) == 0x000010, "Wrong size on FX6StylizedOverlayBlendReference");

// ScriptStruct X6Animation.AnimNode_PoseMatchRecorder
// 0x0140 (0x0150 - 0x0010)
struct alignas(0x10) FAnimNode_PoseMatchRecorder final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         MatchOffset;                                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugInfo;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 DrawDebugColor;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 MirroredDrawDebugColor;                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x124];                                     // 0x002C(0x0124)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_PoseMatchRecorder) == 0x000010, "Wrong alignment on FAnimNode_PoseMatchRecorder");
static_assert(sizeof(FAnimNode_PoseMatchRecorder) == 0x000150, "Wrong size on FAnimNode_PoseMatchRecorder");
static_assert(offsetof(FAnimNode_PoseMatchRecorder, Source) == 0x000010, "Member 'FAnimNode_PoseMatchRecorder::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchRecorder, MatchOffset) == 0x000020, "Member 'FAnimNode_PoseMatchRecorder::MatchOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchRecorder, bShowDebugInfo) == 0x000021, "Member 'FAnimNode_PoseMatchRecorder::bShowDebugInfo' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchRecorder, DrawDebugColor) == 0x000024, "Member 'FAnimNode_PoseMatchRecorder::DrawDebugColor' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchRecorder, MirroredDrawDebugColor) == 0x000028, "Member 'FAnimNode_PoseMatchRecorder::MirroredDrawDebugColor' has a wrong offset!");

}

