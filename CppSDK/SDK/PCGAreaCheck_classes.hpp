#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PCGAreaCheck

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PCGAreaCheck_structs.hpp"


namespace SDK
{

// Class PCGAreaCheck.AreaCheckSubsystem
// 0x0000 (0x0030 - 0x0030)
class UAreaCheckSubsystem final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaCheckSubsystem">();
	}
	static class UAreaCheckSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaCheckSubsystem>();
	}
};
static_assert(alignof(UAreaCheckSubsystem) == 0x000008, "Wrong alignment on UAreaCheckSubsystem");
static_assert(sizeof(UAreaCheckSubsystem) == 0x000030, "Wrong size on UAreaCheckSubsystem");

// Class PCGAreaCheck.MTPointsContainer
// 0x0048 (0x0070 - 0x0028)
class UMTPointsContainer final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MTPointsContainer">();
	}
	static class UMTPointsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMTPointsContainer>();
	}
};
static_assert(alignof(UMTPointsContainer) == 0x000008, "Wrong alignment on UMTPointsContainer");
static_assert(sizeof(UMTPointsContainer) == 0x000070, "Wrong size on UMTPointsContainer");

// Class PCGAreaCheck.PCGAreaBuffActor
// 0x0000 (0x03A8 - 0x03A8)
class APCGAreaBuffActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGAreaBuffActor">();
	}
	static class APCGAreaBuffActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCGAreaBuffActor>();
	}
};
static_assert(alignof(APCGAreaBuffActor) == 0x000008, "Wrong alignment on APCGAreaBuffActor");
static_assert(sizeof(APCGAreaBuffActor) == 0x0003A8, "Wrong size on APCGAreaBuffActor");

// Class PCGAreaCheck.PCGAreaCheckBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPCGAreaCheckBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddActorToUEDataLayer(class AActor* InActor, const class FString& LayerName);
	static bool AddActorToUEDataLayerFromAsset(class AActor* InActor, class UDataLayerAsset* LayerAsset);
	static void BuildLandscapeActorBuffToImage(const class FString& FilePath, const TArray<class FString>& CollectLayers, const class FString& BuffImagePath, EPCGAreaBuffType BuffType);
	static void BuildLandscapesBuffToImage(const class FString& FilePath, const TArray<class FString>& CollectLayers, const class FString& BuffImagePath, EPCGAreaBuffType BuffType);
	static void ChangeSelectedObjectPosTerrainData(const class FString& ReplacedLayerName, const class FString& DeleteLayerFix, int32 ExpendTimes);
	static void CollectLandscapeBuff(class UAreaCheckSubsystem* AreaCheckSubsystem, class ALandscapeProxy* LandscapeProxy, const class FString& landscapeName, const class FString& FilePath);
	static void CollectLandscapesBuff(class UAreaCheckSubsystem* AreaCheckSubsystem, const class FString& FilePath);
	static void CombinLandscapesHeightAreaDataToPng(const class FString& ExportPath, const class FString& TileFilePath, const class FString& LayerName, const TArray<class ALandscapeProxy*>& InSelectedLandscapeProxy, int32 MinZ, int32 MaxZ);
	static void CombinLandscapesMapDataToPng(const class FString& ExportPath, const class FString& TileFilePath, const class FString& LayerName, const TArray<class ALandscapeProxy*>& InSelectedLandscapeProxy, int32 StepSizeX, int32 StepSizeY);
	static bool ConcludeAreaFacePoint(const struct FVector& StartPos, const struct FBox& CheckArea, TMap<struct FIntVector, struct FPCGAreaCheckPointInfo>* OutResult, TMap<struct FIntVector, struct FVector>* OutErrPoint, const TArray<class AActor*>& LineTraceIgnoreActors, float StepSize, int32 MaxSearchSize);
	static struct FBox ExportAllLandscapesToVTPng(const class FString& ExportPath, class UDataTable* AreaMap, int32 BlockWidth, int32 BlockHeight);
	static void ExportBoxDataToPng(const struct FBox& BoundingBox, const class FString& ExportPath, class UDataTable* AreaMap, const TArray<class FString>& ExtCaptureLayers, const class FString& Prefix, int32 TextureSize, bool bExportDataWithTextureSize, bool bUseBlackPlane);
	static void ExportLandscapesMapDataToPng(const class FString& ExportPath, class UDataTable* AreaMap, const TArray<class FString>& ExtCaptureLayers, int32 TextureSize, float CameraZOffset, bool bExportDataWithTextureSize);
	static void ExportLandscapesMapDataToPng_Async(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& ExportPath, class UDataTable* AreaMap, const TArray<class ALandscapeProxy*>& InSelectedLandscapeProxy, const TArray<class FString>& ExtCaptureLayers, int32 TextureSize, float CameraZOffset, bool bExportDataWithTextureSize);
	static void ExportLandscapesToPng(const class FString& ExportPath, class UDataTable* AreaMap, int32 Width, int32 Height, float Scale);
	static void ExportLandscapesToPngWithBlockSize(const class FString& ExportPath, class UDataTable* AreaMap, int32 BlockWidth, int32 BlockHeight);
	static bool ExportLandscapeWeightLayerInfo(const class FString& FilePath);
	static TArray<class AActor*> GetBoxOverlapActors(const struct FBox& InBox, bool bOnlyWithStaticMesh);
	static class AActor* GetEditorWorldCounterpartActor(class AActor* InActor);
	static int32 GetHashString(const class FString& InString);
	static TArray<class AActor*> GetInAreaActors(const TArray<class USplineComponent*>& InSplines);
	static class ULandscapeComponent* GetLandscapeComponentByLocation(const struct FVector& InLocation);
	static TArray<class ULandscapeComponent*> GetLandscapeComponentsByLocation(const struct FVector& InLocation, struct FBox* OutBox, int32 SizeX, int32 SizeY);
	static TArray<class FName> GetLandscapeWeightLayerOrder(const struct FBox& AreaBox, const TArray<class FName>& IgnoreLayers, TArray<float>* OutTotalWeightValue);
	static class FString GetPluginBaseDir(const class FString& PluginName);
	static TArray<class UActorComponent*> GetSelectedComponents();
	static bool RemoveActorFromUEDataLayer(class AActor* InActor, const class FString& LayerName);
	static void RemoveInstanceInSplineArea(class USplineComponent* Spline, const TArray<class FString>& FilterKeys, float MinSize, float CurveStep);
	static void RemoveStaticMeshCoveredGrass(const class FString& ReplacedLayerName, int32 ShrinkTimes);
	static struct FSoftObjectPath StampFromSplineArea(class USplineComponent* Spline, const TArray<class FString>& FilterKeys, const struct FSoftObjectPath& InStampAsset, float MinSize, float CurveStep, bool bReplaceNow, bool bSaveAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGAreaCheckBlueprintLibrary">();
	}
	static class UPCGAreaCheckBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGAreaCheckBlueprintLibrary>();
	}
};
static_assert(alignof(UPCGAreaCheckBlueprintLibrary) == 0x000008, "Wrong alignment on UPCGAreaCheckBlueprintLibrary");
static_assert(sizeof(UPCGAreaCheckBlueprintLibrary) == 0x000028, "Wrong size on UPCGAreaCheckBlueprintLibrary");

// Class PCGAreaCheck.RuntimeCollectData
// 0x0030 (0x0058 - 0x0028)
class URuntimeCollectData final : public UObject
{
public:
	TArray<struct FVector>                        PlayerPositions;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 PointNumArr;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PointColorArr;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RuntimeCollectData">();
	}
	static class URuntimeCollectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeCollectData>();
	}
};
static_assert(alignof(URuntimeCollectData) == 0x000008, "Wrong alignment on URuntimeCollectData");
static_assert(sizeof(URuntimeCollectData) == 0x000058, "Wrong size on URuntimeCollectData");
static_assert(offsetof(URuntimeCollectData, PlayerPositions) == 0x000028, "Member 'URuntimeCollectData::PlayerPositions' has a wrong offset!");
static_assert(offsetof(URuntimeCollectData, PointNumArr) == 0x000038, "Member 'URuntimeCollectData::PointNumArr' has a wrong offset!");
static_assert(offsetof(URuntimeCollectData, PointColorArr) == 0x000048, "Member 'URuntimeCollectData::PointColorArr' has a wrong offset!");

// Class PCGAreaCheck.RuntimeDataColllector
// 0x00A0 (0x0448 - 0x03A8)
class ARuntimeDataColllector final : public AActor
{
public:
	int32                                         TickInterval;                                      // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavePath;                                          // 0x03B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x88];                                     // 0x03C0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSpecialPoint();
	struct FTransform CollectPlayerData();
	void SetSavePath(const class FString& InSavePath);
	void SetTickInterval(const int32 InInterval);
	void ShowCollectData(const struct FSoftObjectPath& PackagePath, TArray<struct FVector>* OutPointsArr, TArray<int32>* OutPointNumArr, TArray<struct FVector>* OutColorArr);
	void StartCollectData(const struct FLinearColor& InBaseColor, const struct FLinearColor& InSpecialColor);
	void StopCollectorData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RuntimeDataColllector">();
	}
	static class ARuntimeDataColllector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARuntimeDataColllector>();
	}
};
static_assert(alignof(ARuntimeDataColllector) == 0x000008, "Wrong alignment on ARuntimeDataColllector");
static_assert(sizeof(ARuntimeDataColllector) == 0x000448, "Wrong size on ARuntimeDataColllector");
static_assert(offsetof(ARuntimeDataColllector, TickInterval) == 0x0003A8, "Member 'ARuntimeDataColllector::TickInterval' has a wrong offset!");
static_assert(offsetof(ARuntimeDataColllector, SavePath) == 0x0003B0, "Member 'ARuntimeDataColllector::SavePath' has a wrong offset!");

}

