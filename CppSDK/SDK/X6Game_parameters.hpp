#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: X6Game

#include "Basic.hpp"

#include "TargetingSystem_structs.hpp"
#include "X6Game_structs.hpp"
#include "Engine_structs.hpp"
#include "X6Camera_structs.hpp"
#include "X6Animation_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "SlateCore_structs.hpp"
#include "MotionWarping_structs.hpp"
#include "AIModule_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "InputCore_structs.hpp"
#include "MovieScene_structs.hpp"
#include "GameplayCameras_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "UMG_structs.hpp"
#include "UIPF_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK::Params
{

// Function X6Game.ActorEventListener.OnPooledActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct ActorEventListener_OnPooledActorDestroyed final
{
public:
	class AActor*                                 InActorAboutToDestroy;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorEventListener_OnPooledActorDestroyed) == 0x000008, "Wrong alignment on ActorEventListener_OnPooledActorDestroyed");
static_assert(sizeof(ActorEventListener_OnPooledActorDestroyed) == 0x000008, "Wrong size on ActorEventListener_OnPooledActorDestroyed");
static_assert(offsetof(ActorEventListener_OnPooledActorDestroyed, InActorAboutToDestroy) == 0x000000, "Member 'ActorEventListener_OnPooledActorDestroyed::InActorAboutToDestroy' has a wrong offset!");

// Function X6Game.AsyncQueryPositionTask.QueryFlyingFollowPosition
// 0x0050 (0x0050 - 0x0000)
struct AsyncQueryPositionTask_QueryFlyingFollowPosition final
{
public:
	class AActor*                                 GoalActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FollowingActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQueryFlyingFollowPositionArgs         Args;                                              // 0x0010(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AsyncQueryPositionTask_QueryFlyingFollowPosition) == 0x000008, "Wrong alignment on AsyncQueryPositionTask_QueryFlyingFollowPosition");
static_assert(sizeof(AsyncQueryPositionTask_QueryFlyingFollowPosition) == 0x000050, "Wrong size on AsyncQueryPositionTask_QueryFlyingFollowPosition");
static_assert(offsetof(AsyncQueryPositionTask_QueryFlyingFollowPosition, GoalActor) == 0x000000, "Member 'AsyncQueryPositionTask_QueryFlyingFollowPosition::GoalActor' has a wrong offset!");
static_assert(offsetof(AsyncQueryPositionTask_QueryFlyingFollowPosition, FollowingActor) == 0x000008, "Member 'AsyncQueryPositionTask_QueryFlyingFollowPosition::FollowingActor' has a wrong offset!");
static_assert(offsetof(AsyncQueryPositionTask_QueryFlyingFollowPosition, Args) == 0x000010, "Member 'AsyncQueryPositionTask_QueryFlyingFollowPosition::Args' has a wrong offset!");
static_assert(offsetof(AsyncQueryPositionTask_QueryFlyingFollowPosition, ReturnValue) == 0x000048, "Member 'AsyncQueryPositionTask_QueryFlyingFollowPosition::ReturnValue' has a wrong offset!");

// Function X6Game.AnimNotify_PlayFootstepEffect.SetRowName
// 0x0008 (0x0008 - 0x0000)
struct AnimNotify_PlayFootstepEffect_SetRowName final
{
public:
	class FName                                   NewRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_PlayFootstepEffect_SetRowName) == 0x000004, "Wrong alignment on AnimNotify_PlayFootstepEffect_SetRowName");
static_assert(sizeof(AnimNotify_PlayFootstepEffect_SetRowName) == 0x000008, "Wrong size on AnimNotify_PlayFootstepEffect_SetRowName");
static_assert(offsetof(AnimNotify_PlayFootstepEffect_SetRowName, NewRowName) == 0x000000, "Member 'AnimNotify_PlayFootstepEffect_SetRowName::NewRowName' has a wrong offset!");

// Function X6Game.AnimNotify_PlayFootstepEffect.SetSocketName
// 0x0008 (0x0008 - 0x0000)
struct AnimNotify_PlayFootstepEffect_SetSocketName final
{
public:
	class FName                                   NewSocketName;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_PlayFootstepEffect_SetSocketName) == 0x000004, "Wrong alignment on AnimNotify_PlayFootstepEffect_SetSocketName");
static_assert(sizeof(AnimNotify_PlayFootstepEffect_SetSocketName) == 0x000008, "Wrong size on AnimNotify_PlayFootstepEffect_SetSocketName");
static_assert(offsetof(AnimNotify_PlayFootstepEffect_SetSocketName, NewSocketName) == 0x000000, "Member 'AnimNotify_PlayFootstepEffect_SetSocketName::NewSocketName' has a wrong offset!");

// Function X6Game.BipedalLocomotionAnimInstance.GetAdditiveAlpha
// 0x0004 (0x0004 - 0x0000)
struct BipedalLocomotionAnimInstance_GetAdditiveAlpha final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionAnimInstance_GetAdditiveAlpha) == 0x000004, "Wrong alignment on BipedalLocomotionAnimInstance_GetAdditiveAlpha");
static_assert(sizeof(BipedalLocomotionAnimInstance_GetAdditiveAlpha) == 0x000004, "Wrong size on BipedalLocomotionAnimInstance_GetAdditiveAlpha");
static_assert(offsetof(BipedalLocomotionAnimInstance_GetAdditiveAlpha, ReturnValue) == 0x000000, "Member 'BipedalLocomotionAnimInstance_GetAdditiveAlpha::ReturnValue' has a wrong offset!");

// Function X6Game.BipedalLocomotionAnimInstance.GetLandRecoveryAlpha
// 0x0004 (0x0004 - 0x0000)
struct BipedalLocomotionAnimInstance_GetLandRecoveryAlpha final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionAnimInstance_GetLandRecoveryAlpha) == 0x000004, "Wrong alignment on BipedalLocomotionAnimInstance_GetLandRecoveryAlpha");
static_assert(sizeof(BipedalLocomotionAnimInstance_GetLandRecoveryAlpha) == 0x000004, "Wrong size on BipedalLocomotionAnimInstance_GetLandRecoveryAlpha");
static_assert(offsetof(BipedalLocomotionAnimInstance_GetLandRecoveryAlpha, ReturnValue) == 0x000000, "Member 'BipedalLocomotionAnimInstance_GetLandRecoveryAlpha::ReturnValue' has a wrong offset!");

// Function X6Game.BipedalLocomotionAnimInstance.GetNextIdleBreak
// 0x0008 (0x0008 - 0x0000)
struct BipedalLocomotionAnimInstance_GetNextIdleBreak final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionAnimInstance_GetNextIdleBreak) == 0x000008, "Wrong alignment on BipedalLocomotionAnimInstance_GetNextIdleBreak");
static_assert(sizeof(BipedalLocomotionAnimInstance_GetNextIdleBreak) == 0x000008, "Wrong size on BipedalLocomotionAnimInstance_GetNextIdleBreak");
static_assert(offsetof(BipedalLocomotionAnimInstance_GetNextIdleBreak, ReturnValue) == 0x000000, "Member 'BipedalLocomotionAnimInstance_GetNextIdleBreak::ReturnValue' has a wrong offset!");

// Function X6Game.BipedalLocomotionAnimInstance.HasAnyIdleBreak
// 0x0001 (0x0001 - 0x0000)
struct BipedalLocomotionAnimInstance_HasAnyIdleBreak final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionAnimInstance_HasAnyIdleBreak) == 0x000001, "Wrong alignment on BipedalLocomotionAnimInstance_HasAnyIdleBreak");
static_assert(sizeof(BipedalLocomotionAnimInstance_HasAnyIdleBreak) == 0x000001, "Wrong size on BipedalLocomotionAnimInstance_HasAnyIdleBreak");
static_assert(offsetof(BipedalLocomotionAnimInstance_HasAnyIdleBreak, ReturnValue) == 0x000000, "Member 'BipedalLocomotionAnimInstance_HasAnyIdleBreak::ReturnValue' has a wrong offset!");

// Function X6Game.BipedalLocomotionAnimInstance.IsForcingIdleReadyInIdleState
// 0x0001 (0x0001 - 0x0000)
struct BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState) == 0x000001, "Wrong alignment on BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState");
static_assert(sizeof(BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState) == 0x000001, "Wrong size on BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState");
static_assert(offsetof(BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState, ReturnValue) == 0x000000, "Member 'BipedalLocomotionAnimInstance_IsForcingIdleReadyInIdleState::ReturnValue' has a wrong offset!");

// Function X6Game.BipedalLocomotionAnimInstance.UseFallLoopAsJump
// 0x0001 (0x0001 - 0x0000)
struct BipedalLocomotionAnimInstance_UseFallLoopAsJump final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionAnimInstance_UseFallLoopAsJump) == 0x000001, "Wrong alignment on BipedalLocomotionAnimInstance_UseFallLoopAsJump");
static_assert(sizeof(BipedalLocomotionAnimInstance_UseFallLoopAsJump) == 0x000001, "Wrong size on BipedalLocomotionAnimInstance_UseFallLoopAsJump");
static_assert(offsetof(BipedalLocomotionAnimInstance_UseFallLoopAsJump, ReturnValue) == 0x000000, "Member 'BipedalLocomotionAnimInstance_UseFallLoopAsJump::ReturnValue' has a wrong offset!");

// Function X6Game.LocomotionDataContainerBase.SetAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct LocomotionDataContainerBase_SetAnimInstance final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionDataContainerBase_SetAnimInstance) == 0x000008, "Wrong alignment on LocomotionDataContainerBase_SetAnimInstance");
static_assert(sizeof(LocomotionDataContainerBase_SetAnimInstance) == 0x000008, "Wrong size on LocomotionDataContainerBase_SetAnimInstance");
static_assert(offsetof(LocomotionDataContainerBase_SetAnimInstance, AnimInstance) == 0x000000, "Member 'LocomotionDataContainerBase_SetAnimInstance::AnimInstance' has a wrong offset!");

// Function X6Game.BipedalLocomotionDataContainer.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct BipedalLocomotionDataContainer_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PrevCustomMode;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BipedalLocomotionDataContainer_OnMovementModeChanged) == 0x000008, "Wrong alignment on BipedalLocomotionDataContainer_OnMovementModeChanged");
static_assert(sizeof(BipedalLocomotionDataContainer_OnMovementModeChanged) == 0x000010, "Wrong size on BipedalLocomotionDataContainer_OnMovementModeChanged");
static_assert(offsetof(BipedalLocomotionDataContainer_OnMovementModeChanged, Character) == 0x000000, "Member 'BipedalLocomotionDataContainer_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(BipedalLocomotionDataContainer_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'BipedalLocomotionDataContainer_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(BipedalLocomotionDataContainer_OnMovementModeChanged, PrevCustomMode) == 0x000009, "Member 'BipedalLocomotionDataContainer_OnMovementModeChanged::PrevCustomMode' has a wrong offset!");

// Function X6Game.BipedalLocomotionDataContainer.SetStandardSpeeds
// 0x000C (0x000C - 0x0000)
struct BipedalLocomotionDataContainer_SetStandardSpeeds final
{
public:
	float                                         InStandardWalkSpeed;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStandardJogSpeed;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStandardSprintSpeed;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionDataContainer_SetStandardSpeeds) == 0x000004, "Wrong alignment on BipedalLocomotionDataContainer_SetStandardSpeeds");
static_assert(sizeof(BipedalLocomotionDataContainer_SetStandardSpeeds) == 0x00000C, "Wrong size on BipedalLocomotionDataContainer_SetStandardSpeeds");
static_assert(offsetof(BipedalLocomotionDataContainer_SetStandardSpeeds, InStandardWalkSpeed) == 0x000000, "Member 'BipedalLocomotionDataContainer_SetStandardSpeeds::InStandardWalkSpeed' has a wrong offset!");
static_assert(offsetof(BipedalLocomotionDataContainer_SetStandardSpeeds, InStandardJogSpeed) == 0x000004, "Member 'BipedalLocomotionDataContainer_SetStandardSpeeds::InStandardJogSpeed' has a wrong offset!");
static_assert(offsetof(BipedalLocomotionDataContainer_SetStandardSpeeds, InStandardSprintSpeed) == 0x000008, "Member 'BipedalLocomotionDataContainer_SetStandardSpeeds::InStandardSprintSpeed' has a wrong offset!");

// Function X6Game.BipedalLocomotionDataContainer.UpdateFloatingJumpStates
// 0x0001 (0x0001 - 0x0000)
struct BipedalLocomotionDataContainer_UpdateFloatingJumpStates final
{
public:
	uint8                                         InFloatingJumpStage;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionDataContainer_UpdateFloatingJumpStates) == 0x000001, "Wrong alignment on BipedalLocomotionDataContainer_UpdateFloatingJumpStates");
static_assert(sizeof(BipedalLocomotionDataContainer_UpdateFloatingJumpStates) == 0x000001, "Wrong size on BipedalLocomotionDataContainer_UpdateFloatingJumpStates");
static_assert(offsetof(BipedalLocomotionDataContainer_UpdateFloatingJumpStates, InFloatingJumpStage) == 0x000000, "Member 'BipedalLocomotionDataContainer_UpdateFloatingJumpStates::InFloatingJumpStage' has a wrong offset!");

// Function X6Game.BipedalLocomotionDataContainer.UpdatePlayerMovementStates
// 0x0008 (0x0008 - 0x0000)
struct BipedalLocomotionDataContainer_UpdatePlayerMovementStates final
{
public:
	EMovementMode                                 InMovementMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               InAllowGait;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InAllowSpeed;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BipedalLocomotionDataContainer_UpdatePlayerMovementStates) == 0x000004, "Wrong alignment on BipedalLocomotionDataContainer_UpdatePlayerMovementStates");
static_assert(sizeof(BipedalLocomotionDataContainer_UpdatePlayerMovementStates) == 0x000008, "Wrong size on BipedalLocomotionDataContainer_UpdatePlayerMovementStates");
static_assert(offsetof(BipedalLocomotionDataContainer_UpdatePlayerMovementStates, InMovementMode) == 0x000000, "Member 'BipedalLocomotionDataContainer_UpdatePlayerMovementStates::InMovementMode' has a wrong offset!");
static_assert(offsetof(BipedalLocomotionDataContainer_UpdatePlayerMovementStates, InAllowGait) == 0x000001, "Member 'BipedalLocomotionDataContainer_UpdatePlayerMovementStates::InAllowGait' has a wrong offset!");
static_assert(offsetof(BipedalLocomotionDataContainer_UpdatePlayerMovementStates, InAllowSpeed) == 0x000004, "Member 'BipedalLocomotionDataContainer_UpdatePlayerMovementStates::InAllowSpeed' has a wrong offset!");

// Function X6Game.CameraModifierVolumeActor.OnActorEnterVolume
// 0x0008 (0x0008 - 0x0000)
struct CameraModifierVolumeActor_OnActorEnterVolume final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifierVolumeActor_OnActorEnterVolume) == 0x000008, "Wrong alignment on CameraModifierVolumeActor_OnActorEnterVolume");
static_assert(sizeof(CameraModifierVolumeActor_OnActorEnterVolume) == 0x000008, "Wrong size on CameraModifierVolumeActor_OnActorEnterVolume");
static_assert(offsetof(CameraModifierVolumeActor_OnActorEnterVolume, Actor) == 0x000000, "Member 'CameraModifierVolumeActor_OnActorEnterVolume::Actor' has a wrong offset!");

// Function X6Game.CameraModifierVolumeActor.OnActorLeaveVolume
// 0x0008 (0x0008 - 0x0000)
struct CameraModifierVolumeActor_OnActorLeaveVolume final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifierVolumeActor_OnActorLeaveVolume) == 0x000008, "Wrong alignment on CameraModifierVolumeActor_OnActorLeaveVolume");
static_assert(sizeof(CameraModifierVolumeActor_OnActorLeaveVolume) == 0x000008, "Wrong size on CameraModifierVolumeActor_OnActorLeaveVolume");
static_assert(offsetof(CameraModifierVolumeActor_OnActorLeaveVolume, Actor) == 0x000000, "Member 'CameraModifierVolumeActor_OnActorLeaveVolume::Actor' has a wrong offset!");

// Function X6Game.CameraModifierVolumeActor.OnEnterBoxComponentBeginOverlap
// 0x0118 (0x0118 - 0x0000)
struct CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap) == 0x000008, "Wrong alignment on CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap");
static_assert(sizeof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap) == 0x000118, "Wrong size on CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap");
static_assert(offsetof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap, OtherActor) == 0x000008, "Member 'CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap, OtherComp) == 0x000010, "Member 'CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap, SweepResult) == 0x000020, "Member 'CameraModifierVolumeActor_OnEnterBoxComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function X6Game.CameraModifierVolumeActor.OnExitBoxBoxComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap) == 0x000008, "Wrong alignment on CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap");
static_assert(sizeof(CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap) == 0x000020, "Wrong size on CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap");
static_assert(offsetof(CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap, OtherActor) == 0x000008, "Member 'CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap, OtherComp) == 0x000010, "Member 'CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'CameraModifierVolumeActor_OnExitBoxBoxComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function X6Game.CameraModifier_CameraBlur.InitializeBlend
// 0x0008 (0x0008 - 0x0000)
struct CameraModifier_CameraBlur_InitializeBlend final
{
public:
	float                                         BlendInTime;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_CameraBlur_InitializeBlend) == 0x000004, "Wrong alignment on CameraModifier_CameraBlur_InitializeBlend");
static_assert(sizeof(CameraModifier_CameraBlur_InitializeBlend) == 0x000008, "Wrong size on CameraModifier_CameraBlur_InitializeBlend");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeBlend, BlendInTime) == 0x000000, "Member 'CameraModifier_CameraBlur_InitializeBlend::BlendInTime' has a wrong offset!");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeBlend, BlendOutTime) == 0x000004, "Member 'CameraModifier_CameraBlur_InitializeBlend::BlendOutTime' has a wrong offset!");

// Function X6Game.CameraModifier_CameraBlur.InitializeMotionBlur
// 0x0008 (0x0008 - 0x0000)
struct CameraModifier_CameraBlur_InitializeMotionBlur final
{
public:
	float                                         InBlurAmount;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlurMax;                                         // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_CameraBlur_InitializeMotionBlur) == 0x000004, "Wrong alignment on CameraModifier_CameraBlur_InitializeMotionBlur");
static_assert(sizeof(CameraModifier_CameraBlur_InitializeMotionBlur) == 0x000008, "Wrong size on CameraModifier_CameraBlur_InitializeMotionBlur");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeMotionBlur, InBlurAmount) == 0x000000, "Member 'CameraModifier_CameraBlur_InitializeMotionBlur::InBlurAmount' has a wrong offset!");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeMotionBlur, InBlurMax) == 0x000004, "Member 'CameraModifier_CameraBlur_InitializeMotionBlur::InBlurMax' has a wrong offset!");

// Function X6Game.CameraModifier_CameraBlur.InitializeRadiusBlur
// 0x0010 (0x0010 - 0x0000)
struct CameraModifier_CameraBlur_InitializeRadiusBlur final
{
public:
	float                                         InOffset;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRadius;                                          // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHardness;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSwitchDir;                                       // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_CameraBlur_InitializeRadiusBlur) == 0x000004, "Wrong alignment on CameraModifier_CameraBlur_InitializeRadiusBlur");
static_assert(sizeof(CameraModifier_CameraBlur_InitializeRadiusBlur) == 0x000010, "Wrong size on CameraModifier_CameraBlur_InitializeRadiusBlur");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeRadiusBlur, InOffset) == 0x000000, "Member 'CameraModifier_CameraBlur_InitializeRadiusBlur::InOffset' has a wrong offset!");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeRadiusBlur, InRadius) == 0x000004, "Member 'CameraModifier_CameraBlur_InitializeRadiusBlur::InRadius' has a wrong offset!");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeRadiusBlur, InHardness) == 0x000008, "Member 'CameraModifier_CameraBlur_InitializeRadiusBlur::InHardness' has a wrong offset!");
static_assert(offsetof(CameraModifier_CameraBlur_InitializeRadiusBlur, InSwitchDir) == 0x00000C, "Member 'CameraModifier_CameraBlur_InitializeRadiusBlur::InSwitchDir' has a wrong offset!");

// Function X6Game.CustomNavLinkMoveInterface.OnLinkMoveRemoved
// 0x0008 (0x0008 - 0x0000)
struct CustomNavLinkMoveInterface_OnLinkMoveRemoved final
{
public:
	class UX6PathFollowingComponent*              PathComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomNavLinkMoveInterface_OnLinkMoveRemoved) == 0x000008, "Wrong alignment on CustomNavLinkMoveInterface_OnLinkMoveRemoved");
static_assert(sizeof(CustomNavLinkMoveInterface_OnLinkMoveRemoved) == 0x000008, "Wrong size on CustomNavLinkMoveInterface_OnLinkMoveRemoved");
static_assert(offsetof(CustomNavLinkMoveInterface_OnLinkMoveRemoved, PathComp) == 0x000000, "Member 'CustomNavLinkMoveInterface_OnLinkMoveRemoved::PathComp' has a wrong offset!");

// Function X6Game.CustomNavLinkMoveInterface.OnLinkMoveStart
// 0x0040 (0x0040 - 0x0000)
struct CustomNavLinkMoveInterface_OnLinkMoveStart final
{
public:
	class UX6PathFollowingComponent*              PathComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPoint;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestPoint;                                         // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CustomNavLinkMoveInterface_OnLinkMoveStart) == 0x000008, "Wrong alignment on CustomNavLinkMoveInterface_OnLinkMoveStart");
static_assert(sizeof(CustomNavLinkMoveInterface_OnLinkMoveStart) == 0x000040, "Wrong size on CustomNavLinkMoveInterface_OnLinkMoveStart");
static_assert(offsetof(CustomNavLinkMoveInterface_OnLinkMoveStart, PathComp) == 0x000000, "Member 'CustomNavLinkMoveInterface_OnLinkMoveStart::PathComp' has a wrong offset!");
static_assert(offsetof(CustomNavLinkMoveInterface_OnLinkMoveStart, StartPoint) == 0x000008, "Member 'CustomNavLinkMoveInterface_OnLinkMoveStart::StartPoint' has a wrong offset!");
static_assert(offsetof(CustomNavLinkMoveInterface_OnLinkMoveStart, DestPoint) == 0x000020, "Member 'CustomNavLinkMoveInterface_OnLinkMoveStart::DestPoint' has a wrong offset!");
static_assert(offsetof(CustomNavLinkMoveInterface_OnLinkMoveStart, ReturnValue) == 0x000038, "Member 'CustomNavLinkMoveInterface_OnLinkMoveStart::ReturnValue' has a wrong offset!");

// Function X6Game.CustomNavLinkMoveInterface.OnLinkMoveStop
// 0x0008 (0x0008 - 0x0000)
struct CustomNavLinkMoveInterface_OnLinkMoveStop final
{
public:
	class UX6PathFollowingComponent*              PathComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomNavLinkMoveInterface_OnLinkMoveStop) == 0x000008, "Wrong alignment on CustomNavLinkMoveInterface_OnLinkMoveStop");
static_assert(sizeof(CustomNavLinkMoveInterface_OnLinkMoveStop) == 0x000008, "Wrong size on CustomNavLinkMoveInterface_OnLinkMoveStop");
static_assert(offsetof(CustomNavLinkMoveInterface_OnLinkMoveStop, PathComp) == 0x000000, "Member 'CustomNavLinkMoveInterface_OnLinkMoveStop::PathComp' has a wrong offset!");

// Function X6Game.CustomNavLinkMoveInterface.StopBlockDetectionInNavLink
// 0x0001 (0x0001 - 0x0000)
struct CustomNavLinkMoveInterface_StopBlockDetectionInNavLink final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomNavLinkMoveInterface_StopBlockDetectionInNavLink) == 0x000001, "Wrong alignment on CustomNavLinkMoveInterface_StopBlockDetectionInNavLink");
static_assert(sizeof(CustomNavLinkMoveInterface_StopBlockDetectionInNavLink) == 0x000001, "Wrong size on CustomNavLinkMoveInterface_StopBlockDetectionInNavLink");
static_assert(offsetof(CustomNavLinkMoveInterface_StopBlockDetectionInNavLink, ReturnValue) == 0x000000, "Member 'CustomNavLinkMoveInterface_StopBlockDetectionInNavLink::ReturnValue' has a wrong offset!");

// Function X6Game.CustomNavLinkMoveInterface.StopCheckingReachTarget
// 0x0001 (0x0001 - 0x0000)
struct CustomNavLinkMoveInterface_StopCheckingReachTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomNavLinkMoveInterface_StopCheckingReachTarget) == 0x000001, "Wrong alignment on CustomNavLinkMoveInterface_StopCheckingReachTarget");
static_assert(sizeof(CustomNavLinkMoveInterface_StopCheckingReachTarget) == 0x000001, "Wrong size on CustomNavLinkMoveInterface_StopCheckingReachTarget");
static_assert(offsetof(CustomNavLinkMoveInterface_StopCheckingReachTarget, ReturnValue) == 0x000000, "Member 'CustomNavLinkMoveInterface_StopCheckingReachTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6TickObject.ReceiveTick
// 0x0004 (0x0004 - 0x0000)
struct X6TickObject_ReceiveTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TickObject_ReceiveTick) == 0x000004, "Wrong alignment on X6TickObject_ReceiveTick");
static_assert(sizeof(X6TickObject_ReceiveTick) == 0x000004, "Wrong size on X6TickObject_ReceiveTick");
static_assert(offsetof(X6TickObject_ReceiveTick, DeltaTime) == 0x000000, "Member 'X6TickObject_ReceiveTick::DeltaTime' has a wrong offset!");

// Function X6Game.X6TickObject.SetTickable
// 0x0001 (0x0001 - 0x0000)
struct X6TickObject_SetTickable final
{
public:
	bool                                          IsTickable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TickObject_SetTickable) == 0x000001, "Wrong alignment on X6TickObject_SetTickable");
static_assert(sizeof(X6TickObject_SetTickable) == 0x000001, "Wrong size on X6TickObject_SetTickable");
static_assert(offsetof(X6TickObject_SetTickable, IsTickable) == 0x000000, "Member 'X6TickObject_SetTickable::IsTickable' has a wrong offset!");

// Function X6Game.X6TickObject.SetTickableWhenPaused
// 0x0001 (0x0001 - 0x0000)
struct X6TickObject_SetTickableWhenPaused final
{
public:
	bool                                          IsTickableWhenPaused;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TickObject_SetTickableWhenPaused) == 0x000001, "Wrong alignment on X6TickObject_SetTickableWhenPaused");
static_assert(sizeof(X6TickObject_SetTickableWhenPaused) == 0x000001, "Wrong size on X6TickObject_SetTickableWhenPaused");
static_assert(offsetof(X6TickObject_SetTickableWhenPaused, IsTickableWhenPaused) == 0x000000, "Member 'X6TickObject_SetTickableWhenPaused::IsTickableWhenPaused' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.BlueprintPrepareDependencies
// 0x0001 (0x0001 - 0x0000)
struct DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies) == 0x000001, "Wrong alignment on DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies) == 0x000001, "Wrong size on DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies, ReturnValue) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_BlueprintPrepareDependencies::ReturnValue' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.BlueprintUpdatePlayerStates
// 0x0004 (0x0004 - 0x0000)
struct DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates) == 0x000004, "Wrong alignment on DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates) == 0x000004, "Wrong size on DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates, DeltaSeconds) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_BlueprintUpdatePlayerStates::DeltaSeconds' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.LoadDamiaoRelaxAnimCompeted
// 0x0018 (0x0018 - 0x0000)
struct DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted final
{
public:
	int32                                         AsyncId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        InLoadedObjects;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted) == 0x000018, "Wrong size on DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted, AsyncId) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted::AsyncId' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted, InLoadedObjects) == 0x000008, "Member 'DaMiaoLocomotionAnimInstance_LoadDamiaoRelaxAnimCompeted::InLoadedObjects' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnApplyAdditiveUpdate
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnApplyAdditiveUpdate::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnCycleStateMachineUpdate
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnCycleStateMachineUpdate::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnJumpStartStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnJumpStartStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnLandRecoveryAdditiveStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnLandRecoveryAdditiveStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnReJumpStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnReJumpStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnStartLeanAdditiveBlendSpacePlayerUpdate
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnStartLeanAdditiveBlendSpacePlayerUpdate::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnStartSequencePlayerUpdate
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnStartSequencePlayerUpdate::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnStartStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnStartStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnStartStateUpdate
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnStartStateUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnStartStateUpdate) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnStartStateUpdate");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnStartStateUpdate) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnStartStateUpdate");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartStateUpdate, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnStartStateUpdate::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStartStateUpdate, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnStartStateUpdate::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnStopSequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnStopSequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnStopStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnStopStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.OnTurnInPlaceStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant) == 0x000020, "Wrong size on DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant, Context) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant, Node) == 0x000010, "Member 'DaMiaoLocomotionAnimInstance_OnTurnInPlaceStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.SetDashState
// 0x0001 (0x0001 - 0x0000)
struct DaMiaoLocomotionAnimInstance_SetDashState final
{
public:
	bool                                          IsInDash;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_SetDashState) == 0x000001, "Wrong alignment on DaMiaoLocomotionAnimInstance_SetDashState");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_SetDashState) == 0x000001, "Wrong size on DaMiaoLocomotionAnimInstance_SetDashState");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_SetDashState, IsInDash) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_SetDashState::IsInDash' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.SetPendingGroundedLocomotionAnimSet
// 0x0100 (0x0100 - 0x0000)
struct DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet final
{
public:
	struct FDaMiaoGroundedLocomotionAnimSet       InGroundedLocomotionAnimSet;                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet) == 0x000008, "Wrong alignment on DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet) == 0x000100, "Wrong size on DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet, InGroundedLocomotionAnimSet) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_SetPendingGroundedLocomotionAnimSet::InGroundedLocomotionAnimSet' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.UpdateDamiaoFloatParam
// 0x0004 (0x0004 - 0x0000)
struct DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam) == 0x000004, "Wrong alignment on DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam) == 0x000004, "Wrong size on DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam, DeltaTime) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_UpdateDamiaoFloatParam::DeltaTime' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.UpdateNativeAllowGait
// 0x0001 (0x0001 - 0x0000)
struct DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait final
{
public:
	ENativePlayerLocomotionType                   InGait;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait) == 0x000001, "Wrong alignment on DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait) == 0x000001, "Wrong size on DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait, InGait) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_UpdateNativeAllowGait::InGait' has a wrong offset!");

// Function X6Game.DaMiaoLocomotionAnimInstance.UpdateNativeFloatingJumpStage
// 0x0001 (0x0001 - 0x0000)
struct DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage final
{
public:
	ENativePlayerFloatingJumpStage                InStage;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage) == 0x000001, "Wrong alignment on DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage");
static_assert(sizeof(DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage) == 0x000001, "Wrong size on DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage");
static_assert(offsetof(DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage, InStage) == 0x000000, "Member 'DaMiaoLocomotionAnimInstance_UpdateNativeFloatingJumpStage::InStage' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.DisableGravity
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterMovementComponent_DisableGravity final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_DisableGravity) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_DisableGravity");
static_assert(sizeof(X6CharacterMovementComponent_DisableGravity) == 0x000008, "Wrong size on X6CharacterMovementComponent_DisableGravity");
static_assert(offsetof(X6CharacterMovementComponent_DisableGravity, Tag) == 0x000000, "Member 'X6CharacterMovementComponent_DisableGravity::Tag' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.EnableGravity
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterMovementComponent_EnableGravity final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_EnableGravity) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_EnableGravity");
static_assert(sizeof(X6CharacterMovementComponent_EnableGravity) == 0x000008, "Wrong size on X6CharacterMovementComponent_EnableGravity");
static_assert(offsetof(X6CharacterMovementComponent_EnableGravity, Tag) == 0x000000, "Member 'X6CharacterMovementComponent_EnableGravity::Tag' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetEnableInertiaVelocityProcess
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_GetEnableInertiaVelocityProcess final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetEnableInertiaVelocityProcess) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_GetEnableInertiaVelocityProcess");
static_assert(sizeof(X6CharacterMovementComponent_GetEnableInertiaVelocityProcess) == 0x000001, "Wrong size on X6CharacterMovementComponent_GetEnableInertiaVelocityProcess");
static_assert(offsetof(X6CharacterMovementComponent_GetEnableInertiaVelocityProcess, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetEnableInertiaVelocityProcess::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.IsRootMotionBrake2D
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_IsRootMotionBrake2D final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_IsRootMotionBrake2D) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_IsRootMotionBrake2D");
static_assert(sizeof(X6CharacterMovementComponent_IsRootMotionBrake2D) == 0x000001, "Wrong size on X6CharacterMovementComponent_IsRootMotionBrake2D");
static_assert(offsetof(X6CharacterMovementComponent_IsRootMotionBrake2D, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_IsRootMotionBrake2D::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.IsX6CharacterMovementFrozen
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_IsX6CharacterMovementFrozen final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_IsX6CharacterMovementFrozen) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_IsX6CharacterMovementFrozen");
static_assert(sizeof(X6CharacterMovementComponent_IsX6CharacterMovementFrozen) == 0x000001, "Wrong size on X6CharacterMovementComponent_IsX6CharacterMovementFrozen");
static_assert(offsetof(X6CharacterMovementComponent_IsX6CharacterMovementFrozen, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_IsX6CharacterMovementFrozen::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.MulticastHasAnyAccelerationChanged
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged final
{
public:
	bool                                          bNewHasAnyAcceleration;                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged) == 0x000008, "Wrong alignment on X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged");
static_assert(sizeof(X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged) == 0x000020, "Wrong size on X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged");
static_assert(offsetof(X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged, bNewHasAnyAcceleration) == 0x000000, "Member 'X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged::bNewHasAnyAcceleration' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged, Location) == 0x000008, "Member 'X6CharacterMovementComponent_MulticastHasAnyAccelerationChanged::Location' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetBrakeWithRootMotion
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_SetBrakeWithRootMotion final
{
public:
	bool                                          bInBrakeWithRootMotion;                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetBrakeWithRootMotion) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_SetBrakeWithRootMotion");
static_assert(sizeof(X6CharacterMovementComponent_SetBrakeWithRootMotion) == 0x000001, "Wrong size on X6CharacterMovementComponent_SetBrakeWithRootMotion");
static_assert(offsetof(X6CharacterMovementComponent_SetBrakeWithRootMotion, bInBrakeWithRootMotion) == 0x000000, "Member 'X6CharacterMovementComponent_SetBrakeWithRootMotion::bInBrakeWithRootMotion' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetEnableInertiaVelocityProcess
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_SetEnableInertiaVelocityProcess final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetEnableInertiaVelocityProcess) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_SetEnableInertiaVelocityProcess");
static_assert(sizeof(X6CharacterMovementComponent_SetEnableInertiaVelocityProcess) == 0x000001, "Wrong size on X6CharacterMovementComponent_SetEnableInertiaVelocityProcess");
static_assert(offsetof(X6CharacterMovementComponent_SetEnableInertiaVelocityProcess, bEnable) == 0x000000, "Member 'X6CharacterMovementComponent_SetEnableInertiaVelocityProcess::bEnable' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetEnableUpdateRegularMovementBase
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase");
static_assert(sizeof(X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase) == 0x000001, "Wrong size on X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase");
static_assert(offsetof(X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase, bEnable) == 0x000000, "Member 'X6CharacterMovementComponent_SetEnableUpdateRegularMovementBase::bEnable' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetMovementModeAtCache
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterMovementComponent_SetMovementModeAtCache final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterMovementComponent_SetMovementModeAtCache) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_SetMovementModeAtCache");
static_assert(sizeof(X6CharacterMovementComponent_SetMovementModeAtCache) == 0x000008, "Wrong size on X6CharacterMovementComponent_SetMovementModeAtCache");
static_assert(offsetof(X6CharacterMovementComponent_SetMovementModeAtCache, Index_0) == 0x000000, "Member 'X6CharacterMovementComponent_SetMovementModeAtCache::Index_0' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_SetMovementModeAtCache, ReturnValue) == 0x000004, "Member 'X6CharacterMovementComponent_SetMovementModeAtCache::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetMovementModeWithTag
// 0x000C (0x000C - 0x0000)
struct X6CharacterMovementComponent_SetMovementModeWithTag final
{
public:
	EMovementMode                                 NewMovementMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewCustomMode;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetMovementModeWithTag) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_SetMovementModeWithTag");
static_assert(sizeof(X6CharacterMovementComponent_SetMovementModeWithTag) == 0x00000C, "Wrong size on X6CharacterMovementComponent_SetMovementModeWithTag");
static_assert(offsetof(X6CharacterMovementComponent_SetMovementModeWithTag, NewMovementMode) == 0x000000, "Member 'X6CharacterMovementComponent_SetMovementModeWithTag::NewMovementMode' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_SetMovementModeWithTag, NewCustomMode) == 0x000001, "Member 'X6CharacterMovementComponent_SetMovementModeWithTag::NewCustomMode' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_SetMovementModeWithTag, Tag) == 0x000004, "Member 'X6CharacterMovementComponent_SetMovementModeWithTag::Tag' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetRootMotionBrakeDistance
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterMovementComponent_SetRootMotionBrakeDistance final
{
public:
	float                                         InBrakeDistance;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetRootMotionBrakeDistance) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_SetRootMotionBrakeDistance");
static_assert(sizeof(X6CharacterMovementComponent_SetRootMotionBrakeDistance) == 0x000004, "Wrong size on X6CharacterMovementComponent_SetRootMotionBrakeDistance");
static_assert(offsetof(X6CharacterMovementComponent_SetRootMotionBrakeDistance, InBrakeDistance) == 0x000000, "Member 'X6CharacterMovementComponent_SetRootMotionBrakeDistance::InBrakeDistance' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetRootMotionBrakeDuration
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterMovementComponent_SetRootMotionBrakeDuration final
{
public:
	float                                         InBrakeDuration;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetRootMotionBrakeDuration) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_SetRootMotionBrakeDuration");
static_assert(sizeof(X6CharacterMovementComponent_SetRootMotionBrakeDuration) == 0x000004, "Wrong size on X6CharacterMovementComponent_SetRootMotionBrakeDuration");
static_assert(offsetof(X6CharacterMovementComponent_SetRootMotionBrakeDuration, InBrakeDuration) == 0x000000, "Member 'X6CharacterMovementComponent_SetRootMotionBrakeDuration::InBrakeDuration' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetToPrevMovementMode
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_SetToPrevMovementMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_SetToPrevMovementMode) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_SetToPrevMovementMode");
static_assert(sizeof(X6CharacterMovementComponent_SetToPrevMovementMode) == 0x000001, "Wrong size on X6CharacterMovementComponent_SetToPrevMovementMode");
static_assert(offsetof(X6CharacterMovementComponent_SetToPrevMovementMode, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_SetToPrevMovementMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.SetToTagMovementMode
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterMovementComponent_SetToTagMovementMode final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Previous;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterMovementComponent_SetToTagMovementMode) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_SetToTagMovementMode");
static_assert(sizeof(X6CharacterMovementComponent_SetToTagMovementMode) == 0x000010, "Wrong size on X6CharacterMovementComponent_SetToTagMovementMode");
static_assert(offsetof(X6CharacterMovementComponent_SetToTagMovementMode, Tag) == 0x000000, "Member 'X6CharacterMovementComponent_SetToTagMovementMode::Tag' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_SetToTagMovementMode, Previous) == 0x000008, "Member 'X6CharacterMovementComponent_SetToTagMovementMode::Previous' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_SetToTagMovementMode, ReturnValue) == 0x00000C, "Member 'X6CharacterMovementComponent_SetToTagMovementMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.UpdateRegularMovementBaseVelocity
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity");
static_assert(sizeof(X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity) == 0x000004, "Wrong size on X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity");
static_assert(offsetof(X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity, DeltaTime) == 0x000000, "Member 'X6CharacterMovementComponent_UpdateRegularMovementBaseVelocity::DeltaTime' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.X6_GetComponentTickDisabledTags
// 0x0050 (0x0050 - 0x0000)
struct X6CharacterMovementComponent_X6_GetComponentTickDisabledTags final
{
public:
	TSet<class FName>                             OutTags;                                           // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_X6_GetComponentTickDisabledTags) == 0x000008, "Wrong alignment on X6CharacterMovementComponent_X6_GetComponentTickDisabledTags");
static_assert(sizeof(X6CharacterMovementComponent_X6_GetComponentTickDisabledTags) == 0x000050, "Wrong size on X6CharacterMovementComponent_X6_GetComponentTickDisabledTags");
static_assert(offsetof(X6CharacterMovementComponent_X6_GetComponentTickDisabledTags, OutTags) == 0x000000, "Member 'X6CharacterMovementComponent_X6_GetComponentTickDisabledTags::OutTags' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.X6_SetComponentTickEnabled
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterMovementComponent_X6_SetComponentTickEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterMovementComponent_X6_SetComponentTickEnabled) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_X6_SetComponentTickEnabled");
static_assert(sizeof(X6CharacterMovementComponent_X6_SetComponentTickEnabled) == 0x000010, "Wrong size on X6CharacterMovementComponent_X6_SetComponentTickEnabled");
static_assert(offsetof(X6CharacterMovementComponent_X6_SetComponentTickEnabled, bEnabled) == 0x000000, "Member 'X6CharacterMovementComponent_X6_SetComponentTickEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_X6_SetComponentTickEnabled, Tag) == 0x000004, "Member 'X6CharacterMovementComponent_X6_SetComponentTickEnabled::Tag' has a wrong offset!");
static_assert(offsetof(X6CharacterMovementComponent_X6_SetComponentTickEnabled, ReturnValue) == 0x00000C, "Member 'X6CharacterMovementComponent_X6_SetComponentTickEnabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.CanTurningInplace
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_CanTurningInplace final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_CanTurningInplace) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_CanTurningInplace");
static_assert(sizeof(X6CharacterMovementComponent_CanTurningInplace) == 0x000001, "Wrong size on X6CharacterMovementComponent_CanTurningInplace");
static_assert(offsetof(X6CharacterMovementComponent_CanTurningInplace, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_CanTurningInplace::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.EnableUpdateRegularMovementBase
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_EnableUpdateRegularMovementBase final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_EnableUpdateRegularMovementBase) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_EnableUpdateRegularMovementBase");
static_assert(sizeof(X6CharacterMovementComponent_EnableUpdateRegularMovementBase) == 0x000001, "Wrong size on X6CharacterMovementComponent_EnableUpdateRegularMovementBase");
static_assert(offsetof(X6CharacterMovementComponent_EnableUpdateRegularMovementBase, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_EnableUpdateRegularMovementBase::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetBrakeWithRootMotion
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_GetBrakeWithRootMotion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetBrakeWithRootMotion) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_GetBrakeWithRootMotion");
static_assert(sizeof(X6CharacterMovementComponent_GetBrakeWithRootMotion) == 0x000001, "Wrong size on X6CharacterMovementComponent_GetBrakeWithRootMotion");
static_assert(offsetof(X6CharacterMovementComponent_GetBrakeWithRootMotion, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetBrakeWithRootMotion::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetCurrentDynamicMovementBaseTransform
// 0x0060 (0x0060 - 0x0000)
struct X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform) == 0x000010, "Wrong alignment on X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform");
static_assert(sizeof(X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform) == 0x000060, "Wrong size on X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform");
static_assert(offsetof(X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetCurrentDynamicMovementBaseTransform::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetLastDynamicMovementBaseTransform
// 0x0060 (0x0060 - 0x0000)
struct X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform) == 0x000010, "Wrong alignment on X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform");
static_assert(sizeof(X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform) == 0x000060, "Wrong size on X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform");
static_assert(offsetof(X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetLastDynamicMovementBaseTransform::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetRegularMovementBaseVelocity
// 0x0018 (0x0018 - 0x0000)
struct X6CharacterMovementComponent_GetRegularMovementBaseVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetRegularMovementBaseVelocity) == 0x000008, "Wrong alignment on X6CharacterMovementComponent_GetRegularMovementBaseVelocity");
static_assert(sizeof(X6CharacterMovementComponent_GetRegularMovementBaseVelocity) == 0x000018, "Wrong size on X6CharacterMovementComponent_GetRegularMovementBaseVelocity");
static_assert(offsetof(X6CharacterMovementComponent_GetRegularMovementBaseVelocity, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetRegularMovementBaseVelocity::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetRootMotionBrakeDistance
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterMovementComponent_GetRootMotionBrakeDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetRootMotionBrakeDistance) == 0x000004, "Wrong alignment on X6CharacterMovementComponent_GetRootMotionBrakeDistance");
static_assert(sizeof(X6CharacterMovementComponent_GetRootMotionBrakeDistance) == 0x000004, "Wrong size on X6CharacterMovementComponent_GetRootMotionBrakeDistance");
static_assert(offsetof(X6CharacterMovementComponent_GetRootMotionBrakeDistance, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetRootMotionBrakeDistance::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetTransformAfterUpdateMovementBase
// 0x0060 (0x0060 - 0x0000)
struct X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase) == 0x000010, "Wrong alignment on X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase");
static_assert(sizeof(X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase) == 0x000060, "Wrong size on X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase");
static_assert(offsetof(X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetTransformAfterUpdateMovementBase::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.GetTransformBeforeUpdateMovementBase
// 0x0060 (0x0060 - 0x0000)
struct X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase) == 0x000010, "Wrong alignment on X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase");
static_assert(sizeof(X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase) == 0x000060, "Wrong size on X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase");
static_assert(offsetof(X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_GetTransformBeforeUpdateMovementBase::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.IsDisableGravity
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_IsDisableGravity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_IsDisableGravity) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_IsDisableGravity");
static_assert(sizeof(X6CharacterMovementComponent_IsDisableGravity) == 0x000001, "Wrong size on X6CharacterMovementComponent_IsDisableGravity");
static_assert(offsetof(X6CharacterMovementComponent_IsDisableGravity, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_IsDisableGravity::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterMovementComponent.IsRegularMovementBaseValid
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterMovementComponent_IsRegularMovementBaseValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterMovementComponent_IsRegularMovementBaseValid) == 0x000001, "Wrong alignment on X6CharacterMovementComponent_IsRegularMovementBaseValid");
static_assert(sizeof(X6CharacterMovementComponent_IsRegularMovementBaseValid) == 0x000001, "Wrong size on X6CharacterMovementComponent_IsRegularMovementBaseValid");
static_assert(offsetof(X6CharacterMovementComponent_IsRegularMovementBaseValid, ReturnValue) == 0x000000, "Member 'X6CharacterMovementComponent_IsRegularMovementBaseValid::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListEntry.OnItemSelectionChanged
// 0x0001 (0x0001 - 0x0000)
struct X6CircularListEntry_OnItemSelectionChanged final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListEntry_OnItemSelectionChanged) == 0x000001, "Wrong alignment on X6CircularListEntry_OnItemSelectionChanged");
static_assert(sizeof(X6CircularListEntry_OnItemSelectionChanged) == 0x000001, "Wrong size on X6CircularListEntry_OnItemSelectionChanged");
static_assert(offsetof(X6CircularListEntry_OnItemSelectionChanged, bIsSelected) == 0x000000, "Member 'X6CircularListEntry_OnItemSelectionChanged::bIsSelected' has a wrong offset!");

// Function X6Game.X6CircularListEntry.OnListItemObjectSet
// 0x0008 (0x0008 - 0x0000)
struct X6CircularListEntry_OnListItemObjectSet final
{
public:
	class UObject*                                ListItemObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListEntry_OnListItemObjectSet) == 0x000008, "Wrong alignment on X6CircularListEntry_OnListItemObjectSet");
static_assert(sizeof(X6CircularListEntry_OnListItemObjectSet) == 0x000008, "Wrong size on X6CircularListEntry_OnListItemObjectSet");
static_assert(offsetof(X6CircularListEntry_OnListItemObjectSet, ListItemObject) == 0x000000, "Member 'X6CircularListEntry_OnListItemObjectSet::ListItemObject' has a wrong offset!");

// Function X6Game.X6CircularListEntryLibrary.GetListItemObject
// 0x0018 (0x0018 - 0x0000)
struct X6CircularListEntryLibrary_GetListItemObject final
{
public:
	TScriptInterface<class IX6CircularListEntry>  X6CircularListEntry;                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListEntryLibrary_GetListItemObject) == 0x000008, "Wrong alignment on X6CircularListEntryLibrary_GetListItemObject");
static_assert(sizeof(X6CircularListEntryLibrary_GetListItemObject) == 0x000018, "Wrong size on X6CircularListEntryLibrary_GetListItemObject");
static_assert(offsetof(X6CircularListEntryLibrary_GetListItemObject, X6CircularListEntry) == 0x000000, "Member 'X6CircularListEntryLibrary_GetListItemObject::X6CircularListEntry' has a wrong offset!");
static_assert(offsetof(X6CircularListEntryLibrary_GetListItemObject, ReturnValue) == 0x000010, "Member 'X6CircularListEntryLibrary_GetListItemObject::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListEntryLibrary.GetOwningListView
// 0x0018 (0x0018 - 0x0000)
struct X6CircularListEntryLibrary_GetOwningListView final
{
public:
	TScriptInterface<class IX6CircularListEntry>  X6CircularListEntry;                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6CircularListView*                    ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListEntryLibrary_GetOwningListView) == 0x000008, "Wrong alignment on X6CircularListEntryLibrary_GetOwningListView");
static_assert(sizeof(X6CircularListEntryLibrary_GetOwningListView) == 0x000018, "Wrong size on X6CircularListEntryLibrary_GetOwningListView");
static_assert(offsetof(X6CircularListEntryLibrary_GetOwningListView, X6CircularListEntry) == 0x000000, "Member 'X6CircularListEntryLibrary_GetOwningListView::X6CircularListEntry' has a wrong offset!");
static_assert(offsetof(X6CircularListEntryLibrary_GetOwningListView, ReturnValue) == 0x000010, "Member 'X6CircularListEntryLibrary_GetOwningListView::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListEntryLibrary.IsListItemSelected
// 0x0018 (0x0018 - 0x0000)
struct X6CircularListEntryLibrary_IsListItemSelected final
{
public:
	TScriptInterface<class IX6CircularListEntry>  X6CircularListEntry;                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CircularListEntryLibrary_IsListItemSelected) == 0x000008, "Wrong alignment on X6CircularListEntryLibrary_IsListItemSelected");
static_assert(sizeof(X6CircularListEntryLibrary_IsListItemSelected) == 0x000018, "Wrong size on X6CircularListEntryLibrary_IsListItemSelected");
static_assert(offsetof(X6CircularListEntryLibrary_IsListItemSelected, X6CircularListEntry) == 0x000000, "Member 'X6CircularListEntryLibrary_IsListItemSelected::X6CircularListEntry' has a wrong offset!");
static_assert(offsetof(X6CircularListEntryLibrary_IsListItemSelected, ReturnValue) == 0x000010, "Member 'X6CircularListEntryLibrary_IsListItemSelected::ReturnValue' has a wrong offset!");

// Function X6Game.LocomotionRequestInterface.RequestTurnInPlaceByAngle
// 0x0028 (0x0028 - 0x0000)
struct LocomotionRequestInterface_RequestTurnInPlaceByAngle final
{
public:
	float                                         InAngleToTurn;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnComplete;                                        // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterrupt;                                       // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocomotionRequestInterface_RequestTurnInPlaceByAngle) == 0x000004, "Wrong alignment on LocomotionRequestInterface_RequestTurnInPlaceByAngle");
static_assert(sizeof(LocomotionRequestInterface_RequestTurnInPlaceByAngle) == 0x000028, "Wrong size on LocomotionRequestInterface_RequestTurnInPlaceByAngle");
static_assert(offsetof(LocomotionRequestInterface_RequestTurnInPlaceByAngle, InAngleToTurn) == 0x000000, "Member 'LocomotionRequestInterface_RequestTurnInPlaceByAngle::InAngleToTurn' has a wrong offset!");
static_assert(offsetof(LocomotionRequestInterface_RequestTurnInPlaceByAngle, OnComplete) == 0x000004, "Member 'LocomotionRequestInterface_RequestTurnInPlaceByAngle::OnComplete' has a wrong offset!");
static_assert(offsetof(LocomotionRequestInterface_RequestTurnInPlaceByAngle, OnInterrupt) == 0x000014, "Member 'LocomotionRequestInterface_RequestTurnInPlaceByAngle::OnInterrupt' has a wrong offset!");
static_assert(offsetof(LocomotionRequestInterface_RequestTurnInPlaceByAngle, ReturnValue) == 0x000024, "Member 'LocomotionRequestInterface_RequestTurnInPlaceByAngle::ReturnValue' has a wrong offset!");

// Function X6Game.LocomotionRequestInterface.SetCanInterruptPendingStopState
// 0x0001 (0x0001 - 0x0000)
struct LocomotionRequestInterface_SetCanInterruptPendingStopState final
{
public:
	bool                                          bCanInterrupt;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionRequestInterface_SetCanInterruptPendingStopState) == 0x000001, "Wrong alignment on LocomotionRequestInterface_SetCanInterruptPendingStopState");
static_assert(sizeof(LocomotionRequestInterface_SetCanInterruptPendingStopState) == 0x000001, "Wrong size on LocomotionRequestInterface_SetCanInterruptPendingStopState");
static_assert(offsetof(LocomotionRequestInterface_SetCanInterruptPendingStopState, bCanInterrupt) == 0x000000, "Member 'LocomotionRequestInterface_SetCanInterruptPendingStopState::bCanInterrupt' has a wrong offset!");

// Function X6Game.LocomotionRequestInterface.CanEverTurnInPlace
// 0x0001 (0x0001 - 0x0000)
struct LocomotionRequestInterface_CanEverTurnInPlace final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocomotionRequestInterface_CanEverTurnInPlace) == 0x000001, "Wrong alignment on LocomotionRequestInterface_CanEverTurnInPlace");
static_assert(sizeof(LocomotionRequestInterface_CanEverTurnInPlace) == 0x000001, "Wrong size on LocomotionRequestInterface_CanEverTurnInPlace");
static_assert(offsetof(LocomotionRequestInterface_CanEverTurnInPlace, ReturnValue) == 0x000000, "Member 'LocomotionRequestInterface_CanEverTurnInPlace::ReturnValue' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.BlueprintInit
// 0x0008 (0x0008 - 0x0000)
struct LookAtLogicHandler_BlueprintInit final
{
public:
	class UX6GeneralAnimationDataComponent*       InOwnerComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_BlueprintInit) == 0x000008, "Wrong alignment on LookAtLogicHandler_BlueprintInit");
static_assert(sizeof(LookAtLogicHandler_BlueprintInit) == 0x000008, "Wrong size on LookAtLogicHandler_BlueprintInit");
static_assert(offsetof(LookAtLogicHandler_BlueprintInit, InOwnerComponent) == 0x000000, "Member 'LookAtLogicHandler_BlueprintInit::InOwnerComponent' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.BlueprintTick
// 0x0004 (0x0004 - 0x0000)
struct LookAtLogicHandler_BlueprintTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_BlueprintTick) == 0x000004, "Wrong alignment on LookAtLogicHandler_BlueprintTick");
static_assert(sizeof(LookAtLogicHandler_BlueprintTick) == 0x000004, "Wrong size on LookAtLogicHandler_BlueprintTick");
static_assert(offsetof(LookAtLogicHandler_BlueprintTick, DeltaTime) == 0x000000, "Member 'LookAtLogicHandler_BlueprintTick::DeltaTime' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.EyeBlinkOnce
// 0x0002 (0x0002 - 0x0000)
struct LookAtLogicHandler_EyeBlinkOnce final
{
public:
	bool                                          bRandomBlink;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_EyeBlinkOnce) == 0x000001, "Wrong alignment on LookAtLogicHandler_EyeBlinkOnce");
static_assert(sizeof(LookAtLogicHandler_EyeBlinkOnce) == 0x000002, "Wrong size on LookAtLogicHandler_EyeBlinkOnce");
static_assert(offsetof(LookAtLogicHandler_EyeBlinkOnce, bRandomBlink) == 0x000000, "Member 'LookAtLogicHandler_EyeBlinkOnce::bRandomBlink' has a wrong offset!");
static_assert(offsetof(LookAtLogicHandler_EyeBlinkOnce, bForce) == 0x000001, "Member 'LookAtLogicHandler_EyeBlinkOnce::bForce' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.GetActorLookAtOffset
// 0x0020 (0x0020 - 0x0000)
struct LookAtLogicHandler_GetActorLookAtOffset final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_GetActorLookAtOffset) == 0x000008, "Wrong alignment on LookAtLogicHandler_GetActorLookAtOffset");
static_assert(sizeof(LookAtLogicHandler_GetActorLookAtOffset) == 0x000020, "Wrong size on LookAtLogicHandler_GetActorLookAtOffset");
static_assert(offsetof(LookAtLogicHandler_GetActorLookAtOffset, InActor) == 0x000000, "Member 'LookAtLogicHandler_GetActorLookAtOffset::InActor' has a wrong offset!");
static_assert(offsetof(LookAtLogicHandler_GetActorLookAtOffset, ReturnValue) == 0x000008, "Member 'LookAtLogicHandler_GetActorLookAtOffset::ReturnValue' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.SetCanOwnerActorDoLookAt
// 0x0001 (0x0001 - 0x0000)
struct LookAtLogicHandler_SetCanOwnerActorDoLookAt final
{
public:
	bool                                          bInCanOwnerActorDoLookAt;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_SetCanOwnerActorDoLookAt) == 0x000001, "Wrong alignment on LookAtLogicHandler_SetCanOwnerActorDoLookAt");
static_assert(sizeof(LookAtLogicHandler_SetCanOwnerActorDoLookAt) == 0x000001, "Wrong size on LookAtLogicHandler_SetCanOwnerActorDoLookAt");
static_assert(offsetof(LookAtLogicHandler_SetCanOwnerActorDoLookAt, bInCanOwnerActorDoLookAt) == 0x000000, "Member 'LookAtLogicHandler_SetCanOwnerActorDoLookAt::bInCanOwnerActorDoLookAt' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.GetOwner
// 0x0008 (0x0008 - 0x0000)
struct LookAtLogicHandler_GetOwner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_GetOwner) == 0x000008, "Wrong alignment on LookAtLogicHandler_GetOwner");
static_assert(sizeof(LookAtLogicHandler_GetOwner) == 0x000008, "Wrong size on LookAtLogicHandler_GetOwner");
static_assert(offsetof(LookAtLogicHandler_GetOwner, ReturnValue) == 0x000000, "Member 'LookAtLogicHandler_GetOwner::ReturnValue' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.GetOwnerComponent
// 0x0008 (0x0008 - 0x0000)
struct LookAtLogicHandler_GetOwnerComponent final
{
public:
	class UX6GeneralAnimationDataComponent*       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_GetOwnerComponent) == 0x000008, "Wrong alignment on LookAtLogicHandler_GetOwnerComponent");
static_assert(sizeof(LookAtLogicHandler_GetOwnerComponent) == 0x000008, "Wrong size on LookAtLogicHandler_GetOwnerComponent");
static_assert(offsetof(LookAtLogicHandler_GetOwnerComponent, ReturnValue) == 0x000000, "Member 'LookAtLogicHandler_GetOwnerComponent::ReturnValue' has a wrong offset!");

// Function X6Game.LookAtLogicHandler.IsEyeBlinking
// 0x0001 (0x0001 - 0x0000)
struct LookAtLogicHandler_IsEyeBlinking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtLogicHandler_IsEyeBlinking) == 0x000001, "Wrong alignment on LookAtLogicHandler_IsEyeBlinking");
static_assert(sizeof(LookAtLogicHandler_IsEyeBlinking) == 0x000001, "Wrong size on LookAtLogicHandler_IsEyeBlinking");
static_assert(offsetof(LookAtLogicHandler_IsEyeBlinking, ReturnValue) == 0x000000, "Member 'LookAtLogicHandler_IsEyeBlinking::ReturnValue' has a wrong offset!");

// Function X6Game.X6ActorComponent.AttributeChange
// 0x0010 (0x0010 - 0x0000)
struct X6ActorComponent_AttributeChange final
{
public:
	class FString                                 AttributeName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ActorComponent_AttributeChange) == 0x000008, "Wrong alignment on X6ActorComponent_AttributeChange");
static_assert(sizeof(X6ActorComponent_AttributeChange) == 0x000010, "Wrong size on X6ActorComponent_AttributeChange");
static_assert(offsetof(X6ActorComponent_AttributeChange, AttributeName) == 0x000000, "Member 'X6ActorComponent_AttributeChange::AttributeName' has a wrong offset!");

// Function X6Game.X6ActorComponent.SetAttributeChangeToSave
// 0x0001 (0x0001 - 0x0000)
struct X6ActorComponent_SetAttributeChangeToSave final
{
public:
	bool                                          Change;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ActorComponent_SetAttributeChangeToSave) == 0x000001, "Wrong alignment on X6ActorComponent_SetAttributeChangeToSave");
static_assert(sizeof(X6ActorComponent_SetAttributeChangeToSave) == 0x000001, "Wrong size on X6ActorComponent_SetAttributeChangeToSave");
static_assert(offsetof(X6ActorComponent_SetAttributeChangeToSave, Change) == 0x000000, "Member 'X6ActorComponent_SetAttributeChangeToSave::Change' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.BP_OnMulticastRemoveLookAtActor
// 0x0018 (0x0018 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor) == 0x000008, "Wrong alignment on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor) == 0x000018, "Wrong size on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor, TargetActor) == 0x000008, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor::TargetActor' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor, bClearAll) == 0x000010, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtActor::bClearAll' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.BP_OnMulticastRemoveLookAtEventsByType
// 0x0002 (0x0002 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType) == 0x000001, "Wrong alignment on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType) == 0x000002, "Wrong size on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType, bClearAll) == 0x000001, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtEventsByType::bClearAll' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.BP_OnMulticastRemoveLookAtLocation
// 0x0002 (0x0002 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation) == 0x000001, "Wrong alignment on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation) == 0x000002, "Wrong size on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation, bClearAll) == 0x000001, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRemoveLookAtLocation::bClearAll' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.BP_OnMulticastRequestLookAtActor
// 0x0030 (0x0030 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   Params_0;                                          // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor) == 0x000008, "Wrong alignment on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor) == 0x000030, "Wrong size on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor, TargetActor) == 0x000008, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor::TargetActor' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor, Params_0) == 0x000010, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtActor::Params_0' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.BP_OnMulticastRequestLookAtLocation
// 0x0020 (0x0020 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation) == 0x000008, "Wrong alignment on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation) == 0x000020, "Wrong size on MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation, TargetLocation) == 0x000008, "Member 'MainCharacterRPCHelperBaseComponent_BP_OnMulticastRequestLookAtLocation::TargetLocation' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.Multicast_RemoveLookAtActor
// 0x0018 (0x0018 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor) == 0x000008, "Wrong alignment on MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor) == 0x000018, "Wrong size on MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor, TargetActor) == 0x000008, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor::TargetActor' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor, bClearAll) == 0x000010, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtActor::bClearAll' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.Multicast_RemoveLookAtEventsByType
// 0x0002 (0x0002 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType) == 0x000001, "Wrong alignment on MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType) == 0x000002, "Wrong size on MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType, bClearAll) == 0x000001, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtEventsByType::bClearAll' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.Multicast_RemoveLookAtLocation
// 0x0002 (0x0002 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation) == 0x000001, "Wrong alignment on MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation) == 0x000002, "Wrong size on MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation, bClearAll) == 0x000001, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RemoveLookAtLocation::bClearAll' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.Multicast_RequestLookAtActor
// 0x0030 (0x0030 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   Params_0;                                          // 0x0010(0x0020)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor) == 0x000008, "Wrong alignment on MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor) == 0x000030, "Wrong size on MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor, TargetActor) == 0x000008, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor::TargetActor' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor, Params_0) == 0x000010, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtActor::Params_0' has a wrong offset!");

// Function X6Game.MainCharacterRPCHelperBaseComponent.Multicast_RequestLookAtLocation
// 0x0020 (0x0020 - 0x0000)
struct MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation) == 0x000008, "Wrong alignment on MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation");
static_assert(sizeof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation) == 0x000020, "Wrong size on MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation, LookAtEventType) == 0x000000, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation::LookAtEventType' has a wrong offset!");
static_assert(offsetof(MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation, TargetLocation) == 0x000008, "Member 'MainCharacterRPCHelperBaseComponent_Multicast_RequestLookAtLocation::TargetLocation' has a wrong offset!");

// Function X6Game.MaskWidget.AddMaskClickClip
// 0x0030 (0x0030 - 0x0000)
struct MaskWidget_AddMaskClickClip final
{
public:
	struct FVector2D                              Position;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Mask;                                              // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaskWidget_AddMaskClickClip) == 0x000008, "Wrong alignment on MaskWidget_AddMaskClickClip");
static_assert(sizeof(MaskWidget_AddMaskClickClip) == 0x000030, "Wrong size on MaskWidget_AddMaskClickClip");
static_assert(offsetof(MaskWidget_AddMaskClickClip, Position) == 0x000000, "Member 'MaskWidget_AddMaskClickClip::Position' has a wrong offset!");
static_assert(offsetof(MaskWidget_AddMaskClickClip, Size) == 0x000010, "Member 'MaskWidget_AddMaskClickClip::Size' has a wrong offset!");
static_assert(offsetof(MaskWidget_AddMaskClickClip, Mask) == 0x000020, "Member 'MaskWidget_AddMaskClickClip::Mask' has a wrong offset!");
static_assert(offsetof(MaskWidget_AddMaskClickClip, ReturnValue) == 0x000028, "Member 'MaskWidget_AddMaskClickClip::ReturnValue' has a wrong offset!");

// Function X6Game.MaskWidget.EnableMaskClickClip
// 0x0008 (0x0008 - 0x0000)
struct MaskWidget_EnableMaskClickClip final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaskWidget_EnableMaskClickClip) == 0x000004, "Wrong alignment on MaskWidget_EnableMaskClickClip");
static_assert(sizeof(MaskWidget_EnableMaskClickClip) == 0x000008, "Wrong size on MaskWidget_EnableMaskClickClip");
static_assert(offsetof(MaskWidget_EnableMaskClickClip, ClipIndex) == 0x000000, "Member 'MaskWidget_EnableMaskClickClip::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_EnableMaskClickClip, Enable) == 0x000004, "Member 'MaskWidget_EnableMaskClickClip::Enable' has a wrong offset!");

// Function X6Game.MaskWidget.RemoveMaskClickClip
// 0x0008 (0x0008 - 0x0000)
struct MaskWidget_RemoveMaskClickClip final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaskWidget_RemoveMaskClickClip) == 0x000004, "Wrong alignment on MaskWidget_RemoveMaskClickClip");
static_assert(sizeof(MaskWidget_RemoveMaskClickClip) == 0x000008, "Wrong size on MaskWidget_RemoveMaskClickClip");
static_assert(offsetof(MaskWidget_RemoveMaskClickClip, ClipIndex) == 0x000000, "Member 'MaskWidget_RemoveMaskClickClip::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_RemoveMaskClickClip, ReturnValue) == 0x000004, "Member 'MaskWidget_RemoveMaskClickClip::ReturnValue' has a wrong offset!");

// Function X6Game.MaskWidget.SetBgColorAndOpacity
// 0x0010 (0x0010 - 0x0000)
struct MaskWidget_SetBgColorAndOpacity final
{
public:
	struct FLinearColor                           InColorAndOpacity;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetBgColorAndOpacity) == 0x000004, "Wrong alignment on MaskWidget_SetBgColorAndOpacity");
static_assert(sizeof(MaskWidget_SetBgColorAndOpacity) == 0x000010, "Wrong size on MaskWidget_SetBgColorAndOpacity");
static_assert(offsetof(MaskWidget_SetBgColorAndOpacity, InColorAndOpacity) == 0x000000, "Member 'MaskWidget_SetBgColorAndOpacity::InColorAndOpacity' has a wrong offset!");

// Function X6Game.MaskWidget.SetBgImage
// 0x0010 (0x0010 - 0x0000)
struct MaskWidget_SetBgImage final
{
public:
	class UTexture2D*                             Tex;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaskWidget_SetBgImage) == 0x000008, "Wrong alignment on MaskWidget_SetBgImage");
static_assert(sizeof(MaskWidget_SetBgImage) == 0x000010, "Wrong size on MaskWidget_SetBgImage");
static_assert(offsetof(MaskWidget_SetBgImage, Tex) == 0x000000, "Member 'MaskWidget_SetBgImage::Tex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetBgImage, bMatchSize) == 0x000008, "Member 'MaskWidget_SetBgImage::bMatchSize' has a wrong offset!");

// Function X6Game.MaskWidget.SetBgOpacity
// 0x0004 (0x0004 - 0x0000)
struct MaskWidget_SetBgOpacity final
{
public:
	float                                         InOpacity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetBgOpacity) == 0x000004, "Wrong alignment on MaskWidget_SetBgOpacity");
static_assert(sizeof(MaskWidget_SetBgOpacity) == 0x000004, "Wrong size on MaskWidget_SetBgOpacity");
static_assert(offsetof(MaskWidget_SetBgOpacity, InOpacity) == 0x000000, "Member 'MaskWidget_SetBgOpacity::InOpacity' has a wrong offset!");

// Function X6Game.MaskWidget.SetBrushTintColor
// 0x0014 (0x0014 - 0x0000)
struct MaskWidget_SetBrushTintColor final
{
public:
	struct FSlateColor                            TintColor;                                         // 0x0000(0x0014)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetBrushTintColor) == 0x000004, "Wrong alignment on MaskWidget_SetBrushTintColor");
static_assert(sizeof(MaskWidget_SetBrushTintColor) == 0x000014, "Wrong size on MaskWidget_SetBrushTintColor");
static_assert(offsetof(MaskWidget_SetBrushTintColor, TintColor) == 0x000000, "Member 'MaskWidget_SetBrushTintColor::TintColor' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskImage
// 0x0010 (0x0010 - 0x0000)
struct MaskWidget_SetMaskImage final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Tex;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskImage) == 0x000008, "Wrong alignment on MaskWidget_SetMaskImage");
static_assert(sizeof(MaskWidget_SetMaskImage) == 0x000010, "Wrong size on MaskWidget_SetMaskImage");
static_assert(offsetof(MaskWidget_SetMaskImage, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskImage::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskImage, Tex) == 0x000008, "Member 'MaskWidget_SetMaskImage::Tex' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskPos
// 0x0018 (0x0018 - 0x0000)
struct MaskWidget_SetMaskPos final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Pos;                                               // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskPos) == 0x000008, "Wrong alignment on MaskWidget_SetMaskPos");
static_assert(sizeof(MaskWidget_SetMaskPos) == 0x000018, "Wrong size on MaskWidget_SetMaskPos");
static_assert(offsetof(MaskWidget_SetMaskPos, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskPos::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPos, Pos) == 0x000008, "Member 'MaskWidget_SetMaskPos::Pos' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskPosSize
// 0x0030 (0x0030 - 0x0000)
struct MaskWidget_SetMaskPosSize final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               PosSize;                                           // 0x0010(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskPosSize) == 0x000010, "Wrong alignment on MaskWidget_SetMaskPosSize");
static_assert(sizeof(MaskWidget_SetMaskPosSize) == 0x000030, "Wrong size on MaskWidget_SetMaskPosSize");
static_assert(offsetof(MaskWidget_SetMaskPosSize, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskPosSize::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosSize, PosSize) == 0x000010, "Member 'MaskWidget_SetMaskPosSize::PosSize' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskPosSizeXYZW
// 0x0014 (0x0014 - 0x0000)
struct MaskWidget_SetMaskPosSizeXYZW final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x000C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskPosSizeXYZW) == 0x000004, "Wrong alignment on MaskWidget_SetMaskPosSizeXYZW");
static_assert(sizeof(MaskWidget_SetMaskPosSizeXYZW) == 0x000014, "Wrong size on MaskWidget_SetMaskPosSizeXYZW");
static_assert(offsetof(MaskWidget_SetMaskPosSizeXYZW, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskPosSizeXYZW::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosSizeXYZW, X) == 0x000004, "Member 'MaskWidget_SetMaskPosSizeXYZW::X' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosSizeXYZW, Y) == 0x000008, "Member 'MaskWidget_SetMaskPosSizeXYZW::Y' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosSizeXYZW, Z) == 0x00000C, "Member 'MaskWidget_SetMaskPosSizeXYZW::Z' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosSizeXYZW, W) == 0x000010, "Member 'MaskWidget_SetMaskPosSizeXYZW::W' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskPosXY
// 0x000C (0x000C - 0x0000)
struct MaskWidget_SetMaskPosXY final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskPosXY) == 0x000004, "Wrong alignment on MaskWidget_SetMaskPosXY");
static_assert(sizeof(MaskWidget_SetMaskPosXY) == 0x00000C, "Wrong size on MaskWidget_SetMaskPosXY");
static_assert(offsetof(MaskWidget_SetMaskPosXY, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskPosXY::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosXY, X) == 0x000004, "Member 'MaskWidget_SetMaskPosXY::X' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskPosXY, Y) == 0x000008, "Member 'MaskWidget_SetMaskPosXY::Y' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskSize
// 0x0018 (0x0018 - 0x0000)
struct MaskWidget_SetMaskSize final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskSize) == 0x000008, "Wrong alignment on MaskWidget_SetMaskSize");
static_assert(sizeof(MaskWidget_SetMaskSize) == 0x000018, "Wrong size on MaskWidget_SetMaskSize");
static_assert(offsetof(MaskWidget_SetMaskSize, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskSize::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskSize, Size) == 0x000008, "Member 'MaskWidget_SetMaskSize::Size' has a wrong offset!");

// Function X6Game.MaskWidget.SetMaskSizeXY
// 0x000C (0x000C - 0x0000)
struct MaskWidget_SetMaskSizeXY final
{
public:
	int32                                         ClipIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaskWidget_SetMaskSizeXY) == 0x000004, "Wrong alignment on MaskWidget_SetMaskSizeXY");
static_assert(sizeof(MaskWidget_SetMaskSizeXY) == 0x00000C, "Wrong size on MaskWidget_SetMaskSizeXY");
static_assert(offsetof(MaskWidget_SetMaskSizeXY, ClipIndex) == 0x000000, "Member 'MaskWidget_SetMaskSizeXY::ClipIndex' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskSizeXY, X) == 0x000004, "Member 'MaskWidget_SetMaskSizeXY::X' has a wrong offset!");
static_assert(offsetof(MaskWidget_SetMaskSizeXY, Y) == 0x000008, "Member 'MaskWidget_SetMaskSizeXY::Y' has a wrong offset!");

// Function X6Game.NikkiClothAnimInstance.UpdateSitRigCurveValue
// 0x0004 (0x0004 - 0x0000)
struct NikkiClothAnimInstance_UpdateSitRigCurveValue final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NikkiClothAnimInstance_UpdateSitRigCurveValue) == 0x000004, "Wrong alignment on NikkiClothAnimInstance_UpdateSitRigCurveValue");
static_assert(sizeof(NikkiClothAnimInstance_UpdateSitRigCurveValue) == 0x000004, "Wrong size on NikkiClothAnimInstance_UpdateSitRigCurveValue");
static_assert(offsetof(NikkiClothAnimInstance_UpdateSitRigCurveValue, DeltaSeconds) == 0x000000, "Member 'NikkiClothAnimInstance_UpdateSitRigCurveValue::DeltaSeconds' has a wrong offset!");

// Function X6Game.NikkiJumpLocomotionAnimInstance.SetJumpMainState
// 0x0001 (0x0001 - 0x0000)
struct NikkiJumpLocomotionAnimInstance_SetJumpMainState final
{
public:
	ENikkiJumpState                               InJumpState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NikkiJumpLocomotionAnimInstance_SetJumpMainState) == 0x000001, "Wrong alignment on NikkiJumpLocomotionAnimInstance_SetJumpMainState");
static_assert(sizeof(NikkiJumpLocomotionAnimInstance_SetJumpMainState) == 0x000001, "Wrong size on NikkiJumpLocomotionAnimInstance_SetJumpMainState");
static_assert(offsetof(NikkiJumpLocomotionAnimInstance_SetJumpMainState, InJumpState) == 0x000000, "Member 'NikkiJumpLocomotionAnimInstance_SetJumpMainState::InJumpState' has a wrong offset!");

// Function X6Game.NikkiJumpLocomotionAnimInstance.SetJumpState_Fall
// 0x0001 (0x0001 - 0x0000)
struct NikkiJumpLocomotionAnimInstance_SetJumpState_Fall final
{
public:
	ENikkiJumpState_Fall                          InFall;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NikkiJumpLocomotionAnimInstance_SetJumpState_Fall) == 0x000001, "Wrong alignment on NikkiJumpLocomotionAnimInstance_SetJumpState_Fall");
static_assert(sizeof(NikkiJumpLocomotionAnimInstance_SetJumpState_Fall) == 0x000001, "Wrong size on NikkiJumpLocomotionAnimInstance_SetJumpState_Fall");
static_assert(offsetof(NikkiJumpLocomotionAnimInstance_SetJumpState_Fall, InFall) == 0x000000, "Member 'NikkiJumpLocomotionAnimInstance_SetJumpState_Fall::InFall' has a wrong offset!");

// Function X6Game.NikkiJumpLocomotionAnimInstance.SetJumpState_TakeOff
// 0x0001 (0x0001 - 0x0000)
struct NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff final
{
public:
	ENikkiJumpState_TakeOff                       InTakeOff;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff) == 0x000001, "Wrong alignment on NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff");
static_assert(sizeof(NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff) == 0x000001, "Wrong size on NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff");
static_assert(offsetof(NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff, InTakeOff) == 0x000000, "Member 'NikkiJumpLocomotionAnimInstance_SetJumpState_TakeOff::InTakeOff' has a wrong offset!");

// Function X6Game.NikkiMovementComponent.K2_CrouchWithEvent
// 0x0001 (0x0001 - 0x0000)
struct NikkiMovementComponent_K2_CrouchWithEvent final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NikkiMovementComponent_K2_CrouchWithEvent) == 0x000001, "Wrong alignment on NikkiMovementComponent_K2_CrouchWithEvent");
static_assert(sizeof(NikkiMovementComponent_K2_CrouchWithEvent) == 0x000001, "Wrong size on NikkiMovementComponent_K2_CrouchWithEvent");
static_assert(offsetof(NikkiMovementComponent_K2_CrouchWithEvent, bClientSimulation) == 0x000000, "Member 'NikkiMovementComponent_K2_CrouchWithEvent::bClientSimulation' has a wrong offset!");

// Function X6Game.NikkiMovementComponent.K2_IsValidLandingSpot
// 0x0118 (0x0118 - 0x0000)
struct NikkiMovementComponent_K2_IsValidLandingSpot final
{
public:
	struct FVector                                CapsuleLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0018(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0110(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NikkiMovementComponent_K2_IsValidLandingSpot) == 0x000008, "Wrong alignment on NikkiMovementComponent_K2_IsValidLandingSpot");
static_assert(sizeof(NikkiMovementComponent_K2_IsValidLandingSpot) == 0x000118, "Wrong size on NikkiMovementComponent_K2_IsValidLandingSpot");
static_assert(offsetof(NikkiMovementComponent_K2_IsValidLandingSpot, CapsuleLocation) == 0x000000, "Member 'NikkiMovementComponent_K2_IsValidLandingSpot::CapsuleLocation' has a wrong offset!");
static_assert(offsetof(NikkiMovementComponent_K2_IsValidLandingSpot, Hit) == 0x000018, "Member 'NikkiMovementComponent_K2_IsValidLandingSpot::Hit' has a wrong offset!");
static_assert(offsetof(NikkiMovementComponent_K2_IsValidLandingSpot, ReturnValue) == 0x000110, "Member 'NikkiMovementComponent_K2_IsValidLandingSpot::ReturnValue' has a wrong offset!");

// Function X6Game.NikkiMovementComponent.K2_StepUp
// 0x0130 (0x0130 - 0x0000)
struct NikkiMovementComponent_K2_StepUp final
{
public:
	struct FVector                                GravDir;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0128(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NikkiMovementComponent_K2_StepUp) == 0x000008, "Wrong alignment on NikkiMovementComponent_K2_StepUp");
static_assert(sizeof(NikkiMovementComponent_K2_StepUp) == 0x000130, "Wrong size on NikkiMovementComponent_K2_StepUp");
static_assert(offsetof(NikkiMovementComponent_K2_StepUp, GravDir) == 0x000000, "Member 'NikkiMovementComponent_K2_StepUp::GravDir' has a wrong offset!");
static_assert(offsetof(NikkiMovementComponent_K2_StepUp, Delta) == 0x000018, "Member 'NikkiMovementComponent_K2_StepUp::Delta' has a wrong offset!");
static_assert(offsetof(NikkiMovementComponent_K2_StepUp, Hit) == 0x000030, "Member 'NikkiMovementComponent_K2_StepUp::Hit' has a wrong offset!");
static_assert(offsetof(NikkiMovementComponent_K2_StepUp, ReturnValue) == 0x000128, "Member 'NikkiMovementComponent_K2_StepUp::ReturnValue' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnAutomaticRuleStateUpdate
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate");
static_assert(sizeof(NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate");
static_assert(offsetof(NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnAutomaticRuleStateUpdate::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnMirrorIdleTransitionSequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnMirrorIdleTransitionSequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnOutputPoseBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnOutputPoseBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnOutputPoseInitialUpdate
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate");
static_assert(sizeof(NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate");
static_assert(offsetof(NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnOutputPoseInitialUpdate::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStarFSequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStarFSequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStarL180SequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStarL180SequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStarL90SequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStarL90SequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStartStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStartStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStartStateBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStartStateBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStartStateBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStartStateBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStartStateBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStartStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStartStateBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStartStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStopL0SequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStopL0SequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStopL180SequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStopL180SequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStopL90SequencePlayerBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStopL90SequencePlayerBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStopSequencePlayerUpdate
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStopSequencePlayerUpdate::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStopStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStopStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStopStateBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStopStateBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStopStateBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStopStateBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopStateBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStopStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopStateBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStopStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnStopStateUpdate
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnStopStateUpdate final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnStopStateUpdate) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnStopStateUpdate");
static_assert(sizeof(NPCLocomotionTemplateBase_OnStopStateUpdate) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnStopStateUpdate");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopStateUpdate, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnStopStateUpdate::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnStopStateUpdate, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnStopStateUpdate::Node' has a wrong offset!");

// Function X6Game.NPCLocomotionTemplateBase.OnTurnInPlaceStateBecomeRelevant
// 0x0020 (0x0020 - 0x0000)
struct NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant) == 0x000008, "Wrong alignment on NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant");
static_assert(sizeof(NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant) == 0x000020, "Wrong size on NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant");
static_assert(offsetof(NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant, Context) == 0x000000, "Member 'NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant::Context' has a wrong offset!");
static_assert(offsetof(NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant, Node) == 0x000010, "Member 'NPCLocomotionTemplateBase_OnTurnInPlaceStateBecomeRelevant::Node' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.CanDoMantleInFalling
// 0x0050 (0x0050 - 0x0000)
struct PlayerJumpPromptLineProcessor_CanDoMantleInFalling final
{
public:
	struct FVector                                CapsuleBaseLocation;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentPlayerInputVector;                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurActorLocation;                                  // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerJumpPromptLineProcessor_CanDoMantleInFalling) == 0x000008, "Wrong alignment on PlayerJumpPromptLineProcessor_CanDoMantleInFalling");
static_assert(sizeof(PlayerJumpPromptLineProcessor_CanDoMantleInFalling) == 0x000050, "Wrong size on PlayerJumpPromptLineProcessor_CanDoMantleInFalling");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDoMantleInFalling, CapsuleBaseLocation) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_CanDoMantleInFalling::CapsuleBaseLocation' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDoMantleInFalling, CurrentPlayerInputVector) == 0x000018, "Member 'PlayerJumpPromptLineProcessor_CanDoMantleInFalling::CurrentPlayerInputVector' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDoMantleInFalling, CurActorLocation) == 0x000030, "Member 'PlayerJumpPromptLineProcessor_CanDoMantleInFalling::CurActorLocation' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDoMantleInFalling, ReturnValue) == 0x000048, "Member 'PlayerJumpPromptLineProcessor_CanDoMantleInFalling::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.CanDrawPredictJumpCurve
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve");
static_assert(sizeof(PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve, ReturnValue) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_CanDrawPredictJumpCurve::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.CanDrawRealTimeJumpCurve
// 0x0008 (0x0008 - 0x0000)
struct PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve final
{
public:
	float                                         CurrentSpeedXY;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve) == 0x000004, "Wrong alignment on PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve");
static_assert(sizeof(PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve) == 0x000008, "Wrong size on PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve, CurrentSpeedXY) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve::CurrentSpeedXY' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve, ReturnValue) == 0x000004, "Member 'PlayerJumpPromptLineProcessor_CanDrawRealTimeJumpCurve::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.DebugDrawPredicJumpCurveLineInWorldSpace
// 0x0040 (0x0040 - 0x0000)
struct PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace final
{
public:
	struct FVector                                WorldStartLocation;                                // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        CurveTrack;                                        // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace) == 0x000008, "Wrong alignment on PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace");
static_assert(sizeof(PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace) == 0x000040, "Wrong size on PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace");
static_assert(offsetof(PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace, WorldStartLocation) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace::WorldStartLocation' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace, CurveTrack) == 0x000018, "Member 'PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace::CurveTrack' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace, LineColor) == 0x000028, "Member 'PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace::LineColor' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace, Duration) == 0x000038, "Member 'PlayerJumpPromptLineProcessor_DebugDrawPredicJumpCurveLineInWorldSpace::Duration' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.DrawPredictJumpCurve
// 0x0008 (0x0008 - 0x0000)
struct PlayerJumpPromptLineProcessor_DrawPredictJumpCurve final
{
public:
	float                                         CosntGravityZ;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_DrawPredictJumpCurve) == 0x000004, "Wrong alignment on PlayerJumpPromptLineProcessor_DrawPredictJumpCurve");
static_assert(sizeof(PlayerJumpPromptLineProcessor_DrawPredictJumpCurve) == 0x000008, "Wrong size on PlayerJumpPromptLineProcessor_DrawPredictJumpCurve");
static_assert(offsetof(PlayerJumpPromptLineProcessor_DrawPredictJumpCurve, CosntGravityZ) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_DrawPredictJumpCurve::CosntGravityZ' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_DrawPredictJumpCurve, DeltaTime) == 0x000004, "Member 'PlayerJumpPromptLineProcessor_DrawPredictJumpCurve::DeltaTime' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.EnableJumpPromptLineFeature
// 0x000C (0x000C - 0x0000)
struct PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature) == 0x000004, "Wrong alignment on PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature");
static_assert(sizeof(PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature) == 0x00000C, "Wrong size on PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature");
static_assert(offsetof(PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature, bEnable) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature::bEnable' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature, Tag) == 0x000004, "Member 'PlayerJumpPromptLineProcessor_EnableJumpPromptLineFeature::Tag' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.HasPlayerStateToHideJumpCurve
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve");
static_assert(sizeof(PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve");
static_assert(offsetof(PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve, ReturnValue) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_HasPlayerStateToHideJumpCurve::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.IsEnableJumpPromptLineFeature
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature");
static_assert(sizeof(PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature");
static_assert(offsetof(PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature, ReturnValue) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_IsEnableJumpPromptLineFeature::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.IsFXAssetLoaded
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_IsFXAssetLoaded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_IsFXAssetLoaded) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_IsFXAssetLoaded");
static_assert(sizeof(PlayerJumpPromptLineProcessor_IsFXAssetLoaded) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_IsFXAssetLoaded");
static_assert(offsetof(PlayerJumpPromptLineProcessor_IsFXAssetLoaded, ReturnValue) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_IsFXAssetLoaded::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.IsFXAssetPathNotNull
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull");
static_assert(sizeof(PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull");
static_assert(offsetof(PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull, ReturnValue) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_IsFXAssetPathNotNull::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.IsJumpCurveCanShow
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_IsJumpCurveCanShow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_IsJumpCurveCanShow) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_IsJumpCurveCanShow");
static_assert(sizeof(PlayerJumpPromptLineProcessor_IsJumpCurveCanShow) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_IsJumpCurveCanShow");
static_assert(offsetof(PlayerJumpPromptLineProcessor_IsJumpCurveCanShow, ReturnValue) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_IsJumpCurveCanShow::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.OnInitialize
// 0x0018 (0x0018 - 0x0000)
struct PlayerJumpPromptLineProcessor_OnInitialize final
{
public:
	class ACharacter*                             Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6RMWalkingComponent*                  X6RMWalkingComponent;                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6RMInAirComponent*                    X6RMInAirComponent;                                // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_OnInitialize) == 0x000008, "Wrong alignment on PlayerJumpPromptLineProcessor_OnInitialize");
static_assert(sizeof(PlayerJumpPromptLineProcessor_OnInitialize) == 0x000018, "Wrong size on PlayerJumpPromptLineProcessor_OnInitialize");
static_assert(offsetof(PlayerJumpPromptLineProcessor_OnInitialize, Owner) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_OnInitialize::Owner' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_OnInitialize, X6RMWalkingComponent) == 0x000008, "Member 'PlayerJumpPromptLineProcessor_OnInitialize::X6RMWalkingComponent' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_OnInitialize, X6RMInAirComponent) == 0x000010, "Member 'PlayerJumpPromptLineProcessor_OnInitialize::X6RMInAirComponent' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.SetEnableJumpPromptLineFeature
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature");
static_assert(sizeof(PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature");
static_assert(offsetof(PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature, bEnable) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_SetEnableJumpPromptLineFeature::bEnable' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.SetHasPlayerStateToHideJumpCurve
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve");
static_assert(sizeof(PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve");
static_assert(offsetof(PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve, bEnable) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_SetHasPlayerStateToHideJumpCurve::bEnable' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.SetJumpCurveCanShow
// 0x0001 (0x0001 - 0x0000)
struct PlayerJumpPromptLineProcessor_SetJumpCurveCanShow final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerJumpPromptLineProcessor_SetJumpCurveCanShow) == 0x000001, "Wrong alignment on PlayerJumpPromptLineProcessor_SetJumpCurveCanShow");
static_assert(sizeof(PlayerJumpPromptLineProcessor_SetJumpCurveCanShow) == 0x000001, "Wrong size on PlayerJumpPromptLineProcessor_SetJumpCurveCanShow");
static_assert(offsetof(PlayerJumpPromptLineProcessor_SetJumpCurveCanShow, bEnable) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_SetJumpCurveCanShow::bEnable' has a wrong offset!");

// Function X6Game.PlayerJumpPromptLineProcessor.TryPointToPointJumping
// 0x0058 (0x0058 - 0x0000)
struct PlayerJumpPromptLineProcessor_TryPointToPointJumping final
{
public:
	struct FVector                                SourcePoint;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPoint;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutVelocity;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteppingSimulationTime;                            // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosntGravityZ;                                     // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTime;                                 // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDebugDraw;                                   // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0055(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerJumpPromptLineProcessor_TryPointToPointJumping) == 0x000008, "Wrong alignment on PlayerJumpPromptLineProcessor_TryPointToPointJumping");
static_assert(sizeof(PlayerJumpPromptLineProcessor_TryPointToPointJumping) == 0x000058, "Wrong size on PlayerJumpPromptLineProcessor_TryPointToPointJumping");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, SourcePoint) == 0x000000, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::SourcePoint' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, TargetPoint) == 0x000018, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::TargetPoint' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, OutVelocity) == 0x000030, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::OutVelocity' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, SteppingSimulationTime) == 0x000048, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::SteppingSimulationTime' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, CosntGravityZ) == 0x00004C, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::CosntGravityZ' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, MaxSimulationTime) == 0x000050, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::MaxSimulationTime' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, EnableDebugDraw) == 0x000054, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::EnableDebugDraw' has a wrong offset!");
static_assert(offsetof(PlayerJumpPromptLineProcessor_TryPointToPointJumping, ReturnValue) == 0x000055, "Member 'PlayerJumpPromptLineProcessor_TryPointToPointJumping::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.CaculateCurRotationActorInterpSpeed
// 0x0058 (0x0058 - 0x0000)
struct PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed final
{
public:
	struct FRotator                               CurrentCameraRotation;                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreCameraRotation;                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraRYawClampUpperLimit;                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveSampleValue;                                  // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotateCurve;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RAngleToRYawSpeedRateMappingCurve;                 // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTurnAroundAngle;                            // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0054(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed");
static_assert(sizeof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed) == 0x000058, "Wrong size on PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, CurrentCameraRotation) == 0x000000, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, PreCameraRotation) == 0x000018, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::PreCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, CameraRYawClampUpperLimit) == 0x000030, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::CameraRYawClampUpperLimit' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, CurveSampleValue) == 0x000034, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::CurveSampleValue' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, DeltaSeconds) == 0x000038, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, RotateCurve) == 0x000040, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::RotateCurve' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, RAngleToRYawSpeedRateMappingCurve) == 0x000048, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::RAngleToRYawSpeedRateMappingCurve' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, CurrentTurnAroundAngle) == 0x000050, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::CurrentTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed, ReturnValue) == 0x000054, "Member 'PlayerLocomotionLogicProxy_CaculateCurRotationActorInterpSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.GatherCurrentCameraInformation
// 0x0010 (0x0010 - 0x0000)
struct PlayerLocomotionLogicProxy_GatherCurrentCameraInformation final
{
public:
	class AActor*                                 PlayerCameraManager;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputValid;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerLocomotionLogicProxy_GatherCurrentCameraInformation) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_GatherCurrentCameraInformation");
static_assert(sizeof(PlayerLocomotionLogicProxy_GatherCurrentCameraInformation) == 0x000010, "Wrong size on PlayerLocomotionLogicProxy_GatherCurrentCameraInformation");
static_assert(offsetof(PlayerLocomotionLogicProxy_GatherCurrentCameraInformation, PlayerCameraManager) == 0x000000, "Member 'PlayerLocomotionLogicProxy_GatherCurrentCameraInformation::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GatherCurrentCameraInformation, bInputValid) == 0x000008, "Member 'PlayerLocomotionLogicProxy_GatherCurrentCameraInformation::bInputValid' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.GetCurFrameInputContext
// 0x0018 (0x0018 - 0x0000)
struct PlayerLocomotionLogicProxy_GetCurFrameInputContext final
{
public:
	struct FFrameInputContext                     ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_GetCurFrameInputContext) == 0x000004, "Wrong alignment on PlayerLocomotionLogicProxy_GetCurFrameInputContext");
static_assert(sizeof(PlayerLocomotionLogicProxy_GetCurFrameInputContext) == 0x000018, "Wrong size on PlayerLocomotionLogicProxy_GetCurFrameInputContext");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetCurFrameInputContext, ReturnValue) == 0x000000, "Member 'PlayerLocomotionLogicProxy_GetCurFrameInputContext::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.GetMappedSpeed
// 0x0018 (0x0018 - 0x0000)
struct PlayerLocomotionLogicProxy_GetMappedSpeed final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerSpeedVal;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddleSpeedVal;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighSpeedVal;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_GetMappedSpeed) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_GetMappedSpeed");
static_assert(sizeof(PlayerLocomotionLogicProxy_GetMappedSpeed) == 0x000018, "Wrong size on PlayerLocomotionLogicProxy_GetMappedSpeed");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetMappedSpeed, CharacterMovementComponent) == 0x000000, "Member 'PlayerLocomotionLogicProxy_GetMappedSpeed::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetMappedSpeed, LowerSpeedVal) == 0x000008, "Member 'PlayerLocomotionLogicProxy_GetMappedSpeed::LowerSpeedVal' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetMappedSpeed, MiddleSpeedVal) == 0x00000C, "Member 'PlayerLocomotionLogicProxy_GetMappedSpeed::MiddleSpeedVal' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetMappedSpeed, HighSpeedVal) == 0x000010, "Member 'PlayerLocomotionLogicProxy_GetMappedSpeed::HighSpeedVal' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetMappedSpeed, ReturnValue) == 0x000014, "Member 'PlayerLocomotionLogicProxy_GetMappedSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.GetTurnAroundAngle
// 0x0038 (0x0038 - 0x0000)
struct PlayerLocomotionLogicProxy_GetTurnAroundAngle final
{
public:
	struct FVector                                InputMovingDirection;                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentForwardVector;                              // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerLocomotionLogicProxy_GetTurnAroundAngle) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_GetTurnAroundAngle");
static_assert(sizeof(PlayerLocomotionLogicProxy_GetTurnAroundAngle) == 0x000038, "Wrong size on PlayerLocomotionLogicProxy_GetTurnAroundAngle");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetTurnAroundAngle, InputMovingDirection) == 0x000000, "Member 'PlayerLocomotionLogicProxy_GetTurnAroundAngle::InputMovingDirection' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetTurnAroundAngle, CurrentForwardVector) == 0x000018, "Member 'PlayerLocomotionLogicProxy_GetTurnAroundAngle::CurrentForwardVector' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_GetTurnAroundAngle, ReturnValue) == 0x000030, "Member 'PlayerLocomotionLogicProxy_GetTurnAroundAngle::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.InitCameraContext
// 0x0038 (0x0038 - 0x0000)
struct PlayerLocomotionLogicProxy_InitCameraContext final
{
public:
	struct FRotator                               CurrentCameraRotation;                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreCameraRotation;                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCameraStateChanged;                               // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnNewTargetCameraBlendEnd;                        // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerLocomotionLogicProxy_InitCameraContext) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_InitCameraContext");
static_assert(sizeof(PlayerLocomotionLogicProxy_InitCameraContext) == 0x000038, "Wrong size on PlayerLocomotionLogicProxy_InitCameraContext");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitCameraContext, CurrentCameraRotation) == 0x000000, "Member 'PlayerLocomotionLogicProxy_InitCameraContext::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitCameraContext, PreCameraRotation) == 0x000018, "Member 'PlayerLocomotionLogicProxy_InitCameraContext::PreCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitCameraContext, bCameraStateChanged) == 0x000030, "Member 'PlayerLocomotionLogicProxy_InitCameraContext::bCameraStateChanged' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitCameraContext, bOnNewTargetCameraBlendEnd) == 0x000031, "Member 'PlayerLocomotionLogicProxy_InitCameraContext::bOnNewTargetCameraBlendEnd' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.InitInputConfigData
// 0x0028 (0x0028 - 0x0000)
struct PlayerLocomotionLogicProxy_InitInputConfigData final
{
public:
	float                                         LogicalFramesPerSecond;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreStartFrames;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStartMovingInputCache;                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMovingInputCacheFrames;                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMutationCache;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MutationInputCacheFrames;                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInvalidInput;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvalidInputFrames;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MutationInputSizeThreshold;                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MutationInputDirectionThreshold;                   // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_InitInputConfigData) == 0x000004, "Wrong alignment on PlayerLocomotionLogicProxy_InitInputConfigData");
static_assert(sizeof(PlayerLocomotionLogicProxy_InitInputConfigData) == 0x000028, "Wrong size on PlayerLocomotionLogicProxy_InitInputConfigData");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, LogicalFramesPerSecond) == 0x000000, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::LogicalFramesPerSecond' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, PreStartFrames) == 0x000004, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::PreStartFrames' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, bEnableStartMovingInputCache) == 0x000008, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::bEnableStartMovingInputCache' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, StartMovingInputCacheFrames) == 0x00000C, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::StartMovingInputCacheFrames' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, bEnableMutationCache) == 0x000010, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::bEnableMutationCache' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, MutationInputCacheFrames) == 0x000014, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::MutationInputCacheFrames' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, bEnableInvalidInput) == 0x000018, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::bEnableInvalidInput' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, InvalidInputFrames) == 0x00001C, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::InvalidInputFrames' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, MutationInputSizeThreshold) == 0x000020, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::MutationInputSizeThreshold' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_InitInputConfigData, MutationInputDirectionThreshold) == 0x000024, "Member 'PlayerLocomotionLogicProxy_InitInputConfigData::MutationInputDirectionThreshold' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.IsEnableMutationCache
// 0x0001 (0x0001 - 0x0000)
struct PlayerLocomotionLogicProxy_IsEnableMutationCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_IsEnableMutationCache) == 0x000001, "Wrong alignment on PlayerLocomotionLogicProxy_IsEnableMutationCache");
static_assert(sizeof(PlayerLocomotionLogicProxy_IsEnableMutationCache) == 0x000001, "Wrong size on PlayerLocomotionLogicProxy_IsEnableMutationCache");
static_assert(offsetof(PlayerLocomotionLogicProxy_IsEnableMutationCache, ReturnValue) == 0x000000, "Member 'PlayerLocomotionLogicProxy_IsEnableMutationCache::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.IsNeedStartMovingCache
// 0x0001 (0x0001 - 0x0000)
struct PlayerLocomotionLogicProxy_IsNeedStartMovingCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_IsNeedStartMovingCache) == 0x000001, "Wrong alignment on PlayerLocomotionLogicProxy_IsNeedStartMovingCache");
static_assert(sizeof(PlayerLocomotionLogicProxy_IsNeedStartMovingCache) == 0x000001, "Wrong size on PlayerLocomotionLogicProxy_IsNeedStartMovingCache");
static_assert(offsetof(PlayerLocomotionLogicProxy_IsNeedStartMovingCache, ReturnValue) == 0x000000, "Member 'PlayerLocomotionLogicProxy_IsNeedStartMovingCache::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.ProcessBasicOnGroundTurnAroundMovementLogic
// 0x0048 (0x0048 - 0x0000)
struct PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentTargetRotation;                             // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InputMovingDirection;                              // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationActorInterpSpeed;                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic");
static_assert(sizeof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic) == 0x000048, "Wrong size on PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, CharacterMovementComponent) == 0x000000, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, CurrentTargetRotation) == 0x000008, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::CurrentTargetRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, InputMovingDirection) == 0x000020, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::InputMovingDirection' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, RotationTargetInterpSpeed) == 0x000038, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, RotationActorInterpSpeed) == 0x00003C, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::RotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, DeltaSeconds) == 0x000040, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic, ReturnValue) == 0x000044, "Member 'PlayerLocomotionLogicProxy_ProcessBasicOnGroundTurnAroundMovementLogic::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.ProcessInputValueCacheLogic
// 0x0008 (0x0008 - 0x0000)
struct PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic) == 0x000004, "Wrong alignment on PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic");
static_assert(sizeof(PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic) == 0x000008, "Wrong size on PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic, DeltaSeconds) == 0x000000, "Member 'PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic, bIsMoving) == 0x000004, "Member 'PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic::bIsMoving' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic, ReturnValue) == 0x000005, "Member 'PlayerLocomotionLogicProxy_ProcessInputValueCacheLogic::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.RecordCurInputInformation
// 0x0010 (0x0010 - 0x0000)
struct PlayerLocomotionLogicProxy_RecordCurInputInformation final
{
public:
	float                                         CurrentInputValForMoveForward;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentInputValForMoveRight;                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreInputValForMoveForward;                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreInputValForMoveRight;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_RecordCurInputInformation) == 0x000004, "Wrong alignment on PlayerLocomotionLogicProxy_RecordCurInputInformation");
static_assert(sizeof(PlayerLocomotionLogicProxy_RecordCurInputInformation) == 0x000010, "Wrong size on PlayerLocomotionLogicProxy_RecordCurInputInformation");
static_assert(offsetof(PlayerLocomotionLogicProxy_RecordCurInputInformation, CurrentInputValForMoveForward) == 0x000000, "Member 'PlayerLocomotionLogicProxy_RecordCurInputInformation::CurrentInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_RecordCurInputInformation, CurrentInputValForMoveRight) == 0x000004, "Member 'PlayerLocomotionLogicProxy_RecordCurInputInformation::CurrentInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_RecordCurInputInformation, PreInputValForMoveForward) == 0x000008, "Member 'PlayerLocomotionLogicProxy_RecordCurInputInformation::PreInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_RecordCurInputInformation, PreInputValForMoveRight) == 0x00000C, "Member 'PlayerLocomotionLogicProxy_RecordCurInputInformation::PreInputValForMoveRight' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.ReplayCameraContext
// 0x0038 (0x0038 - 0x0000)
struct PlayerLocomotionLogicProxy_ReplayCameraContext final
{
public:
	struct FRotator                               CurrentCameraRotation;                             // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreCameraRotation;                                 // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCameraStateChanged;                               // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnNewTargetCameraBlendEnd;                        // 0x0031(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerLocomotionLogicProxy_ReplayCameraContext) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_ReplayCameraContext");
static_assert(sizeof(PlayerLocomotionLogicProxy_ReplayCameraContext) == 0x000038, "Wrong size on PlayerLocomotionLogicProxy_ReplayCameraContext");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCameraContext, CurrentCameraRotation) == 0x000000, "Member 'PlayerLocomotionLogicProxy_ReplayCameraContext::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCameraContext, PreCameraRotation) == 0x000018, "Member 'PlayerLocomotionLogicProxy_ReplayCameraContext::PreCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCameraContext, bCameraStateChanged) == 0x000030, "Member 'PlayerLocomotionLogicProxy_ReplayCameraContext::bCameraStateChanged' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCameraContext, bOnNewTargetCameraBlendEnd) == 0x000031, "Member 'PlayerLocomotionLogicProxy_ReplayCameraContext::bOnNewTargetCameraBlendEnd' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.ReplayCurInputInformation
// 0x0010 (0x0010 - 0x0000)
struct PlayerLocomotionLogicProxy_ReplayCurInputInformation final
{
public:
	float                                         PolishInputValForMoveForward;                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishInputValForMoveRight;                        // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreInputValForMoveForward;                   // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreInputValForMoveRight;                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_ReplayCurInputInformation) == 0x000004, "Wrong alignment on PlayerLocomotionLogicProxy_ReplayCurInputInformation");
static_assert(sizeof(PlayerLocomotionLogicProxy_ReplayCurInputInformation) == 0x000010, "Wrong size on PlayerLocomotionLogicProxy_ReplayCurInputInformation");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCurInputInformation, PolishInputValForMoveForward) == 0x000000, "Member 'PlayerLocomotionLogicProxy_ReplayCurInputInformation::PolishInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCurInputInformation, PolishInputValForMoveRight) == 0x000004, "Member 'PlayerLocomotionLogicProxy_ReplayCurInputInformation::PolishInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCurInputInformation, PolishPreInputValForMoveForward) == 0x000008, "Member 'PlayerLocomotionLogicProxy_ReplayCurInputInformation::PolishPreInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_ReplayCurInputInformation, PolishPreInputValForMoveRight) == 0x00000C, "Member 'PlayerLocomotionLogicProxy_ReplayCurInputInformation::PolishPreInputValForMoveRight' has a wrong offset!");

// Function X6Game.PlayerLocomotionLogicProxy.SmoothPlayerRotation
// 0x0070 (0x0070 - 0x0000)
struct PlayerLocomotionLogicProxy_SmoothPlayerRotation final
{
public:
	struct FRotator                               CurrentTargetRotation;                             // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               NewTargetRotation;                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CurActorRotation;                                  // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationActorInterpSpeed;                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerLocomotionLogicProxy_SmoothPlayerRotation) == 0x000008, "Wrong alignment on PlayerLocomotionLogicProxy_SmoothPlayerRotation");
static_assert(sizeof(PlayerLocomotionLogicProxy_SmoothPlayerRotation) == 0x000070, "Wrong size on PlayerLocomotionLogicProxy_SmoothPlayerRotation");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, CurrentTargetRotation) == 0x000000, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::CurrentTargetRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, NewTargetRotation) == 0x000018, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::NewTargetRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, CurActorRotation) == 0x000030, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::CurActorRotation' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, RotationTargetInterpSpeed) == 0x000048, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, RotationActorInterpSpeed) == 0x00004C, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::RotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, DeltaSeconds) == 0x000050, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerLocomotionLogicProxy_SmoothPlayerRotation, ReturnValue) == 0x000058, "Member 'PlayerLocomotionLogicProxy_SmoothPlayerRotation::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.CaculateShadowTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct PlayerShadowDecalProcessor_CaculateShadowTargetInfo final
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerShadowDecalProcessor_CaculateShadowTargetInfo) == 0x000008, "Wrong alignment on PlayerShadowDecalProcessor_CaculateShadowTargetInfo");
static_assert(sizeof(PlayerShadowDecalProcessor_CaculateShadowTargetInfo) == 0x000018, "Wrong size on PlayerShadowDecalProcessor_CaculateShadowTargetInfo");
static_assert(offsetof(PlayerShadowDecalProcessor_CaculateShadowTargetInfo, OwnerCharacter) == 0x000000, "Member 'PlayerShadowDecalProcessor_CaculateShadowTargetInfo::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_CaculateShadowTargetInfo, SkeletalMeshComponent) == 0x000008, "Member 'PlayerShadowDecalProcessor_CaculateShadowTargetInfo::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_CaculateShadowTargetInfo, ReturnValue) == 0x000010, "Member 'PlayerShadowDecalProcessor_CaculateShadowTargetInfo::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.GetRealCapsultHeight
// 0x0010 (0x0010 - 0x0000)
struct PlayerShadowDecalProcessor_GetRealCapsultHeight final
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerShadowDecalProcessor_GetRealCapsultHeight) == 0x000008, "Wrong alignment on PlayerShadowDecalProcessor_GetRealCapsultHeight");
static_assert(sizeof(PlayerShadowDecalProcessor_GetRealCapsultHeight) == 0x000010, "Wrong size on PlayerShadowDecalProcessor_GetRealCapsultHeight");
static_assert(offsetof(PlayerShadowDecalProcessor_GetRealCapsultHeight, OwnerCharacter) == 0x000000, "Member 'PlayerShadowDecalProcessor_GetRealCapsultHeight::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_GetRealCapsultHeight, ReturnValue) == 0x000008, "Member 'PlayerShadowDecalProcessor_GetRealCapsultHeight::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.InitConfigInformation
// 0x0030 (0x0030 - 0x0000)
struct PlayerShadowDecalProcessor_InitConfigInformation final
{
public:
	float                                         MaxTraceDownHeight;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeight;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShadowDecalSize;                                   // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereTraceRadius;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve_ShadowDecalDistanceMappedToScale2D;          // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerShadowDecalProcessor_InitConfigInformation) == 0x000008, "Wrong alignment on PlayerShadowDecalProcessor_InitConfigInformation");
static_assert(sizeof(PlayerShadowDecalProcessor_InitConfigInformation) == 0x000030, "Wrong size on PlayerShadowDecalProcessor_InitConfigInformation");
static_assert(offsetof(PlayerShadowDecalProcessor_InitConfigInformation, MaxTraceDownHeight) == 0x000000, "Member 'PlayerShadowDecalProcessor_InitConfigInformation::MaxTraceDownHeight' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_InitConfigInformation, MaxJumpHeight) == 0x000004, "Member 'PlayerShadowDecalProcessor_InitConfigInformation::MaxJumpHeight' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_InitConfigInformation, ShadowDecalSize) == 0x000008, "Member 'PlayerShadowDecalProcessor_InitConfigInformation::ShadowDecalSize' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_InitConfigInformation, SphereTraceRadius) == 0x000020, "Member 'PlayerShadowDecalProcessor_InitConfigInformation::SphereTraceRadius' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_InitConfigInformation, Curve_ShadowDecalDistanceMappedToScale2D) == 0x000028, "Member 'PlayerShadowDecalProcessor_InitConfigInformation::Curve_ShadowDecalDistanceMappedToScale2D' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.InitShadowDynamicMIParam
// 0x0018 (0x0018 - 0x0000)
struct PlayerShadowDecalProcessor_InitShadowDynamicMIParam final
{
public:
	class FName                                   OpacityParamName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlurWeightParamName;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScaleParamName;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerShadowDecalProcessor_InitShadowDynamicMIParam) == 0x000004, "Wrong alignment on PlayerShadowDecalProcessor_InitShadowDynamicMIParam");
static_assert(sizeof(PlayerShadowDecalProcessor_InitShadowDynamicMIParam) == 0x000018, "Wrong size on PlayerShadowDecalProcessor_InitShadowDynamicMIParam");
static_assert(offsetof(PlayerShadowDecalProcessor_InitShadowDynamicMIParam, OpacityParamName) == 0x000000, "Member 'PlayerShadowDecalProcessor_InitShadowDynamicMIParam::OpacityParamName' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_InitShadowDynamicMIParam, BlurWeightParamName) == 0x000008, "Member 'PlayerShadowDecalProcessor_InitShadowDynamicMIParam::BlurWeightParamName' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_InitShadowDynamicMIParam, ScaleParamName) == 0x000010, "Member 'PlayerShadowDecalProcessor_InitShadowDynamicMIParam::ScaleParamName' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.UpdateDecalMaterialInstanceParam
// 0x0018 (0x0018 - 0x0000)
struct PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ShadowDynamicMI;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam) == 0x000008, "Wrong alignment on PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam");
static_assert(sizeof(PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam) == 0x000018, "Wrong size on PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam, DeltaSeconds) == 0x000000, "Member 'PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam, OwnerCharacter) == 0x000008, "Member 'PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam, ShadowDynamicMI) == 0x000010, "Member 'PlayerShadowDecalProcessor_UpdateDecalMaterialInstanceParam::ShadowDynamicMI' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.UpdateDrawPlayerShadowDecal
// 0x0030 (0x0030 - 0x0000)
struct PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ShadowOnWaterPlaneMeshComp;                        // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal) == 0x000008, "Wrong alignment on PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal");
static_assert(sizeof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal) == 0x000030, "Wrong size on PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal, DeltaSeconds) == 0x000000, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal, OwnerCharacter) == 0x000008, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal, SkeletalMeshComponent) == 0x000010, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal, DecalComponent) == 0x000018, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal::DecalComponent' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal, ShadowOnWaterPlaneMeshComp) == 0x000020, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal::ShadowOnWaterPlaneMeshComp' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal, ReturnValue) == 0x000028, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal::ReturnValue' has a wrong offset!");

// Function X6Game.PlayerShadowDecalProcessor.UpdateDrawPlayerShadowDecal_Mobile
// 0x0030 (0x0030 - 0x0000)
struct PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CubeMeshComponent;                                 // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ShadowOnWaterPlaneMeshComp;                        // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile) == 0x000008, "Wrong alignment on PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile");
static_assert(sizeof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile) == 0x000030, "Wrong size on PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile, DeltaSeconds) == 0x000000, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile, OwnerCharacter) == 0x000008, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile, SkeletalMeshComponent) == 0x000010, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile, CubeMeshComponent) == 0x000018, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile::CubeMeshComponent' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile, ShadowOnWaterPlaneMeshComp) == 0x000020, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile::ShadowOnWaterPlaneMeshComp' has a wrong offset!");
static_assert(offsetof(PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile, ReturnValue) == 0x000028, "Member 'PlayerShadowDecalProcessor_UpdateDrawPlayerShadowDecal_Mobile::ReturnValue' has a wrong offset!");

// Function X6Game.QuadrupedLocomotionAnimInstance.DeterminTransToContractionPose
// 0x0001 (0x0001 - 0x0000)
struct QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose) == 0x000001, "Wrong alignment on QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose");
static_assert(sizeof(QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose) == 0x000001, "Wrong size on QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose");
static_assert(offsetof(QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose, ReturnValue) == 0x000000, "Member 'QuadrupedLocomotionAnimInstance_DeterminTransToContractionPose::ReturnValue' has a wrong offset!");

// Function X6Game.QuadrupedLocomotionAnimInstance.DeterminTransToRightFoot
// 0x0001 (0x0001 - 0x0000)
struct QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot) == 0x000001, "Wrong alignment on QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot");
static_assert(sizeof(QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot) == 0x000001, "Wrong size on QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot");
static_assert(offsetof(QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot, ReturnValue) == 0x000000, "Member 'QuadrupedLocomotionAnimInstance_DeterminTransToRightFoot::ReturnValue' has a wrong offset!");

// Function X6Game.QuadrupedLocomotionAnimInstance.HandleOnMovementInputChanged
// 0x0002 (0x0002 - 0x0000)
struct QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged final
{
public:
	bool                                          PrevHasMovementInput;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewHasMovementInput;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged) == 0x000001, "Wrong alignment on QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged");
static_assert(sizeof(QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged) == 0x000002, "Wrong size on QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged");
static_assert(offsetof(QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged, PrevHasMovementInput) == 0x000000, "Member 'QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged::PrevHasMovementInput' has a wrong offset!");
static_assert(offsetof(QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged, NewHasMovementInput) == 0x000001, "Member 'QuadrupedLocomotionAnimInstance_HandleOnMovementInputChanged::NewHasMovementInput' has a wrong offset!");

// Function X6Game.RenderTargetBox.SetIgnoreHittestGrid
// 0x0001 (0x0001 - 0x0000)
struct RenderTargetBox_SetIgnoreHittestGrid final
{
public:
	bool                                          InIgnoreHittestGrid;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderTargetBox_SetIgnoreHittestGrid) == 0x000001, "Wrong alignment on RenderTargetBox_SetIgnoreHittestGrid");
static_assert(sizeof(RenderTargetBox_SetIgnoreHittestGrid) == 0x000001, "Wrong size on RenderTargetBox_SetIgnoreHittestGrid");
static_assert(offsetof(RenderTargetBox_SetIgnoreHittestGrid, InIgnoreHittestGrid) == 0x000000, "Member 'RenderTargetBox_SetIgnoreHittestGrid::InIgnoreHittestGrid' has a wrong offset!");

// Function X6Game.RenderTargetBox.SetRenderTarget
// 0x0008 (0x0008 - 0x0000)
struct RenderTargetBox_SetRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderTargetBox_SetRenderTarget) == 0x000008, "Wrong alignment on RenderTargetBox_SetRenderTarget");
static_assert(sizeof(RenderTargetBox_SetRenderTarget) == 0x000008, "Wrong size on RenderTargetBox_SetRenderTarget");
static_assert(offsetof(RenderTargetBox_SetRenderTarget, RenderTarget) == 0x000000, "Member 'RenderTargetBox_SetRenderTarget::RenderTarget' has a wrong offset!");

// Function X6Game.RenderTargetBox.SetShowChild
// 0x0001 (0x0001 - 0x0000)
struct RenderTargetBox_SetShowChild final
{
public:
	bool                                          InShowChild;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RenderTargetBox_SetShowChild) == 0x000001, "Wrong alignment on RenderTargetBox_SetShowChild");
static_assert(sizeof(RenderTargetBox_SetShowChild) == 0x000001, "Wrong size on RenderTargetBox_SetShowChild");
static_assert(offsetof(RenderTargetBox_SetShowChild, InShowChild) == 0x000000, "Member 'RenderTargetBox_SetShowChild::InShowChild' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.CaculateCurRotationActorInterpSpeed
// 0x0058 (0x0058 - 0x0000)
struct RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed final
{
public:
	struct FRotator                               CurrentCameraRotation;                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreCameraRotation;                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraRYawClampUpperLimit;                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveSampleValue;                                  // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotateCurve;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RAngleToRYawSpeedRateMappingCurve;                 // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTurnAroundAngle;                            // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0054(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed");
static_assert(sizeof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed) == 0x000058, "Wrong size on RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, CurrentCameraRotation) == 0x000000, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, PreCameraRotation) == 0x000018, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::PreCameraRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, CameraRYawClampUpperLimit) == 0x000030, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::CameraRYawClampUpperLimit' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, CurveSampleValue) == 0x000034, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::CurveSampleValue' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, DeltaSeconds) == 0x000038, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, RotateCurve) == 0x000040, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::RotateCurve' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, RAngleToRYawSpeedRateMappingCurve) == 0x000048, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::RAngleToRYawSpeedRateMappingCurve' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, CurrentTurnAroundAngle) == 0x000050, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::CurrentTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed, ReturnValue) == 0x000054, "Member 'RMBaseLogicProcessor_CaculateCurRotationActorInterpSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.GetCameraContext
// 0x0038 (0x0038 - 0x0000)
struct RMBaseLogicProcessor_GetCameraContext final
{
public:
	struct FRMCameraContext                       ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_GetCameraContext) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_GetCameraContext");
static_assert(sizeof(RMBaseLogicProcessor_GetCameraContext) == 0x000038, "Wrong size on RMBaseLogicProcessor_GetCameraContext");
static_assert(offsetof(RMBaseLogicProcessor_GetCameraContext, ReturnValue) == 0x000000, "Member 'RMBaseLogicProcessor_GetCameraContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.GetInputContext
// 0x00B8 (0x00B8 - 0x0000)
struct RMBaseLogicProcessor_GetInputContext final
{
public:
	struct FRMInputContext                        ReturnValue;                                       // 0x0000(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_GetInputContext) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_GetInputContext");
static_assert(sizeof(RMBaseLogicProcessor_GetInputContext) == 0x0000B8, "Wrong size on RMBaseLogicProcessor_GetInputContext");
static_assert(offsetof(RMBaseLogicProcessor_GetInputContext, ReturnValue) == 0x000000, "Member 'RMBaseLogicProcessor_GetInputContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.GetMappedSpeed
// 0x0014 (0x0014 - 0x0000)
struct RMBaseLogicProcessor_GetMappedSpeed final
{
public:
	float                                         CurrentSpeed2DVal;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerSpeedVal;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddleSpeedVal;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighSpeedVal;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_GetMappedSpeed) == 0x000004, "Wrong alignment on RMBaseLogicProcessor_GetMappedSpeed");
static_assert(sizeof(RMBaseLogicProcessor_GetMappedSpeed) == 0x000014, "Wrong size on RMBaseLogicProcessor_GetMappedSpeed");
static_assert(offsetof(RMBaseLogicProcessor_GetMappedSpeed, CurrentSpeed2DVal) == 0x000000, "Member 'RMBaseLogicProcessor_GetMappedSpeed::CurrentSpeed2DVal' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetMappedSpeed, LowerSpeedVal) == 0x000004, "Member 'RMBaseLogicProcessor_GetMappedSpeed::LowerSpeedVal' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetMappedSpeed, MiddleSpeedVal) == 0x000008, "Member 'RMBaseLogicProcessor_GetMappedSpeed::MiddleSpeedVal' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetMappedSpeed, HighSpeedVal) == 0x00000C, "Member 'RMBaseLogicProcessor_GetMappedSpeed::HighSpeedVal' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetMappedSpeed, ReturnValue) == 0x000010, "Member 'RMBaseLogicProcessor_GetMappedSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.GetMostRecentValidInputInfoByValidDuration
// 0x0020 (0x0020 - 0x0000)
struct RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration final
{
public:
	float                                         ValidDuration;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameInputContext                     InputContext;                                      // 0x0004(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration) == 0x000004, "Wrong alignment on RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration");
static_assert(sizeof(RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration) == 0x000020, "Wrong size on RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration");
static_assert(offsetof(RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration, ValidDuration) == 0x000000, "Member 'RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration::ValidDuration' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration, InputContext) == 0x000004, "Member 'RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration::InputContext' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration, ReturnValue) == 0x00001C, "Member 'RMBaseLogicProcessor_GetMostRecentValidInputInfoByValidDuration::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.GetTurnAroundAngle
// 0x0038 (0x0038 - 0x0000)
struct RMBaseLogicProcessor_GetTurnAroundAngle final
{
public:
	struct FVector                                InputMovingDirection;                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentForwardVector;                              // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_GetTurnAroundAngle) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_GetTurnAroundAngle");
static_assert(sizeof(RMBaseLogicProcessor_GetTurnAroundAngle) == 0x000038, "Wrong size on RMBaseLogicProcessor_GetTurnAroundAngle");
static_assert(offsetof(RMBaseLogicProcessor_GetTurnAroundAngle, InputMovingDirection) == 0x000000, "Member 'RMBaseLogicProcessor_GetTurnAroundAngle::InputMovingDirection' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetTurnAroundAngle, CurrentForwardVector) == 0x000018, "Member 'RMBaseLogicProcessor_GetTurnAroundAngle::CurrentForwardVector' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetTurnAroundAngle, ReturnValue) == 0x000030, "Member 'RMBaseLogicProcessor_GetTurnAroundAngle::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.GetVariableInputScaleValue
// 0x0080 (0x0080 - 0x0000)
struct RMBaseLogicProcessor_GetVariableInputScaleValue final
{
public:
	struct FRMInputConfig                         RMInputConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsForwardAxis;                                    // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentInputValForMoveForward;                     // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentInputValForMoveRight;                       // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x007C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_GetVariableInputScaleValue) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_GetVariableInputScaleValue");
static_assert(sizeof(RMBaseLogicProcessor_GetVariableInputScaleValue) == 0x000080, "Wrong size on RMBaseLogicProcessor_GetVariableInputScaleValue");
static_assert(offsetof(RMBaseLogicProcessor_GetVariableInputScaleValue, RMInputConfig) == 0x000000, "Member 'RMBaseLogicProcessor_GetVariableInputScaleValue::RMInputConfig' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetVariableInputScaleValue, bIsForwardAxis) == 0x000070, "Member 'RMBaseLogicProcessor_GetVariableInputScaleValue::bIsForwardAxis' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetVariableInputScaleValue, CurrentInputValForMoveForward) == 0x000074, "Member 'RMBaseLogicProcessor_GetVariableInputScaleValue::CurrentInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetVariableInputScaleValue, CurrentInputValForMoveRight) == 0x000078, "Member 'RMBaseLogicProcessor_GetVariableInputScaleValue::CurrentInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_GetVariableInputScaleValue, ReturnValue) == 0x00007C, "Member 'RMBaseLogicProcessor_GetVariableInputScaleValue::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.InitInputConfigData
// 0x0028 (0x0028 - 0x0000)
struct RMBaseLogicProcessor_InitInputConfigData final
{
public:
	float                                         LogicalFramesPerSecond;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreStartFrames;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStartMovingInputCache;                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMovingInputCacheFrames;                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMutationCache;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MutationInputCacheFrames;                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInvalidInput;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvalidInputFrames;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MutationInputSizeThreshold;                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MutationInputDirectionThreshold;                   // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_InitInputConfigData) == 0x000004, "Wrong alignment on RMBaseLogicProcessor_InitInputConfigData");
static_assert(sizeof(RMBaseLogicProcessor_InitInputConfigData) == 0x000028, "Wrong size on RMBaseLogicProcessor_InitInputConfigData");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, LogicalFramesPerSecond) == 0x000000, "Member 'RMBaseLogicProcessor_InitInputConfigData::LogicalFramesPerSecond' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, PreStartFrames) == 0x000004, "Member 'RMBaseLogicProcessor_InitInputConfigData::PreStartFrames' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, bEnableStartMovingInputCache) == 0x000008, "Member 'RMBaseLogicProcessor_InitInputConfigData::bEnableStartMovingInputCache' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, StartMovingInputCacheFrames) == 0x00000C, "Member 'RMBaseLogicProcessor_InitInputConfigData::StartMovingInputCacheFrames' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, bEnableMutationCache) == 0x000010, "Member 'RMBaseLogicProcessor_InitInputConfigData::bEnableMutationCache' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, MutationInputCacheFrames) == 0x000014, "Member 'RMBaseLogicProcessor_InitInputConfigData::MutationInputCacheFrames' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, bEnableInvalidInput) == 0x000018, "Member 'RMBaseLogicProcessor_InitInputConfigData::bEnableInvalidInput' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, InvalidInputFrames) == 0x00001C, "Member 'RMBaseLogicProcessor_InitInputConfigData::InvalidInputFrames' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, MutationInputSizeThreshold) == 0x000020, "Member 'RMBaseLogicProcessor_InitInputConfigData::MutationInputSizeThreshold' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_InitInputConfigData, MutationInputDirectionThreshold) == 0x000024, "Member 'RMBaseLogicProcessor_InitInputConfigData::MutationInputDirectionThreshold' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.IsEnableMutationCache
// 0x0001 (0x0001 - 0x0000)
struct RMBaseLogicProcessor_IsEnableMutationCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_IsEnableMutationCache) == 0x000001, "Wrong alignment on RMBaseLogicProcessor_IsEnableMutationCache");
static_assert(sizeof(RMBaseLogicProcessor_IsEnableMutationCache) == 0x000001, "Wrong size on RMBaseLogicProcessor_IsEnableMutationCache");
static_assert(offsetof(RMBaseLogicProcessor_IsEnableMutationCache, ReturnValue) == 0x000000, "Member 'RMBaseLogicProcessor_IsEnableMutationCache::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.IsNeedStartMovingCache
// 0x0001 (0x0001 - 0x0000)
struct RMBaseLogicProcessor_IsNeedStartMovingCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_IsNeedStartMovingCache) == 0x000001, "Wrong alignment on RMBaseLogicProcessor_IsNeedStartMovingCache");
static_assert(sizeof(RMBaseLogicProcessor_IsNeedStartMovingCache) == 0x000001, "Wrong size on RMBaseLogicProcessor_IsNeedStartMovingCache");
static_assert(offsetof(RMBaseLogicProcessor_IsNeedStartMovingCache, ReturnValue) == 0x000000, "Member 'RMBaseLogicProcessor_IsNeedStartMovingCache::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ObtainingPreciseValueThroughIntegralCalculation
// 0x0028 (0x0028 - 0x0000)
struct RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation final
{
public:
	class UCurveFloat*                            CurCurve;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CurSampleValue;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AdvanceTime;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SamplingInterval;                                  // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation");
static_assert(sizeof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation) == 0x000028, "Wrong size on RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation");
static_assert(offsetof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation, CurCurve) == 0x000000, "Member 'RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation::CurCurve' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation, CurSampleValue) == 0x000008, "Member 'RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation::CurSampleValue' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation, AdvanceTime) == 0x000010, "Member 'RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation::AdvanceTime' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation, SamplingInterval) == 0x000018, "Member 'RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation::SamplingInterval' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation, ReturnValue) == 0x000020, "Member 'RMBaseLogicProcessor_ObtainingPreciseValueThroughIntegralCalculation::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.OnInitialize
// 0x0008 (0x0008 - 0x0000)
struct RMBaseLogicProcessor_OnInitialize final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_OnInitialize) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_OnInitialize");
static_assert(sizeof(RMBaseLogicProcessor_OnInitialize) == 0x000008, "Wrong size on RMBaseLogicProcessor_OnInitialize");
static_assert(offsetof(RMBaseLogicProcessor_OnInitialize, OwnerActor) == 0x000000, "Member 'RMBaseLogicProcessor_OnInitialize::OwnerActor' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.PolishInputValue
// 0x0080 (0x0080 - 0x0000)
struct RMBaseLogicProcessor_PolishInputValue final
{
public:
	struct FRMInputConfig                         RMInputConfig;                                     // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         CurrentInputValForMoveForward;                     // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentInputValForMoveRight;                       // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_PolishInputValue) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_PolishInputValue");
static_assert(sizeof(RMBaseLogicProcessor_PolishInputValue) == 0x000080, "Wrong size on RMBaseLogicProcessor_PolishInputValue");
static_assert(offsetof(RMBaseLogicProcessor_PolishInputValue, RMInputConfig) == 0x000000, "Member 'RMBaseLogicProcessor_PolishInputValue::RMInputConfig' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_PolishInputValue, CurrentInputValForMoveForward) == 0x000070, "Member 'RMBaseLogicProcessor_PolishInputValue::CurrentInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_PolishInputValue, CurrentInputValForMoveRight) == 0x000074, "Member 'RMBaseLogicProcessor_PolishInputValue::CurrentInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_PolishInputValue, ReturnValue) == 0x000078, "Member 'RMBaseLogicProcessor_PolishInputValue::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ProcessBasicOnGroundTurnAroundMovementLogic
// 0x0048 (0x0048 - 0x0000)
struct RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentTargetRotation;                             // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InputMovingDirection;                              // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationActorInterpSpeed;                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic");
static_assert(sizeof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic) == 0x000048, "Wrong size on RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, CharacterMovementComponent) == 0x000000, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, CurrentTargetRotation) == 0x000008, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::CurrentTargetRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, InputMovingDirection) == 0x000020, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::InputMovingDirection' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, RotationTargetInterpSpeed) == 0x000038, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, RotationActorInterpSpeed) == 0x00003C, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::RotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, DeltaSeconds) == 0x000040, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic, ReturnValue) == 0x000044, "Member 'RMBaseLogicProcessor_ProcessBasicOnGroundTurnAroundMovementLogic::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ProcessFollowUpTurnAroundMovementLogic
// 0x0030 (0x0030 - 0x0000)
struct RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InputMovingDirection;                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic");
static_assert(sizeof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic) == 0x000030, "Wrong size on RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic");
static_assert(offsetof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic, CharacterMovementComponent) == 0x000000, "Member 'RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic, InputMovingDirection) == 0x000008, "Member 'RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic::InputMovingDirection' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic, RotationTargetInterpSpeed) == 0x000020, "Member 'RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic, DeltaSeconds) == 0x000024, "Member 'RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic, ReturnValue) == 0x000028, "Member 'RMBaseLogicProcessor_ProcessFollowUpTurnAroundMovementLogic::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ProcessInputAngularDeadZone
// 0x0080 (0x0080 - 0x0000)
struct RMBaseLogicProcessor_ProcessInputAngularDeadZone final
{
public:
	const class UCharacterMovementComponent*      CharacterMovementComponent;                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRMInputConfig                         RMInputConfig;                                     // 0x0008(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0078(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_ProcessInputAngularDeadZone) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_ProcessInputAngularDeadZone");
static_assert(sizeof(RMBaseLogicProcessor_ProcessInputAngularDeadZone) == 0x000080, "Wrong size on RMBaseLogicProcessor_ProcessInputAngularDeadZone");
static_assert(offsetof(RMBaseLogicProcessor_ProcessInputAngularDeadZone, CharacterMovementComponent) == 0x000000, "Member 'RMBaseLogicProcessor_ProcessInputAngularDeadZone::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessInputAngularDeadZone, RMInputConfig) == 0x000008, "Member 'RMBaseLogicProcessor_ProcessInputAngularDeadZone::RMInputConfig' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessInputAngularDeadZone, DeltaSeconds) == 0x000078, "Member 'RMBaseLogicProcessor_ProcessInputAngularDeadZone::DeltaSeconds' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ProcessInputValueCacheLogic
// 0x0008 (0x0008 - 0x0000)
struct RMBaseLogicProcessor_ProcessInputValueCacheLogic final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_ProcessInputValueCacheLogic) == 0x000004, "Wrong alignment on RMBaseLogicProcessor_ProcessInputValueCacheLogic");
static_assert(sizeof(RMBaseLogicProcessor_ProcessInputValueCacheLogic) == 0x000008, "Wrong size on RMBaseLogicProcessor_ProcessInputValueCacheLogic");
static_assert(offsetof(RMBaseLogicProcessor_ProcessInputValueCacheLogic, DeltaSeconds) == 0x000000, "Member 'RMBaseLogicProcessor_ProcessInputValueCacheLogic::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessInputValueCacheLogic, bIsMoving) == 0x000004, "Member 'RMBaseLogicProcessor_ProcessInputValueCacheLogic::bIsMoving' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessInputValueCacheLogic, ReturnValue) == 0x000005, "Member 'RMBaseLogicProcessor_ProcessInputValueCacheLogic::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ProcessRegularFallingTurnAroundMovementLogic
// 0x0030 (0x0030 - 0x0000)
struct RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InputMovingDirection;                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationActorInterpSpeed;                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic");
static_assert(sizeof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic) == 0x000030, "Wrong size on RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic");
static_assert(offsetof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic, CharacterMovementComponent) == 0x000000, "Member 'RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic, InputMovingDirection) == 0x000008, "Member 'RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic::InputMovingDirection' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic, RotationTargetInterpSpeed) == 0x000020, "Member 'RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic, RotationActorInterpSpeed) == 0x000024, "Member 'RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic::RotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic, DeltaSeconds) == 0x000028, "Member 'RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic, ReturnValue) == 0x00002C, "Member 'RMBaseLogicProcessor_ProcessRegularFallingTurnAroundMovementLogic::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.RecordCurInputInformation
// 0x0010 (0x0010 - 0x0000)
struct RMBaseLogicProcessor_RecordCurInputInformation final
{
public:
	float                                         CurrentInputValForMoveForward;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentInputValForMoveRight;                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreInputValForMoveForward;                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreInputValForMoveRight;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_RecordCurInputInformation) == 0x000004, "Wrong alignment on RMBaseLogicProcessor_RecordCurInputInformation");
static_assert(sizeof(RMBaseLogicProcessor_RecordCurInputInformation) == 0x000010, "Wrong size on RMBaseLogicProcessor_RecordCurInputInformation");
static_assert(offsetof(RMBaseLogicProcessor_RecordCurInputInformation, CurrentInputValForMoveForward) == 0x000000, "Member 'RMBaseLogicProcessor_RecordCurInputInformation::CurrentInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_RecordCurInputInformation, CurrentInputValForMoveRight) == 0x000004, "Member 'RMBaseLogicProcessor_RecordCurInputInformation::CurrentInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_RecordCurInputInformation, PreInputValForMoveForward) == 0x000008, "Member 'RMBaseLogicProcessor_RecordCurInputInformation::PreInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_RecordCurInputInformation, PreInputValForMoveRight) == 0x00000C, "Member 'RMBaseLogicProcessor_RecordCurInputInformation::PreInputValForMoveRight' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.RemapInputAccordingToSwitchWalkMode
// 0x0008 (0x0008 - 0x0000)
struct RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode final
{
public:
	class URMProxyTickRecordInterface*            TickRecord;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode");
static_assert(sizeof(RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode) == 0x000008, "Wrong size on RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode");
static_assert(offsetof(RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode, TickRecord) == 0x000000, "Member 'RMBaseLogicProcessor_RemapInputAccordingToSwitchWalkMode::TickRecord' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.ReplayCurInputInformation
// 0x0010 (0x0010 - 0x0000)
struct RMBaseLogicProcessor_ReplayCurInputInformation final
{
public:
	float                                         PolishInputValForMoveForward;                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishInputValForMoveRight;                        // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreInputValForMoveForward;                   // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreInputValForMoveRight;                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_ReplayCurInputInformation) == 0x000004, "Wrong alignment on RMBaseLogicProcessor_ReplayCurInputInformation");
static_assert(sizeof(RMBaseLogicProcessor_ReplayCurInputInformation) == 0x000010, "Wrong size on RMBaseLogicProcessor_ReplayCurInputInformation");
static_assert(offsetof(RMBaseLogicProcessor_ReplayCurInputInformation, PolishInputValForMoveForward) == 0x000000, "Member 'RMBaseLogicProcessor_ReplayCurInputInformation::PolishInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ReplayCurInputInformation, PolishInputValForMoveRight) == 0x000004, "Member 'RMBaseLogicProcessor_ReplayCurInputInformation::PolishInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ReplayCurInputInformation, PolishPreInputValForMoveForward) == 0x000008, "Member 'RMBaseLogicProcessor_ReplayCurInputInformation::PolishPreInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_ReplayCurInputInformation, PolishPreInputValForMoveRight) == 0x00000C, "Member 'RMBaseLogicProcessor_ReplayCurInputInformation::PolishPreInputValForMoveRight' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.SmoothPlayerRotation
// 0x0070 (0x0070 - 0x0000)
struct RMBaseLogicProcessor_SmoothPlayerRotation final
{
public:
	struct FRotator                               CurrentTargetRotation;                             // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               NewTargetRotation;                                 // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CurActorRotation;                                  // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationActorInterpSpeed;                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_SmoothPlayerRotation) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_SmoothPlayerRotation");
static_assert(sizeof(RMBaseLogicProcessor_SmoothPlayerRotation) == 0x000070, "Wrong size on RMBaseLogicProcessor_SmoothPlayerRotation");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, CurrentTargetRotation) == 0x000000, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::CurrentTargetRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, NewTargetRotation) == 0x000018, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::NewTargetRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, CurActorRotation) == 0x000030, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::CurActorRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, RotationTargetInterpSpeed) == 0x000048, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, RotationActorInterpSpeed) == 0x00004C, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::RotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, DeltaSeconds) == 0x000050, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotation, ReturnValue) == 0x000058, "Member 'RMBaseLogicProcessor_SmoothPlayerRotation::ReturnValue' has a wrong offset!");

// Function X6Game.RMBaseLogicProcessor.SmoothPlayerRotationConstant
// 0x0050 (0x0050 - 0x0000)
struct RMBaseLogicProcessor_SmoothPlayerRotationConstant final
{
public:
	struct FRotator                               CurrentRotation;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBaseLogicProcessor_SmoothPlayerRotationConstant) == 0x000008, "Wrong alignment on RMBaseLogicProcessor_SmoothPlayerRotationConstant");
static_assert(sizeof(RMBaseLogicProcessor_SmoothPlayerRotationConstant) == 0x000050, "Wrong size on RMBaseLogicProcessor_SmoothPlayerRotationConstant");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotationConstant, CurrentRotation) == 0x000000, "Member 'RMBaseLogicProcessor_SmoothPlayerRotationConstant::CurrentRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotationConstant, TargetRotation) == 0x000018, "Member 'RMBaseLogicProcessor_SmoothPlayerRotationConstant::TargetRotation' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotationConstant, RotationTargetInterpSpeed) == 0x000030, "Member 'RMBaseLogicProcessor_SmoothPlayerRotationConstant::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotationConstant, DeltaSeconds) == 0x000034, "Member 'RMBaseLogicProcessor_SmoothPlayerRotationConstant::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RMBaseLogicProcessor_SmoothPlayerRotationConstant, ReturnValue) == 0x000038, "Member 'RMBaseLogicProcessor_SmoothPlayerRotationConstant::ReturnValue' has a wrong offset!");

// Function X6Game.RMBehaviorTreeProxyInterface.OnInitialize
// 0x0010 (0x0010 - 0x0000)
struct RMBehaviorTreeProxyInterface_OnInitialize final
{
public:
	class UActorComponent*                        OuterComp;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMBehaviorTreeProxyInterface_OnInitialize) == 0x000008, "Wrong alignment on RMBehaviorTreeProxyInterface_OnInitialize");
static_assert(sizeof(RMBehaviorTreeProxyInterface_OnInitialize) == 0x000010, "Wrong size on RMBehaviorTreeProxyInterface_OnInitialize");
static_assert(offsetof(RMBehaviorTreeProxyInterface_OnInitialize, OuterComp) == 0x000000, "Member 'RMBehaviorTreeProxyInterface_OnInitialize::OuterComp' has a wrong offset!");
static_assert(offsetof(RMBehaviorTreeProxyInterface_OnInitialize, CharacterMovementComponent) == 0x000008, "Member 'RMBehaviorTreeProxyInterface_OnInitialize::CharacterMovementComponent' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.GetConfigContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_GetConfigContext final
{
public:
	class URMConfigContextInterface*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_GetConfigContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_GetConfigContext");
static_assert(sizeof(RMProxyTickRecordInterface_GetConfigContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_GetConfigContext");
static_assert(offsetof(RMProxyTickRecordInterface_GetConfigContext, ReturnValue) == 0x000000, "Member 'RMProxyTickRecordInterface_GetConfigContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.GetCurrentProxy
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_GetCurrentProxy final
{
public:
	class URMBehaviorTreeProxyInterface*          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_GetCurrentProxy) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_GetCurrentProxy");
static_assert(sizeof(RMProxyTickRecordInterface_GetCurrentProxy) == 0x000008, "Wrong size on RMProxyTickRecordInterface_GetCurrentProxy");
static_assert(offsetof(RMProxyTickRecordInterface_GetCurrentProxy, ReturnValue) == 0x000000, "Member 'RMProxyTickRecordInterface_GetCurrentProxy::ReturnValue' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.GetDebugContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_GetDebugContext final
{
public:
	class URegularMovementDebugContext*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_GetDebugContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_GetDebugContext");
static_assert(sizeof(RMProxyTickRecordInterface_GetDebugContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_GetDebugContext");
static_assert(offsetof(RMProxyTickRecordInterface_GetDebugContext, ReturnValue) == 0x000000, "Member 'RMProxyTickRecordInterface_GetDebugContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.GetOutputContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_GetOutputContext final
{
public:
	class URMOutputContextInterface*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_GetOutputContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_GetOutputContext");
static_assert(sizeof(RMProxyTickRecordInterface_GetOutputContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_GetOutputContext");
static_assert(offsetof(RMProxyTickRecordInterface_GetOutputContext, ReturnValue) == 0x000000, "Member 'RMProxyTickRecordInterface_GetOutputContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.GetStateInstructionContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_GetStateInstructionContext final
{
public:
	class URMStateInstructionContext*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_GetStateInstructionContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_GetStateInstructionContext");
static_assert(sizeof(RMProxyTickRecordInterface_GetStateInstructionContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_GetStateInstructionContext");
static_assert(offsetof(RMProxyTickRecordInterface_GetStateInstructionContext, ReturnValue) == 0x000000, "Member 'RMProxyTickRecordInterface_GetStateInstructionContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.GetUseButtonSwitchWalk
// 0x0001 (0x0001 - 0x0000)
struct RMProxyTickRecordInterface_GetUseButtonSwitchWalk final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_GetUseButtonSwitchWalk) == 0x000001, "Wrong alignment on RMProxyTickRecordInterface_GetUseButtonSwitchWalk");
static_assert(sizeof(RMProxyTickRecordInterface_GetUseButtonSwitchWalk) == 0x000001, "Wrong size on RMProxyTickRecordInterface_GetUseButtonSwitchWalk");
static_assert(offsetof(RMProxyTickRecordInterface_GetUseButtonSwitchWalk, ReturnValue) == 0x000000, "Member 'RMProxyTickRecordInterface_GetUseButtonSwitchWalk::ReturnValue' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.OnInitialize
// 0x0030 (0x0030 - 0x0000)
struct RMProxyTickRecordInterface_OnInitialize final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMBaseLogicProcessor*                  RMLogicProxy;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMOutputContextInterface>  RMOutputContextClass;                              // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMStateInstructionContext> RMStateInstructionContextClass;                    // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMConfigContextInterface>  RMConfigContextClass;                              // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URegularMovementDebugContext> RMDebugContextClass;                             // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_OnInitialize) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_OnInitialize");
static_assert(sizeof(RMProxyTickRecordInterface_OnInitialize) == 0x000030, "Wrong size on RMProxyTickRecordInterface_OnInitialize");
static_assert(offsetof(RMProxyTickRecordInterface_OnInitialize, Owner) == 0x000000, "Member 'RMProxyTickRecordInterface_OnInitialize::Owner' has a wrong offset!");
static_assert(offsetof(RMProxyTickRecordInterface_OnInitialize, RMLogicProxy) == 0x000008, "Member 'RMProxyTickRecordInterface_OnInitialize::RMLogicProxy' has a wrong offset!");
static_assert(offsetof(RMProxyTickRecordInterface_OnInitialize, RMOutputContextClass) == 0x000010, "Member 'RMProxyTickRecordInterface_OnInitialize::RMOutputContextClass' has a wrong offset!");
static_assert(offsetof(RMProxyTickRecordInterface_OnInitialize, RMStateInstructionContextClass) == 0x000018, "Member 'RMProxyTickRecordInterface_OnInitialize::RMStateInstructionContextClass' has a wrong offset!");
static_assert(offsetof(RMProxyTickRecordInterface_OnInitialize, RMConfigContextClass) == 0x000020, "Member 'RMProxyTickRecordInterface_OnInitialize::RMConfigContextClass' has a wrong offset!");
static_assert(offsetof(RMProxyTickRecordInterface_OnInitialize, RMDebugContextClass) == 0x000028, "Member 'RMProxyTickRecordInterface_OnInitialize::RMDebugContextClass' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.SetConfigContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_SetConfigContext final
{
public:
	class URMConfigContextInterface*              RMConfigContextInterface;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_SetConfigContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_SetConfigContext");
static_assert(sizeof(RMProxyTickRecordInterface_SetConfigContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_SetConfigContext");
static_assert(offsetof(RMProxyTickRecordInterface_SetConfigContext, RMConfigContextInterface) == 0x000000, "Member 'RMProxyTickRecordInterface_SetConfigContext::RMConfigContextInterface' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.SetCurrentProxy
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_SetCurrentProxy final
{
public:
	class URMBehaviorTreeProxyInterface*          RMProxyInterface;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_SetCurrentProxy) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_SetCurrentProxy");
static_assert(sizeof(RMProxyTickRecordInterface_SetCurrentProxy) == 0x000008, "Wrong size on RMProxyTickRecordInterface_SetCurrentProxy");
static_assert(offsetof(RMProxyTickRecordInterface_SetCurrentProxy, RMProxyInterface) == 0x000000, "Member 'RMProxyTickRecordInterface_SetCurrentProxy::RMProxyInterface' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.SetOutputContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_SetOutputContext final
{
public:
	class URMOutputContextInterface*              RMOutputContextInterface;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_SetOutputContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_SetOutputContext");
static_assert(sizeof(RMProxyTickRecordInterface_SetOutputContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_SetOutputContext");
static_assert(offsetof(RMProxyTickRecordInterface_SetOutputContext, RMOutputContextInterface) == 0x000000, "Member 'RMProxyTickRecordInterface_SetOutputContext::RMOutputContextInterface' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.SetStateInstructionContext
// 0x0008 (0x0008 - 0x0000)
struct RMProxyTickRecordInterface_SetStateInstructionContext final
{
public:
	class URMStateInstructionContext*             RMStateInstructionContext;                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_SetStateInstructionContext) == 0x000008, "Wrong alignment on RMProxyTickRecordInterface_SetStateInstructionContext");
static_assert(sizeof(RMProxyTickRecordInterface_SetStateInstructionContext) == 0x000008, "Wrong size on RMProxyTickRecordInterface_SetStateInstructionContext");
static_assert(offsetof(RMProxyTickRecordInterface_SetStateInstructionContext, RMStateInstructionContext) == 0x000000, "Member 'RMProxyTickRecordInterface_SetStateInstructionContext::RMStateInstructionContext' has a wrong offset!");

// Function X6Game.RMProxyTickRecordInterface.SetUseButtonSwitchWalk
// 0x0001 (0x0001 - 0x0000)
struct RMProxyTickRecordInterface_SetUseButtonSwitchWalk final
{
public:
	bool                                          bNewUseButtonSwitchWalk;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMProxyTickRecordInterface_SetUseButtonSwitchWalk) == 0x000001, "Wrong alignment on RMProxyTickRecordInterface_SetUseButtonSwitchWalk");
static_assert(sizeof(RMProxyTickRecordInterface_SetUseButtonSwitchWalk) == 0x000001, "Wrong size on RMProxyTickRecordInterface_SetUseButtonSwitchWalk");
static_assert(offsetof(RMProxyTickRecordInterface_SetUseButtonSwitchWalk, bNewUseButtonSwitchWalk) == 0x000000, "Member 'RMProxyTickRecordInterface_SetUseButtonSwitchWalk::bNewUseButtonSwitchWalk' has a wrong offset!");

// Function X6Game.RMStateInstructionContext.BP_AddState
// 0x0004 (0x0004 - 0x0000)
struct RMStateInstructionContext_BP_AddState final
{
public:
	int32                                         StateID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateInstructionContext_BP_AddState) == 0x000004, "Wrong alignment on RMStateInstructionContext_BP_AddState");
static_assert(sizeof(RMStateInstructionContext_BP_AddState) == 0x000004, "Wrong size on RMStateInstructionContext_BP_AddState");
static_assert(offsetof(RMStateInstructionContext_BP_AddState, StateID) == 0x000000, "Member 'RMStateInstructionContext_BP_AddState::StateID' has a wrong offset!");

// Function X6Game.RMStateInstructionContext.BP_CanDoAction
// 0x0008 (0x0008 - 0x0000)
struct RMStateInstructionContext_BP_CanDoAction final
{
public:
	int32                                         ActionId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMStateInstructionContext_BP_CanDoAction) == 0x000004, "Wrong alignment on RMStateInstructionContext_BP_CanDoAction");
static_assert(sizeof(RMStateInstructionContext_BP_CanDoAction) == 0x000008, "Wrong size on RMStateInstructionContext_BP_CanDoAction");
static_assert(offsetof(RMStateInstructionContext_BP_CanDoAction, ActionId) == 0x000000, "Member 'RMStateInstructionContext_BP_CanDoAction::ActionId' has a wrong offset!");
static_assert(offsetof(RMStateInstructionContext_BP_CanDoAction, ReturnValue) == 0x000004, "Member 'RMStateInstructionContext_BP_CanDoAction::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateInstructionContext.BP_DoAction
// 0x0004 (0x0004 - 0x0000)
struct RMStateInstructionContext_BP_DoAction final
{
public:
	int32                                         ActionId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateInstructionContext_BP_DoAction) == 0x000004, "Wrong alignment on RMStateInstructionContext_BP_DoAction");
static_assert(sizeof(RMStateInstructionContext_BP_DoAction) == 0x000004, "Wrong size on RMStateInstructionContext_BP_DoAction");
static_assert(offsetof(RMStateInstructionContext_BP_DoAction, ActionId) == 0x000000, "Member 'RMStateInstructionContext_BP_DoAction::ActionId' has a wrong offset!");

// Function X6Game.RMStateInstructionContext.BP_HasState
// 0x0008 (0x0008 - 0x0000)
struct RMStateInstructionContext_BP_HasState final
{
public:
	int32                                         StateID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMStateInstructionContext_BP_HasState) == 0x000004, "Wrong alignment on RMStateInstructionContext_BP_HasState");
static_assert(sizeof(RMStateInstructionContext_BP_HasState) == 0x000008, "Wrong size on RMStateInstructionContext_BP_HasState");
static_assert(offsetof(RMStateInstructionContext_BP_HasState, StateID) == 0x000000, "Member 'RMStateInstructionContext_BP_HasState::StateID' has a wrong offset!");
static_assert(offsetof(RMStateInstructionContext_BP_HasState, ReturnValue) == 0x000004, "Member 'RMStateInstructionContext_BP_HasState::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateInstructionContext.BP_RemoveState
// 0x0004 (0x0004 - 0x0000)
struct RMStateInstructionContext_BP_RemoveState final
{
public:
	int32                                         StateID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateInstructionContext_BP_RemoveState) == 0x000004, "Wrong alignment on RMStateInstructionContext_BP_RemoveState");
static_assert(sizeof(RMStateInstructionContext_BP_RemoveState) == 0x000004, "Wrong size on RMStateInstructionContext_BP_RemoveState");
static_assert(offsetof(RMStateInstructionContext_BP_RemoveState, StateID) == 0x000000, "Member 'RMStateInstructionContext_BP_RemoveState::StateID' has a wrong offset!");

// Function X6Game.RMStateInstructionContext.OnInitialize
// 0x0008 (0x0008 - 0x0000)
struct RMStateInstructionContext_OnInitialize final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateInstructionContext_OnInitialize) == 0x000008, "Wrong alignment on RMStateInstructionContext_OnInitialize");
static_assert(sizeof(RMStateInstructionContext_OnInitialize) == 0x000008, "Wrong size on RMStateInstructionContext_OnInitialize");
static_assert(offsetof(RMStateInstructionContext_OnInitialize, OwnerActor) == 0x000000, "Member 'RMStateInstructionContext_OnInitialize::OwnerActor' has a wrong offset!");

// Function X6Game.RMConfigContext_InAir.SetCrashSetting
// 0x0028 (0x0028 - 0x0000)
struct RMConfigContext_InAir_SetCrashSetting final
{
public:
	float                                         inCrashVelocityZ;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         inCrashGravity;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            inCrashGravityCurve;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         inCrashBrakingDecelerationFalling;                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         inCrashFallingLateralFriction;                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         inCrashAirControl;                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          inEnableLimitCrashMaxFallingSpeed;                 // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         inCrashMaxFallingSpeed;                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMConfigContext_InAir_SetCrashSetting) == 0x000008, "Wrong alignment on RMConfigContext_InAir_SetCrashSetting");
static_assert(sizeof(RMConfigContext_InAir_SetCrashSetting) == 0x000028, "Wrong size on RMConfigContext_InAir_SetCrashSetting");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashVelocityZ) == 0x000000, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashVelocityZ' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashGravity) == 0x000004, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashGravity' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashGravityCurve) == 0x000008, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashGravityCurve' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashBrakingDecelerationFalling) == 0x000010, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashFallingLateralFriction) == 0x000014, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashAirControl) == 0x000018, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashAirControl' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inEnableLimitCrashMaxFallingSpeed) == 0x00001C, "Member 'RMConfigContext_InAir_SetCrashSetting::inEnableLimitCrashMaxFallingSpeed' has a wrong offset!");
static_assert(offsetof(RMConfigContext_InAir_SetCrashSetting, inCrashMaxFallingSpeed) == 0x000020, "Member 'RMConfigContext_InAir_SetCrashSetting::inCrashMaxFallingSpeed' has a wrong offset!");

// Function X6Game.RMInputActionProcessor.OnInitialize
// 0x0008 (0x0008 - 0x0000)
struct RMInputActionProcessor_OnInitialize final
{
public:
	class URMProxyTickRecordInterface*            TickRecord;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_OnInitialize) == 0x000008, "Wrong alignment on RMInputActionProcessor_OnInitialize");
static_assert(sizeof(RMInputActionProcessor_OnInitialize) == 0x000008, "Wrong size on RMInputActionProcessor_OnInitialize");
static_assert(offsetof(RMInputActionProcessor_OnInitialize, TickRecord) == 0x000000, "Member 'RMInputActionProcessor_OnInitialize::TickRecord' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.CanCrash
// 0x0003 (0x0003 - 0x0000)
struct RMInputActionProcessor_InAir_CanCrash final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToDoAction;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_CanCrash) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_CanCrash");
static_assert(sizeof(RMInputActionProcessor_InAir_CanCrash) == 0x000003, "Wrong size on RMInputActionProcessor_InAir_CanCrash");
static_assert(offsetof(RMInputActionProcessor_InAir_CanCrash, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_CanCrash::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_CanCrash, NeedToDoAction) == 0x000001, "Member 'RMInputActionProcessor_InAir_CanCrash::NeedToDoAction' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_CanCrash, ReturnValue) == 0x000002, "Member 'RMInputActionProcessor_InAir_CanCrash::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.CanFloat
// 0x0002 (0x0002 - 0x0000)
struct RMInputActionProcessor_InAir_CanFloat final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_CanFloat) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_CanFloat");
static_assert(sizeof(RMInputActionProcessor_InAir_CanFloat) == 0x000002, "Wrong size on RMInputActionProcessor_InAir_CanFloat");
static_assert(offsetof(RMInputActionProcessor_InAir_CanFloat, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_CanFloat::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_CanFloat, ReturnValue) == 0x000001, "Member 'RMInputActionProcessor_InAir_CanFloat::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.CanJump
// 0x0003 (0x0003 - 0x0000)
struct RMInputActionProcessor_InAir_CanJump final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToDoAction;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_CanJump) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_CanJump");
static_assert(sizeof(RMInputActionProcessor_InAir_CanJump) == 0x000003, "Wrong size on RMInputActionProcessor_InAir_CanJump");
static_assert(offsetof(RMInputActionProcessor_InAir_CanJump, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_CanJump::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_CanJump, NeedToDoAction) == 0x000001, "Member 'RMInputActionProcessor_InAir_CanJump::NeedToDoAction' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_CanJump, ReturnValue) == 0x000002, "Member 'RMInputActionProcessor_InAir_CanJump::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.DoCrash
// 0x0002 (0x0002 - 0x0000)
struct RMInputActionProcessor_InAir_DoCrash final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_DoCrash) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_DoCrash");
static_assert(sizeof(RMInputActionProcessor_InAir_DoCrash) == 0x000002, "Wrong size on RMInputActionProcessor_InAir_DoCrash");
static_assert(offsetof(RMInputActionProcessor_InAir_DoCrash, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_DoCrash::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_DoCrash, ReturnValue) == 0x000001, "Member 'RMInputActionProcessor_InAir_DoCrash::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.DoFall
// 0x0002 (0x0002 - 0x0000)
struct RMInputActionProcessor_InAir_DoFall final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_DoFall) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_DoFall");
static_assert(sizeof(RMInputActionProcessor_InAir_DoFall) == 0x000002, "Wrong size on RMInputActionProcessor_InAir_DoFall");
static_assert(offsetof(RMInputActionProcessor_InAir_DoFall, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_DoFall::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_DoFall, ReturnValue) == 0x000001, "Member 'RMInputActionProcessor_InAir_DoFall::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.DoFloat
// 0x0002 (0x0002 - 0x0000)
struct RMInputActionProcessor_InAir_DoFloat final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_DoFloat) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_DoFloat");
static_assert(sizeof(RMInputActionProcessor_InAir_DoFloat) == 0x000002, "Wrong size on RMInputActionProcessor_InAir_DoFloat");
static_assert(offsetof(RMInputActionProcessor_InAir_DoFloat, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_DoFloat::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_DoFloat, ReturnValue) == 0x000001, "Member 'RMInputActionProcessor_InAir_DoFloat::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.DoJump
// 0x0003 (0x0003 - 0x0000)
struct RMInputActionProcessor_InAir_DoJump final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularJumpMode                              NewRegularJumpMode;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_DoJump) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_DoJump");
static_assert(sizeof(RMInputActionProcessor_InAir_DoJump) == 0x000003, "Wrong size on RMInputActionProcessor_InAir_DoJump");
static_assert(offsetof(RMInputActionProcessor_InAir_DoJump, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_DoJump::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_DoJump, NewRegularJumpMode) == 0x000001, "Member 'RMInputActionProcessor_InAir_DoJump::NewRegularJumpMode' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_DoJump, ReturnValue) == 0x000002, "Member 'RMInputActionProcessor_InAir_DoJump::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.DoLand
// 0x0002 (0x0002 - 0x0000)
struct RMInputActionProcessor_InAir_DoLand final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_DoLand) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_DoLand");
static_assert(sizeof(RMInputActionProcessor_InAir_DoLand) == 0x000002, "Wrong size on RMInputActionProcessor_InAir_DoLand");
static_assert(offsetof(RMInputActionProcessor_InAir_DoLand, bForce) == 0x000000, "Member 'RMInputActionProcessor_InAir_DoLand::bForce' has a wrong offset!");
static_assert(offsetof(RMInputActionProcessor_InAir_DoLand, ReturnValue) == 0x000001, "Member 'RMInputActionProcessor_InAir_DoLand::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.DoReleaseToFall
// 0x0001 (0x0001 - 0x0000)
struct RMInputActionProcessor_InAir_DoReleaseToFall final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_DoReleaseToFall) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_DoReleaseToFall");
static_assert(sizeof(RMInputActionProcessor_InAir_DoReleaseToFall) == 0x000001, "Wrong size on RMInputActionProcessor_InAir_DoReleaseToFall");
static_assert(offsetof(RMInputActionProcessor_InAir_DoReleaseToFall, ReturnValue) == 0x000000, "Member 'RMInputActionProcessor_InAir_DoReleaseToFall::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.EnterFloatByJumpApex
// 0x0001 (0x0001 - 0x0000)
struct RMInputActionProcessor_InAir_EnterFloatByJumpApex final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_EnterFloatByJumpApex) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_EnterFloatByJumpApex");
static_assert(sizeof(RMInputActionProcessor_InAir_EnterFloatByJumpApex) == 0x000001, "Wrong size on RMInputActionProcessor_InAir_EnterFloatByJumpApex");
static_assert(offsetof(RMInputActionProcessor_InAir_EnterFloatByJumpApex, ReturnValue) == 0x000000, "Member 'RMInputActionProcessor_InAir_EnterFloatByJumpApex::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.GetStateMachineContext
// 0x0008 (0x0008 - 0x0000)
struct RMInputActionProcessor_InAir_GetStateMachineContext final
{
public:
	class URMStateMachineContext_InAir*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_GetStateMachineContext) == 0x000008, "Wrong alignment on RMInputActionProcessor_InAir_GetStateMachineContext");
static_assert(sizeof(RMInputActionProcessor_InAir_GetStateMachineContext) == 0x000008, "Wrong size on RMInputActionProcessor_InAir_GetStateMachineContext");
static_assert(offsetof(RMInputActionProcessor_InAir_GetStateMachineContext, ReturnValue) == 0x000000, "Member 'RMInputActionProcessor_InAir_GetStateMachineContext::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.Handle_DetermineActionSlotJumpIsAvailable
// 0x0001 (0x0001 - 0x0000)
struct RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable) == 0x000001, "Wrong alignment on RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable");
static_assert(sizeof(RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable) == 0x000001, "Wrong size on RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable");
static_assert(offsetof(RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable, ReturnValue) == 0x000000, "Member 'RMInputActionProcessor_InAir_Handle_DetermineActionSlotJumpIsAvailable::ReturnValue' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.ProcessActionAndState
// 0x0004 (0x0004 - 0x0000)
struct RMInputActionProcessor_InAir_ProcessActionAndState final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_ProcessActionAndState) == 0x000004, "Wrong alignment on RMInputActionProcessor_InAir_ProcessActionAndState");
static_assert(sizeof(RMInputActionProcessor_InAir_ProcessActionAndState) == 0x000004, "Wrong size on RMInputActionProcessor_InAir_ProcessActionAndState");
static_assert(offsetof(RMInputActionProcessor_InAir_ProcessActionAndState, DeltaTime) == 0x000000, "Member 'RMInputActionProcessor_InAir_ProcessActionAndState::DeltaTime' has a wrong offset!");

// Function X6Game.RMInputActionProcessor_InAir.SetStateMachineContext
// 0x0008 (0x0008 - 0x0000)
struct RMInputActionProcessor_InAir_SetStateMachineContext final
{
public:
	class URMStateMachineContext_InAir*           inStateMachineContext;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMInputActionProcessor_InAir_SetStateMachineContext) == 0x000008, "Wrong alignment on RMInputActionProcessor_InAir_SetStateMachineContext");
static_assert(sizeof(RMInputActionProcessor_InAir_SetStateMachineContext) == 0x000008, "Wrong size on RMInputActionProcessor_InAir_SetStateMachineContext");
static_assert(offsetof(RMInputActionProcessor_InAir_SetStateMachineContext, inStateMachineContext) == 0x000000, "Member 'RMInputActionProcessor_InAir_SetStateMachineContext::inStateMachineContext' has a wrong offset!");

// Function X6Game.RMOutputContext_InAir.GetOverrideGravityScale
// 0x0004 (0x0004 - 0x0000)
struct RMOutputContext_InAir_GetOverrideGravityScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_InAir_GetOverrideGravityScale) == 0x000004, "Wrong alignment on RMOutputContext_InAir_GetOverrideGravityScale");
static_assert(sizeof(RMOutputContext_InAir_GetOverrideGravityScale) == 0x000004, "Wrong size on RMOutputContext_InAir_GetOverrideGravityScale");
static_assert(offsetof(RMOutputContext_InAir_GetOverrideGravityScale, ReturnValue) == 0x000000, "Member 'RMOutputContext_InAir_GetOverrideGravityScale::ReturnValue' has a wrong offset!");

// Function X6Game.RMOutputContext_InAir.GetStageDuration
// 0x0008 (0x0008 - 0x0000)
struct RMOutputContext_InAir_GetStageDuration final
{
public:
	ERegularFloatingJumpStage                     InStage;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_InAir_GetStageDuration) == 0x000004, "Wrong alignment on RMOutputContext_InAir_GetStageDuration");
static_assert(sizeof(RMOutputContext_InAir_GetStageDuration) == 0x000008, "Wrong size on RMOutputContext_InAir_GetStageDuration");
static_assert(offsetof(RMOutputContext_InAir_GetStageDuration, InStage) == 0x000000, "Member 'RMOutputContext_InAir_GetStageDuration::InStage' has a wrong offset!");
static_assert(offsetof(RMOutputContext_InAir_GetStageDuration, ReturnValue) == 0x000004, "Member 'RMOutputContext_InAir_GetStageDuration::ReturnValue' has a wrong offset!");

// Function X6Game.RMOutputContext_InAir.SetOverrideGravityScale
// 0x0008 (0x0008 - 0x0000)
struct RMOutputContext_InAir_SetOverrideGravityScale final
{
public:
	float                                         GravityScale;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularFloatingJumpStage                     InStage;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMOutputContext_InAir_SetOverrideGravityScale) == 0x000004, "Wrong alignment on RMOutputContext_InAir_SetOverrideGravityScale");
static_assert(sizeof(RMOutputContext_InAir_SetOverrideGravityScale) == 0x000008, "Wrong size on RMOutputContext_InAir_SetOverrideGravityScale");
static_assert(offsetof(RMOutputContext_InAir_SetOverrideGravityScale, GravityScale) == 0x000000, "Member 'RMOutputContext_InAir_SetOverrideGravityScale::GravityScale' has a wrong offset!");
static_assert(offsetof(RMOutputContext_InAir_SetOverrideGravityScale, InStage) == 0x000004, "Member 'RMOutputContext_InAir_SetOverrideGravityScale::InStage' has a wrong offset!");

// Function X6Game.RMOutputContext_InAir.SetStageDuration
// 0x0008 (0x0008 - 0x0000)
struct RMOutputContext_InAir_SetStageDuration final
{
public:
	ERegularFloatingJumpStage                     InStage;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         inDuration;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_InAir_SetStageDuration) == 0x000004, "Wrong alignment on RMOutputContext_InAir_SetStageDuration");
static_assert(sizeof(RMOutputContext_InAir_SetStageDuration) == 0x000008, "Wrong size on RMOutputContext_InAir_SetStageDuration");
static_assert(offsetof(RMOutputContext_InAir_SetStageDuration, InStage) == 0x000000, "Member 'RMOutputContext_InAir_SetStageDuration::InStage' has a wrong offset!");
static_assert(offsetof(RMOutputContext_InAir_SetStageDuration, inDuration) == 0x000004, "Member 'RMOutputContext_InAir_SetStageDuration::inDuration' has a wrong offset!");

// Function X6Game.RMOutputContext_InAir.UpdateStateDuration
// 0x0004 (0x0004 - 0x0000)
struct RMOutputContext_InAir_UpdateStateDuration final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_InAir_UpdateStateDuration) == 0x000004, "Wrong alignment on RMOutputContext_InAir_UpdateStateDuration");
static_assert(sizeof(RMOutputContext_InAir_UpdateStateDuration) == 0x000004, "Wrong size on RMOutputContext_InAir_UpdateStateDuration");
static_assert(offsetof(RMOutputContext_InAir_UpdateStateDuration, DeltaSeconds) == 0x000000, "Member 'RMOutputContext_InAir_UpdateStateDuration::DeltaSeconds' has a wrong offset!");

// Function X6Game.RMOutputContext_OnGround.CanSwitchToNewAllowedGait
// 0x0002 (0x0002 - 0x0000)
struct RMOutputContext_OnGround_CanSwitchToNewAllowedGait final
{
public:
	ERegularLocomotionType                        NewAllowedGait;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_OnGround_CanSwitchToNewAllowedGait) == 0x000001, "Wrong alignment on RMOutputContext_OnGround_CanSwitchToNewAllowedGait");
static_assert(sizeof(RMOutputContext_OnGround_CanSwitchToNewAllowedGait) == 0x000002, "Wrong size on RMOutputContext_OnGround_CanSwitchToNewAllowedGait");
static_assert(offsetof(RMOutputContext_OnGround_CanSwitchToNewAllowedGait, NewAllowedGait) == 0x000000, "Member 'RMOutputContext_OnGround_CanSwitchToNewAllowedGait::NewAllowedGait' has a wrong offset!");
static_assert(offsetof(RMOutputContext_OnGround_CanSwitchToNewAllowedGait, ReturnValue) == 0x000001, "Member 'RMOutputContext_OnGround_CanSwitchToNewAllowedGait::ReturnValue' has a wrong offset!");

// Function X6Game.RMOutputContext_OnGround.TryToSwitchSprintGait
// 0x0001 (0x0001 - 0x0000)
struct RMOutputContext_OnGround_TryToSwitchSprintGait final
{
public:
	bool                                          bEnterSprint;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_OnGround_TryToSwitchSprintGait) == 0x000001, "Wrong alignment on RMOutputContext_OnGround_TryToSwitchSprintGait");
static_assert(sizeof(RMOutputContext_OnGround_TryToSwitchSprintGait) == 0x000001, "Wrong size on RMOutputContext_OnGround_TryToSwitchSprintGait");
static_assert(offsetof(RMOutputContext_OnGround_TryToSwitchSprintGait, bEnterSprint) == 0x000000, "Member 'RMOutputContext_OnGround_TryToSwitchSprintGait::bEnterSprint' has a wrong offset!");

// Function X6Game.RMOutputContext_OnGround.TryToSwitchWalkOrRunGait
// 0x0001 (0x0001 - 0x0000)
struct RMOutputContext_OnGround_TryToSwitchWalkOrRunGait final
{
public:
	bool                                          bWalkOrRun;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMOutputContext_OnGround_TryToSwitchWalkOrRunGait) == 0x000001, "Wrong alignment on RMOutputContext_OnGround_TryToSwitchWalkOrRunGait");
static_assert(sizeof(RMOutputContext_OnGround_TryToSwitchWalkOrRunGait) == 0x000001, "Wrong size on RMOutputContext_OnGround_TryToSwitchWalkOrRunGait");
static_assert(offsetof(RMOutputContext_OnGround_TryToSwitchWalkOrRunGait, bWalkOrRun) == 0x000000, "Member 'RMOutputContext_OnGround_TryToSwitchWalkOrRunGait::bWalkOrRun' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.CanAutoDoFloatWhenReachingApex
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex");
static_assert(sizeof(RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex) == 0x000001, "Wrong size on RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex");
static_assert(offsetof(RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_CanAutoDoFloatWhenReachingApex::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.CanAutoDoJumpInAirWhenReachingApex
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex");
static_assert(sizeof(RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex) == 0x000001, "Wrong size on RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex");
static_assert(offsetof(RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_CanAutoDoJumpInAirWhenReachingApex::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.CanReleaseToFall
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_CanReleaseToFall final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_CanReleaseToFall) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_CanReleaseToFall");
static_assert(sizeof(RMPTickRecord_InAir_CanReleaseToFall) == 0x000001, "Wrong size on RMPTickRecord_InAir_CanReleaseToFall");
static_assert(offsetof(RMPTickRecord_InAir_CanReleaseToFall, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_CanReleaseToFall::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.ClearTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct RMPTickRecord_InAir_ClearTimerHandle final
{
public:
	struct FTimerHandle                           TimerHandle;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_ClearTimerHandle) == 0x000008, "Wrong alignment on RMPTickRecord_InAir_ClearTimerHandle");
static_assert(sizeof(RMPTickRecord_InAir_ClearTimerHandle) == 0x000008, "Wrong size on RMPTickRecord_InAir_ClearTimerHandle");
static_assert(offsetof(RMPTickRecord_InAir_ClearTimerHandle, TimerHandle) == 0x000000, "Member 'RMPTickRecord_InAir_ClearTimerHandle::TimerHandle' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.GetCharacterMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct RMPTickRecord_InAir_GetCharacterMovementComponent final
{
public:
	class UCharacterMovementComponent*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_GetCharacterMovementComponent) == 0x000008, "Wrong alignment on RMPTickRecord_InAir_GetCharacterMovementComponent");
static_assert(sizeof(RMPTickRecord_InAir_GetCharacterMovementComponent) == 0x000008, "Wrong size on RMPTickRecord_InAir_GetCharacterMovementComponent");
static_assert(offsetof(RMPTickRecord_InAir_GetCharacterMovementComponent, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_GetCharacterMovementComponent::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.HasFloatAbility
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_HasFloatAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_HasFloatAbility) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_HasFloatAbility");
static_assert(sizeof(RMPTickRecord_InAir_HasFloatAbility) == 0x000001, "Wrong size on RMPTickRecord_InAir_HasFloatAbility");
static_assert(offsetof(RMPTickRecord_InAir_HasFloatAbility, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_HasFloatAbility::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.HasJumpAbility
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_HasJumpAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_HasJumpAbility) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_HasJumpAbility");
static_assert(sizeof(RMPTickRecord_InAir_HasJumpAbility) == 0x000001, "Wrong size on RMPTickRecord_InAir_HasJumpAbility");
static_assert(offsetof(RMPTickRecord_InAir_HasJumpAbility, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_HasJumpAbility::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsApex
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsApex final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsApex) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsApex");
static_assert(sizeof(RMPTickRecord_InAir_IsApex) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsApex");
static_assert(offsetof(RMPTickRecord_InAir_IsApex, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsApex::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsBeforeApex
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsBeforeApex final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsBeforeApex) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsBeforeApex");
static_assert(sizeof(RMPTickRecord_InAir_IsBeforeApex) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsBeforeApex");
static_assert(offsetof(RMPTickRecord_InAir_IsBeforeApex, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsBeforeApex::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsInCrashStage
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsInCrashStage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsInCrashStage) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsInCrashStage");
static_assert(sizeof(RMPTickRecord_InAir_IsInCrashStage) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsInCrashStage");
static_assert(offsetof(RMPTickRecord_InAir_IsInCrashStage, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsInCrashStage::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsInFallStage
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsInFallStage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsInFallStage) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsInFallStage");
static_assert(sizeof(RMPTickRecord_InAir_IsInFallStage) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsInFallStage");
static_assert(offsetof(RMPTickRecord_InAir_IsInFallStage, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsInFallStage::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsInFloatStage
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsInFloatStage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsInFloatStage) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsInFloatStage");
static_assert(sizeof(RMPTickRecord_InAir_IsInFloatStage) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsInFloatStage");
static_assert(offsetof(RMPTickRecord_InAir_IsInFloatStage, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsInFloatStage::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsInJumpStage
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsInJumpStage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsInJumpStage) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsInJumpStage");
static_assert(sizeof(RMPTickRecord_InAir_IsInJumpStage) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsInJumpStage");
static_assert(offsetof(RMPTickRecord_InAir_IsInJumpStage, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsInJumpStage::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsOnLand
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsOnLand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsOnLand) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsOnLand");
static_assert(sizeof(RMPTickRecord_InAir_IsOnLand) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsOnLand");
static_assert(offsetof(RMPTickRecord_InAir_IsOnLand, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsOnLand::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.IsUseDoubleJumpZVelocity
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_IsUseDoubleJumpZVelocity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_IsUseDoubleJumpZVelocity) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_IsUseDoubleJumpZVelocity");
static_assert(sizeof(RMPTickRecord_InAir_IsUseDoubleJumpZVelocity) == 0x000001, "Wrong size on RMPTickRecord_InAir_IsUseDoubleJumpZVelocity");
static_assert(offsetof(RMPTickRecord_InAir_IsUseDoubleJumpZVelocity, ReturnValue) == 0x000000, "Member 'RMPTickRecord_InAir_IsUseDoubleJumpZVelocity::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.SetOverrideGravityScale
// 0x0008 (0x0008 - 0x0000)
struct RMPTickRecord_InAir_SetOverrideGravityScale final
{
public:
	float                                         NewGravityScale;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularFloatingJumpStage                     JumpStage;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RMPTickRecord_InAir_SetOverrideGravityScale) == 0x000004, "Wrong alignment on RMPTickRecord_InAir_SetOverrideGravityScale");
static_assert(sizeof(RMPTickRecord_InAir_SetOverrideGravityScale) == 0x000008, "Wrong size on RMPTickRecord_InAir_SetOverrideGravityScale");
static_assert(offsetof(RMPTickRecord_InAir_SetOverrideGravityScale, NewGravityScale) == 0x000000, "Member 'RMPTickRecord_InAir_SetOverrideGravityScale::NewGravityScale' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetOverrideGravityScale, JumpStage) == 0x000004, "Member 'RMPTickRecord_InAir_SetOverrideGravityScale::JumpStage' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.SetRegularJumpMode
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_InAir_SetRegularJumpMode final
{
public:
	ERegularJumpMode                              NewRegularJumpMode;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_SetRegularJumpMode) == 0x000001, "Wrong alignment on RMPTickRecord_InAir_SetRegularJumpMode");
static_assert(sizeof(RMPTickRecord_InAir_SetRegularJumpMode) == 0x000001, "Wrong size on RMPTickRecord_InAir_SetRegularJumpMode");
static_assert(offsetof(RMPTickRecord_InAir_SetRegularJumpMode, NewRegularJumpMode) == 0x000000, "Member 'RMPTickRecord_InAir_SetRegularJumpMode::NewRegularJumpMode' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.SetTimer
// 0x0030 (0x0030 - 0x0000)
struct RMPTickRecord_InAir_SetTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialStartDelay;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelayVariance;                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_SetTimer) == 0x000008, "Wrong alignment on RMPTickRecord_InAir_SetTimer");
static_assert(sizeof(RMPTickRecord_InAir_SetTimer) == 0x000030, "Wrong size on RMPTickRecord_InAir_SetTimer");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, Object) == 0x000000, "Member 'RMPTickRecord_InAir_SetTimer::Object' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, FunctionName) == 0x000008, "Member 'RMPTickRecord_InAir_SetTimer::FunctionName' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, Time) == 0x000018, "Member 'RMPTickRecord_InAir_SetTimer::Time' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, bLooping) == 0x00001C, "Member 'RMPTickRecord_InAir_SetTimer::bLooping' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, InitialStartDelay) == 0x000020, "Member 'RMPTickRecord_InAir_SetTimer::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, InitialStartDelayVariance) == 0x000024, "Member 'RMPTickRecord_InAir_SetTimer::InitialStartDelayVariance' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_InAir_SetTimer, ReturnValue) == 0x000028, "Member 'RMPTickRecord_InAir_SetTimer::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_InAir.UpdateAccumulateTime_InMovementModeFalling
// 0x0004 (0x0004 - 0x0000)
struct RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling) == 0x000004, "Wrong alignment on RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling");
static_assert(sizeof(RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling) == 0x000004, "Wrong size on RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling");
static_assert(offsetof(RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling, DeltaTime) == 0x000000, "Member 'RMPTickRecord_InAir_UpdateAccumulateTime_InMovementModeFalling::DeltaTime' has a wrong offset!");

// Function X6Game.RMPTickRecord_OnGround.CanChangeCurDesiredGaitToNewGait
// 0x0002 (0x0002 - 0x0000)
struct RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait final
{
public:
	ERegularLocomotionType                        Gait;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait) == 0x000001, "Wrong alignment on RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait");
static_assert(sizeof(RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait) == 0x000002, "Wrong size on RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait");
static_assert(offsetof(RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait, Gait) == 0x000000, "Member 'RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait::Gait' has a wrong offset!");
static_assert(offsetof(RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait, ReturnValue) == 0x000001, "Member 'RMPTickRecord_OnGround_CanChangeCurDesiredGaitToNewGait::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_OnGround.HasSprintAbility
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_OnGround_HasSprintAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_OnGround_HasSprintAbility) == 0x000001, "Wrong alignment on RMPTickRecord_OnGround_HasSprintAbility");
static_assert(sizeof(RMPTickRecord_OnGround_HasSprintAbility) == 0x000001, "Wrong size on RMPTickRecord_OnGround_HasSprintAbility");
static_assert(offsetof(RMPTickRecord_OnGround_HasSprintAbility, ReturnValue) == 0x000000, "Member 'RMPTickRecord_OnGround_HasSprintAbility::ReturnValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_OnGround.SwitchRequiringSprintOperation
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_OnGround_SwitchRequiringSprintOperation final
{
public:
	bool                                          InputBoolValue;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_OnGround_SwitchRequiringSprintOperation) == 0x000001, "Wrong alignment on RMPTickRecord_OnGround_SwitchRequiringSprintOperation");
static_assert(sizeof(RMPTickRecord_OnGround_SwitchRequiringSprintOperation) == 0x000001, "Wrong size on RMPTickRecord_OnGround_SwitchRequiringSprintOperation");
static_assert(offsetof(RMPTickRecord_OnGround_SwitchRequiringSprintOperation, InputBoolValue) == 0x000000, "Member 'RMPTickRecord_OnGround_SwitchRequiringSprintOperation::InputBoolValue' has a wrong offset!");

// Function X6Game.RMPTickRecord_OnGround.SwitchRequiringWalkOperation
// 0x0001 (0x0001 - 0x0000)
struct RMPTickRecord_OnGround_SwitchRequiringWalkOperation final
{
public:
	bool                                          InputBoolValue;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMPTickRecord_OnGround_SwitchRequiringWalkOperation) == 0x000001, "Wrong alignment on RMPTickRecord_OnGround_SwitchRequiringWalkOperation");
static_assert(sizeof(RMPTickRecord_OnGround_SwitchRequiringWalkOperation) == 0x000001, "Wrong size on RMPTickRecord_OnGround_SwitchRequiringWalkOperation");
static_assert(offsetof(RMPTickRecord_OnGround_SwitchRequiringWalkOperation, InputBoolValue) == 0x000000, "Member 'RMPTickRecord_OnGround_SwitchRequiringWalkOperation::InputBoolValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.BP_ChangeJumpStage
// 0x0002 (0x0002 - 0x0000)
struct RMStateMachineContext_InAir_BP_ChangeJumpStage final
{
public:
	ERegularFloatingJumpStage                     NewStage;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_BP_ChangeJumpStage) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_BP_ChangeJumpStage");
static_assert(sizeof(RMStateMachineContext_InAir_BP_ChangeJumpStage) == 0x000002, "Wrong size on RMStateMachineContext_InAir_BP_ChangeJumpStage");
static_assert(offsetof(RMStateMachineContext_InAir_BP_ChangeJumpStage, NewStage) == 0x000000, "Member 'RMStateMachineContext_InAir_BP_ChangeJumpStage::NewStage' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_BP_ChangeJumpStage, bForceUpdate) == 0x000001, "Member 'RMStateMachineContext_InAir_BP_ChangeJumpStage::bForceUpdate' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.BP_Handle_StageChanged
// 0x0002 (0x0002 - 0x0000)
struct RMStateMachineContext_InAir_BP_Handle_StageChanged final
{
public:
	ERegularFloatingJumpStage                     PreviousStage;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularFloatingJumpStage                     NewStage;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_BP_Handle_StageChanged) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_BP_Handle_StageChanged");
static_assert(sizeof(RMStateMachineContext_InAir_BP_Handle_StageChanged) == 0x000002, "Wrong size on RMStateMachineContext_InAir_BP_Handle_StageChanged");
static_assert(offsetof(RMStateMachineContext_InAir_BP_Handle_StageChanged, PreviousStage) == 0x000000, "Member 'RMStateMachineContext_InAir_BP_Handle_StageChanged::PreviousStage' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_BP_Handle_StageChanged, NewStage) == 0x000001, "Member 'RMStateMachineContext_InAir_BP_Handle_StageChanged::NewStage' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.CanCrash
// 0x0001 (0x0001 - 0x0000)
struct RMStateMachineContext_InAir_CanCrash final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_CanCrash) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_CanCrash");
static_assert(sizeof(RMStateMachineContext_InAir_CanCrash) == 0x000001, "Wrong size on RMStateMachineContext_InAir_CanCrash");
static_assert(offsetof(RMStateMachineContext_InAir_CanCrash, ReturnValue) == 0x000000, "Member 'RMStateMachineContext_InAir_CanCrash::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.CanDoFloat
// 0x0002 (0x0002 - 0x0000)
struct RMStateMachineContext_InAir_CanDoFloat final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_CanDoFloat) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_CanDoFloat");
static_assert(sizeof(RMStateMachineContext_InAir_CanDoFloat) == 0x000002, "Wrong size on RMStateMachineContext_InAir_CanDoFloat");
static_assert(offsetof(RMStateMachineContext_InAir_CanDoFloat, bForce) == 0x000000, "Member 'RMStateMachineContext_InAir_CanDoFloat::bForce' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_CanDoFloat, ReturnValue) == 0x000001, "Member 'RMStateMachineContext_InAir_CanDoFloat::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.CanJump
// 0x0003 (0x0003 - 0x0000)
struct RMStateMachineContext_InAir_CanJump final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToDoAction;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_CanJump) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_CanJump");
static_assert(sizeof(RMStateMachineContext_InAir_CanJump) == 0x000003, "Wrong size on RMStateMachineContext_InAir_CanJump");
static_assert(offsetof(RMStateMachineContext_InAir_CanJump, bForce) == 0x000000, "Member 'RMStateMachineContext_InAir_CanJump::bForce' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_CanJump, NeedToDoAction) == 0x000001, "Member 'RMStateMachineContext_InAir_CanJump::NeedToDoAction' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_CanJump, ReturnValue) == 0x000002, "Member 'RMStateMachineContext_InAir_CanJump::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.CanMultipleJump
// 0x0003 (0x0003 - 0x0000)
struct RMStateMachineContext_InAir_CanMultipleJump final
{
public:
	ERegularJumpMode                              NewRegularJumpMode;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToDoAction;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_CanMultipleJump) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_CanMultipleJump");
static_assert(sizeof(RMStateMachineContext_InAir_CanMultipleJump) == 0x000003, "Wrong size on RMStateMachineContext_InAir_CanMultipleJump");
static_assert(offsetof(RMStateMachineContext_InAir_CanMultipleJump, NewRegularJumpMode) == 0x000000, "Member 'RMStateMachineContext_InAir_CanMultipleJump::NewRegularJumpMode' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_CanMultipleJump, NeedToDoAction) == 0x000001, "Member 'RMStateMachineContext_InAir_CanMultipleJump::NeedToDoAction' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_CanMultipleJump, ReturnValue) == 0x000002, "Member 'RMStateMachineContext_InAir_CanMultipleJump::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.ChangeJumpStage
// 0x0002 (0x0002 - 0x0000)
struct RMStateMachineContext_InAir_ChangeJumpStage final
{
public:
	ERegularFloatingJumpStage                     NewStage;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_ChangeJumpStage) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_ChangeJumpStage");
static_assert(sizeof(RMStateMachineContext_InAir_ChangeJumpStage) == 0x000002, "Wrong size on RMStateMachineContext_InAir_ChangeJumpStage");
static_assert(offsetof(RMStateMachineContext_InAir_ChangeJumpStage, NewStage) == 0x000000, "Member 'RMStateMachineContext_InAir_ChangeJumpStage::NewStage' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_ChangeJumpStage, bForceUpdate) == 0x000001, "Member 'RMStateMachineContext_InAir_ChangeJumpStage::bForceUpdate' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.DoFall
// 0x0002 (0x0002 - 0x0000)
struct RMStateMachineContext_InAir_DoFall final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_DoFall) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_DoFall");
static_assert(sizeof(RMStateMachineContext_InAir_DoFall) == 0x000002, "Wrong size on RMStateMachineContext_InAir_DoFall");
static_assert(offsetof(RMStateMachineContext_InAir_DoFall, bForce) == 0x000000, "Member 'RMStateMachineContext_InAir_DoFall::bForce' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_DoFall, ReturnValue) == 0x000001, "Member 'RMStateMachineContext_InAir_DoFall::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.DoFloat
// 0x0002 (0x0002 - 0x0000)
struct RMStateMachineContext_InAir_DoFloat final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_DoFloat) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_DoFloat");
static_assert(sizeof(RMStateMachineContext_InAir_DoFloat) == 0x000002, "Wrong size on RMStateMachineContext_InAir_DoFloat");
static_assert(offsetof(RMStateMachineContext_InAir_DoFloat, bForce) == 0x000000, "Member 'RMStateMachineContext_InAir_DoFloat::bForce' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_DoFloat, ReturnValue) == 0x000001, "Member 'RMStateMachineContext_InAir_DoFloat::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.DoJump
// 0x0003 (0x0003 - 0x0000)
struct RMStateMachineContext_InAir_DoJump final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularJumpMode                              NewRegularJumpMode;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_DoJump) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_DoJump");
static_assert(sizeof(RMStateMachineContext_InAir_DoJump) == 0x000003, "Wrong size on RMStateMachineContext_InAir_DoJump");
static_assert(offsetof(RMStateMachineContext_InAir_DoJump, bForce) == 0x000000, "Member 'RMStateMachineContext_InAir_DoJump::bForce' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_DoJump, NewRegularJumpMode) == 0x000001, "Member 'RMStateMachineContext_InAir_DoJump::NewRegularJumpMode' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_DoJump, ReturnValue) == 0x000002, "Member 'RMStateMachineContext_InAir_DoJump::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.DoMultipleJump
// 0x0003 (0x0003 - 0x0000)
struct RMStateMachineContext_InAir_DoMultipleJump final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularJumpMode                              NewRegularJumpMode;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_DoMultipleJump) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_DoMultipleJump");
static_assert(sizeof(RMStateMachineContext_InAir_DoMultipleJump) == 0x000003, "Wrong size on RMStateMachineContext_InAir_DoMultipleJump");
static_assert(offsetof(RMStateMachineContext_InAir_DoMultipleJump, bForce) == 0x000000, "Member 'RMStateMachineContext_InAir_DoMultipleJump::bForce' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_DoMultipleJump, NewRegularJumpMode) == 0x000001, "Member 'RMStateMachineContext_InAir_DoMultipleJump::NewRegularJumpMode' has a wrong offset!");
static_assert(offsetof(RMStateMachineContext_InAir_DoMultipleJump, ReturnValue) == 0x000002, "Member 'RMStateMachineContext_InAir_DoMultipleJump::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.DoReleaseToFall
// 0x0001 (0x0001 - 0x0000)
struct RMStateMachineContext_InAir_DoReleaseToFall final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_DoReleaseToFall) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_DoReleaseToFall");
static_assert(sizeof(RMStateMachineContext_InAir_DoReleaseToFall) == 0x000001, "Wrong size on RMStateMachineContext_InAir_DoReleaseToFall");
static_assert(offsetof(RMStateMachineContext_InAir_DoReleaseToFall, ReturnValue) == 0x000000, "Member 'RMStateMachineContext_InAir_DoReleaseToFall::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.Handle_DetermineActionSlotJumpIsAvailable
// 0x0001 (0x0001 - 0x0000)
struct RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable");
static_assert(sizeof(RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable) == 0x000001, "Wrong size on RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable");
static_assert(offsetof(RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable, ReturnValue) == 0x000000, "Member 'RMStateMachineContext_InAir_Handle_DetermineActionSlotJumpIsAvailable::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.HasFloatAbility
// 0x0001 (0x0001 - 0x0000)
struct RMStateMachineContext_InAir_HasFloatAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_HasFloatAbility) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_HasFloatAbility");
static_assert(sizeof(RMStateMachineContext_InAir_HasFloatAbility) == 0x000001, "Wrong size on RMStateMachineContext_InAir_HasFloatAbility");
static_assert(offsetof(RMStateMachineContext_InAir_HasFloatAbility, ReturnValue) == 0x000000, "Member 'RMStateMachineContext_InAir_HasFloatAbility::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.HasJumpAbility
// 0x0001 (0x0001 - 0x0000)
struct RMStateMachineContext_InAir_HasJumpAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_HasJumpAbility) == 0x000001, "Wrong alignment on RMStateMachineContext_InAir_HasJumpAbility");
static_assert(sizeof(RMStateMachineContext_InAir_HasJumpAbility) == 0x000001, "Wrong size on RMStateMachineContext_InAir_HasJumpAbility");
static_assert(offsetof(RMStateMachineContext_InAir_HasJumpAbility, ReturnValue) == 0x000000, "Member 'RMStateMachineContext_InAir_HasJumpAbility::ReturnValue' has a wrong offset!");

// Function X6Game.RMStateMachineContext_InAir.OnInitialize
// 0x0008 (0x0008 - 0x0000)
struct RMStateMachineContext_InAir_OnInitialize final
{
public:
	class URMProxyTickRecordInterface*            TickRecord;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RMStateMachineContext_InAir_OnInitialize) == 0x000008, "Wrong alignment on RMStateMachineContext_InAir_OnInitialize");
static_assert(sizeof(RMStateMachineContext_InAir_OnInitialize) == 0x000008, "Wrong size on RMStateMachineContext_InAir_OnInitialize");
static_assert(offsetof(RMStateMachineContext_InAir_OnInitialize, TickRecord) == 0x000000, "Member 'RMStateMachineContext_InAir_OnInitialize::TickRecord' has a wrong offset!");

// Function X6Game.ScreenShotManager.DoHighResShot
// 0x0010 (0x0010 - 0x0000)
struct ScreenShotManager_DoHighResShot final
{
public:
	class FString                                 Cmd;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenShotManager_DoHighResShot) == 0x000008, "Wrong alignment on ScreenShotManager_DoHighResShot");
static_assert(sizeof(ScreenShotManager_DoHighResShot) == 0x000010, "Wrong size on ScreenShotManager_DoHighResShot");
static_assert(offsetof(ScreenShotManager_DoHighResShot, Cmd) == 0x000000, "Member 'ScreenShotManager_DoHighResShot::Cmd' has a wrong offset!");

// Function X6Game.ScreenShotManager.DoShot
// 0x0001 (0x0001 - 0x0000)
struct ScreenShotManager_DoShot final
{
public:
	bool                                          bShowUI;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenShotManager_DoShot) == 0x000001, "Wrong alignment on ScreenShotManager_DoShot");
static_assert(sizeof(ScreenShotManager_DoShot) == 0x000001, "Wrong size on ScreenShotManager_DoShot");
static_assert(offsetof(ScreenShotManager_DoShot, bShowUI) == 0x000000, "Member 'ScreenShotManager_DoShot::bShowUI' has a wrong offset!");

// Function X6Game.ScreenShotManager.GetLastCapturedScreenShot
// 0x0008 (0x0008 - 0x0000)
struct ScreenShotManager_GetLastCapturedScreenShot final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenShotManager_GetLastCapturedScreenShot) == 0x000008, "Wrong alignment on ScreenShotManager_GetLastCapturedScreenShot");
static_assert(sizeof(ScreenShotManager_GetLastCapturedScreenShot) == 0x000008, "Wrong size on ScreenShotManager_GetLastCapturedScreenShot");
static_assert(offsetof(ScreenShotManager_GetLastCapturedScreenShot, ReturnValue) == 0x000000, "Member 'ScreenShotManager_GetLastCapturedScreenShot::ReturnValue' has a wrong offset!");

// Function X6Game.StimuliManager.AddStimuliSensor
// 0x0018 (0x0018 - 0x0000)
struct StimuliManager_AddStimuliSensor final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SenseRadius;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SenseHalfAngle;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliManager_AddStimuliSensor) == 0x000008, "Wrong alignment on StimuliManager_AddStimuliSensor");
static_assert(sizeof(StimuliManager_AddStimuliSensor) == 0x000018, "Wrong size on StimuliManager_AddStimuliSensor");
static_assert(offsetof(StimuliManager_AddStimuliSensor, Identifier) == 0x000000, "Member 'StimuliManager_AddStimuliSensor::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliManager_AddStimuliSensor, OwnerActor) == 0x000008, "Member 'StimuliManager_AddStimuliSensor::OwnerActor' has a wrong offset!");
static_assert(offsetof(StimuliManager_AddStimuliSensor, SenseRadius) == 0x000010, "Member 'StimuliManager_AddStimuliSensor::SenseRadius' has a wrong offset!");
static_assert(offsetof(StimuliManager_AddStimuliSensor, SenseHalfAngle) == 0x000014, "Member 'StimuliManager_AddStimuliSensor::SenseHalfAngle' has a wrong offset!");

// Function X6Game.StimuliManager.AddStimuliSource
// 0x0040 (0x0040 - 0x0000)
struct StimuliManager_AddStimuliSource final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitLocation;                                      // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStimuliSource                         StimuliSource;                                     // 0x0028(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliManager_AddStimuliSource) == 0x000008, "Wrong alignment on StimuliManager_AddStimuliSource");
static_assert(sizeof(StimuliManager_AddStimuliSource) == 0x000040, "Wrong size on StimuliManager_AddStimuliSource");
static_assert(offsetof(StimuliManager_AddStimuliSource, Identifier) == 0x000000, "Member 'StimuliManager_AddStimuliSource::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliManager_AddStimuliSource, Owner) == 0x000008, "Member 'StimuliManager_AddStimuliSource::Owner' has a wrong offset!");
static_assert(offsetof(StimuliManager_AddStimuliSource, InitLocation) == 0x000010, "Member 'StimuliManager_AddStimuliSource::InitLocation' has a wrong offset!");
static_assert(offsetof(StimuliManager_AddStimuliSource, StimuliSource) == 0x000028, "Member 'StimuliManager_AddStimuliSource::StimuliSource' has a wrong offset!");

// Function X6Game.StimuliManager.RemoveAllStimuliSource
// 0x0008 (0x0008 - 0x0000)
struct StimuliManager_RemoveAllStimuliSource final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliManager_RemoveAllStimuliSource) == 0x000008, "Wrong alignment on StimuliManager_RemoveAllStimuliSource");
static_assert(sizeof(StimuliManager_RemoveAllStimuliSource) == 0x000008, "Wrong size on StimuliManager_RemoveAllStimuliSource");
static_assert(offsetof(StimuliManager_RemoveAllStimuliSource, Identifier) == 0x000000, "Member 'StimuliManager_RemoveAllStimuliSource::Identifier' has a wrong offset!");

// Function X6Game.StimuliManager.RemoveMultiStimuliSource
// 0x0018 (0x0018 - 0x0000)
struct StimuliManager_RemoveMultiStimuliSource final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 StimuliTags;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliManager_RemoveMultiStimuliSource) == 0x000008, "Wrong alignment on StimuliManager_RemoveMultiStimuliSource");
static_assert(sizeof(StimuliManager_RemoveMultiStimuliSource) == 0x000018, "Wrong size on StimuliManager_RemoveMultiStimuliSource");
static_assert(offsetof(StimuliManager_RemoveMultiStimuliSource, Identifier) == 0x000000, "Member 'StimuliManager_RemoveMultiStimuliSource::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliManager_RemoveMultiStimuliSource, StimuliTags) == 0x000008, "Member 'StimuliManager_RemoveMultiStimuliSource::StimuliTags' has a wrong offset!");

// Function X6Game.StimuliManager.RemoveStimuliSensor
// 0x0008 (0x0008 - 0x0000)
struct StimuliManager_RemoveStimuliSensor final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliManager_RemoveStimuliSensor) == 0x000008, "Wrong alignment on StimuliManager_RemoveStimuliSensor");
static_assert(sizeof(StimuliManager_RemoveStimuliSensor) == 0x000008, "Wrong size on StimuliManager_RemoveStimuliSensor");
static_assert(offsetof(StimuliManager_RemoveStimuliSensor, Identifier) == 0x000000, "Member 'StimuliManager_RemoveStimuliSensor::Identifier' has a wrong offset!");

// Function X6Game.StimuliManager.RemoveStimuliSource
// 0x0010 (0x0010 - 0x0000)
struct StimuliManager_RemoveStimuliSource final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StimuliTag;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StimuliManager_RemoveStimuliSource) == 0x000008, "Wrong alignment on StimuliManager_RemoveStimuliSource");
static_assert(sizeof(StimuliManager_RemoveStimuliSource) == 0x000010, "Wrong size on StimuliManager_RemoveStimuliSource");
static_assert(offsetof(StimuliManager_RemoveStimuliSource, Identifier) == 0x000000, "Member 'StimuliManager_RemoveStimuliSource::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliManager_RemoveStimuliSource, StimuliTag) == 0x000008, "Member 'StimuliManager_RemoveStimuliSource::StimuliTag' has a wrong offset!");

// Function X6Game.StimuliManager.FindStimuliSource
// 0x0028 (0x0028 - 0x0000)
struct StimuliManager_FindStimuliSource final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StimuliTag;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStimuliSource                         OutSource;                                         // 0x000C(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StimuliManager_FindStimuliSource) == 0x000008, "Wrong alignment on StimuliManager_FindStimuliSource");
static_assert(sizeof(StimuliManager_FindStimuliSource) == 0x000028, "Wrong size on StimuliManager_FindStimuliSource");
static_assert(offsetof(StimuliManager_FindStimuliSource, Identifier) == 0x000000, "Member 'StimuliManager_FindStimuliSource::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliManager_FindStimuliSource, StimuliTag) == 0x000008, "Member 'StimuliManager_FindStimuliSource::StimuliTag' has a wrong offset!");
static_assert(offsetof(StimuliManager_FindStimuliSource, OutSource) == 0x00000C, "Member 'StimuliManager_FindStimuliSource::OutSource' has a wrong offset!");
static_assert(offsetof(StimuliManager_FindStimuliSource, ReturnValue) == 0x000024, "Member 'StimuliManager_FindStimuliSource::ReturnValue' has a wrong offset!");

// Function X6Game.StimuliManager.HasStimuliSourceSet
// 0x0010 (0x0010 - 0x0000)
struct StimuliManager_HasStimuliSourceSet final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StimuliManager_HasStimuliSourceSet) == 0x000008, "Wrong alignment on StimuliManager_HasStimuliSourceSet");
static_assert(sizeof(StimuliManager_HasStimuliSourceSet) == 0x000010, "Wrong size on StimuliManager_HasStimuliSourceSet");
static_assert(offsetof(StimuliManager_HasStimuliSourceSet, Identifier) == 0x000000, "Member 'StimuliManager_HasStimuliSourceSet::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliManager_HasStimuliSourceSet, ReturnValue) == 0x000008, "Member 'StimuliManager_HasStimuliSourceSet::ReturnValue' has a wrong offset!");

// Function X6Game.StimuliPreprocessSystem.OnActorDestroy
// 0x0008 (0x0008 - 0x0000)
struct StimuliPreprocessSystem_OnActorDestroy final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliPreprocessSystem_OnActorDestroy) == 0x000008, "Wrong alignment on StimuliPreprocessSystem_OnActorDestroy");
static_assert(sizeof(StimuliPreprocessSystem_OnActorDestroy) == 0x000008, "Wrong size on StimuliPreprocessSystem_OnActorDestroy");
static_assert(offsetof(StimuliPreprocessSystem_OnActorDestroy, DestroyedActor) == 0x000000, "Member 'StimuliPreprocessSystem_OnActorDestroy::DestroyedActor' has a wrong offset!");

// Function X6Game.StimuliPreprocessSystem.OnSenseStimuli
// 0x0048 (0x0048 - 0x0000)
struct StimuliPreprocessSystem_OnSenseStimuli final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StimuliTag;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SenseActors;                                       // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          IsPendingRemove;                                   // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StimuliPreprocessSystem_OnSenseStimuli) == 0x000008, "Wrong alignment on StimuliPreprocessSystem_OnSenseStimuli");
static_assert(sizeof(StimuliPreprocessSystem_OnSenseStimuli) == 0x000048, "Wrong size on StimuliPreprocessSystem_OnSenseStimuli");
static_assert(offsetof(StimuliPreprocessSystem_OnSenseStimuli, Identifier) == 0x000000, "Member 'StimuliPreprocessSystem_OnSenseStimuli::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnSenseStimuli, SourceLocation) == 0x000008, "Member 'StimuliPreprocessSystem_OnSenseStimuli::SourceLocation' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnSenseStimuli, SourceActor) == 0x000020, "Member 'StimuliPreprocessSystem_OnSenseStimuli::SourceActor' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnSenseStimuli, StimuliTag) == 0x000028, "Member 'StimuliPreprocessSystem_OnSenseStimuli::StimuliTag' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnSenseStimuli, SenseActors) == 0x000030, "Member 'StimuliPreprocessSystem_OnSenseStimuli::SenseActors' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnSenseStimuli, IsPendingRemove) == 0x000040, "Member 'StimuliPreprocessSystem_OnSenseStimuli::IsPendingRemove' has a wrong offset!");

// Function X6Game.StimuliPreprocessSystem.OnStimuliSourceSetRemoved
// 0x0018 (0x0018 - 0x0000)
struct StimuliPreprocessSystem_OnStimuliSourceSetRemoved final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StimuliTag;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliPreprocessSystem_OnStimuliSourceSetRemoved) == 0x000008, "Wrong alignment on StimuliPreprocessSystem_OnStimuliSourceSetRemoved");
static_assert(sizeof(StimuliPreprocessSystem_OnStimuliSourceSetRemoved) == 0x000018, "Wrong size on StimuliPreprocessSystem_OnStimuliSourceSetRemoved");
static_assert(offsetof(StimuliPreprocessSystem_OnStimuliSourceSetRemoved, Identifier) == 0x000000, "Member 'StimuliPreprocessSystem_OnStimuliSourceSetRemoved::Identifier' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnStimuliSourceSetRemoved, StimuliTag) == 0x000008, "Member 'StimuliPreprocessSystem_OnStimuliSourceSetRemoved::StimuliTag' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_OnStimuliSourceSetRemoved, OwnerActor) == 0x000010, "Member 'StimuliPreprocessSystem_OnStimuliSourceSetRemoved::OwnerActor' has a wrong offset!");

// Function X6Game.StimuliPreprocessSystem.RegisterPreprocessorRule
// 0x0078 (0x0078 - 0x0000)
struct StimuliPreprocessSystem_RegisterPreprocessorRule final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStimuliPreprocessorRule               Rule;                                              // 0x0008(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliPreprocessSystem_RegisterPreprocessorRule) == 0x000008, "Wrong alignment on StimuliPreprocessSystem_RegisterPreprocessorRule");
static_assert(sizeof(StimuliPreprocessSystem_RegisterPreprocessorRule) == 0x000078, "Wrong size on StimuliPreprocessSystem_RegisterPreprocessorRule");
static_assert(offsetof(StimuliPreprocessSystem_RegisterPreprocessorRule, OwnerActor) == 0x000000, "Member 'StimuliPreprocessSystem_RegisterPreprocessorRule::OwnerActor' has a wrong offset!");
static_assert(offsetof(StimuliPreprocessSystem_RegisterPreprocessorRule, Rule) == 0x000008, "Member 'StimuliPreprocessSystem_RegisterPreprocessorRule::Rule' has a wrong offset!");

// Function X6Game.StimuliPreprocessSystem.UnregisterPreprocessorRule
// 0x0008 (0x0008 - 0x0000)
struct StimuliPreprocessSystem_UnregisterPreprocessorRule final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StimuliPreprocessSystem_UnregisterPreprocessorRule) == 0x000008, "Wrong alignment on StimuliPreprocessSystem_UnregisterPreprocessorRule");
static_assert(sizeof(StimuliPreprocessSystem_UnregisterPreprocessorRule) == 0x000008, "Wrong size on StimuliPreprocessSystem_UnregisterPreprocessorRule");
static_assert(offsetof(StimuliPreprocessSystem_UnregisterPreprocessorRule, OwnerActor) == 0x000000, "Member 'StimuliPreprocessSystem_UnregisterPreprocessorRule::OwnerActor' has a wrong offset!");

// Function X6Game.TargetSystemComponent.CustomFilterTargets
// 0x0018 (0x0018 - 0x0000)
struct TargetSystemComponent_CustomFilterTargets final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_CustomFilterTargets) == 0x000008, "Wrong alignment on TargetSystemComponent_CustomFilterTargets");
static_assert(sizeof(TargetSystemComponent_CustomFilterTargets) == 0x000018, "Wrong size on TargetSystemComponent_CustomFilterTargets");
static_assert(offsetof(TargetSystemComponent_CustomFilterTargets, Actors) == 0x000000, "Member 'TargetSystemComponent_CustomFilterTargets::Actors' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_CustomFilterTargets, ReturnValue) == 0x000010, "Member 'TargetSystemComponent_CustomFilterTargets::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.ExcuteTargetSwitchCommand
// 0x0008 (0x0008 - 0x0000)
struct TargetSystemComponent_ExcuteTargetSwitchCommand final
{
public:
	class UTargetSwitchCommand*                   TargetSwitchCommand;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_ExcuteTargetSwitchCommand) == 0x000008, "Wrong alignment on TargetSystemComponent_ExcuteTargetSwitchCommand");
static_assert(sizeof(TargetSystemComponent_ExcuteTargetSwitchCommand) == 0x000008, "Wrong size on TargetSystemComponent_ExcuteTargetSwitchCommand");
static_assert(offsetof(TargetSystemComponent_ExcuteTargetSwitchCommand, TargetSwitchCommand) == 0x000000, "Member 'TargetSystemComponent_ExcuteTargetSwitchCommand::TargetSwitchCommand' has a wrong offset!");

// Function X6Game.TargetSystemComponent.GetCurrentCharacterInputVector
// 0x0018 (0x0018 - 0x0000)
struct TargetSystemComponent_GetCurrentCharacterInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_GetCurrentCharacterInputVector) == 0x000008, "Wrong alignment on TargetSystemComponent_GetCurrentCharacterInputVector");
static_assert(sizeof(TargetSystemComponent_GetCurrentCharacterInputVector) == 0x000018, "Wrong size on TargetSystemComponent_GetCurrentCharacterInputVector");
static_assert(offsetof(TargetSystemComponent_GetCurrentCharacterInputVector, ReturnValue) == 0x000000, "Member 'TargetSystemComponent_GetCurrentCharacterInputVector::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.GetSwitchTargetCommandByType
// 0x0010 (0x0010 - 0x0000)
struct TargetSystemComponent_GetSwitchTargetCommandByType final
{
public:
	ETargetSwitchMode                             TargetSwitchMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetSwitchCommand*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_GetSwitchTargetCommandByType) == 0x000008, "Wrong alignment on TargetSystemComponent_GetSwitchTargetCommandByType");
static_assert(sizeof(TargetSystemComponent_GetSwitchTargetCommandByType) == 0x000010, "Wrong size on TargetSystemComponent_GetSwitchTargetCommandByType");
static_assert(offsetof(TargetSystemComponent_GetSwitchTargetCommandByType, TargetSwitchMode) == 0x000000, "Member 'TargetSystemComponent_GetSwitchTargetCommandByType::TargetSwitchMode' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_GetSwitchTargetCommandByType, ReturnValue) == 0x000008, "Member 'TargetSystemComponent_GetSwitchTargetCommandByType::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.GetTargetLockedStatus
// 0x0001 (0x0001 - 0x0000)
struct TargetSystemComponent_GetTargetLockedStatus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_GetTargetLockedStatus) == 0x000001, "Wrong alignment on TargetSystemComponent_GetTargetLockedStatus");
static_assert(sizeof(TargetSystemComponent_GetTargetLockedStatus) == 0x000001, "Wrong size on TargetSystemComponent_GetTargetLockedStatus");
static_assert(offsetof(TargetSystemComponent_GetTargetLockedStatus, ReturnValue) == 0x000000, "Member 'TargetSystemComponent_GetTargetLockedStatus::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.IsEnableTargetLocking
// 0x0001 (0x0001 - 0x0000)
struct TargetSystemComponent_IsEnableTargetLocking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_IsEnableTargetLocking) == 0x000001, "Wrong alignment on TargetSystemComponent_IsEnableTargetLocking");
static_assert(sizeof(TargetSystemComponent_IsEnableTargetLocking) == 0x000001, "Wrong size on TargetSystemComponent_IsEnableTargetLocking");
static_assert(offsetof(TargetSystemComponent_IsEnableTargetLocking, ReturnValue) == 0x000000, "Member 'TargetSystemComponent_IsEnableTargetLocking::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.TargetActorWithAxisInput
// 0x0004 (0x0004 - 0x0000)
struct TargetSystemComponent_TargetActorWithAxisInput final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_TargetActorWithAxisInput) == 0x000004, "Wrong alignment on TargetSystemComponent_TargetActorWithAxisInput");
static_assert(sizeof(TargetSystemComponent_TargetActorWithAxisInput) == 0x000004, "Wrong size on TargetSystemComponent_TargetActorWithAxisInput");
static_assert(offsetof(TargetSystemComponent_TargetActorWithAxisInput, AxisValue) == 0x000000, "Member 'TargetSystemComponent_TargetActorWithAxisInput::AxisValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.TargetFilterByPriorityRuleAndRotation
// 0x0038 (0x0038 - 0x0000)
struct TargetSystemComponent_TargetFilterByPriorityRuleAndRotation final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRotation;                                   // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          needInArea;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation) == 0x000008, "Wrong alignment on TargetSystemComponent_TargetFilterByPriorityRuleAndRotation");
static_assert(sizeof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation) == 0x000038, "Wrong size on TargetSystemComponent_TargetFilterByPriorityRuleAndRotation");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation, Actors) == 0x000000, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation::Actors' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation, CurrentRotation) == 0x000010, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation::CurrentRotation' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation, needInArea) == 0x000028, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation::needInArea' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation, ReturnValue) == 0x000030, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.TargetFilterByPriorityRuleAndRotation_Override
// 0x0038 (0x0038 - 0x0000)
struct TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRotation;                                   // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          needInArea;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override) == 0x000008, "Wrong alignment on TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override");
static_assert(sizeof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override) == 0x000038, "Wrong size on TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override, Actors) == 0x000000, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override::Actors' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override, CurrentRotation) == 0x000010, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override::CurrentRotation' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override, needInArea) == 0x000028, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override::needInArea' has a wrong offset!");
static_assert(offsetof(TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override, ReturnValue) == 0x000030, "Member 'TargetSystemComponent_TargetFilterByPriorityRuleAndRotation_Override::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.GetLockedOnTargetActor
// 0x0008 (0x0008 - 0x0000)
struct TargetSystemComponent_GetLockedOnTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_GetLockedOnTargetActor) == 0x000008, "Wrong alignment on TargetSystemComponent_GetLockedOnTargetActor");
static_assert(sizeof(TargetSystemComponent_GetLockedOnTargetActor) == 0x000008, "Wrong size on TargetSystemComponent_GetLockedOnTargetActor");
static_assert(offsetof(TargetSystemComponent_GetLockedOnTargetActor, ReturnValue) == 0x000000, "Member 'TargetSystemComponent_GetLockedOnTargetActor::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemComponent.IsLocked
// 0x0001 (0x0001 - 0x0000)
struct TargetSystemComponent_IsLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemComponent_IsLocked) == 0x000001, "Wrong alignment on TargetSystemComponent_IsLocked");
static_assert(sizeof(TargetSystemComponent_IsLocked) == 0x000001, "Wrong size on TargetSystemComponent_IsLocked");
static_assert(offsetof(TargetSystemComponent_IsLocked, ReturnValue) == 0x000000, "Member 'TargetSystemComponent_IsLocked::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemTargetableInterface.GetLockedOnMeshSocket
// 0x0008 (0x0008 - 0x0000)
struct TargetSystemTargetableInterface_GetLockedOnMeshSocket final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemTargetableInterface_GetLockedOnMeshSocket) == 0x000004, "Wrong alignment on TargetSystemTargetableInterface_GetLockedOnMeshSocket");
static_assert(sizeof(TargetSystemTargetableInterface_GetLockedOnMeshSocket) == 0x000008, "Wrong size on TargetSystemTargetableInterface_GetLockedOnMeshSocket");
static_assert(offsetof(TargetSystemTargetableInterface_GetLockedOnMeshSocket, ReturnValue) == 0x000000, "Member 'TargetSystemTargetableInterface_GetLockedOnMeshSocket::ReturnValue' has a wrong offset!");

// Function X6Game.TargetSystemTargetableInterface.IsTargetable
// 0x0001 (0x0001 - 0x0000)
struct TargetSystemTargetableInterface_IsTargetable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetSystemTargetableInterface_IsTargetable) == 0x000001, "Wrong alignment on TargetSystemTargetableInterface_IsTargetable");
static_assert(sizeof(TargetSystemTargetableInterface_IsTargetable) == 0x000001, "Wrong size on TargetSystemTargetableInterface_IsTargetable");
static_assert(offsetof(TargetSystemTargetableInterface_IsTargetable, ReturnValue) == 0x000000, "Member 'TargetSystemTargetableInterface_IsTargetable::ReturnValue' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.AddCompAndDelegate
// 0x0018 (0x0018 - 0x0000)
struct WaterVoxelContainer_AddCompAndDelegate final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool IsInWater)>               OnWaterActorsChanged;                              // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaterVoxelContainer_AddCompAndDelegate) == 0x000008, "Wrong alignment on WaterVoxelContainer_AddCompAndDelegate");
static_assert(sizeof(WaterVoxelContainer_AddCompAndDelegate) == 0x000018, "Wrong size on WaterVoxelContainer_AddCompAndDelegate");
static_assert(offsetof(WaterVoxelContainer_AddCompAndDelegate, Component) == 0x000000, "Member 'WaterVoxelContainer_AddCompAndDelegate::Component' has a wrong offset!");
static_assert(offsetof(WaterVoxelContainer_AddCompAndDelegate, OnWaterActorsChanged) == 0x000008, "Member 'WaterVoxelContainer_AddCompAndDelegate::OnWaterActorsChanged' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.DrawLeafBoxes
// 0x0010 (0x0010 - 0x0000)
struct WaterVoxelContainer_DrawLeafBoxes final
{
public:
	class UObject*                                targetUObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawComplicated;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WaterVoxelContainer_DrawLeafBoxes) == 0x000008, "Wrong alignment on WaterVoxelContainer_DrawLeafBoxes");
static_assert(sizeof(WaterVoxelContainer_DrawLeafBoxes) == 0x000010, "Wrong size on WaterVoxelContainer_DrawLeafBoxes");
static_assert(offsetof(WaterVoxelContainer_DrawLeafBoxes, targetUObject) == 0x000000, "Member 'WaterVoxelContainer_DrawLeafBoxes::targetUObject' has a wrong offset!");
static_assert(offsetof(WaterVoxelContainer_DrawLeafBoxes, LifeTime) == 0x000008, "Member 'WaterVoxelContainer_DrawLeafBoxes::LifeTime' has a wrong offset!");
static_assert(offsetof(WaterVoxelContainer_DrawLeafBoxes, bDrawComplicated) == 0x00000C, "Member 'WaterVoxelContainer_DrawLeafBoxes::bDrawComplicated' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.ImportOtherLevelWaterVoxelFromDT
// 0x0010 (0x0010 - 0x0000)
struct WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT) == 0x000008, "Wrong alignment on WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT");
static_assert(sizeof(WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT) == 0x000010, "Wrong size on WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT");
static_assert(offsetof(WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT, LevelName) == 0x000000, "Member 'WaterVoxelContainer_ImportOtherLevelWaterVoxelFromDT::LevelName' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.ImportWaterVoxelFromDTByWorldID
// 0x0020 (0x0020 - 0x0000)
struct WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID final
{
public:
	class FString                                 worldId;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool IsAdd)>                   InOnAssetLoaded;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID) == 0x000008, "Wrong alignment on WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID");
static_assert(sizeof(WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID) == 0x000020, "Wrong size on WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID");
static_assert(offsetof(WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID, worldId) == 0x000000, "Member 'WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID::worldId' has a wrong offset!");
static_assert(offsetof(WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID, InOnAssetLoaded) == 0x000010, "Member 'WaterVoxelContainer_ImportWaterVoxelFromDTByWorldID::InOnAssetLoaded' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.IsEnteredWater
// 0x0020 (0x0020 - 0x0000)
struct WaterVoxelContainer_IsEnteredWater final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WaterVoxelContainer_IsEnteredWater) == 0x000008, "Wrong alignment on WaterVoxelContainer_IsEnteredWater");
static_assert(sizeof(WaterVoxelContainer_IsEnteredWater) == 0x000020, "Wrong size on WaterVoxelContainer_IsEnteredWater");
static_assert(offsetof(WaterVoxelContainer_IsEnteredWater, Point) == 0x000000, "Member 'WaterVoxelContainer_IsEnteredWater::Point' has a wrong offset!");
static_assert(offsetof(WaterVoxelContainer_IsEnteredWater, ReturnValue) == 0x000018, "Member 'WaterVoxelContainer_IsEnteredWater::ReturnValue' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.RemoveCompAndDelegate
// 0x0008 (0x0008 - 0x0000)
struct WaterVoxelContainer_RemoveCompAndDelegate final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaterVoxelContainer_RemoveCompAndDelegate) == 0x000008, "Wrong alignment on WaterVoxelContainer_RemoveCompAndDelegate");
static_assert(sizeof(WaterVoxelContainer_RemoveCompAndDelegate) == 0x000008, "Wrong size on WaterVoxelContainer_RemoveCompAndDelegate");
static_assert(offsetof(WaterVoxelContainer_RemoveCompAndDelegate, Component) == 0x000000, "Member 'WaterVoxelContainer_RemoveCompAndDelegate::Component' has a wrong offset!");

// Function X6Game.WaterVoxelContainer.SetEnableDebugDraw
// 0x0001 (0x0001 - 0x0000)
struct WaterVoxelContainer_SetEnableDebugDraw final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaterVoxelContainer_SetEnableDebugDraw) == 0x000001, "Wrong alignment on WaterVoxelContainer_SetEnableDebugDraw");
static_assert(sizeof(WaterVoxelContainer_SetEnableDebugDraw) == 0x000001, "Wrong size on WaterVoxelContainer_SetEnableDebugDraw");
static_assert(offsetof(WaterVoxelContainer_SetEnableDebugDraw, bEnable) == 0x000000, "Member 'WaterVoxelContainer_SetEnableDebugDraw::bEnable' has a wrong offset!");

// Function X6Game.X6AbilityTask_ChargeUp.ChargeUpProxy
// 0x0018 (0x0018 - 0x0000)
struct X6AbilityTask_ChargeUp_ChargeUpProxy final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTask_ChargeUp*                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_ChargeUp_ChargeUpProxy) == 0x000008, "Wrong alignment on X6AbilityTask_ChargeUp_ChargeUpProxy");
static_assert(sizeof(X6AbilityTask_ChargeUp_ChargeUpProxy) == 0x000018, "Wrong size on X6AbilityTask_ChargeUp_ChargeUpProxy");
static_assert(offsetof(X6AbilityTask_ChargeUp_ChargeUpProxy, OwningAbility) == 0x000000, "Member 'X6AbilityTask_ChargeUp_ChargeUpProxy::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ChargeUp_ChargeUpProxy, Duration) == 0x000008, "Member 'X6AbilityTask_ChargeUp_ChargeUpProxy::Duration' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ChargeUp_ChargeUpProxy, ReturnValue) == 0x000010, "Member 'X6AbilityTask_ChargeUp_ChargeUpProxy::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_PerformTargeting.X6PerformTargetingRequest
// 0x0020 (0x0020 - 0x0000)
struct X6AbilityTask_PerformTargeting_X6PerformTargetingRequest final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetingPreset*                       InTargetingPreset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAsync;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTask_PerformTargeting*        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PerformTargeting_X6PerformTargetingRequest) == 0x000008, "Wrong alignment on X6AbilityTask_PerformTargeting_X6PerformTargetingRequest");
static_assert(sizeof(X6AbilityTask_PerformTargeting_X6PerformTargetingRequest) == 0x000020, "Wrong size on X6AbilityTask_PerformTargeting_X6PerformTargetingRequest");
static_assert(offsetof(X6AbilityTask_PerformTargeting_X6PerformTargetingRequest, OwningAbility) == 0x000000, "Member 'X6AbilityTask_PerformTargeting_X6PerformTargetingRequest::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PerformTargeting_X6PerformTargetingRequest, InTargetingPreset) == 0x000008, "Member 'X6AbilityTask_PerformTargeting_X6PerformTargetingRequest::InTargetingPreset' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PerformTargeting_X6PerformTargetingRequest, bAllowAsync) == 0x000010, "Member 'X6AbilityTask_PerformTargeting_X6PerformTargetingRequest::bAllowAsync' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PerformTargeting_X6PerformTargetingRequest, ReturnValue) == 0x000018, "Member 'X6AbilityTask_PerformTargeting_X6PerformTargetingRequest::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageForMeshAndWaitForEvent.PlayMontageForMeshAndWaitForEvent
// 0x0048 (0x0048 - 0x0000)
struct X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 mesh_0;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay_0;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate_0;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSection_0;                                    // 0x0024(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAbilityEnds_0;                            // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimRootMotionTranslationScale_0;                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideBlendOutTimeForCancelAbility_0;            // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideBlendOutTimeForStopWhenEndAbility_0;       // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirror_0;                                         // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTask_PlayMontageForMeshAndWaitForEvent* ReturnValue;                             // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent");
static_assert(sizeof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent) == 0x000048, "Wrong size on X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, OwningAbility) == 0x000000, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, TaskInstanceName) == 0x000008, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, mesh_0) == 0x000010, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::mesh_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, MontageToPlay_0) == 0x000018, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::MontageToPlay_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, Rate_0) == 0x000020, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::Rate_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, StartSection_0) == 0x000024, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::StartSection_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, bStopWhenAbilityEnds_0) == 0x00002C, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::bStopWhenAbilityEnds_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, AnimRootMotionTranslationScale_0) == 0x000030, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::AnimRootMotionTranslationScale_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, OverrideBlendOutTimeForCancelAbility_0) == 0x000034, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::OverrideBlendOutTimeForCancelAbility_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, OverrideBlendOutTimeForStopWhenEndAbility_0) == 0x000038, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::OverrideBlendOutTimeForStopWhenEndAbility_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, bMirror_0) == 0x00003C, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::bMirror_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent, ReturnValue) == 0x000040, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageForMeshAndWaitForEvent.OnNotifyBeginReceived
// 0x0028 (0x0028 - 0x0000)
struct X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived");
static_assert(sizeof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived) == 0x000028, "Wrong size on X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived, NotifyName) == 0x000000, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyBeginReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageForMeshAndWaitForEvent.OnNotifyEndReceived
// 0x0028 (0x0028 - 0x0000)
struct X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived");
static_assert(sizeof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived) == 0x000028, "Wrong size on X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived, NotifyName) == 0x000000, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'X6AbilityTask_PlayMontageForMeshAndWaitForEvent_OnNotifyEndReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function X6Game.X6AbilityTask_SpawnBullet.SpawnBulletProxy
// 0x0028 (0x0028 - 0x0000)
struct X6AbilityTask_SpawnBullet_SpawnBulletProxy final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimaryDataAsset*                      TriggerData_0;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsModifyHitDirection_0;                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor_0;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6AbilityTask_SpawnBullet*             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_SpawnBullet_SpawnBulletProxy) == 0x000008, "Wrong alignment on X6AbilityTask_SpawnBullet_SpawnBulletProxy");
static_assert(sizeof(X6AbilityTask_SpawnBullet_SpawnBulletProxy) == 0x000028, "Wrong size on X6AbilityTask_SpawnBullet_SpawnBulletProxy");
static_assert(offsetof(X6AbilityTask_SpawnBullet_SpawnBulletProxy, OwningAbility) == 0x000000, "Member 'X6AbilityTask_SpawnBullet_SpawnBulletProxy::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_SpawnBullet_SpawnBulletProxy, TriggerData_0) == 0x000008, "Member 'X6AbilityTask_SpawnBullet_SpawnBulletProxy::TriggerData_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_SpawnBullet_SpawnBulletProxy, IsModifyHitDirection_0) == 0x000010, "Member 'X6AbilityTask_SpawnBullet_SpawnBulletProxy::IsModifyHitDirection_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_SpawnBullet_SpawnBulletProxy, TargetActor_0) == 0x000018, "Member 'X6AbilityTask_SpawnBullet_SpawnBulletProxy::TargetActor_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_SpawnBullet_SpawnBulletProxy, ReturnValue) == 0x000020, "Member 'X6AbilityTask_SpawnBullet_SpawnBulletProxy::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_WaitAccelChange.X6WaitAccelChange
// 0x0018 (0x0018 - 0x0000)
struct X6AbilityTask_WaitAccelChange_X6WaitAccelChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeToZero;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTask_WaitAccelChange*         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_WaitAccelChange_X6WaitAccelChange) == 0x000008, "Wrong alignment on X6AbilityTask_WaitAccelChange_X6WaitAccelChange");
static_assert(sizeof(X6AbilityTask_WaitAccelChange_X6WaitAccelChange) == 0x000018, "Wrong size on X6AbilityTask_WaitAccelChange_X6WaitAccelChange");
static_assert(offsetof(X6AbilityTask_WaitAccelChange_X6WaitAccelChange, OwningAbility) == 0x000000, "Member 'X6AbilityTask_WaitAccelChange_X6WaitAccelChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_WaitAccelChange_X6WaitAccelChange, bChangeToZero) == 0x000008, "Member 'X6AbilityTask_WaitAccelChange_X6WaitAccelChange::bChangeToZero' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_WaitAccelChange_X6WaitAccelChange, ReturnValue) == 0x000010, "Member 'X6AbilityTask_WaitAccelChange_X6WaitAccelChange::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.PostServerInit
// 0x0001 (0x0001 - 0x0000)
struct X6Actor_PostServerInit final
{
public:
	bool                                          bServer;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_PostServerInit) == 0x000001, "Wrong alignment on X6Actor_PostServerInit");
static_assert(sizeof(X6Actor_PostServerInit) == 0x000001, "Wrong size on X6Actor_PostServerInit");
static_assert(offsetof(X6Actor_PostServerInit, bServer) == 0x000000, "Member 'X6Actor_PostServerInit::bServer' has a wrong offset!");

// Function X6Game.X6Actor.ServerInit
// 0x0001 (0x0001 - 0x0000)
struct X6Actor_ServerInit final
{
public:
	bool                                          bServer;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_ServerInit) == 0x000001, "Wrong alignment on X6Actor_ServerInit");
static_assert(sizeof(X6Actor_ServerInit) == 0x000001, "Wrong size on X6Actor_ServerInit");
static_assert(offsetof(X6Actor_ServerInit, bServer) == 0x000000, "Member 'X6Actor_ServerInit::bServer' has a wrong offset!");

// Function X6Game.X6Actor.X6_AddTag
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_AddTag final
{
public:
	TArray<class FName>                           NewX6Tags;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_AddTag) == 0x000008, "Wrong alignment on X6Actor_X6_AddTag");
static_assert(sizeof(X6Actor_X6_AddTag) == 0x000010, "Wrong size on X6Actor_X6_AddTag");
static_assert(offsetof(X6Actor_X6_AddTag, NewX6Tags) == 0x000000, "Member 'X6Actor_X6_AddTag::NewX6Tags' has a wrong offset!");

// Function X6Game.X6Actor.X6_ClearAndInvalidateTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6Actor_X6_ClearAndInvalidateTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_ClearAndInvalidateTimerHandle) == 0x000008, "Wrong alignment on X6Actor_X6_ClearAndInvalidateTimerHandle");
static_assert(sizeof(X6Actor_X6_ClearAndInvalidateTimerHandle) == 0x000008, "Wrong size on X6Actor_X6_ClearAndInvalidateTimerHandle");
static_assert(offsetof(X6Actor_X6_ClearAndInvalidateTimerHandle, Handle) == 0x000000, "Member 'X6Actor_X6_ClearAndInvalidateTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6Actor.X6_ClearTimer
// 0x0018 (0x0018 - 0x0000)
struct X6Actor_X6_ClearTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_ClearTimer) == 0x000008, "Wrong alignment on X6Actor_X6_ClearTimer");
static_assert(sizeof(X6Actor_X6_ClearTimer) == 0x000018, "Wrong size on X6Actor_X6_ClearTimer");
static_assert(offsetof(X6Actor_X6_ClearTimer, Object) == 0x000000, "Member 'X6Actor_X6_ClearTimer::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_ClearTimer, FunctionName) == 0x000008, "Member 'X6Actor_X6_ClearTimer::FunctionName' has a wrong offset!");

// Function X6Game.X6Actor.X6_ClearTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_ClearTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_ClearTimerDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_ClearTimerDelegate");
static_assert(sizeof(X6Actor_X6_ClearTimerDelegate) == 0x000010, "Wrong size on X6Actor_X6_ClearTimerDelegate");
static_assert(offsetof(X6Actor_X6_ClearTimerDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_ClearTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6Actor.X6_ClearTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6Actor_X6_ClearTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_ClearTimerHandle) == 0x000008, "Wrong alignment on X6Actor_X6_ClearTimerHandle");
static_assert(sizeof(X6Actor_X6_ClearTimerHandle) == 0x000008, "Wrong size on X6Actor_X6_ClearTimerHandle");
static_assert(offsetof(X6Actor_X6_ClearTimerHandle, Handle) == 0x000000, "Member 'X6Actor_X6_ClearTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6Actor.X6_DeleteTag
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_DeleteTag final
{
public:
	class FString                                 strTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_DeleteTag) == 0x000008, "Wrong alignment on X6Actor_X6_DeleteTag");
static_assert(sizeof(X6Actor_X6_DeleteTag) == 0x000010, "Wrong size on X6Actor_X6_DeleteTag");
static_assert(offsetof(X6Actor_X6_DeleteTag, strTag) == 0x000000, "Member 'X6Actor_X6_DeleteTag::strTag' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetActorHiddenFlags
// 0x0058 (0x0058 - 0x0000)
struct X6Actor_X6_GetActorHiddenFlags final
{
public:
	TSet<int32>                                   OutFlags;                                          // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetActorHiddenFlags) == 0x000008, "Wrong alignment on X6Actor_X6_GetActorHiddenFlags");
static_assert(sizeof(X6Actor_X6_GetActorHiddenFlags) == 0x000058, "Wrong size on X6Actor_X6_GetActorHiddenFlags");
static_assert(offsetof(X6Actor_X6_GetActorHiddenFlags, OutFlags) == 0x000000, "Member 'X6Actor_X6_GetActorHiddenFlags::OutFlags' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetActorHiddenFlags, ReturnValue) == 0x000050, "Member 'X6Actor_X6_GetActorHiddenFlags::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTag
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_GetTag final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_GetTag) == 0x000008, "Wrong alignment on X6Actor_X6_GetTag");
static_assert(sizeof(X6Actor_X6_GetTag) == 0x000010, "Wrong size on X6Actor_X6_GetTag");
static_assert(offsetof(X6Actor_X6_GetTag, ReturnValue) == 0x000000, "Member 'X6Actor_X6_GetTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerElapsedTime
// 0x0020 (0x0020 - 0x0000)
struct X6Actor_X6_GetTimerElapsedTime final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetTimerElapsedTime) == 0x000008, "Wrong alignment on X6Actor_X6_GetTimerElapsedTime");
static_assert(sizeof(X6Actor_X6_GetTimerElapsedTime) == 0x000020, "Wrong size on X6Actor_X6_GetTimerElapsedTime");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTime, Object) == 0x000000, "Member 'X6Actor_X6_GetTimerElapsedTime::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTime, FunctionName) == 0x000008, "Member 'X6Actor_X6_GetTimerElapsedTime::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTime, ReturnValue) == 0x000018, "Member 'X6Actor_X6_GetTimerElapsedTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerElapsedTimeDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6Actor_X6_GetTimerElapsedTimeDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_GetTimerElapsedTimeDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_GetTimerElapsedTimeDelegate");
static_assert(sizeof(X6Actor_X6_GetTimerElapsedTimeDelegate) == 0x000014, "Wrong size on X6Actor_X6_GetTimerElapsedTimeDelegate");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_GetTimerElapsedTimeDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeDelegate, ReturnValue) == 0x000010, "Member 'X6Actor_X6_GetTimerElapsedTimeDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerElapsedTimeDelegateEachTrigger
// 0x0014 (0x0014 - 0x0000)
struct X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger) == 0x000004, "Wrong alignment on X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger");
static_assert(sizeof(X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger) == 0x000014, "Wrong size on X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger, Delegate) == 0x000000, "Member 'X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger, ReturnValue) == 0x000010, "Member 'X6Actor_X6_GetTimerElapsedTimeDelegateEachTrigger::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerElapsedTimeEachTrigger
// 0x0020 (0x0020 - 0x0000)
struct X6Actor_X6_GetTimerElapsedTimeEachTrigger final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetTimerElapsedTimeEachTrigger) == 0x000008, "Wrong alignment on X6Actor_X6_GetTimerElapsedTimeEachTrigger");
static_assert(sizeof(X6Actor_X6_GetTimerElapsedTimeEachTrigger) == 0x000020, "Wrong size on X6Actor_X6_GetTimerElapsedTimeEachTrigger");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeEachTrigger, Object) == 0x000000, "Member 'X6Actor_X6_GetTimerElapsedTimeEachTrigger::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeEachTrigger, FunctionName) == 0x000008, "Member 'X6Actor_X6_GetTimerElapsedTimeEachTrigger::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeEachTrigger, ReturnValue) == 0x000018, "Member 'X6Actor_X6_GetTimerElapsedTimeEachTrigger::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerElapsedTimeHandle
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_GetTimerElapsedTimeHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetTimerElapsedTimeHandle) == 0x000008, "Wrong alignment on X6Actor_X6_GetTimerElapsedTimeHandle");
static_assert(sizeof(X6Actor_X6_GetTimerElapsedTimeHandle) == 0x000010, "Wrong size on X6Actor_X6_GetTimerElapsedTimeHandle");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeHandle, Handle) == 0x000000, "Member 'X6Actor_X6_GetTimerElapsedTimeHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeHandle, ReturnValue) == 0x000008, "Member 'X6Actor_X6_GetTimerElapsedTimeHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerElapsedTimeHandleEachTrigger
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger) == 0x000008, "Wrong alignment on X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger");
static_assert(sizeof(X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger) == 0x000010, "Wrong size on X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger, Handle) == 0x000000, "Member 'X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger, ReturnValue) == 0x000008, "Member 'X6Actor_X6_GetTimerElapsedTimeHandleEachTrigger::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerRemainingTime
// 0x0020 (0x0020 - 0x0000)
struct X6Actor_X6_GetTimerRemainingTime final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetTimerRemainingTime) == 0x000008, "Wrong alignment on X6Actor_X6_GetTimerRemainingTime");
static_assert(sizeof(X6Actor_X6_GetTimerRemainingTime) == 0x000020, "Wrong size on X6Actor_X6_GetTimerRemainingTime");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTime, Object) == 0x000000, "Member 'X6Actor_X6_GetTimerRemainingTime::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTime, FunctionName) == 0x000008, "Member 'X6Actor_X6_GetTimerRemainingTime::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTime, ReturnValue) == 0x000018, "Member 'X6Actor_X6_GetTimerRemainingTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerRemainingTimeDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6Actor_X6_GetTimerRemainingTimeDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_GetTimerRemainingTimeDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_GetTimerRemainingTimeDelegate");
static_assert(sizeof(X6Actor_X6_GetTimerRemainingTimeDelegate) == 0x000014, "Wrong size on X6Actor_X6_GetTimerRemainingTimeDelegate");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTimeDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_GetTimerRemainingTimeDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTimeDelegate, ReturnValue) == 0x000010, "Member 'X6Actor_X6_GetTimerRemainingTimeDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_GetTimerRemainingTimeHandle
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_GetTimerRemainingTimeHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_GetTimerRemainingTimeHandle) == 0x000008, "Wrong alignment on X6Actor_X6_GetTimerRemainingTimeHandle");
static_assert(sizeof(X6Actor_X6_GetTimerRemainingTimeHandle) == 0x000010, "Wrong size on X6Actor_X6_GetTimerRemainingTimeHandle");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTimeHandle, Handle) == 0x000000, "Member 'X6Actor_X6_GetTimerRemainingTimeHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_GetTimerRemainingTimeHandle, ReturnValue) == 0x000008, "Member 'X6Actor_X6_GetTimerRemainingTimeHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_HasSimulatePhysicsComponent
// 0x0001 (0x0001 - 0x0000)
struct X6Actor_X6_HasSimulatePhysicsComponent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_HasSimulatePhysicsComponent) == 0x000001, "Wrong alignment on X6Actor_X6_HasSimulatePhysicsComponent");
static_assert(sizeof(X6Actor_X6_HasSimulatePhysicsComponent) == 0x000001, "Wrong size on X6Actor_X6_HasSimulatePhysicsComponent");
static_assert(offsetof(X6Actor_X6_HasSimulatePhysicsComponent, ReturnValue) == 0x000000, "Member 'X6Actor_X6_HasSimulatePhysicsComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_HasTag
// 0x0018 (0x0018 - 0x0000)
struct X6Actor_X6_HasTag final
{
public:
	class FString                                 strTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_HasTag) == 0x000008, "Wrong alignment on X6Actor_X6_HasTag");
static_assert(sizeof(X6Actor_X6_HasTag) == 0x000018, "Wrong size on X6Actor_X6_HasTag");
static_assert(offsetof(X6Actor_X6_HasTag, strTag) == 0x000000, "Member 'X6Actor_X6_HasTag::strTag' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_HasTag, ReturnValue) == 0x000010, "Member 'X6Actor_X6_HasTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsTimerActive
// 0x0020 (0x0020 - 0x0000)
struct X6Actor_X6_IsTimerActive final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsTimerActive) == 0x000008, "Wrong alignment on X6Actor_X6_IsTimerActive");
static_assert(sizeof(X6Actor_X6_IsTimerActive) == 0x000020, "Wrong size on X6Actor_X6_IsTimerActive");
static_assert(offsetof(X6Actor_X6_IsTimerActive, Object) == 0x000000, "Member 'X6Actor_X6_IsTimerActive::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerActive, FunctionName) == 0x000008, "Member 'X6Actor_X6_IsTimerActive::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerActive, ReturnValue) == 0x000018, "Member 'X6Actor_X6_IsTimerActive::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsTimerActiveDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6Actor_X6_IsTimerActiveDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsTimerActiveDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_IsTimerActiveDelegate");
static_assert(sizeof(X6Actor_X6_IsTimerActiveDelegate) == 0x000014, "Wrong size on X6Actor_X6_IsTimerActiveDelegate");
static_assert(offsetof(X6Actor_X6_IsTimerActiveDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_IsTimerActiveDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerActiveDelegate, ReturnValue) == 0x000010, "Member 'X6Actor_X6_IsTimerActiveDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsTimerActiveHandle
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_IsTimerActiveHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsTimerActiveHandle) == 0x000008, "Wrong alignment on X6Actor_X6_IsTimerActiveHandle");
static_assert(sizeof(X6Actor_X6_IsTimerActiveHandle) == 0x000010, "Wrong size on X6Actor_X6_IsTimerActiveHandle");
static_assert(offsetof(X6Actor_X6_IsTimerActiveHandle, Handle) == 0x000000, "Member 'X6Actor_X6_IsTimerActiveHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerActiveHandle, ReturnValue) == 0x000008, "Member 'X6Actor_X6_IsTimerActiveHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsTimerPaused
// 0x0020 (0x0020 - 0x0000)
struct X6Actor_X6_IsTimerPaused final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsTimerPaused) == 0x000008, "Wrong alignment on X6Actor_X6_IsTimerPaused");
static_assert(sizeof(X6Actor_X6_IsTimerPaused) == 0x000020, "Wrong size on X6Actor_X6_IsTimerPaused");
static_assert(offsetof(X6Actor_X6_IsTimerPaused, Object) == 0x000000, "Member 'X6Actor_X6_IsTimerPaused::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerPaused, FunctionName) == 0x000008, "Member 'X6Actor_X6_IsTimerPaused::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerPaused, ReturnValue) == 0x000018, "Member 'X6Actor_X6_IsTimerPaused::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsTimerPausedDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6Actor_X6_IsTimerPausedDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsTimerPausedDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_IsTimerPausedDelegate");
static_assert(sizeof(X6Actor_X6_IsTimerPausedDelegate) == 0x000014, "Wrong size on X6Actor_X6_IsTimerPausedDelegate");
static_assert(offsetof(X6Actor_X6_IsTimerPausedDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_IsTimerPausedDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerPausedDelegate, ReturnValue) == 0x000010, "Member 'X6Actor_X6_IsTimerPausedDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsTimerPausedHandle
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_IsTimerPausedHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsTimerPausedHandle) == 0x000008, "Wrong alignment on X6Actor_X6_IsTimerPausedHandle");
static_assert(sizeof(X6Actor_X6_IsTimerPausedHandle) == 0x000010, "Wrong size on X6Actor_X6_IsTimerPausedHandle");
static_assert(offsetof(X6Actor_X6_IsTimerPausedHandle, Handle) == 0x000000, "Member 'X6Actor_X6_IsTimerPausedHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsTimerPausedHandle, ReturnValue) == 0x000008, "Member 'X6Actor_X6_IsTimerPausedHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_IsValidTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_IsValidTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_IsValidTimerHandle) == 0x000008, "Wrong alignment on X6Actor_X6_IsValidTimerHandle");
static_assert(sizeof(X6Actor_X6_IsValidTimerHandle) == 0x000010, "Wrong size on X6Actor_X6_IsValidTimerHandle");
static_assert(offsetof(X6Actor_X6_IsValidTimerHandle, Handle) == 0x000000, "Member 'X6Actor_X6_IsValidTimerHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_IsValidTimerHandle, ReturnValue) == 0x000008, "Member 'X6Actor_X6_IsValidTimerHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_PauseTimer
// 0x0018 (0x0018 - 0x0000)
struct X6Actor_X6_PauseTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_PauseTimer) == 0x000008, "Wrong alignment on X6Actor_X6_PauseTimer");
static_assert(sizeof(X6Actor_X6_PauseTimer) == 0x000018, "Wrong size on X6Actor_X6_PauseTimer");
static_assert(offsetof(X6Actor_X6_PauseTimer, Object) == 0x000000, "Member 'X6Actor_X6_PauseTimer::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_PauseTimer, FunctionName) == 0x000008, "Member 'X6Actor_X6_PauseTimer::FunctionName' has a wrong offset!");

// Function X6Game.X6Actor.X6_PauseTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_PauseTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_PauseTimerDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_PauseTimerDelegate");
static_assert(sizeof(X6Actor_X6_PauseTimerDelegate) == 0x000010, "Wrong size on X6Actor_X6_PauseTimerDelegate");
static_assert(offsetof(X6Actor_X6_PauseTimerDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_PauseTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6Actor.X6_PauseTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6Actor_X6_PauseTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_PauseTimerHandle) == 0x000008, "Wrong alignment on X6Actor_X6_PauseTimerHandle");
static_assert(sizeof(X6Actor_X6_PauseTimerHandle) == 0x000008, "Wrong size on X6Actor_X6_PauseTimerHandle");
static_assert(offsetof(X6Actor_X6_PauseTimerHandle, Handle) == 0x000000, "Member 'X6Actor_X6_PauseTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6Actor.X6_RequireActorFade
// 0x000C (0x000C - 0x0000)
struct X6Actor_X6_RequireActorFade final
{
public:
	bool                                          bFadeIn;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FadeOutHiddenFlag;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInView;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_RequireActorFade) == 0x000004, "Wrong alignment on X6Actor_X6_RequireActorFade");
static_assert(sizeof(X6Actor_X6_RequireActorFade) == 0x00000C, "Wrong size on X6Actor_X6_RequireActorFade");
static_assert(offsetof(X6Actor_X6_RequireActorFade, bFadeIn) == 0x000000, "Member 'X6Actor_X6_RequireActorFade::bFadeIn' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_RequireActorFade, FadeOutHiddenFlag) == 0x000004, "Member 'X6Actor_X6_RequireActorFade::FadeOutHiddenFlag' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_RequireActorFade, bInView) == 0x000008, "Member 'X6Actor_X6_RequireActorFade::bInView' has a wrong offset!");

// Function X6Game.X6Actor.X6_SetActorHiddenInGame
// 0x000C (0x000C - 0x0000)
struct X6Actor_X6_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Flag;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFlag;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_SetActorHiddenInGame) == 0x000004, "Wrong alignment on X6Actor_X6_SetActorHiddenInGame");
static_assert(sizeof(X6Actor_X6_SetActorHiddenInGame) == 0x00000C, "Wrong size on X6Actor_X6_SetActorHiddenInGame");
static_assert(offsetof(X6Actor_X6_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'X6Actor_X6_SetActorHiddenInGame::bNewHidden' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetActorHiddenInGame, Flag) == 0x000004, "Member 'X6Actor_X6_SetActorHiddenInGame::Flag' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetActorHiddenInGame, bClearFlag) == 0x000008, "Member 'X6Actor_X6_SetActorHiddenInGame::bClearFlag' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetActorHiddenInGame, ReturnValue) == 0x000009, "Member 'X6Actor_X6_SetActorHiddenInGame::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_SetTimer
// 0x0030 (0x0030 - 0x0000)
struct X6Actor_X6_SetTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialStartDelay;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelayVariance;                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_SetTimer) == 0x000008, "Wrong alignment on X6Actor_X6_SetTimer");
static_assert(sizeof(X6Actor_X6_SetTimer) == 0x000030, "Wrong size on X6Actor_X6_SetTimer");
static_assert(offsetof(X6Actor_X6_SetTimer, Object) == 0x000000, "Member 'X6Actor_X6_SetTimer::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimer, FunctionName) == 0x000008, "Member 'X6Actor_X6_SetTimer::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimer, Time) == 0x000018, "Member 'X6Actor_X6_SetTimer::Time' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimer, bLooping) == 0x00001C, "Member 'X6Actor_X6_SetTimer::bLooping' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimer, InitialStartDelay) == 0x000020, "Member 'X6Actor_X6_SetTimer::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimer, InitialStartDelayVariance) == 0x000024, "Member 'X6Actor_X6_SetTimer::InitialStartDelayVariance' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimer, ReturnValue) == 0x000028, "Member 'X6Actor_X6_SetTimer::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_SetTimerDelegate
// 0x0028 (0x0028 - 0x0000)
struct X6Actor_X6_SetTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialStartDelay;                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelayVariance;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_SetTimerDelegate) == 0x000008, "Wrong alignment on X6Actor_X6_SetTimerDelegate");
static_assert(sizeof(X6Actor_X6_SetTimerDelegate) == 0x000028, "Wrong size on X6Actor_X6_SetTimerDelegate");
static_assert(offsetof(X6Actor_X6_SetTimerDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_SetTimerDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimerDelegate, Time) == 0x000010, "Member 'X6Actor_X6_SetTimerDelegate::Time' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimerDelegate, bLooping) == 0x000014, "Member 'X6Actor_X6_SetTimerDelegate::bLooping' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimerDelegate, InitialStartDelay) == 0x000018, "Member 'X6Actor_X6_SetTimerDelegate::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimerDelegate, InitialStartDelayVariance) == 0x00001C, "Member 'X6Actor_X6_SetTimerDelegate::InitialStartDelayVariance' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_SetTimerDelegate, ReturnValue) == 0x000020, "Member 'X6Actor_X6_SetTimerDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_TimerExists
// 0x0020 (0x0020 - 0x0000)
struct X6Actor_X6_TimerExists final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_TimerExists) == 0x000008, "Wrong alignment on X6Actor_X6_TimerExists");
static_assert(sizeof(X6Actor_X6_TimerExists) == 0x000020, "Wrong size on X6Actor_X6_TimerExists");
static_assert(offsetof(X6Actor_X6_TimerExists, Object) == 0x000000, "Member 'X6Actor_X6_TimerExists::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_TimerExists, FunctionName) == 0x000008, "Member 'X6Actor_X6_TimerExists::FunctionName' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_TimerExists, ReturnValue) == 0x000018, "Member 'X6Actor_X6_TimerExists::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_TimerExistsDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6Actor_X6_TimerExistsDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_TimerExistsDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_TimerExistsDelegate");
static_assert(sizeof(X6Actor_X6_TimerExistsDelegate) == 0x000014, "Wrong size on X6Actor_X6_TimerExistsDelegate");
static_assert(offsetof(X6Actor_X6_TimerExistsDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_TimerExistsDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_TimerExistsDelegate, ReturnValue) == 0x000010, "Member 'X6Actor_X6_TimerExistsDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_TimerExistsHandle
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_TimerExistsHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Actor_X6_TimerExistsHandle) == 0x000008, "Wrong alignment on X6Actor_X6_TimerExistsHandle");
static_assert(sizeof(X6Actor_X6_TimerExistsHandle) == 0x000010, "Wrong size on X6Actor_X6_TimerExistsHandle");
static_assert(offsetof(X6Actor_X6_TimerExistsHandle, Handle) == 0x000000, "Member 'X6Actor_X6_TimerExistsHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_TimerExistsHandle, ReturnValue) == 0x000008, "Member 'X6Actor_X6_TimerExistsHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6Actor.X6_UnPauseTimer
// 0x0018 (0x0018 - 0x0000)
struct X6Actor_X6_UnPauseTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_UnPauseTimer) == 0x000008, "Wrong alignment on X6Actor_X6_UnPauseTimer");
static_assert(sizeof(X6Actor_X6_UnPauseTimer) == 0x000018, "Wrong size on X6Actor_X6_UnPauseTimer");
static_assert(offsetof(X6Actor_X6_UnPauseTimer, Object) == 0x000000, "Member 'X6Actor_X6_UnPauseTimer::Object' has a wrong offset!");
static_assert(offsetof(X6Actor_X6_UnPauseTimer, FunctionName) == 0x000008, "Member 'X6Actor_X6_UnPauseTimer::FunctionName' has a wrong offset!");

// Function X6Game.X6Actor.X6_UnPauseTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6Actor_X6_UnPauseTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_UnPauseTimerDelegate) == 0x000004, "Wrong alignment on X6Actor_X6_UnPauseTimerDelegate");
static_assert(sizeof(X6Actor_X6_UnPauseTimerDelegate) == 0x000010, "Wrong size on X6Actor_X6_UnPauseTimerDelegate");
static_assert(offsetof(X6Actor_X6_UnPauseTimerDelegate, Delegate) == 0x000000, "Member 'X6Actor_X6_UnPauseTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6Actor.X6_UnPauseTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6Actor_X6_UnPauseTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Actor_X6_UnPauseTimerHandle) == 0x000008, "Wrong alignment on X6Actor_X6_UnPauseTimerHandle");
static_assert(sizeof(X6Actor_X6_UnPauseTimerHandle) == 0x000008, "Wrong size on X6Actor_X6_UnPauseTimerHandle");
static_assert(offsetof(X6Actor_X6_UnPauseTimerHandle, Handle) == 0x000000, "Member 'X6Actor_X6_UnPauseTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6AdjustmentBlendWarpComponent.AddOrUpdateWarpTarget
// 0x0080 (0x0080 - 0x0000)
struct X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget final
{
public:
	struct FMotionWarpingTarget                   WarpTarget;                                        // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget) == 0x000008, "Wrong alignment on X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget");
static_assert(sizeof(X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget) == 0x000080, "Wrong size on X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget");
static_assert(offsetof(X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget, WarpTarget) == 0x000000, "Member 'X6AdjustmentBlendWarpComponent_AddOrUpdateWarpTarget::WarpTarget' has a wrong offset!");

// Function X6Game.X6AdjustmentBlendWarpComponent.RemoveWarpTarget
// 0x000C (0x000C - 0x0000)
struct X6AdjustmentBlendWarpComponent_RemoveWarpTarget final
{
public:
	class FName                                   WarpTargetName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AdjustmentBlendWarpComponent_RemoveWarpTarget) == 0x000004, "Wrong alignment on X6AdjustmentBlendWarpComponent_RemoveWarpTarget");
static_assert(sizeof(X6AdjustmentBlendWarpComponent_RemoveWarpTarget) == 0x00000C, "Wrong size on X6AdjustmentBlendWarpComponent_RemoveWarpTarget");
static_assert(offsetof(X6AdjustmentBlendWarpComponent_RemoveWarpTarget, WarpTargetName) == 0x000000, "Member 'X6AdjustmentBlendWarpComponent_RemoveWarpTarget::WarpTargetName' has a wrong offset!");
static_assert(offsetof(X6AdjustmentBlendWarpComponent_RemoveWarpTarget, ReturnValue) == 0x000008, "Member 'X6AdjustmentBlendWarpComponent_RemoveWarpTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.AdjustLocationWhenOverlap
// 0x0018 (0x0018 - 0x0000)
struct X6AIBlueprintLibrary_AdjustLocationWhenOverlap final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComponet;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_AdjustLocationWhenOverlap) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_AdjustLocationWhenOverlap");
static_assert(sizeof(X6AIBlueprintLibrary_AdjustLocationWhenOverlap) == 0x000018, "Wrong size on X6AIBlueprintLibrary_AdjustLocationWhenOverlap");
static_assert(offsetof(X6AIBlueprintLibrary_AdjustLocationWhenOverlap, OwnerActor) == 0x000000, "Member 'X6AIBlueprintLibrary_AdjustLocationWhenOverlap::OwnerActor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_AdjustLocationWhenOverlap, CapsuleComponet) == 0x000008, "Member 'X6AIBlueprintLibrary_AdjustLocationWhenOverlap::CapsuleComponet' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_AdjustLocationWhenOverlap, ReturnValue) == 0x000010, "Member 'X6AIBlueprintLibrary_AdjustLocationWhenOverlap::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.CachedOrResetCapsuleCompLocation
// 0x0070 (0x0070 - 0x0000)
struct X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComponet;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetData;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRootComponent;                                   // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int64, float>                            ChildComponentRelativeZMap;                        // 0x0020(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation");
static_assert(sizeof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation) == 0x000070, "Wrong size on X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, OwnerActor) == 0x000000, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::OwnerActor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, CapsuleComponet) == 0x000008, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::CapsuleComponet' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, bResetData) == 0x000010, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::bResetData' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, IsRootComponent) == 0x000011, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::IsRootComponent' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, Radius) == 0x000014, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::Radius' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, HalfHeight) == 0x000018, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::HalfHeight' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation, ChildComponentRelativeZMap) == 0x000020, "Member 'X6AIBlueprintLibrary_CachedOrResetCapsuleCompLocation::ChildComponentRelativeZMap' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.DisableActorRelatedTicks
// 0x0020 (0x0020 - 0x0000)
struct X6AIBlueprintLibrary_DisableActorRelatedTicks final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 IgnoreClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OutDisabledUObjects;                               // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_DisableActorRelatedTicks) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_DisableActorRelatedTicks");
static_assert(sizeof(X6AIBlueprintLibrary_DisableActorRelatedTicks) == 0x000020, "Wrong size on X6AIBlueprintLibrary_DisableActorRelatedTicks");
static_assert(offsetof(X6AIBlueprintLibrary_DisableActorRelatedTicks, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_DisableActorRelatedTicks::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_DisableActorRelatedTicks, IgnoreClass) == 0x000008, "Member 'X6AIBlueprintLibrary_DisableActorRelatedTicks::IgnoreClass' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_DisableActorRelatedTicks, OutDisabledUObjects) == 0x000010, "Member 'X6AIBlueprintLibrary_DisableActorRelatedTicks::OutDisabledUObjects' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.EnableUObjectsTick
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_EnableUObjectsTick final
{
public:
	TArray<class UObject*>                        UObjects;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_EnableUObjectsTick) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_EnableUObjectsTick");
static_assert(sizeof(X6AIBlueprintLibrary_EnableUObjectsTick) == 0x000010, "Wrong size on X6AIBlueprintLibrary_EnableUObjectsTick");
static_assert(offsetof(X6AIBlueprintLibrary_EnableUObjectsTick, UObjects) == 0x000000, "Member 'X6AIBlueprintLibrary_EnableUObjectsTick::UObjects' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.FindWalkableFloorInTargetSurround
// 0x0048 (0x0048 - 0x0000)
struct X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround final
{
public:
	class ACharacter*                             FollowTargetCharacter;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutWlakablePoint;                                  // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetectDirectLand;                                 // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectLandDownTraceDis;                            // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondTraceDeltaDistance;                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalDistance;                                // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownDistance;                                      // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaterCollionChannel;                               // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround");
static_assert(sizeof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround) == 0x000048, "Wrong size on X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, FollowTargetCharacter) == 0x000000, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::FollowTargetCharacter' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, OwnerCharacter) == 0x000008, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, OutWlakablePoint) == 0x000010, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::OutWlakablePoint' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, bDetectDirectLand) == 0x000028, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::bDetectDirectLand' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, DirectLandDownTraceDis) == 0x00002C, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::DirectLandDownTraceDis' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, SecondTraceDeltaDistance) == 0x000030, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::SecondTraceDeltaDistance' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, HorizontalDistance) == 0x000034, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::HorizontalDistance' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, DownDistance) == 0x000038, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::DownDistance' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, WaterCollionChannel) == 0x00003C, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::WaterCollionChannel' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround, ReturnValue) == 0x000040, "Member 'X6AIBlueprintLibrary_FindWalkableFloorInTargetSurround::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.GetActorCollisionHalfHeight
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_GetActorCollisionHalfHeight final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_GetActorCollisionHalfHeight) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_GetActorCollisionHalfHeight");
static_assert(sizeof(X6AIBlueprintLibrary_GetActorCollisionHalfHeight) == 0x000010, "Wrong size on X6AIBlueprintLibrary_GetActorCollisionHalfHeight");
static_assert(offsetof(X6AIBlueprintLibrary_GetActorCollisionHalfHeight, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_GetActorCollisionHalfHeight::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetActorCollisionHalfHeight, ReturnValue) == 0x000008, "Member 'X6AIBlueprintLibrary_GetActorCollisionHalfHeight::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.GetActorCollisionRadius
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_GetActorCollisionRadius final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_GetActorCollisionRadius) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_GetActorCollisionRadius");
static_assert(sizeof(X6AIBlueprintLibrary_GetActorCollisionRadius) == 0x000010, "Wrong size on X6AIBlueprintLibrary_GetActorCollisionRadius");
static_assert(offsetof(X6AIBlueprintLibrary_GetActorCollisionRadius, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_GetActorCollisionRadius::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetActorCollisionRadius, ReturnValue) == 0x000008, "Member 'X6AIBlueprintLibrary_GetActorCollisionRadius::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.GetActorNavLocation
// 0x0020 (0x0020 - 0x0000)
struct X6AIBlueprintLibrary_GetActorNavLocation final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_GetActorNavLocation) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_GetActorNavLocation");
static_assert(sizeof(X6AIBlueprintLibrary_GetActorNavLocation) == 0x000020, "Wrong size on X6AIBlueprintLibrary_GetActorNavLocation");
static_assert(offsetof(X6AIBlueprintLibrary_GetActorNavLocation, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_GetActorNavLocation::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetActorNavLocation, ReturnValue) == 0x000008, "Member 'X6AIBlueprintLibrary_GetActorNavLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.GetDistToActorWithoutRadius
// 0x0018 (0x0018 - 0x0000)
struct X6AIBlueprintLibrary_GetDistToActorWithoutRadius final
{
public:
	class AActor*                                 ActorA;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorB;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnXYPlane;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_GetDistToActorWithoutRadius) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_GetDistToActorWithoutRadius");
static_assert(sizeof(X6AIBlueprintLibrary_GetDistToActorWithoutRadius) == 0x000018, "Wrong size on X6AIBlueprintLibrary_GetDistToActorWithoutRadius");
static_assert(offsetof(X6AIBlueprintLibrary_GetDistToActorWithoutRadius, ActorA) == 0x000000, "Member 'X6AIBlueprintLibrary_GetDistToActorWithoutRadius::ActorA' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetDistToActorWithoutRadius, ActorB) == 0x000008, "Member 'X6AIBlueprintLibrary_GetDistToActorWithoutRadius::ActorB' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetDistToActorWithoutRadius, OnXYPlane) == 0x000010, "Member 'X6AIBlueprintLibrary_GetDistToActorWithoutRadius::OnXYPlane' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetDistToActorWithoutRadius, ReturnValue) == 0x000014, "Member 'X6AIBlueprintLibrary_GetDistToActorWithoutRadius::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.GetRootBehaviorTree
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_GetRootBehaviorTree final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_GetRootBehaviorTree) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_GetRootBehaviorTree");
static_assert(sizeof(X6AIBlueprintLibrary_GetRootBehaviorTree) == 0x000010, "Wrong size on X6AIBlueprintLibrary_GetRootBehaviorTree");
static_assert(offsetof(X6AIBlueprintLibrary_GetRootBehaviorTree, Controller) == 0x000000, "Member 'X6AIBlueprintLibrary_GetRootBehaviorTree::Controller' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetRootBehaviorTree, ReturnValue) == 0x000008, "Member 'X6AIBlueprintLibrary_GetRootBehaviorTree::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.GetSignedAngleBetweenVector
// 0x0038 (0x0038 - 0x0000)
struct X6AIBlueprintLibrary_GetSignedAngleBetweenVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_GetSignedAngleBetweenVector) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_GetSignedAngleBetweenVector");
static_assert(sizeof(X6AIBlueprintLibrary_GetSignedAngleBetweenVector) == 0x000038, "Wrong size on X6AIBlueprintLibrary_GetSignedAngleBetweenVector");
static_assert(offsetof(X6AIBlueprintLibrary_GetSignedAngleBetweenVector, A) == 0x000000, "Member 'X6AIBlueprintLibrary_GetSignedAngleBetweenVector::A' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetSignedAngleBetweenVector, B) == 0x000018, "Member 'X6AIBlueprintLibrary_GetSignedAngleBetweenVector::B' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_GetSignedAngleBetweenVector, ReturnValue) == 0x000030, "Member 'X6AIBlueprintLibrary_GetSignedAngleBetweenVector::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.InsertSteeringPointToPath
// 0x0030 (0x0030 - 0x0000)
struct X6AIBlueprintLibrary_InsertSteeringPointToPath final
{
public:
	class UX6NavigationPathPoints*                PathPoints;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Orientation;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSteeringAngle;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSteeringDistance;                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutYaw;                                            // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_InsertSteeringPointToPath) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_InsertSteeringPointToPath");
static_assert(sizeof(X6AIBlueprintLibrary_InsertSteeringPointToPath) == 0x000030, "Wrong size on X6AIBlueprintLibrary_InsertSteeringPointToPath");
static_assert(offsetof(X6AIBlueprintLibrary_InsertSteeringPointToPath, PathPoints) == 0x000000, "Member 'X6AIBlueprintLibrary_InsertSteeringPointToPath::PathPoints' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_InsertSteeringPointToPath, Orientation) == 0x000008, "Member 'X6AIBlueprintLibrary_InsertSteeringPointToPath::Orientation' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_InsertSteeringPointToPath, MaxSteeringAngle) == 0x000020, "Member 'X6AIBlueprintLibrary_InsertSteeringPointToPath::MaxSteeringAngle' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_InsertSteeringPointToPath, StartSteeringDistance) == 0x000024, "Member 'X6AIBlueprintLibrary_InsertSteeringPointToPath::StartSteeringDistance' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_InsertSteeringPointToPath, OutYaw) == 0x000028, "Member 'X6AIBlueprintLibrary_InsertSteeringPointToPath::OutYaw' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_InsertSteeringPointToPath, ReturnValue) == 0x00002C, "Member 'X6AIBlueprintLibrary_InsertSteeringPointToPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.InvalidLocation
// 0x0018 (0x0018 - 0x0000)
struct X6AIBlueprintLibrary_InvalidLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_InvalidLocation) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_InvalidLocation");
static_assert(sizeof(X6AIBlueprintLibrary_InvalidLocation) == 0x000018, "Wrong size on X6AIBlueprintLibrary_InvalidLocation");
static_assert(offsetof(X6AIBlueprintLibrary_InvalidLocation, ReturnValue) == 0x000000, "Member 'X6AIBlueprintLibrary_InvalidLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.InvalidRotation
// 0x0018 (0x0018 - 0x0000)
struct X6AIBlueprintLibrary_InvalidRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_InvalidRotation) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_InvalidRotation");
static_assert(sizeof(X6AIBlueprintLibrary_InvalidRotation) == 0x000018, "Wrong size on X6AIBlueprintLibrary_InvalidRotation");
static_assert(offsetof(X6AIBlueprintLibrary_InvalidRotation, ReturnValue) == 0x000000, "Member 'X6AIBlueprintLibrary_InvalidRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsActorInRange
// 0x0028 (0x0028 - 0x0000)
struct X6AIBlueprintLibrary_IsActorInRange final
{
public:
	class AActor*                                 TestActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginPoint;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsActorInRange) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsActorInRange");
static_assert(sizeof(X6AIBlueprintLibrary_IsActorInRange) == 0x000028, "Wrong size on X6AIBlueprintLibrary_IsActorInRange");
static_assert(offsetof(X6AIBlueprintLibrary_IsActorInRange, TestActor) == 0x000000, "Member 'X6AIBlueprintLibrary_IsActorInRange::TestActor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsActorInRange, OriginPoint) == 0x000008, "Member 'X6AIBlueprintLibrary_IsActorInRange::OriginPoint' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsActorInRange, Radius) == 0x000020, "Member 'X6AIBlueprintLibrary_IsActorInRange::Radius' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsActorInRange, ReturnValue) == 0x000024, "Member 'X6AIBlueprintLibrary_IsActorInRange::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsActorMovingOnGround
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_IsActorMovingOnGround final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsActorMovingOnGround) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsActorMovingOnGround");
static_assert(sizeof(X6AIBlueprintLibrary_IsActorMovingOnGround) == 0x000010, "Wrong size on X6AIBlueprintLibrary_IsActorMovingOnGround");
static_assert(offsetof(X6AIBlueprintLibrary_IsActorMovingOnGround, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_IsActorMovingOnGround::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsActorMovingOnGround, ReturnValue) == 0x000008, "Member 'X6AIBlueprintLibrary_IsActorMovingOnGround::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsAgentFollowingAPath
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_IsAgentFollowingAPath final
{
public:
	class APawn*                                  Agent;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsAgentFollowingAPath) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsAgentFollowingAPath");
static_assert(sizeof(X6AIBlueprintLibrary_IsAgentFollowingAPath) == 0x000010, "Wrong size on X6AIBlueprintLibrary_IsAgentFollowingAPath");
static_assert(offsetof(X6AIBlueprintLibrary_IsAgentFollowingAPath, Agent) == 0x000000, "Member 'X6AIBlueprintLibrary_IsAgentFollowingAPath::Agent' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsAgentFollowingAPath, ReturnValue) == 0x000008, "Member 'X6AIBlueprintLibrary_IsAgentFollowingAPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsNoneBBKeySelector
// 0x0030 (0x0030 - 0x0000)
struct X6AIBlueprintLibrary_IsNoneBBKeySelector final
{
public:
	struct FBlackboardKeySelector                 InBBKeySelector;                                   // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsNoneBBKeySelector) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsNoneBBKeySelector");
static_assert(sizeof(X6AIBlueprintLibrary_IsNoneBBKeySelector) == 0x000030, "Wrong size on X6AIBlueprintLibrary_IsNoneBBKeySelector");
static_assert(offsetof(X6AIBlueprintLibrary_IsNoneBBKeySelector, InBBKeySelector) == 0x000000, "Member 'X6AIBlueprintLibrary_IsNoneBBKeySelector::InBBKeySelector' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsNoneBBKeySelector, ReturnValue) == 0x000028, "Member 'X6AIBlueprintLibrary_IsNoneBBKeySelector::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsPointInActorCone
// 0x0030 (0x0030 - 0x0000)
struct X6AIBlueprintLibrary_IsPointInActorCone final
{
public:
	struct FVector                                TestPoint;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngleOffset;                                   // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnXYPlane;                                         // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsPointInActorCone) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsPointInActorCone");
static_assert(sizeof(X6AIBlueprintLibrary_IsPointInActorCone) == 0x000030, "Wrong size on X6AIBlueprintLibrary_IsPointInActorCone");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorCone, TestPoint) == 0x000000, "Member 'X6AIBlueprintLibrary_IsPointInActorCone::TestPoint' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorCone, Actor) == 0x000018, "Member 'X6AIBlueprintLibrary_IsPointInActorCone::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorCone, ConeHalfAngle) == 0x000020, "Member 'X6AIBlueprintLibrary_IsPointInActorCone::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorCone, ConeAngleOffset) == 0x000024, "Member 'X6AIBlueprintLibrary_IsPointInActorCone::ConeAngleOffset' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorCone, OnXYPlane) == 0x000028, "Member 'X6AIBlueprintLibrary_IsPointInActorCone::OnXYPlane' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorCone, ReturnValue) == 0x000029, "Member 'X6AIBlueprintLibrary_IsPointInActorCone::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsPointInActorRange
// 0x0030 (0x0030 - 0x0000)
struct X6AIBlueprintLibrary_IsPointInActorRange final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestPoint;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfAngle;                                         // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffset;                                       // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsPointInActorRange) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsPointInActorRange");
static_assert(sizeof(X6AIBlueprintLibrary_IsPointInActorRange) == 0x000030, "Wrong size on X6AIBlueprintLibrary_IsPointInActorRange");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_IsPointInActorRange::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange, TestPoint) == 0x000008, "Member 'X6AIBlueprintLibrary_IsPointInActorRange::TestPoint' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange, Radius) == 0x000020, "Member 'X6AIBlueprintLibrary_IsPointInActorRange::Radius' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange, HalfAngle) == 0x000024, "Member 'X6AIBlueprintLibrary_IsPointInActorRange::HalfAngle' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange, AngleOffset) == 0x000028, "Member 'X6AIBlueprintLibrary_IsPointInActorRange::AngleOffset' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange, ReturnValue) == 0x00002C, "Member 'X6AIBlueprintLibrary_IsPointInActorRange::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.IsPointInActorRange2D
// 0x0030 (0x0030 - 0x0000)
struct X6AIBlueprintLibrary_IsPointInActorRange2D final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestPoint;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfAngle;                                         // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffset;                                       // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_IsPointInActorRange2D) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_IsPointInActorRange2D");
static_assert(sizeof(X6AIBlueprintLibrary_IsPointInActorRange2D) == 0x000030, "Wrong size on X6AIBlueprintLibrary_IsPointInActorRange2D");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange2D, Actor) == 0x000000, "Member 'X6AIBlueprintLibrary_IsPointInActorRange2D::Actor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange2D, TestPoint) == 0x000008, "Member 'X6AIBlueprintLibrary_IsPointInActorRange2D::TestPoint' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange2D, Radius) == 0x000020, "Member 'X6AIBlueprintLibrary_IsPointInActorRange2D::Radius' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange2D, HalfAngle) == 0x000024, "Member 'X6AIBlueprintLibrary_IsPointInActorRange2D::HalfAngle' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange2D, AngleOffset) == 0x000028, "Member 'X6AIBlueprintLibrary_IsPointInActorRange2D::AngleOffset' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_IsPointInActorRange2D, ReturnValue) == 0x00002C, "Member 'X6AIBlueprintLibrary_IsPointInActorRange2D::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.LineSphereIntersection
// 0x0058 (0x0058 - 0x0000)
struct X6AIBlueprintLibrary_LineSphereIntersection final
{
public:
	struct FVector                                CircleCenter;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LineStart;                                         // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_LineSphereIntersection) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_LineSphereIntersection");
static_assert(sizeof(X6AIBlueprintLibrary_LineSphereIntersection) == 0x000058, "Wrong size on X6AIBlueprintLibrary_LineSphereIntersection");
static_assert(offsetof(X6AIBlueprintLibrary_LineSphereIntersection, CircleCenter) == 0x000000, "Member 'X6AIBlueprintLibrary_LineSphereIntersection::CircleCenter' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_LineSphereIntersection, Radius) == 0x000018, "Member 'X6AIBlueprintLibrary_LineSphereIntersection::Radius' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_LineSphereIntersection, LineStart) == 0x000020, "Member 'X6AIBlueprintLibrary_LineSphereIntersection::LineStart' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_LineSphereIntersection, LineEnd) == 0x000038, "Member 'X6AIBlueprintLibrary_LineSphereIntersection::LineEnd' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_LineSphereIntersection, ReturnValue) == 0x000050, "Member 'X6AIBlueprintLibrary_LineSphereIntersection::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.MakeNavigationPathPoints
// 0x0018 (0x0018 - 0x0000)
struct X6AIBlueprintLibrary_MakeNavigationPathPoints final
{
public:
	TArray<struct FVector>                        PointLocations;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UX6NavigationPathPoints*                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_MakeNavigationPathPoints) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_MakeNavigationPathPoints");
static_assert(sizeof(X6AIBlueprintLibrary_MakeNavigationPathPoints) == 0x000018, "Wrong size on X6AIBlueprintLibrary_MakeNavigationPathPoints");
static_assert(offsetof(X6AIBlueprintLibrary_MakeNavigationPathPoints, PointLocations) == 0x000000, "Member 'X6AIBlueprintLibrary_MakeNavigationPathPoints::PointLocations' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_MakeNavigationPathPoints, ReturnValue) == 0x000010, "Member 'X6AIBlueprintLibrary_MakeNavigationPathPoints::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.PathPointsSineInterp
// 0x0028 (0x0028 - 0x0000)
struct X6AIBlueprintLibrary_PathPointsSineInterp final
{
public:
	class UX6NavigationPathPoints*                PathPoints;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           PathOwner;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OneCycleSampleNum;                                 // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplitudeMin;                                      // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplitudeMax;                                      // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyMin;                                      // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyMax;                                      // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_PathPointsSineInterp) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_PathPointsSineInterp");
static_assert(sizeof(X6AIBlueprintLibrary_PathPointsSineInterp) == 0x000028, "Wrong size on X6AIBlueprintLibrary_PathPointsSineInterp");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, PathPoints) == 0x000000, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::PathPoints' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, PathOwner) == 0x000008, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::PathOwner' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, OneCycleSampleNum) == 0x000010, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::OneCycleSampleNum' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, AmplitudeMin) == 0x000014, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::AmplitudeMin' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, AmplitudeMax) == 0x000018, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::AmplitudeMax' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, FrequencyMin) == 0x00001C, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::FrequencyMin' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_PathPointsSineInterp, FrequencyMax) == 0x000020, "Member 'X6AIBlueprintLibrary_PathPointsSineInterp::FrequencyMax' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.SetPreciseReachThreshold
// 0x0010 (0x0010 - 0x0000)
struct X6AIBlueprintLibrary_SetPreciseReachThreshold final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentRadiusMultiplier;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentHalfHeightMultiplier;                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_SetPreciseReachThreshold) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_SetPreciseReachThreshold");
static_assert(sizeof(X6AIBlueprintLibrary_SetPreciseReachThreshold) == 0x000010, "Wrong size on X6AIBlueprintLibrary_SetPreciseReachThreshold");
static_assert(offsetof(X6AIBlueprintLibrary_SetPreciseReachThreshold, Controller) == 0x000000, "Member 'X6AIBlueprintLibrary_SetPreciseReachThreshold::Controller' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SetPreciseReachThreshold, AgentRadiusMultiplier) == 0x000008, "Member 'X6AIBlueprintLibrary_SetPreciseReachThreshold::AgentRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SetPreciseReachThreshold, AgentHalfHeightMultiplier) == 0x00000C, "Member 'X6AIBlueprintLibrary_SetPreciseReachThreshold::AgentHalfHeightMultiplier' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.ShowAIGameplayDebugger
// 0x0028 (0x0028 - 0x0000)
struct X6AIBlueprintLibrary_ShowAIGameplayDebugger final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShow;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 EnableFeaturesArray;                               // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_ShowAIGameplayDebugger) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_ShowAIGameplayDebugger");
static_assert(sizeof(X6AIBlueprintLibrary_ShowAIGameplayDebugger) == 0x000028, "Wrong size on X6AIBlueprintLibrary_ShowAIGameplayDebugger");
static_assert(offsetof(X6AIBlueprintLibrary_ShowAIGameplayDebugger, WorldContextObject) == 0x000000, "Member 'X6AIBlueprintLibrary_ShowAIGameplayDebugger::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_ShowAIGameplayDebugger, bIsShow) == 0x000008, "Member 'X6AIBlueprintLibrary_ShowAIGameplayDebugger::bIsShow' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_ShowAIGameplayDebugger, InTargetActor) == 0x000010, "Member 'X6AIBlueprintLibrary_ShowAIGameplayDebugger::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_ShowAIGameplayDebugger, EnableFeaturesArray) == 0x000018, "Member 'X6AIBlueprintLibrary_ShowAIGameplayDebugger::EnableFeaturesArray' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.SmoothPathByConstantRadius
// 0x0030 (0x0030 - 0x0000)
struct X6AIBlueprintLibrary_SmoothPathByConstantRadius final
{
public:
	class AActor*                                 PathOwner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        InOutPath;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpStep;                                        // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawTime;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_SmoothPathByConstantRadius) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_SmoothPathByConstantRadius");
static_assert(sizeof(X6AIBlueprintLibrary_SmoothPathByConstantRadius) == 0x000030, "Wrong size on X6AIBlueprintLibrary_SmoothPathByConstantRadius");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, PathOwner) == 0x000000, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::PathOwner' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, InOutPath) == 0x000008, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::InOutPath' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, Radius) == 0x000018, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::Radius' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, InterpStep) == 0x00001C, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::InterpStep' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, bDrawDebug) == 0x000020, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::bDrawDebug' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, DrawTime) == 0x000024, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::DrawTime' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SmoothPathByConstantRadius, ReturnValue) == 0x000028, "Member 'X6AIBlueprintLibrary_SmoothPathByConstantRadius::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.StopAIMovementAndResetVelocity
// 0x0008 (0x0008 - 0x0000)
struct X6AIBlueprintLibrary_StopAIMovementAndResetVelocity final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_StopAIMovementAndResetVelocity) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_StopAIMovementAndResetVelocity");
static_assert(sizeof(X6AIBlueprintLibrary_StopAIMovementAndResetVelocity) == 0x000008, "Wrong size on X6AIBlueprintLibrary_StopAIMovementAndResetVelocity");
static_assert(offsetof(X6AIBlueprintLibrary_StopAIMovementAndResetVelocity, AIController) == 0x000000, "Member 'X6AIBlueprintLibrary_StopAIMovementAndResetVelocity::AIController' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.SubsteppingQInterpTo
// 0x0058 (0x0058 - 0x0000)
struct X6AIBlueprintLibrary_SubsteppingQInterpTo final
{
public:
	struct FRotator                               Current;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Target;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeStep;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_SubsteppingQInterpTo) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_SubsteppingQInterpTo");
static_assert(sizeof(X6AIBlueprintLibrary_SubsteppingQInterpTo) == 0x000058, "Wrong size on X6AIBlueprintLibrary_SubsteppingQInterpTo");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingQInterpTo, Current) == 0x000000, "Member 'X6AIBlueprintLibrary_SubsteppingQInterpTo::Current' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingQInterpTo, Target) == 0x000018, "Member 'X6AIBlueprintLibrary_SubsteppingQInterpTo::Target' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingQInterpTo, DeltaTime) == 0x000030, "Member 'X6AIBlueprintLibrary_SubsteppingQInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingQInterpTo, InterpSpeed) == 0x000034, "Member 'X6AIBlueprintLibrary_SubsteppingQInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingQInterpTo, TimeStep) == 0x000038, "Member 'X6AIBlueprintLibrary_SubsteppingQInterpTo::TimeStep' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingQInterpTo, ReturnValue) == 0x000040, "Member 'X6AIBlueprintLibrary_SubsteppingQInterpTo::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.SubsteppingVInterpTo
// 0x0058 (0x0058 - 0x0000)
struct X6AIBlueprintLibrary_SubsteppingVInterpTo final
{
public:
	struct FVector                                Current;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeStep;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_SubsteppingVInterpTo) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_SubsteppingVInterpTo");
static_assert(sizeof(X6AIBlueprintLibrary_SubsteppingVInterpTo) == 0x000058, "Wrong size on X6AIBlueprintLibrary_SubsteppingVInterpTo");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingVInterpTo, Current) == 0x000000, "Member 'X6AIBlueprintLibrary_SubsteppingVInterpTo::Current' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingVInterpTo, Target) == 0x000018, "Member 'X6AIBlueprintLibrary_SubsteppingVInterpTo::Target' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingVInterpTo, DeltaTime) == 0x000030, "Member 'X6AIBlueprintLibrary_SubsteppingVInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingVInterpTo, InterpSpeed) == 0x000034, "Member 'X6AIBlueprintLibrary_SubsteppingVInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingVInterpTo, TimeStep) == 0x000038, "Member 'X6AIBlueprintLibrary_SubsteppingVInterpTo::TimeStep' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_SubsteppingVInterpTo, ReturnValue) == 0x000040, "Member 'X6AIBlueprintLibrary_SubsteppingVInterpTo::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.TestFloorDist
// 0x0118 (0x0118 - 0x0000)
struct X6AIBlueprintLibrary_TestFloorDist final
{
public:
	const class AActor*                           TestActor;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceType;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineDistance;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFindFloorResult                       OutFindFloorResult;                                // 0x0010(0x0108)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIBlueprintLibrary_TestFloorDist) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_TestFloorDist");
static_assert(sizeof(X6AIBlueprintLibrary_TestFloorDist) == 0x000118, "Wrong size on X6AIBlueprintLibrary_TestFloorDist");
static_assert(offsetof(X6AIBlueprintLibrary_TestFloorDist, TestActor) == 0x000000, "Member 'X6AIBlueprintLibrary_TestFloorDist::TestActor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TestFloorDist, TraceType) == 0x000008, "Member 'X6AIBlueprintLibrary_TestFloorDist::TraceType' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TestFloorDist, LineDistance) == 0x00000C, "Member 'X6AIBlueprintLibrary_TestFloorDist::LineDistance' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TestFloorDist, OutFindFloorResult) == 0x000010, "Member 'X6AIBlueprintLibrary_TestFloorDist::OutFindFloorResult' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.TryAdjustPathEndPoint
// 0x0048 (0x0048 - 0x0000)
struct X6AIBlueprintLibrary_TryAdjustPathEndPoint final
{
public:
	class UX6NavigationPathPoints*                PathPoints;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PathOwner;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredLocation;                                   // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceMinDistanceSq;                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceMaxDistanceSq;                           // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_TryAdjustPathEndPoint) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_TryAdjustPathEndPoint");
static_assert(sizeof(X6AIBlueprintLibrary_TryAdjustPathEndPoint) == 0x000048, "Wrong size on X6AIBlueprintLibrary_TryAdjustPathEndPoint");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, PathPoints) == 0x000000, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::PathPoints' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, PathOwner) == 0x000008, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::PathOwner' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, DesiredLocation) == 0x000010, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::DesiredLocation' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, AcceptanceMinDistanceSq) == 0x000028, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::AcceptanceMinDistanceSq' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, AcceptanceMaxDistanceSq) == 0x00002C, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::AcceptanceMaxDistanceSq' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, ActorsToIgnore) == 0x000030, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_TryAdjustPathEndPoint, ReturnValue) == 0x000040, "Member 'X6AIBlueprintLibrary_TryAdjustPathEndPoint::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIBlueprintLibrary.VisibilityClippingPathPoints
// 0x0020 (0x0020 - 0x0000)
struct X6AIBlueprintLibrary_VisibilityClippingPathPoints final
{
public:
	class APawn*                                  OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6NavigationPathPoints*                PathPoints;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibilityClipMode                           ClipMode;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClipScreenSize;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationCount;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIBlueprintLibrary_VisibilityClippingPathPoints) == 0x000008, "Wrong alignment on X6AIBlueprintLibrary_VisibilityClippingPathPoints");
static_assert(sizeof(X6AIBlueprintLibrary_VisibilityClippingPathPoints) == 0x000020, "Wrong size on X6AIBlueprintLibrary_VisibilityClippingPathPoints");
static_assert(offsetof(X6AIBlueprintLibrary_VisibilityClippingPathPoints, OwnerActor) == 0x000000, "Member 'X6AIBlueprintLibrary_VisibilityClippingPathPoints::OwnerActor' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_VisibilityClippingPathPoints, PathPoints) == 0x000008, "Member 'X6AIBlueprintLibrary_VisibilityClippingPathPoints::PathPoints' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_VisibilityClippingPathPoints, ClipMode) == 0x000010, "Member 'X6AIBlueprintLibrary_VisibilityClippingPathPoints::ClipMode' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_VisibilityClippingPathPoints, ClipScreenSize) == 0x000014, "Member 'X6AIBlueprintLibrary_VisibilityClippingPathPoints::ClipScreenSize' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_VisibilityClippingPathPoints, IterationCount) == 0x000018, "Member 'X6AIBlueprintLibrary_VisibilityClippingPathPoints::IterationCount' has a wrong offset!");
static_assert(offsetof(X6AIBlueprintLibrary_VisibilityClippingPathPoints, ReturnValue) == 0x00001C, "Member 'X6AIBlueprintLibrary_VisibilityClippingPathPoints::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.SetGetOutOfNavmeshThreshold
// 0x0004 (0x0004 - 0x0000)
struct X6AIController_SetGetOutOfNavmeshThreshold final
{
public:
	int32                                         threshold;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_SetGetOutOfNavmeshThreshold) == 0x000004, "Wrong alignment on X6AIController_SetGetOutOfNavmeshThreshold");
static_assert(sizeof(X6AIController_SetGetOutOfNavmeshThreshold) == 0x000004, "Wrong size on X6AIController_SetGetOutOfNavmeshThreshold");
static_assert(offsetof(X6AIController_SetGetOutOfNavmeshThreshold, threshold) == 0x000000, "Member 'X6AIController_SetGetOutOfNavmeshThreshold::threshold' has a wrong offset!");

// Function X6Game.X6AIController.FlyToActor
// 0x0018 (0x0018 - 0x0000)
struct X6AIController_FlyToActor final
{
public:
	const class AActor*                           Goal;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserFlag;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_FlyToActor) == 0x000008, "Wrong alignment on X6AIController_FlyToActor");
static_assert(sizeof(X6AIController_FlyToActor) == 0x000018, "Wrong size on X6AIController_FlyToActor");
static_assert(offsetof(X6AIController_FlyToActor, Goal) == 0x000000, "Member 'X6AIController_FlyToActor::Goal' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToActor, AcceptanceRadius) == 0x000008, "Member 'X6AIController_FlyToActor::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToActor, bStopOnOverlap) == 0x00000C, "Member 'X6AIController_FlyToActor::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToActor, UserFlag) == 0x000010, "Member 'X6AIController_FlyToActor::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToActor, ReturnValue) == 0x000014, "Member 'X6AIController_FlyToActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.FlyToLocation
// 0x0028 (0x0028 - 0x0000)
struct X6AIController_FlyToLocation final
{
public:
	struct FVector                                dest;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserFlag;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_FlyToLocation) == 0x000008, "Wrong alignment on X6AIController_FlyToLocation");
static_assert(sizeof(X6AIController_FlyToLocation) == 0x000028, "Wrong size on X6AIController_FlyToLocation");
static_assert(offsetof(X6AIController_FlyToLocation, dest) == 0x000000, "Member 'X6AIController_FlyToLocation::dest' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToLocation, AcceptanceRadius) == 0x000018, "Member 'X6AIController_FlyToLocation::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToLocation, bStopOnOverlap) == 0x00001C, "Member 'X6AIController_FlyToLocation::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToLocation, UserFlag) == 0x000020, "Member 'X6AIController_FlyToLocation::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_FlyToLocation, ReturnValue) == 0x000024, "Member 'X6AIController_FlyToLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.GetAccelerationRotateSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6AIController_GetAccelerationRotateSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_GetAccelerationRotateSpeed) == 0x000004, "Wrong alignment on X6AIController_GetAccelerationRotateSpeed");
static_assert(sizeof(X6AIController_GetAccelerationRotateSpeed) == 0x000004, "Wrong size on X6AIController_GetAccelerationRotateSpeed");
static_assert(offsetof(X6AIController_GetAccelerationRotateSpeed, ReturnValue) == 0x000000, "Member 'X6AIController_GetAccelerationRotateSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.GetPerceptionComponent
// 0x0008 (0x0008 - 0x0000)
struct X6AIController_GetPerceptionComponent final
{
public:
	class UAIPerceptionComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_GetPerceptionComponent) == 0x000008, "Wrong alignment on X6AIController_GetPerceptionComponent");
static_assert(sizeof(X6AIController_GetPerceptionComponent) == 0x000008, "Wrong size on X6AIController_GetPerceptionComponent");
static_assert(offsetof(X6AIController_GetPerceptionComponent, ReturnValue) == 0x000000, "Member 'X6AIController_GetPerceptionComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.MoveToLocationWithFlag
// 0x0038 (0x0038 - 0x0000)
struct X6AIController_MoveToLocationWithFlag final
{
public:
	struct FVector                                dest;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserFlag;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathfinding;                                   // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectDestinationToNavigation;                   // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStrafe;                                        // 0x0023(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPath;                                 // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0031(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_MoveToLocationWithFlag) == 0x000008, "Wrong alignment on X6AIController_MoveToLocationWithFlag");
static_assert(sizeof(X6AIController_MoveToLocationWithFlag) == 0x000038, "Wrong size on X6AIController_MoveToLocationWithFlag");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, dest) == 0x000000, "Member 'X6AIController_MoveToLocationWithFlag::dest' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, UserFlag) == 0x000018, "Member 'X6AIController_MoveToLocationWithFlag::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, AcceptanceRadius) == 0x00001C, "Member 'X6AIController_MoveToLocationWithFlag::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, bStopOnOverlap) == 0x000020, "Member 'X6AIController_MoveToLocationWithFlag::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, bUsePathfinding) == 0x000021, "Member 'X6AIController_MoveToLocationWithFlag::bUsePathfinding' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, bProjectDestinationToNavigation) == 0x000022, "Member 'X6AIController_MoveToLocationWithFlag::bProjectDestinationToNavigation' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, bCanStrafe) == 0x000023, "Member 'X6AIController_MoveToLocationWithFlag::bCanStrafe' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, FilterClass) == 0x000028, "Member 'X6AIController_MoveToLocationWithFlag::FilterClass' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, bAllowPartialPath) == 0x000030, "Member 'X6AIController_MoveToLocationWithFlag::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithFlag, ReturnValue) == 0x000031, "Member 'X6AIController_MoveToLocationWithFlag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.MoveToLocationWithPath
// 0x0048 (0x0048 - 0x0000)
struct X6AIController_MoveToLocationWithPath final
{
public:
	struct FVector                                dest;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PathPoints;                                        // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         UserFlag;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathfinding;                                   // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectDestinationToNavigation;                   // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStrafe;                                        // 0x0033(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPaths;                                // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_MoveToLocationWithPath) == 0x000008, "Wrong alignment on X6AIController_MoveToLocationWithPath");
static_assert(sizeof(X6AIController_MoveToLocationWithPath) == 0x000048, "Wrong size on X6AIController_MoveToLocationWithPath");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, dest) == 0x000000, "Member 'X6AIController_MoveToLocationWithPath::dest' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, PathPoints) == 0x000018, "Member 'X6AIController_MoveToLocationWithPath::PathPoints' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, UserFlag) == 0x000028, "Member 'X6AIController_MoveToLocationWithPath::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, AcceptanceRadius) == 0x00002C, "Member 'X6AIController_MoveToLocationWithPath::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, bStopOnOverlap) == 0x000030, "Member 'X6AIController_MoveToLocationWithPath::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, bUsePathfinding) == 0x000031, "Member 'X6AIController_MoveToLocationWithPath::bUsePathfinding' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, bProjectDestinationToNavigation) == 0x000032, "Member 'X6AIController_MoveToLocationWithPath::bProjectDestinationToNavigation' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, bCanStrafe) == 0x000033, "Member 'X6AIController_MoveToLocationWithPath::bCanStrafe' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, FilterClass) == 0x000038, "Member 'X6AIController_MoveToLocationWithPath::FilterClass' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, bAllowPartialPaths) == 0x000040, "Member 'X6AIController_MoveToLocationWithPath::bAllowPartialPaths' has a wrong offset!");
static_assert(offsetof(X6AIController_MoveToLocationWithPath, ReturnValue) == 0x000041, "Member 'X6AIController_MoveToLocationWithPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.OnGetServerPath
// 0x0010 (0x0010 - 0x0000)
struct X6AIController_OnGetServerPath final
{
public:
	int64                                         InRequestID;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6NavigationPathPoints*                PathPoints;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_OnGetServerPath) == 0x000008, "Wrong alignment on X6AIController_OnGetServerPath");
static_assert(sizeof(X6AIController_OnGetServerPath) == 0x000010, "Wrong size on X6AIController_OnGetServerPath");
static_assert(offsetof(X6AIController_OnGetServerPath, InRequestID) == 0x000000, "Member 'X6AIController_OnGetServerPath::InRequestID' has a wrong offset!");
static_assert(offsetof(X6AIController_OnGetServerPath, PathPoints) == 0x000008, "Member 'X6AIController_OnGetServerPath::PathPoints' has a wrong offset!");

// Function X6Game.X6AIController.PauseBehaviorTree
// 0x0010 (0x0010 - 0x0000)
struct X6AIController_PauseBehaviorTree final
{
public:
	class FString                                 Reason;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_PauseBehaviorTree) == 0x000008, "Wrong alignment on X6AIController_PauseBehaviorTree");
static_assert(sizeof(X6AIController_PauseBehaviorTree) == 0x000010, "Wrong size on X6AIController_PauseBehaviorTree");
static_assert(offsetof(X6AIController_PauseBehaviorTree, Reason) == 0x000000, "Member 'X6AIController_PauseBehaviorTree::Reason' has a wrong offset!");

// Function X6Game.X6AIController.ResumeBehaviorTree
// 0x0010 (0x0010 - 0x0000)
struct X6AIController_ResumeBehaviorTree final
{
public:
	class FString                                 Reason;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_ResumeBehaviorTree) == 0x000008, "Wrong alignment on X6AIController_ResumeBehaviorTree");
static_assert(sizeof(X6AIController_ResumeBehaviorTree) == 0x000010, "Wrong size on X6AIController_ResumeBehaviorTree");
static_assert(offsetof(X6AIController_ResumeBehaviorTree, Reason) == 0x000000, "Member 'X6AIController_ResumeBehaviorTree::Reason' has a wrong offset!");

// Function X6Game.X6AIController.SetAccelerationRotateSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6AIController_SetAccelerationRotateSpeed final
{
public:
	float                                         InAccelerationRotateSpeed;                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_SetAccelerationRotateSpeed) == 0x000004, "Wrong alignment on X6AIController_SetAccelerationRotateSpeed");
static_assert(sizeof(X6AIController_SetAccelerationRotateSpeed) == 0x000004, "Wrong size on X6AIController_SetAccelerationRotateSpeed");
static_assert(offsetof(X6AIController_SetAccelerationRotateSpeed, InAccelerationRotateSpeed) == 0x000000, "Member 'X6AIController_SetAccelerationRotateSpeed::InAccelerationRotateSpeed' has a wrong offset!");

// Function X6Game.X6AIController.SetMaxPitchAngle
// 0x0008 (0x0008 - 0x0000)
struct X6AIController_SetMaxPitchAngle final
{
public:
	float                                         ControlDepressionAngle;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlElevationAngle;                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_SetMaxPitchAngle) == 0x000004, "Wrong alignment on X6AIController_SetMaxPitchAngle");
static_assert(sizeof(X6AIController_SetMaxPitchAngle) == 0x000008, "Wrong size on X6AIController_SetMaxPitchAngle");
static_assert(offsetof(X6AIController_SetMaxPitchAngle, ControlDepressionAngle) == 0x000000, "Member 'X6AIController_SetMaxPitchAngle::ControlDepressionAngle' has a wrong offset!");
static_assert(offsetof(X6AIController_SetMaxPitchAngle, ControlElevationAngle) == 0x000004, "Member 'X6AIController_SetMaxPitchAngle::ControlElevationAngle' has a wrong offset!");

// Function X6Game.X6AIController.SetUseServerPathFinding
// 0x0001 (0x0001 - 0x0000)
struct X6AIController_SetUseServerPathFinding final
{
public:
	bool                                          InUseServerPathFinding;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_SetUseServerPathFinding) == 0x000001, "Wrong alignment on X6AIController_SetUseServerPathFinding");
static_assert(sizeof(X6AIController_SetUseServerPathFinding) == 0x000001, "Wrong size on X6AIController_SetUseServerPathFinding");
static_assert(offsetof(X6AIController_SetUseServerPathFinding, InUseServerPathFinding) == 0x000000, "Member 'X6AIController_SetUseServerPathFinding::InUseServerPathFinding' has a wrong offset!");

// Function X6Game.X6AIController.StopBehaviorTree
// 0x0010 (0x0010 - 0x0000)
struct X6AIController_StopBehaviorTree final
{
public:
	class FString                                 Reason;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIController_StopBehaviorTree) == 0x000008, "Wrong alignment on X6AIController_StopBehaviorTree");
static_assert(sizeof(X6AIController_StopBehaviorTree) == 0x000010, "Wrong size on X6AIController_StopBehaviorTree");
static_assert(offsetof(X6AIController_StopBehaviorTree, Reason) == 0x000000, "Member 'X6AIController_StopBehaviorTree::Reason' has a wrong offset!");

// Function X6Game.X6AIController.X6FollowSpecifiedPath
// 0x0018 (0x0018 - 0x0000)
struct X6AIController_X6FollowSpecifiedPath final
{
public:
	class UX6NavigationPathPoints*                PathPoints;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserFlag;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStrafe;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_X6FollowSpecifiedPath) == 0x000008, "Wrong alignment on X6AIController_X6FollowSpecifiedPath");
static_assert(sizeof(X6AIController_X6FollowSpecifiedPath) == 0x000018, "Wrong size on X6AIController_X6FollowSpecifiedPath");
static_assert(offsetof(X6AIController_X6FollowSpecifiedPath, PathPoints) == 0x000000, "Member 'X6AIController_X6FollowSpecifiedPath::PathPoints' has a wrong offset!");
static_assert(offsetof(X6AIController_X6FollowSpecifiedPath, AcceptanceRadius) == 0x000008, "Member 'X6AIController_X6FollowSpecifiedPath::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_X6FollowSpecifiedPath, bStopOnOverlap) == 0x00000C, "Member 'X6AIController_X6FollowSpecifiedPath::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_X6FollowSpecifiedPath, UserFlag) == 0x000010, "Member 'X6AIController_X6FollowSpecifiedPath::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_X6FollowSpecifiedPath, bCanStrafe) == 0x000014, "Member 'X6AIController_X6FollowSpecifiedPath::bCanStrafe' has a wrong offset!");
static_assert(offsetof(X6AIController_X6FollowSpecifiedPath, ReturnValue) == 0x000015, "Member 'X6AIController_X6FollowSpecifiedPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.X6MoveToActor
// 0x0048 (0x0048 - 0x0000)
struct X6AIController_X6MoveToActor final
{
public:
	class AActor*                                 Goal;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathfinding;                                   // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserFlag;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectMoveIfPossible;                             // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectMoveParams                      DirectMoveChecker;                                 // 0x0018(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanStrafe;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPath;                                 // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_X6MoveToActor) == 0x000008, "Wrong alignment on X6AIController_X6MoveToActor");
static_assert(sizeof(X6AIController_X6MoveToActor) == 0x000048, "Wrong size on X6AIController_X6MoveToActor");
static_assert(offsetof(X6AIController_X6MoveToActor, Goal) == 0x000000, "Member 'X6AIController_X6MoveToActor::Goal' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, AcceptanceRadius) == 0x000008, "Member 'X6AIController_X6MoveToActor::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, bStopOnOverlap) == 0x00000C, "Member 'X6AIController_X6MoveToActor::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, bUsePathfinding) == 0x00000D, "Member 'X6AIController_X6MoveToActor::bUsePathfinding' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, UserFlag) == 0x000010, "Member 'X6AIController_X6MoveToActor::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, bDirectMoveIfPossible) == 0x000014, "Member 'X6AIController_X6MoveToActor::bDirectMoveIfPossible' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, DirectMoveChecker) == 0x000018, "Member 'X6AIController_X6MoveToActor::DirectMoveChecker' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, bCanStrafe) == 0x000030, "Member 'X6AIController_X6MoveToActor::bCanStrafe' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, FilterClass) == 0x000038, "Member 'X6AIController_X6MoveToActor::FilterClass' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, bAllowPartialPath) == 0x000040, "Member 'X6AIController_X6MoveToActor::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToActor, ReturnValue) == 0x000041, "Member 'X6AIController_X6MoveToActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.X6MoveToLocation
// 0x0078 (0x0078 - 0x0000)
struct X6AIController_X6MoveToLocation final
{
public:
	struct FVector                                dest;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnOverlap;                                    // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathfinding;                                   // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserFlag;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectMoveIfPossible;                             // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectMoveParams                      DirectMoveChecker;                                 // 0x0028(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bProjectDestinationToNavigation;                   // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStrafe;                                        // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPaths;                                // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FinalRotation;                                     // 0x0058(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingRequestResult                   ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_X6MoveToLocation) == 0x000008, "Wrong alignment on X6AIController_X6MoveToLocation");
static_assert(sizeof(X6AIController_X6MoveToLocation) == 0x000078, "Wrong size on X6AIController_X6MoveToLocation");
static_assert(offsetof(X6AIController_X6MoveToLocation, dest) == 0x000000, "Member 'X6AIController_X6MoveToLocation::dest' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, AcceptanceRadius) == 0x000018, "Member 'X6AIController_X6MoveToLocation::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, bStopOnOverlap) == 0x00001C, "Member 'X6AIController_X6MoveToLocation::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, bUsePathfinding) == 0x00001D, "Member 'X6AIController_X6MoveToLocation::bUsePathfinding' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, UserFlag) == 0x000020, "Member 'X6AIController_X6MoveToLocation::UserFlag' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, bDirectMoveIfPossible) == 0x000024, "Member 'X6AIController_X6MoveToLocation::bDirectMoveIfPossible' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, DirectMoveChecker) == 0x000028, "Member 'X6AIController_X6MoveToLocation::DirectMoveChecker' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, bProjectDestinationToNavigation) == 0x000040, "Member 'X6AIController_X6MoveToLocation::bProjectDestinationToNavigation' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, bCanStrafe) == 0x000041, "Member 'X6AIController_X6MoveToLocation::bCanStrafe' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, FilterClass) == 0x000048, "Member 'X6AIController_X6MoveToLocation::FilterClass' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, bAllowPartialPaths) == 0x000050, "Member 'X6AIController_X6MoveToLocation::bAllowPartialPaths' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, FinalRotation) == 0x000058, "Member 'X6AIController_X6MoveToLocation::FinalRotation' has a wrong offset!");
static_assert(offsetof(X6AIController_X6MoveToLocation, ReturnValue) == 0x000070, "Member 'X6AIController_X6MoveToLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.X6RunBehaviorTree
// 0x0010 (0x0010 - 0x0000)
struct X6AIController_X6RunBehaviorTree final
{
public:
	class UBehaviorTree*                          BTAsset;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_X6RunBehaviorTree) == 0x000008, "Wrong alignment on X6AIController_X6RunBehaviorTree");
static_assert(sizeof(X6AIController_X6RunBehaviorTree) == 0x000010, "Wrong size on X6AIController_X6RunBehaviorTree");
static_assert(offsetof(X6AIController_X6RunBehaviorTree, BTAsset) == 0x000000, "Member 'X6AIController_X6RunBehaviorTree::BTAsset' has a wrong offset!");
static_assert(offsetof(X6AIController_X6RunBehaviorTree, ReturnValue) == 0x000008, "Member 'X6AIController_X6RunBehaviorTree::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIController.CanDirectMoveToLocation
// 0x0038 (0x0038 - 0x0000)
struct X6AIController_CanDirectMoveToLocation final
{
public:
	struct FVector                                dest;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectMoveParams                      DirectMoveChecker;                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EX6DirectMoveCheckMode                        CheckMode;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0031(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIController_CanDirectMoveToLocation) == 0x000008, "Wrong alignment on X6AIController_CanDirectMoveToLocation");
static_assert(sizeof(X6AIController_CanDirectMoveToLocation) == 0x000038, "Wrong size on X6AIController_CanDirectMoveToLocation");
static_assert(offsetof(X6AIController_CanDirectMoveToLocation, dest) == 0x000000, "Member 'X6AIController_CanDirectMoveToLocation::dest' has a wrong offset!");
static_assert(offsetof(X6AIController_CanDirectMoveToLocation, DirectMoveChecker) == 0x000018, "Member 'X6AIController_CanDirectMoveToLocation::DirectMoveChecker' has a wrong offset!");
static_assert(offsetof(X6AIController_CanDirectMoveToLocation, CheckMode) == 0x000030, "Member 'X6AIController_CanDirectMoveToLocation::CheckMode' has a wrong offset!");
static_assert(offsetof(X6AIController_CanDirectMoveToLocation, ReturnValue) == 0x000031, "Member 'X6AIController_CanDirectMoveToLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIPerceptionComponent.AddModifier
// 0x0010 (0x0010 - 0x0000)
struct X6AIPerceptionComponent_AddModifier final
{
public:
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6AISenseModifier*                     ToAddModifier;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIPerceptionComponent_AddModifier) == 0x000008, "Wrong alignment on X6AIPerceptionComponent_AddModifier");
static_assert(sizeof(X6AIPerceptionComponent_AddModifier) == 0x000010, "Wrong size on X6AIPerceptionComponent_AddModifier");
static_assert(offsetof(X6AIPerceptionComponent_AddModifier, SenseClass) == 0x000000, "Member 'X6AIPerceptionComponent_AddModifier::SenseClass' has a wrong offset!");
static_assert(offsetof(X6AIPerceptionComponent_AddModifier, ToAddModifier) == 0x000008, "Member 'X6AIPerceptionComponent_AddModifier::ToAddModifier' has a wrong offset!");

// Function X6Game.X6AIPerceptionComponent.AddSenseConfig
// 0x0008 (0x0008 - 0x0000)
struct X6AIPerceptionComponent_AddSenseConfig final
{
public:
	class UAISenseConfig*                         SenseConfig;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIPerceptionComponent_AddSenseConfig) == 0x000008, "Wrong alignment on X6AIPerceptionComponent_AddSenseConfig");
static_assert(sizeof(X6AIPerceptionComponent_AddSenseConfig) == 0x000008, "Wrong size on X6AIPerceptionComponent_AddSenseConfig");
static_assert(offsetof(X6AIPerceptionComponent_AddSenseConfig, SenseConfig) == 0x000000, "Member 'X6AIPerceptionComponent_AddSenseConfig::SenseConfig' has a wrong offset!");

// Function X6Game.X6AIPerceptionComponent.SetSenseEnabledSafe
// 0x0010 (0x0010 - 0x0000)
struct X6AIPerceptionComponent_SetSenseEnabledSafe final
{
public:
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIPerceptionComponent_SetSenseEnabledSafe) == 0x000008, "Wrong alignment on X6AIPerceptionComponent_SetSenseEnabledSafe");
static_assert(sizeof(X6AIPerceptionComponent_SetSenseEnabledSafe) == 0x000010, "Wrong size on X6AIPerceptionComponent_SetSenseEnabledSafe");
static_assert(offsetof(X6AIPerceptionComponent_SetSenseEnabledSafe, SenseClass) == 0x000000, "Member 'X6AIPerceptionComponent_SetSenseEnabledSafe::SenseClass' has a wrong offset!");
static_assert(offsetof(X6AIPerceptionComponent_SetSenseEnabledSafe, bEnable) == 0x000008, "Member 'X6AIPerceptionComponent_SetSenseEnabledSafe::bEnable' has a wrong offset!");

// Function X6Game.X6AIPerformanceManager.GetFunctionBudgetInMicroseconds
// 0x000C (0x000C - 0x0000)
struct X6AIPerformanceManager_GetFunctionBudgetInMicroseconds final
{
public:
	class FName                                   InFunctionName;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIPerformanceManager_GetFunctionBudgetInMicroseconds) == 0x000004, "Wrong alignment on X6AIPerformanceManager_GetFunctionBudgetInMicroseconds");
static_assert(sizeof(X6AIPerformanceManager_GetFunctionBudgetInMicroseconds) == 0x00000C, "Wrong size on X6AIPerformanceManager_GetFunctionBudgetInMicroseconds");
static_assert(offsetof(X6AIPerformanceManager_GetFunctionBudgetInMicroseconds, InFunctionName) == 0x000000, "Member 'X6AIPerformanceManager_GetFunctionBudgetInMicroseconds::InFunctionName' has a wrong offset!");
static_assert(offsetof(X6AIPerformanceManager_GetFunctionBudgetInMicroseconds, ReturnValue) == 0x000008, "Member 'X6AIPerformanceManager_GetFunctionBudgetInMicroseconds::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIPerformanceManager.RegisterUnImportantFunctionDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6AIPerformanceManager_RegisterUnImportantFunctionDelegate final
{
public:
	TDelegate<void()>                             ExecuteDelegate;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AIPerformanceManager_RegisterUnImportantFunctionDelegate) == 0x000004, "Wrong alignment on X6AIPerformanceManager_RegisterUnImportantFunctionDelegate");
static_assert(sizeof(X6AIPerformanceManager_RegisterUnImportantFunctionDelegate) == 0x000010, "Wrong size on X6AIPerformanceManager_RegisterUnImportantFunctionDelegate");
static_assert(offsetof(X6AIPerformanceManager_RegisterUnImportantFunctionDelegate, ExecuteDelegate) == 0x000000, "Member 'X6AIPerformanceManager_RegisterUnImportantFunctionDelegate::ExecuteDelegate' has a wrong offset!");

// Function X6Game.X6AISenseConfig_Sight.NeedLineTrace
// 0x0001 (0x0001 - 0x0000)
struct X6AISenseConfig_Sight_NeedLineTrace final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AISenseConfig_Sight_NeedLineTrace) == 0x000001, "Wrong alignment on X6AISenseConfig_Sight_NeedLineTrace");
static_assert(sizeof(X6AISenseConfig_Sight_NeedLineTrace) == 0x000001, "Wrong size on X6AISenseConfig_Sight_NeedLineTrace");
static_assert(offsetof(X6AISenseConfig_Sight_NeedLineTrace, ReturnValue) == 0x000000, "Member 'X6AISenseConfig_Sight_NeedLineTrace::ReturnValue' has a wrong offset!");

// Function X6Game.X6AISense_Sight.IsInterestedTarget
// 0x0020 (0x0020 - 0x0000)
struct X6AISense_Sight_IsInterestedTarget final
{
public:
	const class AActor*                           ListenerActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6AISenseConfig_Sight*                 Config;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AISense_Sight_IsInterestedTarget) == 0x000008, "Wrong alignment on X6AISense_Sight_IsInterestedTarget");
static_assert(sizeof(X6AISense_Sight_IsInterestedTarget) == 0x000020, "Wrong size on X6AISense_Sight_IsInterestedTarget");
static_assert(offsetof(X6AISense_Sight_IsInterestedTarget, ListenerActor) == 0x000000, "Member 'X6AISense_Sight_IsInterestedTarget::ListenerActor' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_IsInterestedTarget, TargetActor) == 0x000008, "Member 'X6AISense_Sight_IsInterestedTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_IsInterestedTarget, Config) == 0x000010, "Member 'X6AISense_Sight_IsInterestedTarget::Config' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_IsInterestedTarget, ReturnValue) == 0x000018, "Member 'X6AISense_Sight_IsInterestedTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6AISense_Sight.ReportStimulus
// 0x0020 (0x0020 - 0x0000)
struct X6AISense_Sight_ReportStimulus final
{
public:
	const class AActor*                           ListenerActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6AISenseConfig_Sight*                 Config;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6AISenseSightResultType                     ResultType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastResult;                                       // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AISense_Sight_ReportStimulus) == 0x000008, "Wrong alignment on X6AISense_Sight_ReportStimulus");
static_assert(sizeof(X6AISense_Sight_ReportStimulus) == 0x000020, "Wrong size on X6AISense_Sight_ReportStimulus");
static_assert(offsetof(X6AISense_Sight_ReportStimulus, ListenerActor) == 0x000000, "Member 'X6AISense_Sight_ReportStimulus::ListenerActor' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_ReportStimulus, TargetActor) == 0x000008, "Member 'X6AISense_Sight_ReportStimulus::TargetActor' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_ReportStimulus, Config) == 0x000010, "Member 'X6AISense_Sight_ReportStimulus::Config' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_ReportStimulus, ResultType) == 0x000018, "Member 'X6AISense_Sight_ReportStimulus::ResultType' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_ReportStimulus, bLastResult) == 0x000019, "Member 'X6AISense_Sight_ReportStimulus::bLastResult' has a wrong offset!");
static_assert(offsetof(X6AISense_Sight_ReportStimulus, ReturnValue) == 0x00001A, "Member 'X6AISense_Sight_ReportStimulus::ReturnValue' has a wrong offset!");

// Function X6Game.X6AIStimuliSourceComponent.GetSocketPos
// 0x0028 (0x0028 - 0x0000)
struct X6AIStimuliSourceComponent_GetSocketPos final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutPos;                                            // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AIStimuliSourceComponent_GetSocketPos) == 0x000008, "Wrong alignment on X6AIStimuliSourceComponent_GetSocketPos");
static_assert(sizeof(X6AIStimuliSourceComponent_GetSocketPos) == 0x000028, "Wrong size on X6AIStimuliSourceComponent_GetSocketPos");
static_assert(offsetof(X6AIStimuliSourceComponent_GetSocketPos, SocketName) == 0x000000, "Member 'X6AIStimuliSourceComponent_GetSocketPos::SocketName' has a wrong offset!");
static_assert(offsetof(X6AIStimuliSourceComponent_GetSocketPos, OutPos) == 0x000008, "Member 'X6AIStimuliSourceComponent_GetSocketPos::OutPos' has a wrong offset!");
static_assert(offsetof(X6AIStimuliSourceComponent_GetSocketPos, ReturnValue) == 0x000020, "Member 'X6AIStimuliSourceComponent_GetSocketPos::ReturnValue' has a wrong offset!");

// Function X6Game.AsyncActionLoadSoftObjPath.AsyncLoadPrimaryAsset
// 0x0028 (0x0028 - 0x0000)
struct AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                InAssetsToLoad;                                    // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          InForceLoadBPClass;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncActionLoadSoftObjPath*            ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset) == 0x000008, "Wrong alignment on AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset");
static_assert(sizeof(AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset) == 0x000028, "Wrong size on AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset");
static_assert(offsetof(AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset, WorldContextObject) == 0x000000, "Member 'AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset, InAssetsToLoad) == 0x000008, "Member 'AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset::InAssetsToLoad' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset, InForceLoadBPClass) == 0x000018, "Member 'AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset::InForceLoadBPClass' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset, ReturnValue) == 0x000020, "Member 'AsyncActionLoadSoftObjPath_AsyncLoadPrimaryAsset::ReturnValue' has a wrong offset!");

// Function X6Game.X6TileView.BP_NavigateToItemIndex
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_BP_NavigateToItemIndex final
{
public:
	int32                                         ItemIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_BP_NavigateToItemIndex) == 0x000004, "Wrong alignment on X6TileView_BP_NavigateToItemIndex");
static_assert(sizeof(X6TileView_BP_NavigateToItemIndex) == 0x000004, "Wrong size on X6TileView_BP_NavigateToItemIndex");
static_assert(offsetof(X6TileView_BP_NavigateToItemIndex, ItemIndex) == 0x000000, "Member 'X6TileView_BP_NavigateToItemIndex::ItemIndex' has a wrong offset!");

// Function X6Game.X6TileView.BP_OnTileItemValueChanged
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_BP_OnTileItemValueChanged final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_BP_OnTileItemValueChanged) == 0x000004, "Wrong alignment on X6TileView_BP_OnTileItemValueChanged");
static_assert(sizeof(X6TileView_BP_OnTileItemValueChanged) == 0x000004, "Wrong size on X6TileView_BP_OnTileItemValueChanged");
static_assert(offsetof(X6TileView_BP_OnTileItemValueChanged, Index_0) == 0x000000, "Member 'X6TileView_BP_OnTileItemValueChanged::Index_0' has a wrong offset!");

// Function X6Game.X6TileView.BP_ScrollItemIndexIntoView
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_BP_ScrollItemIndexIntoView final
{
public:
	int32                                         ItemIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_BP_ScrollItemIndexIntoView) == 0x000004, "Wrong alignment on X6TileView_BP_ScrollItemIndexIntoView");
static_assert(sizeof(X6TileView_BP_ScrollItemIndexIntoView) == 0x000004, "Wrong size on X6TileView_BP_ScrollItemIndexIntoView");
static_assert(offsetof(X6TileView_BP_ScrollItemIndexIntoView, ItemIndex) == 0x000000, "Member 'X6TileView_BP_ScrollItemIndexIntoView::ItemIndex' has a wrong offset!");

// Function X6Game.X6TileView.BP_SetItemSelectionByIndex
// 0x0008 (0x0008 - 0x0000)
struct X6TileView_BP_SetItemSelectionByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TileView_BP_SetItemSelectionByIndex) == 0x000004, "Wrong alignment on X6TileView_BP_SetItemSelectionByIndex");
static_assert(sizeof(X6TileView_BP_SetItemSelectionByIndex) == 0x000008, "Wrong size on X6TileView_BP_SetItemSelectionByIndex");
static_assert(offsetof(X6TileView_BP_SetItemSelectionByIndex, Index_0) == 0x000000, "Member 'X6TileView_BP_SetItemSelectionByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6TileView_BP_SetItemSelectionByIndex, bSelected) == 0x000004, "Member 'X6TileView_BP_SetItemSelectionByIndex::bSelected' has a wrong offset!");

// Function X6Game.X6TileView.BP_SetSelectedItemByIndex
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_BP_SetSelectedItemByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_BP_SetSelectedItemByIndex) == 0x000004, "Wrong alignment on X6TileView_BP_SetSelectedItemByIndex");
static_assert(sizeof(X6TileView_BP_SetSelectedItemByIndex) == 0x000004, "Wrong size on X6TileView_BP_SetSelectedItemByIndex");
static_assert(offsetof(X6TileView_BP_SetSelectedItemByIndex, Index_0) == 0x000000, "Member 'X6TileView_BP_SetSelectedItemByIndex::Index_0' has a wrong offset!");

// Function X6Game.X6TileView.BP_SetTileItemCount
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_BP_SetTileItemCount final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_BP_SetTileItemCount) == 0x000004, "Wrong alignment on X6TileView_BP_SetTileItemCount");
static_assert(sizeof(X6TileView_BP_SetTileItemCount) == 0x000004, "Wrong size on X6TileView_BP_SetTileItemCount");
static_assert(offsetof(X6TileView_BP_SetTileItemCount, Count) == 0x000000, "Member 'X6TileView_BP_SetTileItemCount::Count' has a wrong offset!");

// Function X6Game.X6TileView.GetLineOrientationItemNums
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_GetLineOrientationItemNums final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_GetLineOrientationItemNums) == 0x000004, "Wrong alignment on X6TileView_GetLineOrientationItemNums");
static_assert(sizeof(X6TileView_GetLineOrientationItemNums) == 0x000004, "Wrong size on X6TileView_GetLineOrientationItemNums");
static_assert(offsetof(X6TileView_GetLineOrientationItemNums, ReturnValue) == 0x000000, "Member 'X6TileView_GetLineOrientationItemNums::ReturnValue' has a wrong offset!");

// Function X6Game.X6TileView.GetScrollVelocity
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_GetScrollVelocity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_GetScrollVelocity) == 0x000004, "Wrong alignment on X6TileView_GetScrollVelocity");
static_assert(sizeof(X6TileView_GetScrollVelocity) == 0x000004, "Wrong size on X6TileView_GetScrollVelocity");
static_assert(offsetof(X6TileView_GetScrollVelocity, ReturnValue) == 0x000000, "Member 'X6TileView_GetScrollVelocity::ReturnValue' has a wrong offset!");

// Function X6Game.X6TileView.RemoveItemByIndex
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_RemoveItemByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_RemoveItemByIndex) == 0x000004, "Wrong alignment on X6TileView_RemoveItemByIndex");
static_assert(sizeof(X6TileView_RemoveItemByIndex) == 0x000004, "Wrong size on X6TileView_RemoveItemByIndex");
static_assert(offsetof(X6TileView_RemoveItemByIndex, Index_0) == 0x000000, "Member 'X6TileView_RemoveItemByIndex::Index_0' has a wrong offset!");

// Function X6Game.X6TileView.BP_GetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct X6TileView_BP_GetSelectedIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TileView_BP_GetSelectedIndex) == 0x000004, "Wrong alignment on X6TileView_BP_GetSelectedIndex");
static_assert(sizeof(X6TileView_BP_GetSelectedIndex) == 0x000004, "Wrong size on X6TileView_BP_GetSelectedIndex");
static_assert(offsetof(X6TileView_BP_GetSelectedIndex, ReturnValue) == 0x000000, "Member 'X6TileView_BP_GetSelectedIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6TileView.BP_GetSelectedItemsViaIndex
// 0x0018 (0x0018 - 0x0000)
struct X6TileView_BP_GetSelectedItemsViaIndex final
{
public:
	TArray<int32>                                 Items;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TileView_BP_GetSelectedItemsViaIndex) == 0x000008, "Wrong alignment on X6TileView_BP_GetSelectedItemsViaIndex");
static_assert(sizeof(X6TileView_BP_GetSelectedItemsViaIndex) == 0x000018, "Wrong size on X6TileView_BP_GetSelectedItemsViaIndex");
static_assert(offsetof(X6TileView_BP_GetSelectedItemsViaIndex, Items) == 0x000000, "Member 'X6TileView_BP_GetSelectedItemsViaIndex::Items' has a wrong offset!");
static_assert(offsetof(X6TileView_BP_GetSelectedItemsViaIndex, ReturnValue) == 0x000010, "Member 'X6TileView_BP_GetSelectedItemsViaIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6TileView.BP_IsItemVisibleByIndex
// 0x0008 (0x0008 - 0x0000)
struct X6TileView_BP_IsItemVisibleByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TileView_BP_IsItemVisibleByIndex) == 0x000004, "Wrong alignment on X6TileView_BP_IsItemVisibleByIndex");
static_assert(sizeof(X6TileView_BP_IsItemVisibleByIndex) == 0x000008, "Wrong size on X6TileView_BP_IsItemVisibleByIndex");
static_assert(offsetof(X6TileView_BP_IsItemVisibleByIndex, Index_0) == 0x000000, "Member 'X6TileView_BP_IsItemVisibleByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6TileView_BP_IsItemVisibleByIndex, ReturnValue) == 0x000004, "Member 'X6TileView_BP_IsItemVisibleByIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6AsyncCollisionTraceBlueprintLibrary.AsyncBoxOverlapActors
// 0x0078 (0x0078 - 0x0000)
struct X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxPos;                                            // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback;   // 0x0060(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors) == 0x000008, "Wrong alignment on X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors");
static_assert(sizeof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors) == 0x000078, "Wrong size on X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, WorldContextObject) == 0x000000, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, BoxPos) == 0x000008, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::BoxPos' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, BoxExtent) == 0x000020, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::BoxExtent' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, ObjectTypes) == 0x000038, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, ActorClassFilter) == 0x000048, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, ActorsToIgnore) == 0x000050, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, DelegateCallback) == 0x000060, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::DelegateCallback' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors, ReturnValue) == 0x000070, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncBoxOverlapActors::ReturnValue' has a wrong offset!");

// Function X6Game.X6AsyncCollisionTraceBlueprintLibrary.AsyncCapsuleOverlapActors
// 0x0068 (0x0068 - 0x0000)
struct X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsulePos;                                        // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback;   // 0x0050(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors) == 0x000008, "Wrong alignment on X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors");
static_assert(sizeof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors) == 0x000068, "Wrong size on X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, WorldContextObject) == 0x000000, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, CapsulePos) == 0x000008, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::CapsulePos' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, Radius) == 0x000020, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::Radius' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, HalfHeight) == 0x000024, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::HalfHeight' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, ObjectTypes) == 0x000028, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, ActorClassFilter) == 0x000038, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, ActorsToIgnore) == 0x000040, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, DelegateCallback) == 0x000050, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::DelegateCallback' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors, ReturnValue) == 0x000060, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncCapsuleOverlapActors::ReturnValue' has a wrong offset!");

// Function X6Game.X6AsyncCollisionTraceBlueprintLibrary.AsyncLineTraceByChannel
// 0x0070 (0x0070 - 0x0000)
struct X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel final
{
public:
	EX6AsyncTraceType                             InTraceType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             InTraceChannel;                                    // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0048(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsHit, const TArray<struct FHitResult>& HitResults, uint32 CustomFlag)> DelegateCallback; // 0x0058(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomFlag;                                        // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x006C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel) == 0x000008, "Wrong alignment on X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel");
static_assert(sizeof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel) == 0x000070, "Wrong size on X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, InTraceType) == 0x000000, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::InTraceType' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, WorldContextObject) == 0x000008, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, Start) == 0x000010, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::Start' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, End) == 0x000028, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::End' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, InTraceChannel) == 0x000040, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::InTraceChannel' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, bTraceComplex) == 0x000041, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::bTraceComplex' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, ActorsToIgnore) == 0x000048, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, DelegateCallback) == 0x000058, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::DelegateCallback' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, CustomFlag) == 0x000068, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::CustomFlag' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel, ReturnValue) == 0x00006C, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncLineTraceByChannel::ReturnValue' has a wrong offset!");

// Function X6Game.X6AsyncCollisionTraceBlueprintLibrary.AsyncOverlapActorsCustomizeChannel
// 0x00A8 (0x00A8 - 0x0000)
struct X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UShapeComponent*                  shapeComp;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            AllChannelsResponse;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   TraceChannels;                                     // 0x0018(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0070(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         ActorsClassFilter;                                 // 0x0080(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback;   // 0x0090(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel) == 0x000008, "Wrong alignment on X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel");
static_assert(sizeof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel) == 0x0000A8, "Wrong size on X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, WorldContextObject) == 0x000000, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, shapeComp) == 0x000008, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::shapeComp' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, AllChannelsResponse) == 0x000010, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::AllChannelsResponse' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, TraceChannels) == 0x000018, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::TraceChannels' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, bTraceComplex) == 0x000068, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::bTraceComplex' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, ActorsToIgnore) == 0x000070, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, ActorsClassFilter) == 0x000080, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::ActorsClassFilter' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, DelegateCallback) == 0x000090, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::DelegateCallback' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel, ReturnValue) == 0x0000A0, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncOverlapActorsCustomizeChannel::ReturnValue' has a wrong offset!");

// Function X6Game.X6AsyncCollisionTraceBlueprintLibrary.AsyncSphereOverlapActors
// 0x0068 (0x0068 - 0x0000)
struct X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpherePos;                                         // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback;   // 0x0050(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors) == 0x000008, "Wrong alignment on X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors");
static_assert(sizeof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors) == 0x000068, "Wrong size on X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, WorldContextObject) == 0x000000, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, SpherePos) == 0x000008, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::SpherePos' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, SphereRadius) == 0x000020, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::SphereRadius' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, ObjectTypes) == 0x000028, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, ActorClassFilter) == 0x000038, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, ActorsToIgnore) == 0x000040, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, DelegateCallback) == 0x000050, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::DelegateCallback' has a wrong offset!");
static_assert(offsetof(X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors, ReturnValue) == 0x000060, "Member 'X6AsyncCollisionTraceBlueprintLibrary_AsyncSphereOverlapActors::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.AddRoad
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationSubSystem_AddRoad final
{
public:
	class UX6SplineRoad*                          Road;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_AddRoad) == 0x000008, "Wrong alignment on X6NavigationSubSystem_AddRoad");
static_assert(sizeof(X6NavigationSubSystem_AddRoad) == 0x000008, "Wrong size on X6NavigationSubSystem_AddRoad");
static_assert(offsetof(X6NavigationSubSystem_AddRoad, Road) == 0x000000, "Member 'X6NavigationSubSystem_AddRoad::Road' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.AddRoadNodesToPathV2
// 0x0078 (0x0078 - 0x0000)
struct X6NavigationSubSystem_AddRoadNodesToPathV2 final
{
public:
	TArray<struct FVector>                        PathPoints;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OffMeshIdxs;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int64>                            SplineNodes;                                       // 0x0020(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          DebugDraw;                                         // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawDuration;                                 // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_AddRoadNodesToPathV2) == 0x000008, "Wrong alignment on X6NavigationSubSystem_AddRoadNodesToPathV2");
static_assert(sizeof(X6NavigationSubSystem_AddRoadNodesToPathV2) == 0x000078, "Wrong size on X6NavigationSubSystem_AddRoadNodesToPathV2");
static_assert(offsetof(X6NavigationSubSystem_AddRoadNodesToPathV2, PathPoints) == 0x000000, "Member 'X6NavigationSubSystem_AddRoadNodesToPathV2::PathPoints' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_AddRoadNodesToPathV2, OffMeshIdxs) == 0x000010, "Member 'X6NavigationSubSystem_AddRoadNodesToPathV2::OffMeshIdxs' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_AddRoadNodesToPathV2, SplineNodes) == 0x000020, "Member 'X6NavigationSubSystem_AddRoadNodesToPathV2::SplineNodes' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_AddRoadNodesToPathV2, DebugDraw) == 0x000070, "Member 'X6NavigationSubSystem_AddRoadNodesToPathV2::DebugDraw' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_AddRoadNodesToPathV2, DebugDrawDuration) == 0x000074, "Member 'X6NavigationSubSystem_AddRoadNodesToPathV2::DebugDrawDuration' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.DrawNavLink
// 0x0030 (0x0030 - 0x0000)
struct X6NavigationSubSystem_DrawNavLink final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNavigationLink>                NavLinks;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationSubSystem_DrawNavLink) == 0x000008, "Wrong alignment on X6NavigationSubSystem_DrawNavLink");
static_assert(sizeof(X6NavigationSubSystem_DrawNavLink) == 0x000030, "Wrong size on X6NavigationSubSystem_DrawNavLink");
static_assert(offsetof(X6NavigationSubSystem_DrawNavLink, InWorld) == 0x000000, "Member 'X6NavigationSubSystem_DrawNavLink::InWorld' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_DrawNavLink, NavLinks) == 0x000008, "Member 'X6NavigationSubSystem_DrawNavLink::NavLinks' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_DrawNavLink, Color) == 0x000018, "Member 'X6NavigationSubSystem_DrawNavLink::Color' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_DrawNavLink, Time) == 0x000028, "Member 'X6NavigationSubSystem_DrawNavLink::Time' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.DrawNavMesh
// 0x0030 (0x0030 - 0x0000)
struct X6NavigationSubSystem_DrawNavMesh final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Tiles;                                             // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationSubSystem_DrawNavMesh) == 0x000008, "Wrong alignment on X6NavigationSubSystem_DrawNavMesh");
static_assert(sizeof(X6NavigationSubSystem_DrawNavMesh) == 0x000030, "Wrong size on X6NavigationSubSystem_DrawNavMesh");
static_assert(offsetof(X6NavigationSubSystem_DrawNavMesh, InWorld) == 0x000000, "Member 'X6NavigationSubSystem_DrawNavMesh::InWorld' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_DrawNavMesh, Tiles) == 0x000008, "Member 'X6NavigationSubSystem_DrawNavMesh::Tiles' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_DrawNavMesh, Color) == 0x000018, "Member 'X6NavigationSubSystem_DrawNavMesh::Color' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_DrawNavMesh, Time) == 0x000028, "Member 'X6NavigationSubSystem_DrawNavMesh::Time' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.GetNavigationRegionFilterFlags
// 0x0038 (0x0038 - 0x0000)
struct X6NavigationSubSystem_GetNavigationRegionFilterFlags final
{
public:
	int32                                         OutIncludeFlags;                                   // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutExcludeFlags;                                   // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_GetNavigationRegionFilterFlags) == 0x000008, "Wrong alignment on X6NavigationSubSystem_GetNavigationRegionFilterFlags");
static_assert(sizeof(X6NavigationSubSystem_GetNavigationRegionFilterFlags) == 0x000038, "Wrong size on X6NavigationSubSystem_GetNavigationRegionFilterFlags");
static_assert(offsetof(X6NavigationSubSystem_GetNavigationRegionFilterFlags, OutIncludeFlags) == 0x000000, "Member 'X6NavigationSubSystem_GetNavigationRegionFilterFlags::OutIncludeFlags' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_GetNavigationRegionFilterFlags, OutExcludeFlags) == 0x000004, "Member 'X6NavigationSubSystem_GetNavigationRegionFilterFlags::OutExcludeFlags' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_GetNavigationRegionFilterFlags, StartLocation) == 0x000008, "Member 'X6NavigationSubSystem_GetNavigationRegionFilterFlags::StartLocation' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_GetNavigationRegionFilterFlags, GoalLocation) == 0x000020, "Member 'X6NavigationSubSystem_GetNavigationRegionFilterFlags::GoalLocation' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.RemoveRoad
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationSubSystem_RemoveRoad final
{
public:
	int64                                         RoadID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_RemoveRoad) == 0x000008, "Wrong alignment on X6NavigationSubSystem_RemoveRoad");
static_assert(sizeof(X6NavigationSubSystem_RemoveRoad) == 0x000008, "Wrong size on X6NavigationSubSystem_RemoveRoad");
static_assert(offsetof(X6NavigationSubSystem_RemoveRoad, RoadID) == 0x000000, "Member 'X6NavigationSubSystem_RemoveRoad::RoadID' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.SetRoadOffsetClamp
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationSubSystem_SetRoadOffsetClamp final
{
public:
	float                                         ClampMin;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_SetRoadOffsetClamp) == 0x000004, "Wrong alignment on X6NavigationSubSystem_SetRoadOffsetClamp");
static_assert(sizeof(X6NavigationSubSystem_SetRoadOffsetClamp) == 0x000008, "Wrong size on X6NavigationSubSystem_SetRoadOffsetClamp");
static_assert(offsetof(X6NavigationSubSystem_SetRoadOffsetClamp, ClampMin) == 0x000000, "Member 'X6NavigationSubSystem_SetRoadOffsetClamp::ClampMin' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_SetRoadOffsetClamp, ClampMax) == 0x000004, "Member 'X6NavigationSubSystem_SetRoadOffsetClamp::ClampMax' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.SetSegmentSampleStep
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationSubSystem_SetSegmentSampleStep final
{
public:
	float                                         NewStep;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_SetSegmentSampleStep) == 0x000004, "Wrong alignment on X6NavigationSubSystem_SetSegmentSampleStep");
static_assert(sizeof(X6NavigationSubSystem_SetSegmentSampleStep) == 0x000004, "Wrong size on X6NavigationSubSystem_SetSegmentSampleStep");
static_assert(offsetof(X6NavigationSubSystem_SetSegmentSampleStep, NewStep) == 0x000000, "Member 'X6NavigationSubSystem_SetSegmentSampleStep::NewStep' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.SetSegmentStepsMinDistance
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationSubSystem_SetSegmentStepsMinDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_SetSegmentStepsMinDistance) == 0x000004, "Wrong alignment on X6NavigationSubSystem_SetSegmentStepsMinDistance");
static_assert(sizeof(X6NavigationSubSystem_SetSegmentStepsMinDistance) == 0x000004, "Wrong size on X6NavigationSubSystem_SetSegmentStepsMinDistance");
static_assert(offsetof(X6NavigationSubSystem_SetSegmentStepsMinDistance, Distance) == 0x000000, "Member 'X6NavigationSubSystem_SetSegmentStepsMinDistance::Distance' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.GetOwnerRoad
// 0x0010 (0x0010 - 0x0000)
struct X6NavigationSubSystem_GetOwnerRoad final
{
public:
	int64                                         NodeUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6SplineRoad*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_GetOwnerRoad) == 0x000008, "Wrong alignment on X6NavigationSubSystem_GetOwnerRoad");
static_assert(sizeof(X6NavigationSubSystem_GetOwnerRoad) == 0x000010, "Wrong size on X6NavigationSubSystem_GetOwnerRoad");
static_assert(offsetof(X6NavigationSubSystem_GetOwnerRoad, NodeUID) == 0x000000, "Member 'X6NavigationSubSystem_GetOwnerRoad::NodeUID' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_GetOwnerRoad, ReturnValue) == 0x000008, "Member 'X6NavigationSubSystem_GetOwnerRoad::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.GetOwnerRoadUID
// 0x0010 (0x0010 - 0x0000)
struct X6NavigationSubSystem_GetOwnerRoadUID final
{
public:
	int64                                         NodeUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_GetOwnerRoadUID) == 0x000008, "Wrong alignment on X6NavigationSubSystem_GetOwnerRoadUID");
static_assert(sizeof(X6NavigationSubSystem_GetOwnerRoadUID) == 0x000010, "Wrong size on X6NavigationSubSystem_GetOwnerRoadUID");
static_assert(offsetof(X6NavigationSubSystem_GetOwnerRoadUID, NodeUID) == 0x000000, "Member 'X6NavigationSubSystem_GetOwnerRoadUID::NodeUID' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_GetOwnerRoadUID, ReturnValue) == 0x000008, "Member 'X6NavigationSubSystem_GetOwnerRoadUID::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.GetSegmentSampleStep
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationSubSystem_GetSegmentSampleStep final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_GetSegmentSampleStep) == 0x000004, "Wrong alignment on X6NavigationSubSystem_GetSegmentSampleStep");
static_assert(sizeof(X6NavigationSubSystem_GetSegmentSampleStep) == 0x000004, "Wrong size on X6NavigationSubSystem_GetSegmentSampleStep");
static_assert(offsetof(X6NavigationSubSystem_GetSegmentSampleStep, ReturnValue) == 0x000000, "Member 'X6NavigationSubSystem_GetSegmentSampleStep::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.GetSegmentStepsMinDistanceSq
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationSubSystem_GetSegmentStepsMinDistanceSq final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_GetSegmentStepsMinDistanceSq) == 0x000004, "Wrong alignment on X6NavigationSubSystem_GetSegmentStepsMinDistanceSq");
static_assert(sizeof(X6NavigationSubSystem_GetSegmentStepsMinDistanceSq) == 0x000004, "Wrong size on X6NavigationSubSystem_GetSegmentStepsMinDistanceSq");
static_assert(offsetof(X6NavigationSubSystem_GetSegmentStepsMinDistanceSq, ReturnValue) == 0x000000, "Member 'X6NavigationSubSystem_GetSegmentStepsMinDistanceSq::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.HasRoadNode
// 0x0010 (0x0010 - 0x0000)
struct X6NavigationSubSystem_HasRoadNode final
{
public:
	int64                                         NodeUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationSubSystem_HasRoadNode) == 0x000008, "Wrong alignment on X6NavigationSubSystem_HasRoadNode");
static_assert(sizeof(X6NavigationSubSystem_HasRoadNode) == 0x000010, "Wrong size on X6NavigationSubSystem_HasRoadNode");
static_assert(offsetof(X6NavigationSubSystem_HasRoadNode, NodeUID) == 0x000000, "Member 'X6NavigationSubSystem_HasRoadNode::NodeUID' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_HasRoadNode, ReturnValue) == 0x000008, "Member 'X6NavigationSubSystem_HasRoadNode::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.MakeNavigationPathPoints
// 0x00B8 (0x00B8 - 0x0000)
struct X6NavigationSubSystem_MakeNavigationPathPoints final
{
public:
	TArray<struct FVector>                        PointLocations;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<int32, int64>                            NavLinkMark;                                       // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<int32, int64>                            RoadNodeMark;                                      // 0x0060(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UX6NavigationPathPoints*                ReturnValue;                                       // 0x00B0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_MakeNavigationPathPoints) == 0x000008, "Wrong alignment on X6NavigationSubSystem_MakeNavigationPathPoints");
static_assert(sizeof(X6NavigationSubSystem_MakeNavigationPathPoints) == 0x0000B8, "Wrong size on X6NavigationSubSystem_MakeNavigationPathPoints");
static_assert(offsetof(X6NavigationSubSystem_MakeNavigationPathPoints, PointLocations) == 0x000000, "Member 'X6NavigationSubSystem_MakeNavigationPathPoints::PointLocations' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_MakeNavigationPathPoints, NavLinkMark) == 0x000010, "Member 'X6NavigationSubSystem_MakeNavigationPathPoints::NavLinkMark' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_MakeNavigationPathPoints, RoadNodeMark) == 0x000060, "Member 'X6NavigationSubSystem_MakeNavigationPathPoints::RoadNodeMark' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_MakeNavigationPathPoints, ReturnValue) == 0x0000B0, "Member 'X6NavigationSubSystem_MakeNavigationPathPoints::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationSubSystem.MakePureNavigationPathPoints
// 0x0018 (0x0018 - 0x0000)
struct X6NavigationSubSystem_MakePureNavigationPathPoints final
{
public:
	TArray<struct FVector>                        PointLocations;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UX6NavigationPathPoints*                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationSubSystem_MakePureNavigationPathPoints) == 0x000008, "Wrong alignment on X6NavigationSubSystem_MakePureNavigationPathPoints");
static_assert(sizeof(X6NavigationSubSystem_MakePureNavigationPathPoints) == 0x000018, "Wrong size on X6NavigationSubSystem_MakePureNavigationPathPoints");
static_assert(offsetof(X6NavigationSubSystem_MakePureNavigationPathPoints, PointLocations) == 0x000000, "Member 'X6NavigationSubSystem_MakePureNavigationPathPoints::PointLocations' has a wrong offset!");
static_assert(offsetof(X6NavigationSubSystem_MakePureNavigationPathPoints, ReturnValue) == 0x000010, "Member 'X6NavigationSubSystem_MakePureNavigationPathPoints::ReturnValue' has a wrong offset!");

// Function X6Game.X6AvatarSubsystem.OnActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct X6AvatarSubsystem_OnActorDestroyed final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarSubsystem_OnActorDestroyed) == 0x000008, "Wrong alignment on X6AvatarSubsystem_OnActorDestroyed");
static_assert(sizeof(X6AvatarSubsystem_OnActorDestroyed) == 0x000008, "Wrong size on X6AvatarSubsystem_OnActorDestroyed");
static_assert(offsetof(X6AvatarSubsystem_OnActorDestroyed, Actor) == 0x000000, "Member 'X6AvatarSubsystem_OnActorDestroyed::Actor' has a wrong offset!");

// Function X6Game.AvatarComponent.CopySkeletalMeshFromActor
// 0x0008 (0x0008 - 0x0000)
struct AvatarComponent_CopySkeletalMeshFromActor final
{
public:
	class AActor*                                 Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarComponent_CopySkeletalMeshFromActor) == 0x000008, "Wrong alignment on AvatarComponent_CopySkeletalMeshFromActor");
static_assert(sizeof(AvatarComponent_CopySkeletalMeshFromActor) == 0x000008, "Wrong size on AvatarComponent_CopySkeletalMeshFromActor");
static_assert(offsetof(AvatarComponent_CopySkeletalMeshFromActor, Template) == 0x000000, "Member 'AvatarComponent_CopySkeletalMeshFromActor::Template' has a wrong offset!");

// Function X6Game.AvatarComponent.SetAvatarTag
// 0x0010 (0x0010 - 0x0000)
struct AvatarComponent_SetAvatarTag final
{
public:
	class FString                                 Tag;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarComponent_SetAvatarTag) == 0x000008, "Wrong alignment on AvatarComponent_SetAvatarTag");
static_assert(sizeof(AvatarComponent_SetAvatarTag) == 0x000010, "Wrong size on AvatarComponent_SetAvatarTag");
static_assert(offsetof(AvatarComponent_SetAvatarTag, Tag) == 0x000000, "Member 'AvatarComponent_SetAvatarTag::Tag' has a wrong offset!");

// Function X6Game.AvatarComponent.SetSkeletalMeshFromMapping
// 0x0058 (0x0058 - 0x0000)
struct AvatarComponent_SetSkeletalMeshFromMapping final
{
public:
	TMap<class FName, class USkeletalMesh*>       PartToMeshMapping;                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MainSkeletal;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarComponent_SetSkeletalMeshFromMapping) == 0x000008, "Wrong alignment on AvatarComponent_SetSkeletalMeshFromMapping");
static_assert(sizeof(AvatarComponent_SetSkeletalMeshFromMapping) == 0x000058, "Wrong size on AvatarComponent_SetSkeletalMeshFromMapping");
static_assert(offsetof(AvatarComponent_SetSkeletalMeshFromMapping, PartToMeshMapping) == 0x000000, "Member 'AvatarComponent_SetSkeletalMeshFromMapping::PartToMeshMapping' has a wrong offset!");
static_assert(offsetof(AvatarComponent_SetSkeletalMeshFromMapping, MainSkeletal) == 0x000050, "Member 'AvatarComponent_SetSkeletalMeshFromMapping::MainSkeletal' has a wrong offset!");

// Function X6Game.AvatarComponent.SetupAvatarByDataConfig
// 0x0060 (0x0060 - 0x0000)
struct AvatarComponent_SetupAvatarByDataConfig final
{
public:
	class USkeletalMeshComponent*                 MainMeshComp;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuitId;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FClothMeshSetting>   PartToClothMeshMapping;                            // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarComponent_SetupAvatarByDataConfig) == 0x000008, "Wrong alignment on AvatarComponent_SetupAvatarByDataConfig");
static_assert(sizeof(AvatarComponent_SetupAvatarByDataConfig) == 0x000060, "Wrong size on AvatarComponent_SetupAvatarByDataConfig");
static_assert(offsetof(AvatarComponent_SetupAvatarByDataConfig, MainMeshComp) == 0x000000, "Member 'AvatarComponent_SetupAvatarByDataConfig::MainMeshComp' has a wrong offset!");
static_assert(offsetof(AvatarComponent_SetupAvatarByDataConfig, SuitId) == 0x000008, "Member 'AvatarComponent_SetupAvatarByDataConfig::SuitId' has a wrong offset!");
static_assert(offsetof(AvatarComponent_SetupAvatarByDataConfig, PartToClothMeshMapping) == 0x000010, "Member 'AvatarComponent_SetupAvatarByDataConfig::PartToClothMeshMapping' has a wrong offset!");

// Function X6Game.AvatarComponent.SetupAvatarByRuntime
// 0x0010 (0x0010 - 0x0000)
struct AvatarComponent_SetupAvatarByRuntime final
{
public:
	class FString                                 NewTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarComponent_SetupAvatarByRuntime) == 0x000008, "Wrong alignment on AvatarComponent_SetupAvatarByRuntime");
static_assert(sizeof(AvatarComponent_SetupAvatarByRuntime) == 0x000010, "Wrong size on AvatarComponent_SetupAvatarByRuntime");
static_assert(offsetof(AvatarComponent_SetupAvatarByRuntime, NewTag) == 0x000000, "Member 'AvatarComponent_SetupAvatarByRuntime::NewTag' has a wrong offset!");

// Function X6Game.X6AvatarPreviewSubsystem.OnActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct X6AvatarPreviewSubsystem_OnActorDestroyed final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewSubsystem_OnActorDestroyed) == 0x000008, "Wrong alignment on X6AvatarPreviewSubsystem_OnActorDestroyed");
static_assert(sizeof(X6AvatarPreviewSubsystem_OnActorDestroyed) == 0x000008, "Wrong size on X6AvatarPreviewSubsystem_OnActorDestroyed");
static_assert(offsetof(X6AvatarPreviewSubsystem_OnActorDestroyed, Actor) == 0x000000, "Member 'X6AvatarPreviewSubsystem_OnActorDestroyed::Actor' has a wrong offset!");

// Function X6Game.X6AvatarPreviewSubsystem.OnGenAssetActorDestory
// 0x0008 (0x0008 - 0x0000)
struct X6AvatarPreviewSubsystem_OnGenAssetActorDestory final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewSubsystem_OnGenAssetActorDestory) == 0x000008, "Wrong alignment on X6AvatarPreviewSubsystem_OnGenAssetActorDestory");
static_assert(sizeof(X6AvatarPreviewSubsystem_OnGenAssetActorDestory) == 0x000008, "Wrong size on X6AvatarPreviewSubsystem_OnGenAssetActorDestory");
static_assert(offsetof(X6AvatarPreviewSubsystem_OnGenAssetActorDestory, Actor) == 0x000000, "Member 'X6AvatarPreviewSubsystem_OnGenAssetActorDestory::Actor' has a wrong offset!");

// Function X6Game.X6AvatarPreviewComponent.InitWithCharacterGenAsset
// 0x0008 (0x0008 - 0x0000)
struct X6AvatarPreviewComponent_InitWithCharacterGenAsset final
{
public:
	class UCharacterGenAsset*                     inCharacterGenAsset;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewComponent_InitWithCharacterGenAsset) == 0x000008, "Wrong alignment on X6AvatarPreviewComponent_InitWithCharacterGenAsset");
static_assert(sizeof(X6AvatarPreviewComponent_InitWithCharacterGenAsset) == 0x000008, "Wrong size on X6AvatarPreviewComponent_InitWithCharacterGenAsset");
static_assert(offsetof(X6AvatarPreviewComponent_InitWithCharacterGenAsset, inCharacterGenAsset) == 0x000000, "Member 'X6AvatarPreviewComponent_InitWithCharacterGenAsset::inCharacterGenAsset' has a wrong offset!");

// Function X6Game.X6AvatarPreviewComponent.SetAvatarTag
// 0x0004 (0x0004 - 0x0000)
struct X6AvatarPreviewComponent_SetAvatarTag final
{
public:
	int32                                         AvatarTagValue;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewComponent_SetAvatarTag) == 0x000004, "Wrong alignment on X6AvatarPreviewComponent_SetAvatarTag");
static_assert(sizeof(X6AvatarPreviewComponent_SetAvatarTag) == 0x000004, "Wrong size on X6AvatarPreviewComponent_SetAvatarTag");
static_assert(offsetof(X6AvatarPreviewComponent_SetAvatarTag, AvatarTagValue) == 0x000000, "Member 'X6AvatarPreviewComponent_SetAvatarTag::AvatarTagValue' has a wrong offset!");

// Function X6Game.X6AvatarPreviewComponent.SetAvatarTagByName
// 0x0010 (0x0010 - 0x0000)
struct X6AvatarPreviewComponent_SetAvatarTagByName final
{
public:
	class FString                                 EnumDisplayName;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewComponent_SetAvatarTagByName) == 0x000008, "Wrong alignment on X6AvatarPreviewComponent_SetAvatarTagByName");
static_assert(sizeof(X6AvatarPreviewComponent_SetAvatarTagByName) == 0x000010, "Wrong size on X6AvatarPreviewComponent_SetAvatarTagByName");
static_assert(offsetof(X6AvatarPreviewComponent_SetAvatarTagByName, EnumDisplayName) == 0x000000, "Member 'X6AvatarPreviewComponent_SetAvatarTagByName::EnumDisplayName' has a wrong offset!");

// Function X6Game.X6AvatarPreviewComponent.TestHiddenPart
// 0x0004 (0x0004 - 0x0000)
struct X6AvatarPreviewComponent_TestHiddenPart final
{
public:
	int32                                         AvatarTagValue;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewComponent_TestHiddenPart) == 0x000004, "Wrong alignment on X6AvatarPreviewComponent_TestHiddenPart");
static_assert(sizeof(X6AvatarPreviewComponent_TestHiddenPart) == 0x000004, "Wrong size on X6AvatarPreviewComponent_TestHiddenPart");
static_assert(offsetof(X6AvatarPreviewComponent_TestHiddenPart, AvatarTagValue) == 0x000000, "Member 'X6AvatarPreviewComponent_TestHiddenPart::AvatarTagValue' has a wrong offset!");

// Function X6Game.X6AvatarPreviewComponent.TestHighHeel
// 0x0004 (0x0004 - 0x0000)
struct X6AvatarPreviewComponent_TestHighHeel final
{
public:
	int32                                         AvatarTagValue;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AvatarPreviewComponent_TestHighHeel) == 0x000004, "Wrong alignment on X6AvatarPreviewComponent_TestHighHeel");
static_assert(sizeof(X6AvatarPreviewComponent_TestHighHeel) == 0x000004, "Wrong size on X6AvatarPreviewComponent_TestHighHeel");
static_assert(offsetof(X6AvatarPreviewComponent_TestHighHeel, AvatarTagValue) == 0x000000, "Member 'X6AvatarPreviewComponent_TestHighHeel::AvatarTagValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.AddHitResult
// 0x0108 (0x0108 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_AddHitResult final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_AddHitResult) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_AddHitResult");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_AddHitResult) == 0x000108, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_AddHitResult");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddHitResult, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddHitResult::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddHitResult, HitResult) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddHitResult::HitResult' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddHitResult, ReturnValue) == 0x000100, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddHitResult::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.AddSingleTargetComponentForPriority
// 0x0018 (0x0018 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    InTargetComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority) == 0x000018, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority, InTargetComponent) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority::InTargetComponent' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority, ReturnValue) == 0x000010, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddSingleTargetComponentForPriority::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.AddTargetActor
// 0x0018 (0x0018 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_AddTargetActor final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InTargetActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_AddTargetActor) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_AddTargetActor");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_AddTargetActor) == 0x000018, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_AddTargetActor");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddTargetActor, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddTargetActor::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddTargetActor, InTargetActor) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddTargetActor::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddTargetActor, ReturnValue) == 0x000010, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddTargetActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.AddTargetComponent
// 0x0018 (0x0018 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    InTargetComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent) == 0x000018, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent, InTargetComponent) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent::InTargetComponent' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent, ReturnValue) == 0x000010, "Member 'X6TargetingSelectionTask_ChargeUpBase_AddTargetComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.K2_CanSelect
// 0x0058 (0x0058 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetingSourceContext                SourceContext;                                     // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect) == 0x000058, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect, SourceContext) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect::SourceContext' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect, ReturnValue) == 0x000050, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_CanSelect::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.K2_IsExistForwardTargets
// 0x0040 (0x0040 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets final
{
public:
	const class AActor*                           SourceActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InHalfSize;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InOffset;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets) == 0x000040, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets, SourceActor) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets::SourceActor' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets, InHalfSize) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets::InHalfSize' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets, InOffset) == 0x000020, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets::InOffset' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets, ReturnValue) == 0x000038, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsExistForwardTargets::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.K2_IsResultsExistTargetActorOrComponent
// 0x0020 (0x0020 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InTargetActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    InTargetComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent) == 0x000020, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent, InTargetActor) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent, InTargetComponent) == 0x000010, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent::InTargetComponent' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent, ReturnValue) == 0x000018, "Member 'X6TargetingSelectionTask_ChargeUpBase_K2_IsResultsExistTargetActorOrComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.SelectTargets
// 0x0050 (0x0050 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_SelectTargets final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetingSourceContext                SourceContext;                                     // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_SelectTargets) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_SelectTargets");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_SelectTargets) == 0x000050, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_SelectTargets");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_SelectTargets, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_SelectTargets::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_SelectTargets, SourceContext) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_SelectTargets::SourceContext' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_ChargeUpBase.UpdateSelectingTransformInfo
// 0x0030 (0x0030 - 0x0000)
struct X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo final
{
public:
	const class AActor*                           SourceActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthLength;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo");
static_assert(sizeof(X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo) == 0x000030, "Wrong size on X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo, SourceActor) == 0x000000, "Member 'X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo, SocketName) == 0x000008, "Member 'X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo::SocketName' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo, DepthLength) == 0x000010, "Member 'X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo::DepthLength' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo, Offset) == 0x000018, "Member 'X6TargetingSelectionTask_ChargeUpBase_UpdateSelectingTransformInfo::Offset' has a wrong offset!");

// Function X6Game.X6BasePuzzleManager.HandleCheckPropertiesBeginPlayCompleted
// 0x0008 (0x0008 - 0x0000)
struct X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted) == 0x000008, "Wrong alignment on X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted");
static_assert(sizeof(X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted) == 0x000008, "Wrong size on X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted");
static_assert(offsetof(X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted, Actor) == 0x000000, "Member 'X6BasePuzzleManager_HandleCheckPropertiesBeginPlayCompleted::Actor' has a wrong offset!");

// Function X6Game.X6CharacterBase.ReceiveMovementFromServer
// 0x0068 (0x0068 - 0x0000)
struct X6CharacterBase_ReceiveMovementFromServer final
{
public:
	struct FX6ReplicatedMovement                  InReplicatedMovement;                              // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_ReceiveMovementFromServer) == 0x000008, "Wrong alignment on X6CharacterBase_ReceiveMovementFromServer");
static_assert(sizeof(X6CharacterBase_ReceiveMovementFromServer) == 0x000068, "Wrong size on X6CharacterBase_ReceiveMovementFromServer");
static_assert(offsetof(X6CharacterBase_ReceiveMovementFromServer, InReplicatedMovement) == 0x000000, "Member 'X6CharacterBase_ReceiveMovementFromServer::InReplicatedMovement' has a wrong offset!");

// Function X6Game.X6CharacterBase.ServerInit
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterBase_ServerInit final
{
public:
	bool                                          bServer;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_ServerInit) == 0x000001, "Wrong alignment on X6CharacterBase_ServerInit");
static_assert(sizeof(X6CharacterBase_ServerInit) == 0x000001, "Wrong size on X6CharacterBase_ServerInit");
static_assert(offsetof(X6CharacterBase_ServerInit, bServer) == 0x000000, "Member 'X6CharacterBase_ServerInit::bServer' has a wrong offset!");

// Function X6Game.X6CharacterBase.SetLocalRole
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterBase_SetLocalRole final
{
public:
	ENetRole                                      InRole;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_SetLocalRole) == 0x000001, "Wrong alignment on X6CharacterBase_SetLocalRole");
static_assert(sizeof(X6CharacterBase_SetLocalRole) == 0x000001, "Wrong size on X6CharacterBase_SetLocalRole");
static_assert(offsetof(X6CharacterBase_SetLocalRole, InRole) == 0x000000, "Member 'X6CharacterBase_SetLocalRole::InRole' has a wrong offset!");

// Function X6Game.X6CharacterBase.SetSimulatedReplicateMovement
// 0x0002 (0x0002 - 0x0000)
struct X6CharacterBase_SetSimulatedReplicateMovement final
{
public:
	bool                                          bInSimulatedReplicateMovement;                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshReplication;                               // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_SetSimulatedReplicateMovement) == 0x000001, "Wrong alignment on X6CharacterBase_SetSimulatedReplicateMovement");
static_assert(sizeof(X6CharacterBase_SetSimulatedReplicateMovement) == 0x000002, "Wrong size on X6CharacterBase_SetSimulatedReplicateMovement");
static_assert(offsetof(X6CharacterBase_SetSimulatedReplicateMovement, bInSimulatedReplicateMovement) == 0x000000, "Member 'X6CharacterBase_SetSimulatedReplicateMovement::bInSimulatedReplicateMovement' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_SetSimulatedReplicateMovement, bRefreshReplication) == 0x000001, "Member 'X6CharacterBase_SetSimulatedReplicateMovement::bRefreshReplication' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_AddTag
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_AddTag final
{
public:
	TArray<class FName>                           NewX6Tags;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_AddTag) == 0x000008, "Wrong alignment on X6CharacterBase_X6_AddTag");
static_assert(sizeof(X6CharacterBase_X6_AddTag) == 0x000010, "Wrong size on X6CharacterBase_X6_AddTag");
static_assert(offsetof(X6CharacterBase_X6_AddTag, NewX6Tags) == 0x000000, "Member 'X6CharacterBase_X6_AddTag::NewX6Tags' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_ClearAndInvalidateTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterBase_X6_ClearAndInvalidateTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_ClearAndInvalidateTimerHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_ClearAndInvalidateTimerHandle");
static_assert(sizeof(X6CharacterBase_X6_ClearAndInvalidateTimerHandle) == 0x000008, "Wrong size on X6CharacterBase_X6_ClearAndInvalidateTimerHandle");
static_assert(offsetof(X6CharacterBase_X6_ClearAndInvalidateTimerHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_ClearAndInvalidateTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_ClearTimer
// 0x0018 (0x0018 - 0x0000)
struct X6CharacterBase_X6_ClearTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_ClearTimer) == 0x000008, "Wrong alignment on X6CharacterBase_X6_ClearTimer");
static_assert(sizeof(X6CharacterBase_X6_ClearTimer) == 0x000018, "Wrong size on X6CharacterBase_X6_ClearTimer");
static_assert(offsetof(X6CharacterBase_X6_ClearTimer, Object) == 0x000000, "Member 'X6CharacterBase_X6_ClearTimer::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_ClearTimer, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_ClearTimer::FunctionName' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_ClearTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_ClearTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_ClearTimerDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_ClearTimerDelegate");
static_assert(sizeof(X6CharacterBase_X6_ClearTimerDelegate) == 0x000010, "Wrong size on X6CharacterBase_X6_ClearTimerDelegate");
static_assert(offsetof(X6CharacterBase_X6_ClearTimerDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_ClearTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_ClearTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterBase_X6_ClearTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_ClearTimerHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_ClearTimerHandle");
static_assert(sizeof(X6CharacterBase_X6_ClearTimerHandle) == 0x000008, "Wrong size on X6CharacterBase_X6_ClearTimerHandle");
static_assert(offsetof(X6CharacterBase_X6_ClearTimerHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_ClearTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_DeleteTag
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_DeleteTag final
{
public:
	class FString                                 strTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_DeleteTag) == 0x000008, "Wrong alignment on X6CharacterBase_X6_DeleteTag");
static_assert(sizeof(X6CharacterBase_X6_DeleteTag) == 0x000010, "Wrong size on X6CharacterBase_X6_DeleteTag");
static_assert(offsetof(X6CharacterBase_X6_DeleteTag, strTag) == 0x000000, "Member 'X6CharacterBase_X6_DeleteTag::strTag' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetActorHiddenFlags
// 0x0058 (0x0058 - 0x0000)
struct X6CharacterBase_X6_GetActorHiddenFlags final
{
public:
	TSet<int32>                                   OutFlags;                                          // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetActorHiddenFlags) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetActorHiddenFlags");
static_assert(sizeof(X6CharacterBase_X6_GetActorHiddenFlags) == 0x000058, "Wrong size on X6CharacterBase_X6_GetActorHiddenFlags");
static_assert(offsetof(X6CharacterBase_X6_GetActorHiddenFlags, OutFlags) == 0x000000, "Member 'X6CharacterBase_X6_GetActorHiddenFlags::OutFlags' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetActorHiddenFlags, ReturnValue) == 0x000050, "Member 'X6CharacterBase_X6_GetActorHiddenFlags::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTag
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_GetTag final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_GetTag) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTag");
static_assert(sizeof(X6CharacterBase_X6_GetTag) == 0x000010, "Wrong size on X6CharacterBase_X6_GetTag");
static_assert(offsetof(X6CharacterBase_X6_GetTag, ReturnValue) == 0x000000, "Member 'X6CharacterBase_X6_GetTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerElapsedTime
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_X6_GetTimerElapsedTime final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetTimerElapsedTime) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTimerElapsedTime");
static_assert(sizeof(X6CharacterBase_X6_GetTimerElapsedTime) == 0x000020, "Wrong size on X6CharacterBase_X6_GetTimerElapsedTime");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTime, Object) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerElapsedTime::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTime, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_GetTimerElapsedTime::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTime, ReturnValue) == 0x000018, "Member 'X6CharacterBase_X6_GetTimerElapsedTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerElapsedTimeDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6CharacterBase_X6_GetTimerElapsedTimeDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_GetTimerElapsedTimeDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_GetTimerElapsedTimeDelegate");
static_assert(sizeof(X6CharacterBase_X6_GetTimerElapsedTimeDelegate) == 0x000014, "Wrong size on X6CharacterBase_X6_GetTimerElapsedTimeDelegate");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeDelegate, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerElapsedTimeDelegateEachTrigger
// 0x0014 (0x0014 - 0x0000)
struct X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger) == 0x000004, "Wrong alignment on X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger");
static_assert(sizeof(X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger) == 0x000014, "Wrong size on X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeDelegateEachTrigger::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerElapsedTimeEachTrigger
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger");
static_assert(sizeof(X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger) == 0x000020, "Wrong size on X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger, Object) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger, ReturnValue) == 0x000018, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeEachTrigger::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerElapsedTimeHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_GetTimerElapsedTimeHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetTimerElapsedTimeHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTimerElapsedTimeHandle");
static_assert(sizeof(X6CharacterBase_X6_GetTimerElapsedTimeHandle) == 0x000010, "Wrong size on X6CharacterBase_X6_GetTimerElapsedTimeHandle");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeHandle, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerElapsedTimeHandleEachTrigger
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger");
static_assert(sizeof(X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger) == 0x000010, "Wrong size on X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger, Handle) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_GetTimerElapsedTimeHandleEachTrigger::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerRemainingTime
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_X6_GetTimerRemainingTime final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetTimerRemainingTime) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTimerRemainingTime");
static_assert(sizeof(X6CharacterBase_X6_GetTimerRemainingTime) == 0x000020, "Wrong size on X6CharacterBase_X6_GetTimerRemainingTime");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTime, Object) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerRemainingTime::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTime, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_GetTimerRemainingTime::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTime, ReturnValue) == 0x000018, "Member 'X6CharacterBase_X6_GetTimerRemainingTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerRemainingTimeDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6CharacterBase_X6_GetTimerRemainingTimeDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_GetTimerRemainingTimeDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_GetTimerRemainingTimeDelegate");
static_assert(sizeof(X6CharacterBase_X6_GetTimerRemainingTimeDelegate) == 0x000014, "Wrong size on X6CharacterBase_X6_GetTimerRemainingTimeDelegate");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTimeDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerRemainingTimeDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTimeDelegate, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_GetTimerRemainingTimeDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_GetTimerRemainingTimeHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_GetTimerRemainingTimeHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_GetTimerRemainingTimeHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_GetTimerRemainingTimeHandle");
static_assert(sizeof(X6CharacterBase_X6_GetTimerRemainingTimeHandle) == 0x000010, "Wrong size on X6CharacterBase_X6_GetTimerRemainingTimeHandle");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTimeHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_GetTimerRemainingTimeHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_GetTimerRemainingTimeHandle, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_GetTimerRemainingTimeHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_HasTag
// 0x0018 (0x0018 - 0x0000)
struct X6CharacterBase_X6_HasTag final
{
public:
	class FString                                 strTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_HasTag) == 0x000008, "Wrong alignment on X6CharacterBase_X6_HasTag");
static_assert(sizeof(X6CharacterBase_X6_HasTag) == 0x000018, "Wrong size on X6CharacterBase_X6_HasTag");
static_assert(offsetof(X6CharacterBase_X6_HasTag, strTag) == 0x000000, "Member 'X6CharacterBase_X6_HasTag::strTag' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_HasTag, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_HasTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsTimerActive
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_X6_IsTimerActive final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsTimerActive) == 0x000008, "Wrong alignment on X6CharacterBase_X6_IsTimerActive");
static_assert(sizeof(X6CharacterBase_X6_IsTimerActive) == 0x000020, "Wrong size on X6CharacterBase_X6_IsTimerActive");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActive, Object) == 0x000000, "Member 'X6CharacterBase_X6_IsTimerActive::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActive, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_IsTimerActive::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActive, ReturnValue) == 0x000018, "Member 'X6CharacterBase_X6_IsTimerActive::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsTimerActiveDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6CharacterBase_X6_IsTimerActiveDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsTimerActiveDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_IsTimerActiveDelegate");
static_assert(sizeof(X6CharacterBase_X6_IsTimerActiveDelegate) == 0x000014, "Wrong size on X6CharacterBase_X6_IsTimerActiveDelegate");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActiveDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_IsTimerActiveDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActiveDelegate, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_IsTimerActiveDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsTimerActiveHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_IsTimerActiveHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsTimerActiveHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_IsTimerActiveHandle");
static_assert(sizeof(X6CharacterBase_X6_IsTimerActiveHandle) == 0x000010, "Wrong size on X6CharacterBase_X6_IsTimerActiveHandle");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActiveHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_IsTimerActiveHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerActiveHandle, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_IsTimerActiveHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsTimerPaused
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_X6_IsTimerPaused final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsTimerPaused) == 0x000008, "Wrong alignment on X6CharacterBase_X6_IsTimerPaused");
static_assert(sizeof(X6CharacterBase_X6_IsTimerPaused) == 0x000020, "Wrong size on X6CharacterBase_X6_IsTimerPaused");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPaused, Object) == 0x000000, "Member 'X6CharacterBase_X6_IsTimerPaused::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPaused, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_IsTimerPaused::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPaused, ReturnValue) == 0x000018, "Member 'X6CharacterBase_X6_IsTimerPaused::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsTimerPausedDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6CharacterBase_X6_IsTimerPausedDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsTimerPausedDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_IsTimerPausedDelegate");
static_assert(sizeof(X6CharacterBase_X6_IsTimerPausedDelegate) == 0x000014, "Wrong size on X6CharacterBase_X6_IsTimerPausedDelegate");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPausedDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_IsTimerPausedDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPausedDelegate, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_IsTimerPausedDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsTimerPausedHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_IsTimerPausedHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsTimerPausedHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_IsTimerPausedHandle");
static_assert(sizeof(X6CharacterBase_X6_IsTimerPausedHandle) == 0x000010, "Wrong size on X6CharacterBase_X6_IsTimerPausedHandle");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPausedHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_IsTimerPausedHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsTimerPausedHandle, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_IsTimerPausedHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_IsValidTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_IsValidTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_IsValidTimerHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_IsValidTimerHandle");
static_assert(sizeof(X6CharacterBase_X6_IsValidTimerHandle) == 0x000010, "Wrong size on X6CharacterBase_X6_IsValidTimerHandle");
static_assert(offsetof(X6CharacterBase_X6_IsValidTimerHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_IsValidTimerHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_IsValidTimerHandle, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_IsValidTimerHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_PauseTimer
// 0x0018 (0x0018 - 0x0000)
struct X6CharacterBase_X6_PauseTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_PauseTimer) == 0x000008, "Wrong alignment on X6CharacterBase_X6_PauseTimer");
static_assert(sizeof(X6CharacterBase_X6_PauseTimer) == 0x000018, "Wrong size on X6CharacterBase_X6_PauseTimer");
static_assert(offsetof(X6CharacterBase_X6_PauseTimer, Object) == 0x000000, "Member 'X6CharacterBase_X6_PauseTimer::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_PauseTimer, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_PauseTimer::FunctionName' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_PauseTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_PauseTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_PauseTimerDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_PauseTimerDelegate");
static_assert(sizeof(X6CharacterBase_X6_PauseTimerDelegate) == 0x000010, "Wrong size on X6CharacterBase_X6_PauseTimerDelegate");
static_assert(offsetof(X6CharacterBase_X6_PauseTimerDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_PauseTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_PauseTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterBase_X6_PauseTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_PauseTimerHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_PauseTimerHandle");
static_assert(sizeof(X6CharacterBase_X6_PauseTimerHandle) == 0x000008, "Wrong size on X6CharacterBase_X6_PauseTimerHandle");
static_assert(offsetof(X6CharacterBase_X6_PauseTimerHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_PauseTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_RequireActorFade
// 0x000C (0x000C - 0x0000)
struct X6CharacterBase_X6_RequireActorFade final
{
public:
	bool                                          bFadeIn;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FadeOutHiddenFlag;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInView;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_RequireActorFade) == 0x000004, "Wrong alignment on X6CharacterBase_X6_RequireActorFade");
static_assert(sizeof(X6CharacterBase_X6_RequireActorFade) == 0x00000C, "Wrong size on X6CharacterBase_X6_RequireActorFade");
static_assert(offsetof(X6CharacterBase_X6_RequireActorFade, bFadeIn) == 0x000000, "Member 'X6CharacterBase_X6_RequireActorFade::bFadeIn' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_RequireActorFade, FadeOutHiddenFlag) == 0x000004, "Member 'X6CharacterBase_X6_RequireActorFade::FadeOutHiddenFlag' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_RequireActorFade, bInView) == 0x000008, "Member 'X6CharacterBase_X6_RequireActorFade::bInView' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_SetActorHiddenInGame
// 0x000C (0x000C - 0x0000)
struct X6CharacterBase_X6_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Flag;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFlag;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_SetActorHiddenInGame) == 0x000004, "Wrong alignment on X6CharacterBase_X6_SetActorHiddenInGame");
static_assert(sizeof(X6CharacterBase_X6_SetActorHiddenInGame) == 0x00000C, "Wrong size on X6CharacterBase_X6_SetActorHiddenInGame");
static_assert(offsetof(X6CharacterBase_X6_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'X6CharacterBase_X6_SetActorHiddenInGame::bNewHidden' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetActorHiddenInGame, Flag) == 0x000004, "Member 'X6CharacterBase_X6_SetActorHiddenInGame::Flag' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetActorHiddenInGame, bClearFlag) == 0x000008, "Member 'X6CharacterBase_X6_SetActorHiddenInGame::bClearFlag' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetActorHiddenInGame, ReturnValue) == 0x000009, "Member 'X6CharacterBase_X6_SetActorHiddenInGame::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_SetTimer
// 0x0030 (0x0030 - 0x0000)
struct X6CharacterBase_X6_SetTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialStartDelay;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelayVariance;                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_SetTimer) == 0x000008, "Wrong alignment on X6CharacterBase_X6_SetTimer");
static_assert(sizeof(X6CharacterBase_X6_SetTimer) == 0x000030, "Wrong size on X6CharacterBase_X6_SetTimer");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, Object) == 0x000000, "Member 'X6CharacterBase_X6_SetTimer::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_SetTimer::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, Time) == 0x000018, "Member 'X6CharacterBase_X6_SetTimer::Time' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, bLooping) == 0x00001C, "Member 'X6CharacterBase_X6_SetTimer::bLooping' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, InitialStartDelay) == 0x000020, "Member 'X6CharacterBase_X6_SetTimer::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, InitialStartDelayVariance) == 0x000024, "Member 'X6CharacterBase_X6_SetTimer::InitialStartDelayVariance' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimer, ReturnValue) == 0x000028, "Member 'X6CharacterBase_X6_SetTimer::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_SetTimerDelegate
// 0x0028 (0x0028 - 0x0000)
struct X6CharacterBase_X6_SetTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialStartDelay;                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelayVariance;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_SetTimerDelegate) == 0x000008, "Wrong alignment on X6CharacterBase_X6_SetTimerDelegate");
static_assert(sizeof(X6CharacterBase_X6_SetTimerDelegate) == 0x000028, "Wrong size on X6CharacterBase_X6_SetTimerDelegate");
static_assert(offsetof(X6CharacterBase_X6_SetTimerDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_SetTimerDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimerDelegate, Time) == 0x000010, "Member 'X6CharacterBase_X6_SetTimerDelegate::Time' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimerDelegate, bLooping) == 0x000014, "Member 'X6CharacterBase_X6_SetTimerDelegate::bLooping' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimerDelegate, InitialStartDelay) == 0x000018, "Member 'X6CharacterBase_X6_SetTimerDelegate::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimerDelegate, InitialStartDelayVariance) == 0x00001C, "Member 'X6CharacterBase_X6_SetTimerDelegate::InitialStartDelayVariance' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_SetTimerDelegate, ReturnValue) == 0x000020, "Member 'X6CharacterBase_X6_SetTimerDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_TimerExists
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_X6_TimerExists final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_TimerExists) == 0x000008, "Wrong alignment on X6CharacterBase_X6_TimerExists");
static_assert(sizeof(X6CharacterBase_X6_TimerExists) == 0x000020, "Wrong size on X6CharacterBase_X6_TimerExists");
static_assert(offsetof(X6CharacterBase_X6_TimerExists, Object) == 0x000000, "Member 'X6CharacterBase_X6_TimerExists::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_TimerExists, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_TimerExists::FunctionName' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_TimerExists, ReturnValue) == 0x000018, "Member 'X6CharacterBase_X6_TimerExists::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_TimerExistsDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6CharacterBase_X6_TimerExistsDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_TimerExistsDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_TimerExistsDelegate");
static_assert(sizeof(X6CharacterBase_X6_TimerExistsDelegate) == 0x000014, "Wrong size on X6CharacterBase_X6_TimerExistsDelegate");
static_assert(offsetof(X6CharacterBase_X6_TimerExistsDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_TimerExistsDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_TimerExistsDelegate, ReturnValue) == 0x000010, "Member 'X6CharacterBase_X6_TimerExistsDelegate::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_TimerExistsHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_TimerExistsHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterBase_X6_TimerExistsHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_TimerExistsHandle");
static_assert(sizeof(X6CharacterBase_X6_TimerExistsHandle) == 0x000010, "Wrong size on X6CharacterBase_X6_TimerExistsHandle");
static_assert(offsetof(X6CharacterBase_X6_TimerExistsHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_TimerExistsHandle::Handle' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_TimerExistsHandle, ReturnValue) == 0x000008, "Member 'X6CharacterBase_X6_TimerExistsHandle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_UnPauseTimer
// 0x0018 (0x0018 - 0x0000)
struct X6CharacterBase_X6_UnPauseTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_UnPauseTimer) == 0x000008, "Wrong alignment on X6CharacterBase_X6_UnPauseTimer");
static_assert(sizeof(X6CharacterBase_X6_UnPauseTimer) == 0x000018, "Wrong size on X6CharacterBase_X6_UnPauseTimer");
static_assert(offsetof(X6CharacterBase_X6_UnPauseTimer, Object) == 0x000000, "Member 'X6CharacterBase_X6_UnPauseTimer::Object' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_X6_UnPauseTimer, FunctionName) == 0x000008, "Member 'X6CharacterBase_X6_UnPauseTimer::FunctionName' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_UnPauseTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct X6CharacterBase_X6_UnPauseTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_UnPauseTimerDelegate) == 0x000004, "Wrong alignment on X6CharacterBase_X6_UnPauseTimerDelegate");
static_assert(sizeof(X6CharacterBase_X6_UnPauseTimerDelegate) == 0x000010, "Wrong size on X6CharacterBase_X6_UnPauseTimerDelegate");
static_assert(offsetof(X6CharacterBase_X6_UnPauseTimerDelegate, Delegate) == 0x000000, "Member 'X6CharacterBase_X6_UnPauseTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6CharacterBase.X6_UnPauseTimerHandle
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterBase_X6_UnPauseTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_X6_UnPauseTimerHandle) == 0x000008, "Wrong alignment on X6CharacterBase_X6_UnPauseTimerHandle");
static_assert(sizeof(X6CharacterBase_X6_UnPauseTimerHandle) == 0x000008, "Wrong size on X6CharacterBase_X6_UnPauseTimerHandle");
static_assert(offsetof(X6CharacterBase_X6_UnPauseTimerHandle, Handle) == 0x000000, "Member 'X6CharacterBase_X6_UnPauseTimerHandle::Handle' has a wrong offset!");

// Function X6Game.X6CharacterBase.GetMoveGoalOffsetInternal
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterBase_GetMoveGoalOffsetInternal final
{
public:
	const class AActor*                           MovingActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_GetMoveGoalOffsetInternal) == 0x000008, "Wrong alignment on X6CharacterBase_GetMoveGoalOffsetInternal");
static_assert(sizeof(X6CharacterBase_GetMoveGoalOffsetInternal) == 0x000020, "Wrong size on X6CharacterBase_GetMoveGoalOffsetInternal");
static_assert(offsetof(X6CharacterBase_GetMoveGoalOffsetInternal, MovingActor) == 0x000000, "Member 'X6CharacterBase_GetMoveGoalOffsetInternal::MovingActor' has a wrong offset!");
static_assert(offsetof(X6CharacterBase_GetMoveGoalOffsetInternal, ReturnValue) == 0x000008, "Member 'X6CharacterBase_GetMoveGoalOffsetInternal::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.IsSimulatedReplicateAttachment
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterBase_IsSimulatedReplicateAttachment final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_IsSimulatedReplicateAttachment) == 0x000001, "Wrong alignment on X6CharacterBase_IsSimulatedReplicateAttachment");
static_assert(sizeof(X6CharacterBase_IsSimulatedReplicateAttachment) == 0x000001, "Wrong size on X6CharacterBase_IsSimulatedReplicateAttachment");
static_assert(offsetof(X6CharacterBase_IsSimulatedReplicateAttachment, ReturnValue) == 0x000000, "Member 'X6CharacterBase_IsSimulatedReplicateAttachment::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterBase.IsSimulatedReplicateMovement
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterBase_IsSimulatedReplicateMovement final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterBase_IsSimulatedReplicateMovement) == 0x000001, "Wrong alignment on X6CharacterBase_IsSimulatedReplicateMovement");
static_assert(sizeof(X6CharacterBase_IsSimulatedReplicateMovement) == 0x000001, "Wrong size on X6CharacterBase_IsSimulatedReplicateMovement");
static_assert(offsetof(X6CharacterBase_IsSimulatedReplicateMovement, ReturnValue) == 0x000000, "Member 'X6CharacterBase_IsSimulatedReplicateMovement::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterWithAbilities.K2_SetReplicatePriority
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterWithAbilities_K2_SetReplicatePriority final
{
public:
	int32                                         NewReplicatePriority;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterWithAbilities_K2_SetReplicatePriority) == 0x000004, "Wrong alignment on X6CharacterWithAbilities_K2_SetReplicatePriority");
static_assert(sizeof(X6CharacterWithAbilities_K2_SetReplicatePriority) == 0x000004, "Wrong size on X6CharacterWithAbilities_K2_SetReplicatePriority");
static_assert(offsetof(X6CharacterWithAbilities_K2_SetReplicatePriority, NewReplicatePriority) == 0x000000, "Member 'X6CharacterWithAbilities_K2_SetReplicatePriority::NewReplicatePriority' has a wrong offset!");

// Function X6Game.X6CharacterWithAbilities.K2_SetShouldForceReplicateProperty
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty final
{
public:
	bool                                          bReplicate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty) == 0x000001, "Wrong alignment on X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty");
static_assert(sizeof(X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty) == 0x000001, "Wrong size on X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty");
static_assert(offsetof(X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty, bReplicate) == 0x000000, "Member 'X6CharacterWithAbilities_K2_SetShouldForceReplicateProperty::bReplicate' has a wrong offset!");

// Function X6Game.X6CharacterWithAbilities.GetX6AbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterWithAbilities_GetX6AbilitySystemComponent final
{
public:
	class UX6AbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterWithAbilities_GetX6AbilitySystemComponent) == 0x000008, "Wrong alignment on X6CharacterWithAbilities_GetX6AbilitySystemComponent");
static_assert(sizeof(X6CharacterWithAbilities_GetX6AbilitySystemComponent) == 0x000008, "Wrong size on X6CharacterWithAbilities_GetX6AbilitySystemComponent");
static_assert(offsetof(X6CharacterWithAbilities_GetX6AbilitySystemComponent, ReturnValue) == 0x000000, "Member 'X6CharacterWithAbilities_GetX6AbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiPawn.Client_GetCameraState
// 0x0004 (0x0004 - 0x0000)
struct X6NikkiPawn_Client_GetCameraState final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiPawn_Client_GetCameraState) == 0x000004, "Wrong alignment on X6NikkiPawn_Client_GetCameraState");
static_assert(sizeof(X6NikkiPawn_Client_GetCameraState) == 0x000004, "Wrong size on X6NikkiPawn_Client_GetCameraState");
static_assert(offsetof(X6NikkiPawn_Client_GetCameraState, ReturnValue) == 0x000000, "Member 'X6NikkiPawn_Client_GetCameraState::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiPawn.IsCarryItem
// 0x0001 (0x0001 - 0x0000)
struct X6NikkiPawn_IsCarryItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiPawn_IsCarryItem) == 0x000001, "Wrong alignment on X6NikkiPawn_IsCarryItem");
static_assert(sizeof(X6NikkiPawn_IsCarryItem) == 0x000001, "Wrong size on X6NikkiPawn_IsCarryItem");
static_assert(offsetof(X6NikkiPawn_IsCarryItem, ReturnValue) == 0x000000, "Member 'X6NikkiPawn_IsCarryItem::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiPawn.IsEnableFootIK
// 0x0001 (0x0001 - 0x0000)
struct X6NikkiPawn_IsEnableFootIK final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiPawn_IsEnableFootIK) == 0x000001, "Wrong alignment on X6NikkiPawn_IsEnableFootIK");
static_assert(sizeof(X6NikkiPawn_IsEnableFootIK) == 0x000001, "Wrong size on X6NikkiPawn_IsEnableFootIK");
static_assert(offsetof(X6NikkiPawn_IsEnableFootIK, ReturnValue) == 0x000000, "Member 'X6NikkiPawn_IsEnableFootIK::ReturnValue' has a wrong offset!");

// Function X6Game.X6BasicMoveableComponent.GatherCurrentInputDirection
// 0x0028 (0x0028 - 0x0000)
struct X6BasicMoveableComponent_GatherCurrentInputDirection final
{
public:
	class AActor*                                 ReferenceActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardInputValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightInputValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BasicMoveableComponent_GatherCurrentInputDirection) == 0x000008, "Wrong alignment on X6BasicMoveableComponent_GatherCurrentInputDirection");
static_assert(sizeof(X6BasicMoveableComponent_GatherCurrentInputDirection) == 0x000028, "Wrong size on X6BasicMoveableComponent_GatherCurrentInputDirection");
static_assert(offsetof(X6BasicMoveableComponent_GatherCurrentInputDirection, ReferenceActor) == 0x000000, "Member 'X6BasicMoveableComponent_GatherCurrentInputDirection::ReferenceActor' has a wrong offset!");
static_assert(offsetof(X6BasicMoveableComponent_GatherCurrentInputDirection, ForwardInputValue) == 0x000008, "Member 'X6BasicMoveableComponent_GatherCurrentInputDirection::ForwardInputValue' has a wrong offset!");
static_assert(offsetof(X6BasicMoveableComponent_GatherCurrentInputDirection, RightInputValue) == 0x00000C, "Member 'X6BasicMoveableComponent_GatherCurrentInputDirection::RightInputValue' has a wrong offset!");
static_assert(offsetof(X6BasicMoveableComponent_GatherCurrentInputDirection, ReturnValue) == 0x000010, "Member 'X6BasicMoveableComponent_GatherCurrentInputDirection::ReturnValue' has a wrong offset!");

// Function X6Game.X6BasicRegularMovementComponent.CalculateMovementBlockedByHeight
// 0x0108 (0x0108 - 0x0000)
struct X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         BoundaryFromLowToHigh;                             // 0x00F8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterBlockAngle;                                   // 0x00FC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0100(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight) == 0x000008, "Wrong alignment on X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight");
static_assert(sizeof(X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight) == 0x000108, "Wrong size on X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight");
static_assert(offsetof(X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight, HitResult) == 0x000000, "Member 'X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight::HitResult' has a wrong offset!");
static_assert(offsetof(X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight, BoundaryFromLowToHigh) == 0x0000F8, "Member 'X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight::BoundaryFromLowToHigh' has a wrong offset!");
static_assert(offsetof(X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight, EnterBlockAngle) == 0x0000FC, "Member 'X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight::EnterBlockAngle' has a wrong offset!");
static_assert(offsetof(X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight, ReturnValue) == 0x000100, "Member 'X6BasicRegularMovementComponent_CalculateMovementBlockedByHeight::ReturnValue' has a wrong offset!");

// Function X6Game.X6BasicRegularMovementComponent.CheckExitMovementBlockedByState
// 0x0008 (0x0008 - 0x0000)
struct X6BasicRegularMovementComponent_CheckExitMovementBlockedByState final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitBlockAngle;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BasicRegularMovementComponent_CheckExitMovementBlockedByState) == 0x000004, "Wrong alignment on X6BasicRegularMovementComponent_CheckExitMovementBlockedByState");
static_assert(sizeof(X6BasicRegularMovementComponent_CheckExitMovementBlockedByState) == 0x000008, "Wrong size on X6BasicRegularMovementComponent_CheckExitMovementBlockedByState");
static_assert(offsetof(X6BasicRegularMovementComponent_CheckExitMovementBlockedByState, DeltaSeconds) == 0x000000, "Member 'X6BasicRegularMovementComponent_CheckExitMovementBlockedByState::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(X6BasicRegularMovementComponent_CheckExitMovementBlockedByState, ExitBlockAngle) == 0x000004, "Member 'X6BasicRegularMovementComponent_CheckExitMovementBlockedByState::ExitBlockAngle' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.GetAssetPath
// 0x0028 (0x0028 - 0x0000)
struct X6MultiPlayerSubSystem_GetAssetPath final
{
public:
	int32                                         InGuid;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OutPath;                                           // 0x0008(0x0020)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiPlayerSubSystem_GetAssetPath) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_GetAssetPath");
static_assert(sizeof(X6MultiPlayerSubSystem_GetAssetPath) == 0x000028, "Wrong size on X6MultiPlayerSubSystem_GetAssetPath");
static_assert(offsetof(X6MultiPlayerSubSystem_GetAssetPath, InGuid) == 0x000000, "Member 'X6MultiPlayerSubSystem_GetAssetPath::InGuid' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_GetAssetPath, OutPath) == 0x000008, "Member 'X6MultiPlayerSubSystem_GetAssetPath::OutPath' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.RegisterSimulatedActor
// 0x0010 (0x0010 - 0x0000)
struct X6MultiPlayerSubSystem_RegisterSimulatedActor final
{
public:
	int32                                         EntityID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewSimulatedActor;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiPlayerSubSystem_RegisterSimulatedActor) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_RegisterSimulatedActor");
static_assert(sizeof(X6MultiPlayerSubSystem_RegisterSimulatedActor) == 0x000010, "Wrong size on X6MultiPlayerSubSystem_RegisterSimulatedActor");
static_assert(offsetof(X6MultiPlayerSubSystem_RegisterSimulatedActor, EntityID) == 0x000000, "Member 'X6MultiPlayerSubSystem_RegisterSimulatedActor::EntityID' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_RegisterSimulatedActor, NewSimulatedActor) == 0x000008, "Member 'X6MultiPlayerSubSystem_RegisterSimulatedActor::NewSimulatedActor' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.RegisterSpawner
// 0x0010 (0x0010 - 0x0000)
struct X6MultiPlayerSubSystem_RegisterSpawner final
{
public:
	int64                                         SpawnerID;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiPlayerSubSystem_RegisterSpawner) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_RegisterSpawner");
static_assert(sizeof(X6MultiPlayerSubSystem_RegisterSpawner) == 0x000010, "Wrong size on X6MultiPlayerSubSystem_RegisterSpawner");
static_assert(offsetof(X6MultiPlayerSubSystem_RegisterSpawner, SpawnerID) == 0x000000, "Member 'X6MultiPlayerSubSystem_RegisterSpawner::SpawnerID' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_RegisterSpawner, Actor) == 0x000008, "Member 'X6MultiPlayerSubSystem_RegisterSpawner::Actor' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.UnregisterSimulatedActor
// 0x0004 (0x0004 - 0x0000)
struct X6MultiPlayerSubSystem_UnregisterSimulatedActor final
{
public:
	int32                                         EntityID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiPlayerSubSystem_UnregisterSimulatedActor) == 0x000004, "Wrong alignment on X6MultiPlayerSubSystem_UnregisterSimulatedActor");
static_assert(sizeof(X6MultiPlayerSubSystem_UnregisterSimulatedActor) == 0x000004, "Wrong size on X6MultiPlayerSubSystem_UnregisterSimulatedActor");
static_assert(offsetof(X6MultiPlayerSubSystem_UnregisterSimulatedActor, EntityID) == 0x000000, "Member 'X6MultiPlayerSubSystem_UnregisterSimulatedActor::EntityID' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.UnregisterSpawner
// 0x0010 (0x0010 - 0x0000)
struct X6MultiPlayerSubSystem_UnregisterSpawner final
{
public:
	int64                                         SpawnerID;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiPlayerSubSystem_UnregisterSpawner) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_UnregisterSpawner");
static_assert(sizeof(X6MultiPlayerSubSystem_UnregisterSpawner) == 0x000010, "Wrong size on X6MultiPlayerSubSystem_UnregisterSpawner");
static_assert(offsetof(X6MultiPlayerSubSystem_UnregisterSpawner, SpawnerID) == 0x000000, "Member 'X6MultiPlayerSubSystem_UnregisterSpawner::SpawnerID' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_UnregisterSpawner, Actor) == 0x000008, "Member 'X6MultiPlayerSubSystem_UnregisterSpawner::Actor' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.GetAssetGuid
// 0x0028 (0x0028 - 0x0000)
struct X6MultiPlayerSubSystem_GetAssetGuid final
{
public:
	struct FSoftObjectPath                        InPath;                                            // 0x0000(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6MultiPlayerSubSystem_GetAssetGuid) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_GetAssetGuid");
static_assert(sizeof(X6MultiPlayerSubSystem_GetAssetGuid) == 0x000028, "Wrong size on X6MultiPlayerSubSystem_GetAssetGuid");
static_assert(offsetof(X6MultiPlayerSubSystem_GetAssetGuid, InPath) == 0x000000, "Member 'X6MultiPlayerSubSystem_GetAssetGuid::InPath' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_GetAssetGuid, ReturnValue) == 0x000020, "Member 'X6MultiPlayerSubSystem_GetAssetGuid::ReturnValue' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.GetAssetPathString
// 0x0018 (0x0018 - 0x0000)
struct X6MultiPlayerSubSystem_GetAssetPathString final
{
public:
	int32                                         InGuid;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiPlayerSubSystem_GetAssetPathString) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_GetAssetPathString");
static_assert(sizeof(X6MultiPlayerSubSystem_GetAssetPathString) == 0x000018, "Wrong size on X6MultiPlayerSubSystem_GetAssetPathString");
static_assert(offsetof(X6MultiPlayerSubSystem_GetAssetPathString, InGuid) == 0x000000, "Member 'X6MultiPlayerSubSystem_GetAssetPathString::InGuid' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_GetAssetPathString, ReturnValue) == 0x000008, "Member 'X6MultiPlayerSubSystem_GetAssetPathString::ReturnValue' has a wrong offset!");

// Function X6Game.X6MultiPlayerSubSystem.GetPathStringGuid
// 0x0018 (0x0018 - 0x0000)
struct X6MultiPlayerSubSystem_GetPathStringGuid final
{
public:
	class FString                                 InPathString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6MultiPlayerSubSystem_GetPathStringGuid) == 0x000008, "Wrong alignment on X6MultiPlayerSubSystem_GetPathStringGuid");
static_assert(sizeof(X6MultiPlayerSubSystem_GetPathStringGuid) == 0x000018, "Wrong size on X6MultiPlayerSubSystem_GetPathStringGuid");
static_assert(offsetof(X6MultiPlayerSubSystem_GetPathStringGuid, InPathString) == 0x000000, "Member 'X6MultiPlayerSubSystem_GetPathStringGuid::InPathString' has a wrong offset!");
static_assert(offsetof(X6MultiPlayerSubSystem_GetPathStringGuid, ReturnValue) == 0x000010, "Member 'X6MultiPlayerSubSystem_GetPathStringGuid::ReturnValue' has a wrong offset!");

// Function X6Game.X6CarrierBaseProcessor.Update
// 0x0004 (0x0004 - 0x0000)
struct X6CarrierBaseProcessor_Update final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CarrierBaseProcessor_Update) == 0x000004, "Wrong alignment on X6CarrierBaseProcessor_Update");
static_assert(sizeof(X6CarrierBaseProcessor_Update) == 0x000004, "Wrong size on X6CarrierBaseProcessor_Update");
static_assert(offsetof(X6CarrierBaseProcessor_Update, DeltaSeconds) == 0x000000, "Member 'X6CarrierBaseProcessor_Update::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.COMAdjustment
// 0x0004 (0x0004 - 0x0000)
struct X6BikePosturalCorrectionProcessor_COMAdjustment final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_COMAdjustment) == 0x000004, "Wrong alignment on X6BikePosturalCorrectionProcessor_COMAdjustment");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_COMAdjustment) == 0x000004, "Wrong size on X6BikePosturalCorrectionProcessor_COMAdjustment");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_COMAdjustment, DeltaSeconds) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_COMAdjustment::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.SetUseAccelerateSlopeCalculate
// 0x0001 (0x0001 - 0x0000)
struct X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate final
{
public:
	bool                                          bUseAccelerate;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate) == 0x000001, "Wrong alignment on X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate) == 0x000001, "Wrong size on X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate, bUseAccelerate) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_SetUseAccelerateSlopeCalculate::bUseAccelerate' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.UpdateBikeOnSlopeAngle
// 0x0004 (0x0004 - 0x0000)
struct X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle) == 0x000004, "Wrong alignment on X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle) == 0x000004, "Wrong size on X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle, DeltaSeconds) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_UpdateBikeOnSlopeAngle::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.UpdateBikeWheelInAirAngle
// 0x0008 (0x0008 - 0x0000)
struct X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle) == 0x000004, "Wrong alignment on X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle) == 0x000008, "Wrong size on X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle, DeltaSeconds) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle, ReturnValue) == 0x000004, "Member 'X6BikePosturalCorrectionProcessor_UpdateBikeWheelInAirAngle::ReturnValue' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.UpdateBikeWheelOnGroundAngle
// 0x0004 (0x0004 - 0x0000)
struct X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle) == 0x000004, "Wrong alignment on X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle) == 0x000004, "Wrong size on X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle, DeltaSeconds) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_UpdateBikeWheelOnGroundAngle::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.UpdateBikeWheelRotationAngle
// 0x0004 (0x0004 - 0x0000)
struct X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle) == 0x000004, "Wrong alignment on X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle) == 0x000004, "Wrong size on X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle, DeltaSeconds) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_UpdateBikeWheelRotationAngle::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BikePosturalCorrectionProcessor.UpdateFloorNormal
// 0x0004 (0x0004 - 0x0000)
struct X6BikePosturalCorrectionProcessor_UpdateFloorNormal final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BikePosturalCorrectionProcessor_UpdateFloorNormal) == 0x000004, "Wrong alignment on X6BikePosturalCorrectionProcessor_UpdateFloorNormal");
static_assert(sizeof(X6BikePosturalCorrectionProcessor_UpdateFloorNormal) == 0x000004, "Wrong size on X6BikePosturalCorrectionProcessor_UpdateFloorNormal");
static_assert(offsetof(X6BikePosturalCorrectionProcessor_UpdateFloorNormal, DeltaSeconds) == 0x000000, "Member 'X6BikePosturalCorrectionProcessor_UpdateFloorNormal::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6GetActiveAudioComponentOpertion.Activate
// 0x0008 (0x0008 - 0x0000)
struct X6GetActiveAudioComponentOpertion_Activate final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GetActiveAudioComponentOpertion_Activate) == 0x000008, "Wrong alignment on X6GetActiveAudioComponentOpertion_Activate");
static_assert(sizeof(X6GetActiveAudioComponentOpertion_Activate) == 0x000008, "Wrong size on X6GetActiveAudioComponentOpertion_Activate");
static_assert(offsetof(X6GetActiveAudioComponentOpertion_Activate, WorldContextObject) == 0x000000, "Member 'X6GetActiveAudioComponentOpertion_Activate::WorldContextObject' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ActorFaceTowardsActor
// 0x0040 (0x0040 - 0x0000)
struct X6BlueprintLibrary_ActorFaceTowardsActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnInPlace;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAt;                                           // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLookAtParams                          LookAtParam;                                       // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnComplete;                                        // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterrupt;                                       // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ActorFaceTowardsActor) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ActorFaceTowardsActor");
static_assert(sizeof(X6BlueprintLibrary_ActorFaceTowardsActor) == 0x000040, "Wrong size on X6BlueprintLibrary_ActorFaceTowardsActor");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, InActor) == 0x000000, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, TargetActor) == 0x000008, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::TargetActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, bTurnInPlace) == 0x000010, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::bTurnInPlace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, bLookAt) == 0x000011, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::bLookAt' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, LookAtParam) == 0x000014, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::LookAtParam' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, OnComplete) == 0x000020, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::OnComplete' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsActor, OnInterrupt) == 0x000030, "Member 'X6BlueprintLibrary_ActorFaceTowardsActor::OnInterrupt' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ActorFaceTowardsLocation
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_ActorFaceTowardsLocation final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnInPlace;                                      // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAt;                                           // 0x0021(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLookAtParams                          LookAtParam;                                       // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnComplete;                                        // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterrupt;                                       // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ActorFaceTowardsLocation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ActorFaceTowardsLocation");
static_assert(sizeof(X6BlueprintLibrary_ActorFaceTowardsLocation) == 0x000050, "Wrong size on X6BlueprintLibrary_ActorFaceTowardsLocation");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, InActor) == 0x000000, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, TargetLocation) == 0x000008, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, bTurnInPlace) == 0x000020, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::bTurnInPlace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, bLookAt) == 0x000021, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::bLookAt' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, LookAtParam) == 0x000024, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::LookAtParam' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, OnComplete) == 0x000030, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::OnComplete' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsLocation, OnInterrupt) == 0x000040, "Member 'X6BlueprintLibrary_ActorFaceTowardsLocation::OnInterrupt' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ActorFaceTowardsRotation
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_ActorFaceTowardsRotation final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTurnInPlace;                                      // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAt;                                           // 0x0021(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLookAtParams                          LookAtParam;                                       // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnComplete;                                        // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterrupt;                                       // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ActorFaceTowardsRotation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ActorFaceTowardsRotation");
static_assert(sizeof(X6BlueprintLibrary_ActorFaceTowardsRotation) == 0x000050, "Wrong size on X6BlueprintLibrary_ActorFaceTowardsRotation");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, InActor) == 0x000000, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, TargetRotation) == 0x000008, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::TargetRotation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, bTurnInPlace) == 0x000020, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::bTurnInPlace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, bLookAt) == 0x000021, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::bLookAt' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, LookAtParam) == 0x000024, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::LookAtParam' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, OnComplete) == 0x000030, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::OnComplete' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ActorFaceTowardsRotation, OnInterrupt) == 0x000040, "Member 'X6BlueprintLibrary_ActorFaceTowardsRotation::OnInterrupt' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.AddEffectOutlineOnActor
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_AddEffectOutlineOnActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_AddEffectOutlineOnActor) == 0x000008, "Wrong alignment on X6BlueprintLibrary_AddEffectOutlineOnActor");
static_assert(sizeof(X6BlueprintLibrary_AddEffectOutlineOnActor) == 0x000008, "Wrong size on X6BlueprintLibrary_AddEffectOutlineOnActor");
static_assert(offsetof(X6BlueprintLibrary_AddEffectOutlineOnActor, InActor) == 0x000000, "Member 'X6BlueprintLibrary_AddEffectOutlineOnActor::InActor' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.AddViewSlaveLocation
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_AddViewSlaveLocation final
{
public:
	struct FVector                                SlaveLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostFactor;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocation;                                 // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_AddViewSlaveLocation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_AddViewSlaveLocation");
static_assert(sizeof(X6BlueprintLibrary_AddViewSlaveLocation) == 0x000028, "Wrong size on X6BlueprintLibrary_AddViewSlaveLocation");
static_assert(offsetof(X6BlueprintLibrary_AddViewSlaveLocation, SlaveLocation) == 0x000000, "Member 'X6BlueprintLibrary_AddViewSlaveLocation::SlaveLocation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_AddViewSlaveLocation, BoostFactor) == 0x000018, "Member 'X6BlueprintLibrary_AddViewSlaveLocation::BoostFactor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_AddViewSlaveLocation, bOverrideLocation) == 0x00001C, "Member 'X6BlueprintLibrary_AddViewSlaveLocation::bOverrideLocation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_AddViewSlaveLocation, Duration) == 0x000020, "Member 'X6BlueprintLibrary_AddViewSlaveLocation::Duration' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ApplyLevelTransform
// 0x0070 (0x0070 - 0x0000)
struct X6BlueprintLibrary_ApplyLevelTransform final
{
public:
	class ULevelStreaming*                        loadLevels;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ApplyLevelTransform) == 0x000010, "Wrong alignment on X6BlueprintLibrary_ApplyLevelTransform");
static_assert(sizeof(X6BlueprintLibrary_ApplyLevelTransform) == 0x000070, "Wrong size on X6BlueprintLibrary_ApplyLevelTransform");
static_assert(offsetof(X6BlueprintLibrary_ApplyLevelTransform, loadLevels) == 0x000000, "Member 'X6BlueprintLibrary_ApplyLevelTransform::loadLevels' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ApplyLevelTransform, Transform) == 0x000010, "Member 'X6BlueprintLibrary_ApplyLevelTransform::Transform' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.AsyncGetFoliageGeometryInfosInCircleRange
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Radius;                                            // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const TArray<struct FFoliageGeometryInfo>& OutFoliageGeometryInfos)> OnFoliageGeometryInfoReady; // 0x0028(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange) == 0x000008, "Wrong alignment on X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange");
static_assert(sizeof(X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange) == 0x000038, "Wrong size on X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange");
static_assert(offsetof(X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange, Center) == 0x000008, "Member 'X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange::Center' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange, Radius) == 0x000020, "Member 'X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange::Radius' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange, OnFoliageGeometryInfoReady) == 0x000028, "Member 'X6BlueprintLibrary_AsyncGetFoliageGeometryInfosInCircleRange::OnFoliageGeometryInfoReady' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CalculateBesselCurve
// 0x0080 (0x0080 - 0x0000)
struct X6BlueprintLibrary_CalculateBesselCurve final
{
public:
	struct FVector                                StartPoint;                                        // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ControllerPoint1;                                  // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ControllerPoint2;                                  // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPoint;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPoints;                                         // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        OutPoints;                                         // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0078(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_CalculateBesselCurve) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CalculateBesselCurve");
static_assert(sizeof(X6BlueprintLibrary_CalculateBesselCurve) == 0x000080, "Wrong size on X6BlueprintLibrary_CalculateBesselCurve");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, StartPoint) == 0x000000, "Member 'X6BlueprintLibrary_CalculateBesselCurve::StartPoint' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, ControllerPoint1) == 0x000018, "Member 'X6BlueprintLibrary_CalculateBesselCurve::ControllerPoint1' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, ControllerPoint2) == 0x000030, "Member 'X6BlueprintLibrary_CalculateBesselCurve::ControllerPoint2' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, EndPoint) == 0x000048, "Member 'X6BlueprintLibrary_CalculateBesselCurve::EndPoint' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, NumPoints) == 0x000060, "Member 'X6BlueprintLibrary_CalculateBesselCurve::NumPoints' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, OutPoints) == 0x000068, "Member 'X6BlueprintLibrary_CalculateBesselCurve::OutPoints' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CalculateBesselCurve, ReturnValue) == 0x000078, "Member 'X6BlueprintLibrary_CalculateBesselCurve::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CheckActorHasBegunPlay
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_CheckActorHasBegunPlay final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_CheckActorHasBegunPlay) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CheckActorHasBegunPlay");
static_assert(sizeof(X6BlueprintLibrary_CheckActorHasBegunPlay) == 0x000010, "Wrong size on X6BlueprintLibrary_CheckActorHasBegunPlay");
static_assert(offsetof(X6BlueprintLibrary_CheckActorHasBegunPlay, Actor) == 0x000000, "Member 'X6BlueprintLibrary_CheckActorHasBegunPlay::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckActorHasBegunPlay, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_CheckActorHasBegunPlay::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CheckBulletConditionCanTraceStartToEnd
// 0x00B8 (0x00B8 - 0x0000)
struct X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HalfSize;                                          // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0058(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0078(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0089(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPenetrate;                                        // 0x008A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x1];                                       // 0x008B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x008C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x009C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00AC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd");
static_assert(sizeof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd) == 0x0000B8, "Wrong size on X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, Start) == 0x000008, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::Start' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, End) == 0x000020, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::End' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, Radius) == 0x000038, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::Radius' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, HalfSize) == 0x000040, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::HalfSize' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, Orientation) == 0x000058, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::Orientation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, bTraceComplex) == 0x000070, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::bTraceComplex' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, ActorsToIgnore) == 0x000078, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, DrawDebugType) == 0x000088, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, bIgnoreSelf) == 0x000089, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, bPenetrate) == 0x00008A, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::bPenetrate' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, TraceColor) == 0x00008C, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::TraceColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, TraceHitColor) == 0x00009C, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::TraceHitColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, DrawTime) == 0x0000AC, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::DrawTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd, ReturnValue) == 0x0000B0, "Member 'X6BlueprintLibrary_CheckBulletConditionCanTraceStartToEnd::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CheckIsInWater
// 0x0030 (0x0030 - 0x0000)
struct X6BlueprintLibrary_CheckIsInWater final
{
public:
	const class UObject*                          InWorldContextObject;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CheckLocation;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWaterLengthTolerance;                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneLayerWaterCheck;                               // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_CheckIsInWater) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CheckIsInWater");
static_assert(sizeof(X6BlueprintLibrary_CheckIsInWater) == 0x000030, "Wrong size on X6BlueprintLibrary_CheckIsInWater");
static_assert(offsetof(X6BlueprintLibrary_CheckIsInWater, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_CheckIsInWater::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckIsInWater, CheckLocation) == 0x000008, "Member 'X6BlueprintLibrary_CheckIsInWater::CheckLocation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckIsInWater, TraceLength) == 0x000020, "Member 'X6BlueprintLibrary_CheckIsInWater::TraceLength' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckIsInWater, MinWaterLengthTolerance) == 0x000024, "Member 'X6BlueprintLibrary_CheckIsInWater::MinWaterLengthTolerance' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckIsInWater, bOneLayerWaterCheck) == 0x000028, "Member 'X6BlueprintLibrary_CheckIsInWater::bOneLayerWaterCheck' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CheckIsInWater, ReturnValue) == 0x000029, "Member 'X6BlueprintLibrary_CheckIsInWater::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClearAnimInstanceRootMotionMovementParams
// 0x0070 (0x0070 - 0x0000)
struct X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams) == 0x000010, "Wrong alignment on X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams");
static_assert(sizeof(X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams) == 0x000070, "Wrong size on X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams");
static_assert(offsetof(X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams, AnimInstance) == 0x000000, "Member 'X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams::AnimInstance' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_ClearAnimInstanceRootMotionMovementParams::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClearCurrentRootMotionSource
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ClearCurrentRootMotionSource final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClearCurrentRootMotionSource) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ClearCurrentRootMotionSource");
static_assert(sizeof(X6BlueprintLibrary_ClearCurrentRootMotionSource) == 0x000008, "Wrong size on X6BlueprintLibrary_ClearCurrentRootMotionSource");
static_assert(offsetof(X6BlueprintLibrary_ClearCurrentRootMotionSource, CharacterMovementComponent) == 0x000000, "Member 'X6BlueprintLibrary_ClearCurrentRootMotionSource::CharacterMovementComponent' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClearGameViewportForceCursorType
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ClearGameViewportForceCursorType final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClearGameViewportForceCursorType) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ClearGameViewportForceCursorType");
static_assert(sizeof(X6BlueprintLibrary_ClearGameViewportForceCursorType) == 0x000008, "Wrong size on X6BlueprintLibrary_ClearGameViewportForceCursorType");
static_assert(offsetof(X6BlueprintLibrary_ClearGameViewportForceCursorType, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_ClearGameViewportForceCursorType::InWorldContextObject' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClearMeshComponentOverrideMaterials
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ClearMeshComponentOverrideMaterials final
{
public:
	class UMeshComponent*                         InMeshComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClearMeshComponentOverrideMaterials) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ClearMeshComponentOverrideMaterials");
static_assert(sizeof(X6BlueprintLibrary_ClearMeshComponentOverrideMaterials) == 0x000008, "Wrong size on X6BlueprintLibrary_ClearMeshComponentOverrideMaterials");
static_assert(offsetof(X6BlueprintLibrary_ClearMeshComponentOverrideMaterials, InMeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_ClearMeshComponentOverrideMaterials::InMeshComponent' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClearTransformUpdatedEvent
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ClearTransformUpdatedEvent final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClearTransformUpdatedEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ClearTransformUpdatedEvent");
static_assert(sizeof(X6BlueprintLibrary_ClearTransformUpdatedEvent) == 0x000008, "Wrong size on X6BlueprintLibrary_ClearTransformUpdatedEvent");
static_assert(offsetof(X6BlueprintLibrary_ClearTransformUpdatedEvent, Target) == 0x000000, "Member 'X6BlueprintLibrary_ClearTransformUpdatedEvent::Target' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClipboardCopy
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_ClipboardCopy final
{
public:
	class FString                                 CopyText;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClipboardCopy) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ClipboardCopy");
static_assert(sizeof(X6BlueprintLibrary_ClipboardCopy) == 0x000010, "Wrong size on X6BlueprintLibrary_ClipboardCopy");
static_assert(offsetof(X6BlueprintLibrary_ClipboardCopy, CopyText) == 0x000000, "Member 'X6BlueprintLibrary_ClipboardCopy::CopyText' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ClipboardPaste
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_ClipboardPaste final
{
public:
	class FString                                 OutPasteText;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ClipboardPaste) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ClipboardPaste");
static_assert(sizeof(X6BlueprintLibrary_ClipboardPaste) == 0x000010, "Wrong size on X6BlueprintLibrary_ClipboardPaste");
static_assert(offsetof(X6BlueprintLibrary_ClipboardPaste, OutPasteText) == 0x000000, "Member 'X6BlueprintLibrary_ClipboardPaste::OutPasteText' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ComponentSweepMulti
// 0x0080 (0x0080 - 0x0000)
struct X6BlueprintLibrary_ComponentSweepMulti final
{
public:
	TArray<struct FHitResult>                     OutHits;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                 PenetrationDepth;                                  // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    PrimComp;                                          // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quat;                                              // 0x0060(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ComponentSweepMulti) == 0x000010, "Wrong alignment on X6BlueprintLibrary_ComponentSweepMulti");
static_assert(sizeof(X6BlueprintLibrary_ComponentSweepMulti) == 0x000080, "Wrong size on X6BlueprintLibrary_ComponentSweepMulti");
static_assert(offsetof(X6BlueprintLibrary_ComponentSweepMulti, OutHits) == 0x000000, "Member 'X6BlueprintLibrary_ComponentSweepMulti::OutHits' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComponentSweepMulti, PenetrationDepth) == 0x000010, "Member 'X6BlueprintLibrary_ComponentSweepMulti::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComponentSweepMulti, PrimComp) == 0x000020, "Member 'X6BlueprintLibrary_ComponentSweepMulti::PrimComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComponentSweepMulti, Start) == 0x000028, "Member 'X6BlueprintLibrary_ComponentSweepMulti::Start' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComponentSweepMulti, End) == 0x000040, "Member 'X6BlueprintLibrary_ComponentSweepMulti::End' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComponentSweepMulti, Quat) == 0x000060, "Member 'X6BlueprintLibrary_ComponentSweepMulti::Quat' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ComputeGroundMovementDelta
// 0x0130 (0x0130 - 0x0000)
struct X6BlueprintLibrary_ComputeGroundMovementDelta final
{
public:
	struct FVector                                Delta;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             RampHit;                                           // 0x0018(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHitFromLineTrace;                                 // 0x0110(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0118(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ComputeGroundMovementDelta) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ComputeGroundMovementDelta");
static_assert(sizeof(X6BlueprintLibrary_ComputeGroundMovementDelta) == 0x000130, "Wrong size on X6BlueprintLibrary_ComputeGroundMovementDelta");
static_assert(offsetof(X6BlueprintLibrary_ComputeGroundMovementDelta, Delta) == 0x000000, "Member 'X6BlueprintLibrary_ComputeGroundMovementDelta::Delta' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComputeGroundMovementDelta, RampHit) == 0x000018, "Member 'X6BlueprintLibrary_ComputeGroundMovementDelta::RampHit' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComputeGroundMovementDelta, bHitFromLineTrace) == 0x000110, "Member 'X6BlueprintLibrary_ComputeGroundMovementDelta::bHitFromLineTrace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ComputeGroundMovementDelta, ReturnValue) == 0x000118, "Member 'X6BlueprintLibrary_ComputeGroundMovementDelta::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ConvertFileNameToObjectPath
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_ConvertFileNameToObjectPath final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackageName;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_ConvertFileNameToObjectPath) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ConvertFileNameToObjectPath");
static_assert(sizeof(X6BlueprintLibrary_ConvertFileNameToObjectPath) == 0x000028, "Wrong size on X6BlueprintLibrary_ConvertFileNameToObjectPath");
static_assert(offsetof(X6BlueprintLibrary_ConvertFileNameToObjectPath, Filename) == 0x000000, "Member 'X6BlueprintLibrary_ConvertFileNameToObjectPath::Filename' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ConvertFileNameToObjectPath, PackageName) == 0x000010, "Member 'X6BlueprintLibrary_ConvertFileNameToObjectPath::PackageName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ConvertFileNameToObjectPath, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_ConvertFileNameToObjectPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CopyFile
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_CopyFile final
{
public:
	class FString                                 SourcePath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestPath;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_CopyFile) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CopyFile");
static_assert(sizeof(X6BlueprintLibrary_CopyFile) == 0x000028, "Wrong size on X6BlueprintLibrary_CopyFile");
static_assert(offsetof(X6BlueprintLibrary_CopyFile, SourcePath) == 0x000000, "Member 'X6BlueprintLibrary_CopyFile::SourcePath' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CopyFile, DestPath) == 0x000010, "Member 'X6BlueprintLibrary_CopyFile::DestPath' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CopyFile, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_CopyFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CreateGuid
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_CreateGuid final
{
public:
	struct FGuid                                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_CreateGuid) == 0x000004, "Wrong alignment on X6BlueprintLibrary_CreateGuid");
static_assert(sizeof(X6BlueprintLibrary_CreateGuid) == 0x000010, "Wrong size on X6BlueprintLibrary_CreateGuid");
static_assert(offsetof(X6BlueprintLibrary_CreateGuid, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_CreateGuid::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CreateMediaTexture
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_CreateMediaTexture final
{
public:
	class UObject*                                Outer_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaTexture*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_CreateMediaTexture) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CreateMediaTexture");
static_assert(sizeof(X6BlueprintLibrary_CreateMediaTexture) == 0x000010, "Wrong size on X6BlueprintLibrary_CreateMediaTexture");
static_assert(offsetof(X6BlueprintLibrary_CreateMediaTexture, Outer_0) == 0x000000, "Member 'X6BlueprintLibrary_CreateMediaTexture::Outer_0' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CreateMediaTexture, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_CreateMediaTexture::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CreateTextFromBuffer
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_CreateTextFromBuffer final
{
public:
	class FString                                 BufferStr;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_CreateTextFromBuffer) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CreateTextFromBuffer");
static_assert(sizeof(X6BlueprintLibrary_CreateTextFromBuffer) == 0x000020, "Wrong size on X6BlueprintLibrary_CreateTextFromBuffer");
static_assert(offsetof(X6BlueprintLibrary_CreateTextFromBuffer, BufferStr) == 0x000000, "Member 'X6BlueprintLibrary_CreateTextFromBuffer::BufferStr' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CreateTextFromBuffer, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_CreateTextFromBuffer::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CreateTexture2DFromImageFile
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_CreateTexture2DFromImageFile final
{
public:
	class FString                                 ImageFileName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_CreateTexture2DFromImageFile) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CreateTexture2DFromImageFile");
static_assert(sizeof(X6BlueprintLibrary_CreateTexture2DFromImageFile) == 0x000018, "Wrong size on X6BlueprintLibrary_CreateTexture2DFromImageFile");
static_assert(offsetof(X6BlueprintLibrary_CreateTexture2DFromImageFile, ImageFileName) == 0x000000, "Member 'X6BlueprintLibrary_CreateTexture2DFromImageFile::ImageFileName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CreateTexture2DFromImageFile, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_CreateTexture2DFromImageFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.CreateTexture2DFromWidget
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_CreateTexture2DFromWidget final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DrawSize;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWriteContentInGammaSpace;                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_CreateTexture2DFromWidget) == 0x000008, "Wrong alignment on X6BlueprintLibrary_CreateTexture2DFromWidget");
static_assert(sizeof(X6BlueprintLibrary_CreateTexture2DFromWidget) == 0x000028, "Wrong size on X6BlueprintLibrary_CreateTexture2DFromWidget");
static_assert(offsetof(X6BlueprintLibrary_CreateTexture2DFromWidget, Widget) == 0x000000, "Member 'X6BlueprintLibrary_CreateTexture2DFromWidget::Widget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CreateTexture2DFromWidget, DrawSize) == 0x000008, "Member 'X6BlueprintLibrary_CreateTexture2DFromWidget::DrawSize' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CreateTexture2DFromWidget, bWriteContentInGammaSpace) == 0x000018, "Member 'X6BlueprintLibrary_CreateTexture2DFromWidget::bWriteContentInGammaSpace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_CreateTexture2DFromWidget, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_CreateTexture2DFromWidget::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.DeleteDirectory
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_DeleteDirectory final
{
public:
	class FString                                 InDirPath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireExists;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Tree;                                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0012(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_DeleteDirectory) == 0x000008, "Wrong alignment on X6BlueprintLibrary_DeleteDirectory");
static_assert(sizeof(X6BlueprintLibrary_DeleteDirectory) == 0x000018, "Wrong size on X6BlueprintLibrary_DeleteDirectory");
static_assert(offsetof(X6BlueprintLibrary_DeleteDirectory, InDirPath) == 0x000000, "Member 'X6BlueprintLibrary_DeleteDirectory::InDirPath' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DeleteDirectory, RequireExists) == 0x000010, "Member 'X6BlueprintLibrary_DeleteDirectory::RequireExists' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DeleteDirectory, Tree) == 0x000011, "Member 'X6BlueprintLibrary_DeleteDirectory::Tree' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DeleteDirectory, ReturnValue) == 0x000012, "Member 'X6BlueprintLibrary_DeleteDirectory::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.DestroyActorRecusively
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_DestroyActorRecusively final
{
public:
	class AActor*                                 ActorToDestroy;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_DestroyActorRecusively) == 0x000008, "Wrong alignment on X6BlueprintLibrary_DestroyActorRecusively");
static_assert(sizeof(X6BlueprintLibrary_DestroyActorRecusively) == 0x000008, "Wrong size on X6BlueprintLibrary_DestroyActorRecusively");
static_assert(offsetof(X6BlueprintLibrary_DestroyActorRecusively, ActorToDestroy) == 0x000000, "Member 'X6BlueprintLibrary_DestroyActorRecusively::ActorToDestroy' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.DoesAnimHasNotifyOrNotifyState
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState final
{
public:
	class UAnimSequence*                          InAnimationSequence;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    InNotifyOrNotifyStateClass;                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState) == 0x000008, "Wrong alignment on X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState");
static_assert(sizeof(X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState) == 0x000018, "Wrong size on X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState");
static_assert(offsetof(X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState, InAnimationSequence) == 0x000000, "Member 'X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState::InAnimationSequence' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState, InNotifyOrNotifyStateClass) == 0x000008, "Member 'X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState::InNotifyOrNotifyStateClass' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_DoesAnimHasNotifyOrNotifyState::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.DrawCylinderWithFOV
// 0x00A0 (0x00A0 - 0x0000)
struct X6BlueprintLibrary_DrawCylinderWithFOV final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             QueryTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0080(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffset;                                         // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_DrawCylinderWithFOV) == 0x000010, "Wrong alignment on X6BlueprintLibrary_DrawCylinderWithFOV");
static_assert(sizeof(X6BlueprintLibrary_DrawCylinderWithFOV) == 0x0000A0, "Wrong size on X6BlueprintLibrary_DrawCylinderWithFOV");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, QueryTransform) == 0x000010, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::QueryTransform' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, Height) == 0x000070, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::Height' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, Radius) == 0x000074, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::Radius' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, FOV) == 0x000078, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::FOV' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, Segments) == 0x00007C, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::Segments' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, Color) == 0x000080, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::Color' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, LifeTime) == 0x000084, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::LifeTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, DepthPriority) == 0x000088, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::DepthPriority' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, Thickness) == 0x00008C, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::Thickness' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_DrawCylinderWithFOV, YawOffset) == 0x000090, "Member 'X6BlueprintLibrary_DrawCylinderWithFOV::YawOffset' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.FindAssetsInMemory
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_FindAssetsInMemory final
{
public:
	TArray<class FString>                         InAssetPaths;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OutObjects;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_FindAssetsInMemory) == 0x000008, "Wrong alignment on X6BlueprintLibrary_FindAssetsInMemory");
static_assert(sizeof(X6BlueprintLibrary_FindAssetsInMemory) == 0x000028, "Wrong size on X6BlueprintLibrary_FindAssetsInMemory");
static_assert(offsetof(X6BlueprintLibrary_FindAssetsInMemory, InAssetPaths) == 0x000000, "Member 'X6BlueprintLibrary_FindAssetsInMemory::InAssetPaths' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindAssetsInMemory, OutObjects) == 0x000010, "Member 'X6BlueprintLibrary_FindAssetsInMemory::OutObjects' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindAssetsInMemory, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_FindAssetsInMemory::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.FindBindingIDByName
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_FindBindingIDByName final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovieSceneObjectBindingSpace                 Space;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneObjectBindingID             ReturnValue;                                       // 0x001C(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_FindBindingIDByName) == 0x000008, "Wrong alignment on X6BlueprintLibrary_FindBindingIDByName");
static_assert(sizeof(X6BlueprintLibrary_FindBindingIDByName) == 0x000038, "Wrong size on X6BlueprintLibrary_FindBindingIDByName");
static_assert(offsetof(X6BlueprintLibrary_FindBindingIDByName, Sequence) == 0x000000, "Member 'X6BlueprintLibrary_FindBindingIDByName::Sequence' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindBindingIDByName, Name_0) == 0x000008, "Member 'X6BlueprintLibrary_FindBindingIDByName::Name_0' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindBindingIDByName, Space) == 0x000018, "Member 'X6BlueprintLibrary_FindBindingIDByName::Space' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindBindingIDByName, ReturnValue) == 0x00001C, "Member 'X6BlueprintLibrary_FindBindingIDByName::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.FindPackagesInDirectory
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_FindPackagesInDirectory final
{
public:
	TArray<class FString>                         OutPackages;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RootDir;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_FindPackagesInDirectory) == 0x000008, "Wrong alignment on X6BlueprintLibrary_FindPackagesInDirectory");
static_assert(sizeof(X6BlueprintLibrary_FindPackagesInDirectory) == 0x000028, "Wrong size on X6BlueprintLibrary_FindPackagesInDirectory");
static_assert(offsetof(X6BlueprintLibrary_FindPackagesInDirectory, OutPackages) == 0x000000, "Member 'X6BlueprintLibrary_FindPackagesInDirectory::OutPackages' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindPackagesInDirectory, RootDir) == 0x000010, "Member 'X6BlueprintLibrary_FindPackagesInDirectory::RootDir' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_FindPackagesInDirectory, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_FindPackagesInDirectory::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.FlushWorldComposition
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_FlushWorldComposition final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_FlushWorldComposition) == 0x000008, "Wrong alignment on X6BlueprintLibrary_FlushWorldComposition");
static_assert(sizeof(X6BlueprintLibrary_FlushWorldComposition) == 0x000008, "Wrong size on X6BlueprintLibrary_FlushWorldComposition");
static_assert(offsetof(X6BlueprintLibrary_FlushWorldComposition, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_FlushWorldComposition::WorldContextObject' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ForceTickAnimationWithNoneDeltaTime
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime");
static_assert(sizeof(X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime) == 0x000008, "Wrong size on X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime");
static_assert(offsetof(X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime, InSkeletalMeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_ForceTickAnimationWithNoneDeltaTime::InSkeletalMeshComponent' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ForceTickAnimOnlyWithNoneDeltaTime
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime");
static_assert(sizeof(X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime) == 0x000008, "Wrong size on X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime");
static_assert(offsetof(X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime, InSkeletalMeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_ForceTickAnimOnlyWithNoneDeltaTime::InSkeletalMeshComponent' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GameViewportFadeIn
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GameViewportFadeIn final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackDuration;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableInput;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GameViewportFadeIn) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GameViewportFadeIn");
static_assert(sizeof(X6BlueprintLibrary_GameViewportFadeIn) == 0x000018, "Wrong size on X6BlueprintLibrary_GameViewportFadeIn");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeIn, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GameViewportFadeIn::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeIn, BlackDuration) == 0x000008, "Member 'X6BlueprintLibrary_GameViewportFadeIn::BlackDuration' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeIn, FadeInDuration) == 0x00000C, "Member 'X6BlueprintLibrary_GameViewportFadeIn::FadeInDuration' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeIn, bShouldDisableInput) == 0x000010, "Member 'X6BlueprintLibrary_GameViewportFadeIn::bShouldDisableInput' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GameViewportFadeOut
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GameViewportFadeOut final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableInput;                               // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GameViewportFadeOut) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GameViewportFadeOut");
static_assert(sizeof(X6BlueprintLibrary_GameViewportFadeOut) == 0x000010, "Wrong size on X6BlueprintLibrary_GameViewportFadeOut");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOut, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GameViewportFadeOut::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOut, FadeOutDuration) == 0x000008, "Member 'X6BlueprintLibrary_GameViewportFadeOut::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOut, bShouldDisableInput) == 0x00000C, "Member 'X6BlueprintLibrary_GameViewportFadeOut::bShouldDisableInput' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GameViewportFadeOutAndFadeIn
// 0x0060 (0x0060 - 0x0000)
struct X6BlueprintLibrary_GameViewportFadeOutAndFadeIn final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackDuration;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableInput;                               // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFade;                                        // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             _FadeOutEndEvent;                                  // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             _FadeBlackEndEvent;                                // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             _FadeInEndEvent;                                   // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopFadeWhenPause;                                // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           InFadeColor;                                       // 0x004C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x005C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GameViewportFadeOutAndFadeIn");
static_assert(sizeof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn) == 0x000060, "Wrong size on X6BlueprintLibrary_GameViewportFadeOutAndFadeIn");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, FadeOutDuration) == 0x000008, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, BlackDuration) == 0x00000C, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::BlackDuration' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, FadeInDuration) == 0x000010, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::FadeInDuration' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, bShouldDisableInput) == 0x000014, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::bShouldDisableInput' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, bForceFade) == 0x000015, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::bForceFade' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, _FadeOutEndEvent) == 0x000018, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::_FadeOutEndEvent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, _FadeBlackEndEvent) == 0x000028, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::_FadeBlackEndEvent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, _FadeInEndEvent) == 0x000038, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::_FadeInEndEvent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, bStopFadeWhenPause) == 0x000048, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::bStopFadeWhenPause' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, InFadeColor) == 0x00004C, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::InFadeColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GameViewportFadeOutAndFadeIn, ReturnValue) == 0x00005C, "Member 'X6BlueprintLibrary_GameViewportFadeOutAndFadeIn::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GameViewportHasFocus
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_GameViewportHasFocus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GameViewportHasFocus) == 0x000001, "Wrong alignment on X6BlueprintLibrary_GameViewportHasFocus");
static_assert(sizeof(X6BlueprintLibrary_GameViewportHasFocus) == 0x000001, "Wrong size on X6BlueprintLibrary_GameViewportHasFocus");
static_assert(offsetof(X6BlueprintLibrary_GameViewportHasFocus, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GameViewportHasFocus::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetActorByX6Tag
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetActorByX6Tag final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tag;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetActorByX6Tag) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetActorByX6Tag");
static_assert(sizeof(X6BlueprintLibrary_GetActorByX6Tag) == 0x000028, "Wrong size on X6BlueprintLibrary_GetActorByX6Tag");
static_assert(offsetof(X6BlueprintLibrary_GetActorByX6Tag, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetActorByX6Tag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetActorByX6Tag, Tag) == 0x000008, "Member 'X6BlueprintLibrary_GetActorByX6Tag::Tag' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetActorByX6Tag, ReturnValue) == 0x000018, "Member 'X6BlueprintLibrary_GetActorByX6Tag::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetAddressPing
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_GetAddressPing final
{
public:
	class FString                                 TargetAddress;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Result)>                 Callback;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetAddressPing) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetAddressPing");
static_assert(sizeof(X6BlueprintLibrary_GetAddressPing) == 0x000020, "Wrong size on X6BlueprintLibrary_GetAddressPing");
static_assert(offsetof(X6BlueprintLibrary_GetAddressPing, TargetAddress) == 0x000000, "Member 'X6BlueprintLibrary_GetAddressPing::TargetAddress' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetAddressPing, Callback) == 0x000010, "Member 'X6BlueprintLibrary_GetAddressPing::Callback' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetAirPathfindingMng
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetAirPathfindingMng final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADonNavigationManagerUnbound*           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetAirPathfindingMng) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetAirPathfindingMng");
static_assert(sizeof(X6BlueprintLibrary_GetAirPathfindingMng) == 0x000010, "Wrong size on X6BlueprintLibrary_GetAirPathfindingMng");
static_assert(offsetof(X6BlueprintLibrary_GetAirPathfindingMng, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetAirPathfindingMng::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetAirPathfindingMng, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetAirPathfindingMng::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetAssetUserDataOfClass
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetAssetUserDataOfClass final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAssetUserData>             InUserDataClass;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetUserData*                         ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetAssetUserDataOfClass) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetAssetUserDataOfClass");
static_assert(sizeof(X6BlueprintLibrary_GetAssetUserDataOfClass) == 0x000018, "Wrong size on X6BlueprintLibrary_GetAssetUserDataOfClass");
static_assert(offsetof(X6BlueprintLibrary_GetAssetUserDataOfClass, InObject) == 0x000000, "Member 'X6BlueprintLibrary_GetAssetUserDataOfClass::InObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetAssetUserDataOfClass, InUserDataClass) == 0x000008, "Member 'X6BlueprintLibrary_GetAssetUserDataOfClass::InUserDataClass' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetAssetUserDataOfClass, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetAssetUserDataOfClass::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetBatteryLevel
// 0x0004 (0x0004 - 0x0000)
struct X6BlueprintLibrary_GetBatteryLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetBatteryLevel) == 0x000004, "Wrong alignment on X6BlueprintLibrary_GetBatteryLevel");
static_assert(sizeof(X6BlueprintLibrary_GetBatteryLevel) == 0x000004, "Wrong size on X6BlueprintLibrary_GetBatteryLevel");
static_assert(offsetof(X6BlueprintLibrary_GetBatteryLevel, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetBatteryLevel::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetBinaryVersion
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetBinaryVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetBinaryVersion) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetBinaryVersion");
static_assert(sizeof(X6BlueprintLibrary_GetBinaryVersion) == 0x000010, "Wrong size on X6BlueprintLibrary_GetBinaryVersion");
static_assert(offsetof(X6BlueprintLibrary_GetBinaryVersion, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetBinaryVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetBoneComponentLocation
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetBoneComponentLocation final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetBoneComponentLocation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetBoneComponentLocation");
static_assert(sizeof(X6BlueprintLibrary_GetBoneComponentLocation) == 0x000028, "Wrong size on X6BlueprintLibrary_GetBoneComponentLocation");
static_assert(offsetof(X6BlueprintLibrary_GetBoneComponentLocation, MeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_GetBoneComponentLocation::MeshComponent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetBoneComponentLocation, BoneName) == 0x000008, "Member 'X6BlueprintLibrary_GetBoneComponentLocation::BoneName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetBoneComponentLocation, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetBoneComponentLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetBoneComponentQuaternion
// 0x0030 (0x0030 - 0x0000)
struct X6BlueprintLibrary_GetBoneComponentQuaternion final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetBoneComponentQuaternion) == 0x000010, "Wrong alignment on X6BlueprintLibrary_GetBoneComponentQuaternion");
static_assert(sizeof(X6BlueprintLibrary_GetBoneComponentQuaternion) == 0x000030, "Wrong size on X6BlueprintLibrary_GetBoneComponentQuaternion");
static_assert(offsetof(X6BlueprintLibrary_GetBoneComponentQuaternion, MeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_GetBoneComponentQuaternion::MeshComponent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetBoneComponentQuaternion, BoneName) == 0x000008, "Member 'X6BlueprintLibrary_GetBoneComponentQuaternion::BoneName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetBoneComponentQuaternion, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetBoneComponentQuaternion::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetBoneWorldLocation
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetBoneWorldLocation final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetBoneWorldLocation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetBoneWorldLocation");
static_assert(sizeof(X6BlueprintLibrary_GetBoneWorldLocation) == 0x000028, "Wrong size on X6BlueprintLibrary_GetBoneWorldLocation");
static_assert(offsetof(X6BlueprintLibrary_GetBoneWorldLocation, MeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_GetBoneWorldLocation::MeshComponent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetBoneWorldLocation, BoneName) == 0x000008, "Member 'X6BlueprintLibrary_GetBoneWorldLocation::BoneName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetBoneWorldLocation, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetBoneWorldLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetBuildVersionDesc
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetBuildVersionDesc final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetBuildVersionDesc) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetBuildVersionDesc");
static_assert(sizeof(X6BlueprintLibrary_GetBuildVersionDesc) == 0x000010, "Wrong size on X6BlueprintLibrary_GetBuildVersionDesc");
static_assert(offsetof(X6BlueprintLibrary_GetBuildVersionDesc, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetBuildVersionDesc::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetCodesFromKey
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetCodesFromKey final
{
public:
	struct FKey                                   InKey;                                             // 0x0000(0x0018)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OutKeyCode;                                        // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OutCharCode;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetCodesFromKey) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetCodesFromKey");
static_assert(sizeof(X6BlueprintLibrary_GetCodesFromKey) == 0x000028, "Wrong size on X6BlueprintLibrary_GetCodesFromKey");
static_assert(offsetof(X6BlueprintLibrary_GetCodesFromKey, InKey) == 0x000000, "Member 'X6BlueprintLibrary_GetCodesFromKey::InKey' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetCodesFromKey, OutKeyCode) == 0x000018, "Member 'X6BlueprintLibrary_GetCodesFromKey::OutKeyCode' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetCodesFromKey, OutCharCode) == 0x000020, "Member 'X6BlueprintLibrary_GetCodesFromKey::OutCharCode' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetComputeSlopeDegree
// 0x0058 (0x0058 - 0x0000)
struct X6BlueprintLibrary_GetComputeSlopeDegree final
{
public:
	const class UObject*                          InWorldContextObject;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ForwardVector;                                     // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0030(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthLength;                                       // 0x0048(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetComputeSlopeDegree) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetComputeSlopeDegree");
static_assert(sizeof(X6BlueprintLibrary_GetComputeSlopeDegree) == 0x000058, "Wrong size on X6BlueprintLibrary_GetComputeSlopeDegree");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, ObjectTypes) == 0x000008, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, ForwardVector) == 0x000018, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::ForwardVector' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, Start) == 0x000030, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::Start' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, DepthLength) == 0x000048, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::DepthLength' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, DrawDebugType) == 0x00004C, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeDegree, ReturnValue) == 0x000050, "Member 'X6BlueprintLibrary_GetComputeSlopeDegree::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetComputeSlopeRotation
// 0x00B0 (0x00B0 - 0x0000)
struct X6BlueprintLibrary_GetComputeSlopeRotation final
{
public:
	const class UObject*                          InWorldContextObject;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CheckPointTransform;                               // 0x0020(0x0060)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFloorAngle;                                      // 0x0080(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthLength;                                       // 0x0084(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0090(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetComputeSlopeRotation) == 0x000010, "Wrong alignment on X6BlueprintLibrary_GetComputeSlopeRotation");
static_assert(sizeof(X6BlueprintLibrary_GetComputeSlopeRotation) == 0x0000B0, "Wrong size on X6BlueprintLibrary_GetComputeSlopeRotation");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, ObjectTypes) == 0x000008, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, CheckPointTransform) == 0x000020, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::CheckPointTransform' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, InFloorAngle) == 0x000080, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::InFloorAngle' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, DepthLength) == 0x000084, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::DepthLength' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, DrawDebugType) == 0x000088, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetComputeSlopeRotation, ReturnValue) == 0x000090, "Member 'X6BlueprintLibrary_GetComputeSlopeRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetCurrentTotalMillisecond
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_GetCurrentTotalMillisecond final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetCurrentTotalMillisecond) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetCurrentTotalMillisecond");
static_assert(sizeof(X6BlueprintLibrary_GetCurrentTotalMillisecond) == 0x000008, "Wrong size on X6BlueprintLibrary_GetCurrentTotalMillisecond");
static_assert(offsetof(X6BlueprintLibrary_GetCurrentTotalMillisecond, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetCurrentTotalMillisecond::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetFileNames
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetFileNames final
{
public:
	class FString                                 InDirPath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutFileNames;                                      // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetFileNames) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetFileNames");
static_assert(sizeof(X6BlueprintLibrary_GetFileNames) == 0x000028, "Wrong size on X6BlueprintLibrary_GetFileNames");
static_assert(offsetof(X6BlueprintLibrary_GetFileNames, InDirPath) == 0x000000, "Member 'X6BlueprintLibrary_GetFileNames::InDirPath' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetFileNames, OutFileNames) == 0x000010, "Member 'X6BlueprintLibrary_GetFileNames::OutFileNames' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetFileNames, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_GetFileNames::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetFPS
// 0x0004 (0x0004 - 0x0000)
struct X6BlueprintLibrary_GetFPS final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetFPS) == 0x000004, "Wrong alignment on X6BlueprintLibrary_GetFPS");
static_assert(sizeof(X6BlueprintLibrary_GetFPS) == 0x000004, "Wrong size on X6BlueprintLibrary_GetFPS");
static_assert(offsetof(X6BlueprintLibrary_GetFPS, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetFPS::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetFrameOfMarkedFrame
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_GetFrameOfMarkedFrame final
{
public:
	class ULevelSequence*                         Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Label;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetFrameOfMarkedFrame) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetFrameOfMarkedFrame");
static_assert(sizeof(X6BlueprintLibrary_GetFrameOfMarkedFrame) == 0x000020, "Wrong size on X6BlueprintLibrary_GetFrameOfMarkedFrame");
static_assert(offsetof(X6BlueprintLibrary_GetFrameOfMarkedFrame, Sequence) == 0x000000, "Member 'X6BlueprintLibrary_GetFrameOfMarkedFrame::Sequence' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetFrameOfMarkedFrame, Label) == 0x000008, "Member 'X6BlueprintLibrary_GetFrameOfMarkedFrame::Label' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetFrameOfMarkedFrame, ReturnValue) == 0x000018, "Member 'X6BlueprintLibrary_GetFrameOfMarkedFrame::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetKeyBoardFocusedWidget
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetKeyBoardFocusedWidget final
{
public:
	class UUserWidget*                            InScopeWidget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetKeyBoardFocusedWidget) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetKeyBoardFocusedWidget");
static_assert(sizeof(X6BlueprintLibrary_GetKeyBoardFocusedWidget) == 0x000010, "Wrong size on X6BlueprintLibrary_GetKeyBoardFocusedWidget");
static_assert(offsetof(X6BlueprintLibrary_GetKeyBoardFocusedWidget, InScopeWidget) == 0x000000, "Member 'X6BlueprintLibrary_GetKeyBoardFocusedWidget::InScopeWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetKeyBoardFocusedWidget, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetKeyBoardFocusedWidget::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetKeyFromCodes
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetKeyFromCodes final
{
public:
	int64                                         KeyCode;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CharCode;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetKeyFromCodes) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetKeyFromCodes");
static_assert(sizeof(X6BlueprintLibrary_GetKeyFromCodes) == 0x000028, "Wrong size on X6BlueprintLibrary_GetKeyFromCodes");
static_assert(offsetof(X6BlueprintLibrary_GetKeyFromCodes, KeyCode) == 0x000000, "Member 'X6BlueprintLibrary_GetKeyFromCodes::KeyCode' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetKeyFromCodes, CharCode) == 0x000008, "Member 'X6BlueprintLibrary_GetKeyFromCodes::CharCode' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetKeyFromCodes, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetKeyFromCodes::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetLastUserInteractionDeltaTime
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetLastUserInteractionDeltaTime final
{
public:
	bool                                          bIgnoreMotionInput;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetLastUserInteractionDeltaTime) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetLastUserInteractionDeltaTime");
static_assert(sizeof(X6BlueprintLibrary_GetLastUserInteractionDeltaTime) == 0x000010, "Wrong size on X6BlueprintLibrary_GetLastUserInteractionDeltaTime");
static_assert(offsetof(X6BlueprintLibrary_GetLastUserInteractionDeltaTime, bIgnoreMotionInput) == 0x000000, "Member 'X6BlueprintLibrary_GetLastUserInteractionDeltaTime::bIgnoreMotionInput' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetLastUserInteractionDeltaTime, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetLastUserInteractionDeltaTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetLeftMouseButtonKey
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetLeftMouseButtonKey final
{
public:
	struct FKey                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetLeftMouseButtonKey) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetLeftMouseButtonKey");
static_assert(sizeof(X6BlueprintLibrary_GetLeftMouseButtonKey) == 0x000018, "Wrong size on X6BlueprintLibrary_GetLeftMouseButtonKey");
static_assert(offsetof(X6BlueprintLibrary_GetLeftMouseButtonKey, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetLeftMouseButtonKey::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetLevel
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetLevel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetLevel) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetLevel");
static_assert(sizeof(X6BlueprintLibrary_GetLevel) == 0x000018, "Wrong size on X6BlueprintLibrary_GetLevel");
static_assert(offsetof(X6BlueprintLibrary_GetLevel, Actor) == 0x000000, "Member 'X6BlueprintLibrary_GetLevel::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetLevel, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetLevel::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetLevelOffset
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_GetLevelOffset final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetLevelOffset) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetLevelOffset");
static_assert(sizeof(X6BlueprintLibrary_GetLevelOffset) == 0x000020, "Wrong size on X6BlueprintLibrary_GetLevelOffset");
static_assert(offsetof(X6BlueprintLibrary_GetLevelOffset, InActor) == 0x000000, "Member 'X6BlueprintLibrary_GetLevelOffset::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetLevelOffset, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetLevelOffset::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetLocalPlayerCameraManager
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetLocalPlayerCameraManager final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AX6PlayerCameraManager*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetLocalPlayerCameraManager) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetLocalPlayerCameraManager");
static_assert(sizeof(X6BlueprintLibrary_GetLocalPlayerCameraManager) == 0x000010, "Wrong size on X6BlueprintLibrary_GetLocalPlayerCameraManager");
static_assert(offsetof(X6BlueprintLibrary_GetLocalPlayerCameraManager, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetLocalPlayerCameraManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetLocalPlayerCameraManager, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetLocalPlayerCameraManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetMainSkeletalComponent
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetMainSkeletalComponent final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetMainSkeletalComponent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetMainSkeletalComponent");
static_assert(sizeof(X6BlueprintLibrary_GetMainSkeletalComponent) == 0x000010, "Wrong size on X6BlueprintLibrary_GetMainSkeletalComponent");
static_assert(offsetof(X6BlueprintLibrary_GetMainSkeletalComponent, InActor) == 0x000000, "Member 'X6BlueprintLibrary_GetMainSkeletalComponent::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetMainSkeletalComponent, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetMainSkeletalComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetMostPriorityHitComponent
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetMostPriorityHitComponent final
{
public:
	const class AActor*                           InTargetActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetMostPriorityHitComponent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetMostPriorityHitComponent");
static_assert(sizeof(X6BlueprintLibrary_GetMostPriorityHitComponent) == 0x000010, "Wrong size on X6BlueprintLibrary_GetMostPriorityHitComponent");
static_assert(offsetof(X6BlueprintLibrary_GetMostPriorityHitComponent, InTargetActor) == 0x000000, "Member 'X6BlueprintLibrary_GetMostPriorityHitComponent::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetMostPriorityHitComponent, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetMostPriorityHitComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetNavMeshTileSize
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetNavMeshTileSize final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetNavMeshTileSize) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetNavMeshTileSize");
static_assert(sizeof(X6BlueprintLibrary_GetNavMeshTileSize) == 0x000010, "Wrong size on X6BlueprintLibrary_GetNavMeshTileSize");
static_assert(offsetof(X6BlueprintLibrary_GetNavMeshTileSize, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetNavMeshTileSize::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNavMeshTileSize, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetNavMeshTileSize::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetNikkiAroundBound
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetNikkiAroundBound final
{
public:
	class ACharacter*                             InNikki;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNikkiAroundMeshInfo>           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetNikkiAroundBound) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetNikkiAroundBound");
static_assert(sizeof(X6BlueprintLibrary_GetNikkiAroundBound) == 0x000018, "Wrong size on X6BlueprintLibrary_GetNikkiAroundBound");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiAroundBound, InNikki) == 0x000000, "Member 'X6BlueprintLibrary_GetNikkiAroundBound::InNikki' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiAroundBound, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetNikkiAroundBound::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetNikkiMeshForwardVector
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetNikkiMeshForwardVector final
{
public:
	class ACharacter*                             InNikki;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZAxis;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetNikkiMeshForwardVector) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetNikkiMeshForwardVector");
static_assert(sizeof(X6BlueprintLibrary_GetNikkiMeshForwardVector) == 0x000028, "Wrong size on X6BlueprintLibrary_GetNikkiMeshForwardVector");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiMeshForwardVector, InNikki) == 0x000000, "Member 'X6BlueprintLibrary_GetNikkiMeshForwardVector::InNikki' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiMeshForwardVector, bIgnoreZAxis) == 0x000008, "Member 'X6BlueprintLibrary_GetNikkiMeshForwardVector::bIgnoreZAxis' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiMeshForwardVector, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetNikkiMeshForwardVector::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetNikkiPlayerController
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetNikkiPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AX6NikkiPlayerController*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetNikkiPlayerController) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetNikkiPlayerController");
static_assert(sizeof(X6BlueprintLibrary_GetNikkiPlayerController) == 0x000010, "Wrong size on X6BlueprintLibrary_GetNikkiPlayerController");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiPlayerController, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetNikkiPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNikkiPlayerController, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetNikkiPlayerController::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetNotifyStartAndEndTime
// 0x00C0 (0x00C0 - 0x0000)
struct X6BlueprintLibrary_GetNotifyStartAndEndTime final
{
public:
	struct FAnimNotifyEvent                       InQueryNotify;                                     // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OutStartTime;                                      // 0x00B8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutEndTime;                                        // 0x00BC(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetNotifyStartAndEndTime) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetNotifyStartAndEndTime");
static_assert(sizeof(X6BlueprintLibrary_GetNotifyStartAndEndTime) == 0x0000C0, "Wrong size on X6BlueprintLibrary_GetNotifyStartAndEndTime");
static_assert(offsetof(X6BlueprintLibrary_GetNotifyStartAndEndTime, InQueryNotify) == 0x000000, "Member 'X6BlueprintLibrary_GetNotifyStartAndEndTime::InQueryNotify' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNotifyStartAndEndTime, OutStartTime) == 0x0000B8, "Member 'X6BlueprintLibrary_GetNotifyStartAndEndTime::OutStartTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetNotifyStartAndEndTime, OutEndTime) == 0x0000BC, "Member 'X6BlueprintLibrary_GetNotifyStartAndEndTime::OutEndTime' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetObjectsMemoryUsage
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetObjectsMemoryUsage final
{
public:
	TArray<class UObject*>                        Objects;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	double                                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetObjectsMemoryUsage) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetObjectsMemoryUsage");
static_assert(sizeof(X6BlueprintLibrary_GetObjectsMemoryUsage) == 0x000018, "Wrong size on X6BlueprintLibrary_GetObjectsMemoryUsage");
static_assert(offsetof(X6BlueprintLibrary_GetObjectsMemoryUsage, Objects) == 0x000000, "Member 'X6BlueprintLibrary_GetObjectsMemoryUsage::Objects' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetObjectsMemoryUsage, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetObjectsMemoryUsage::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetPlatformMilliseconds
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_GetPlatformMilliseconds final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetPlatformMilliseconds) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetPlatformMilliseconds");
static_assert(sizeof(X6BlueprintLibrary_GetPlatformMilliseconds) == 0x000008, "Wrong size on X6BlueprintLibrary_GetPlatformMilliseconds");
static_assert(offsetof(X6BlueprintLibrary_GetPlatformMilliseconds, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetPlatformMilliseconds::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetPointerPosition
// 0x000C (0x000C - 0x0000)
struct X6BlueprintLibrary_GetPointerPosition final
{
public:
	int32                                         PointerIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetPointerPosition) == 0x000004, "Wrong alignment on X6BlueprintLibrary_GetPointerPosition");
static_assert(sizeof(X6BlueprintLibrary_GetPointerPosition) == 0x00000C, "Wrong size on X6BlueprintLibrary_GetPointerPosition");
static_assert(offsetof(X6BlueprintLibrary_GetPointerPosition, PointerIndex) == 0x000000, "Member 'X6BlueprintLibrary_GetPointerPosition::PointerIndex' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetPointerPosition, ReturnValue) == 0x000004, "Member 'X6BlueprintLibrary_GetPointerPosition::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetProjectVersion
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetProjectVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetProjectVersion) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetProjectVersion");
static_assert(sizeof(X6BlueprintLibrary_GetProjectVersion) == 0x000010, "Wrong size on X6BlueprintLibrary_GetProjectVersion");
static_assert(offsetof(X6BlueprintLibrary_GetProjectVersion, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetProjectVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSafePaddingLeftRightSymmetric
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric) == 0x000001, "Wrong alignment on X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric");
static_assert(sizeof(X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric) == 0x000001, "Wrong size on X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric");
static_assert(offsetof(X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetSafePaddingLeftRightSymmetric::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSafePaddingTopBottomSymmetric
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric) == 0x000001, "Wrong alignment on X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric");
static_assert(sizeof(X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric) == 0x000001, "Wrong size on X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric");
static_assert(offsetof(X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetSafePaddingTopBottomSymmetric::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSafeZonePaddingMaxValue
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetSafeZonePaddingMaxValue final
{
public:
	struct FVector4f                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSafeZonePaddingMaxValue) == 0x000010, "Wrong alignment on X6BlueprintLibrary_GetSafeZonePaddingMaxValue");
static_assert(sizeof(X6BlueprintLibrary_GetSafeZonePaddingMaxValue) == 0x000010, "Wrong size on X6BlueprintLibrary_GetSafeZonePaddingMaxValue");
static_assert(offsetof(X6BlueprintLibrary_GetSafeZonePaddingMaxValue, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetSafeZonePaddingMaxValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSafeZonePaddingOriginalValue
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetSafeZonePaddingOriginalValue final
{
public:
	struct FVector4f                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSafeZonePaddingOriginalValue) == 0x000010, "Wrong alignment on X6BlueprintLibrary_GetSafeZonePaddingOriginalValue");
static_assert(sizeof(X6BlueprintLibrary_GetSafeZonePaddingOriginalValue) == 0x000010, "Wrong size on X6BlueprintLibrary_GetSafeZonePaddingOriginalValue");
static_assert(offsetof(X6BlueprintLibrary_GetSafeZonePaddingOriginalValue, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_GetSafeZonePaddingOriginalValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSequenceFloatCurveKeys
// 0x0030 (0x0030 - 0x0000)
struct X6BlueprintLibrary_GetSequenceFloatCurveKeys final
{
public:
	class UAnimSequence*                          AnimationSequence;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 KeyData;                                           // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSequenceFloatCurveKeys) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetSequenceFloatCurveKeys");
static_assert(sizeof(X6BlueprintLibrary_GetSequenceFloatCurveKeys) == 0x000030, "Wrong size on X6BlueprintLibrary_GetSequenceFloatCurveKeys");
static_assert(offsetof(X6BlueprintLibrary_GetSequenceFloatCurveKeys, AnimationSequence) == 0x000000, "Member 'X6BlueprintLibrary_GetSequenceFloatCurveKeys::AnimationSequence' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequenceFloatCurveKeys, CurveName) == 0x000008, "Member 'X6BlueprintLibrary_GetSequenceFloatCurveKeys::CurveName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequenceFloatCurveKeys, Times) == 0x000010, "Member 'X6BlueprintLibrary_GetSequenceFloatCurveKeys::Times' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequenceFloatCurveKeys, KeyData) == 0x000020, "Member 'X6BlueprintLibrary_GetSequenceFloatCurveKeys::KeyData' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSequencerTransfromTrackBoxs
// 0x0090 (0x0090 - 0x0000)
struct X6BlueprintLibrary_GetSequencerTransfromTrackBoxs final
{
public:
	class UMovieSceneSequence*                    InSequence;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMovieSceneSequencePlayer*              InPlayer;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             InTransform;                                       // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBox>                           OutBoxArray;                                       // 0x0070(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0080(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0xF];                                       // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs) == 0x000010, "Wrong alignment on X6BlueprintLibrary_GetSequencerTransfromTrackBoxs");
static_assert(sizeof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs) == 0x000090, "Wrong size on X6BlueprintLibrary_GetSequencerTransfromTrackBoxs");
static_assert(offsetof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs, InSequence) == 0x000000, "Member 'X6BlueprintLibrary_GetSequencerTransfromTrackBoxs::InSequence' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs, InPlayer) == 0x000008, "Member 'X6BlueprintLibrary_GetSequencerTransfromTrackBoxs::InPlayer' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs, InTransform) == 0x000010, "Member 'X6BlueprintLibrary_GetSequencerTransfromTrackBoxs::InTransform' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs, OutBoxArray) == 0x000070, "Member 'X6BlueprintLibrary_GetSequencerTransfromTrackBoxs::OutBoxArray' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSequencerTransfromTrackBoxs, ReturnValue) == 0x000080, "Member 'X6BlueprintLibrary_GetSequencerTransfromTrackBoxs::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSingleAnimCurrentTime
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetSingleAnimCurrentTime final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetSingleAnimCurrentTime) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetSingleAnimCurrentTime");
static_assert(sizeof(X6BlueprintLibrary_GetSingleAnimCurrentTime) == 0x000010, "Wrong size on X6BlueprintLibrary_GetSingleAnimCurrentTime");
static_assert(offsetof(X6BlueprintLibrary_GetSingleAnimCurrentTime, MeshComp) == 0x000000, "Member 'X6BlueprintLibrary_GetSingleAnimCurrentTime::MeshComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSingleAnimCurrentTime, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetSingleAnimCurrentTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSkeletalMeshForwardVector
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetSkeletalMeshForwardVector final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZAxis;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSkeletalMeshForwardVector) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetSkeletalMeshForwardVector");
static_assert(sizeof(X6BlueprintLibrary_GetSkeletalMeshForwardVector) == 0x000028, "Wrong size on X6BlueprintLibrary_GetSkeletalMeshForwardVector");
static_assert(offsetof(X6BlueprintLibrary_GetSkeletalMeshForwardVector, InSkeletalMeshComponent) == 0x000000, "Member 'X6BlueprintLibrary_GetSkeletalMeshForwardVector::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSkeletalMeshForwardVector, bIgnoreZAxis) == 0x000008, "Member 'X6BlueprintLibrary_GetSkeletalMeshForwardVector::bIgnoreZAxis' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSkeletalMeshForwardVector, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetSkeletalMeshForwardVector::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSocketComponentSpaceTransformByTime
// 0x0080 (0x0080 - 0x0000)
struct X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0020(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime) == 0x000010, "Wrong alignment on X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime");
static_assert(sizeof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime) == 0x000080, "Wrong size on X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime");
static_assert(offsetof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime, SkeletalMeshComp) == 0x000000, "Member 'X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime, AnimSequence) == 0x000008, "Member 'X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime::AnimSequence' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime, SocketName) == 0x000010, "Member 'X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime::SocketName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime, Time) == 0x000018, "Member 'X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime::Time' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_GetSocketComponentSpaceTransformByTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetStringArrayFromFile
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_GetStringArrayFromFile final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Content;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetStringArrayFromFile) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetStringArrayFromFile");
static_assert(sizeof(X6BlueprintLibrary_GetStringArrayFromFile) == 0x000020, "Wrong size on X6BlueprintLibrary_GetStringArrayFromFile");
static_assert(offsetof(X6BlueprintLibrary_GetStringArrayFromFile, Filename) == 0x000000, "Member 'X6BlueprintLibrary_GetStringArrayFromFile::Filename' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetStringArrayFromFile, Content) == 0x000010, "Member 'X6BlueprintLibrary_GetStringArrayFromFile::Content' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetStringFromFile
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_GetStringFromFile final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Content;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetStringFromFile) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetStringFromFile");
static_assert(sizeof(X6BlueprintLibrary_GetStringFromFile) == 0x000028, "Wrong size on X6BlueprintLibrary_GetStringFromFile");
static_assert(offsetof(X6BlueprintLibrary_GetStringFromFile, Filename) == 0x000000, "Member 'X6BlueprintLibrary_GetStringFromFile::Filename' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetStringFromFile, Content) == 0x000010, "Member 'X6BlueprintLibrary_GetStringFromFile::Content' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetStringFromFile, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_GetStringFromFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetStringHash
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetStringHash final
{
public:
	class FString                                 Str;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetStringHash) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetStringHash");
static_assert(sizeof(X6BlueprintLibrary_GetStringHash) == 0x000018, "Wrong size on X6BlueprintLibrary_GetStringHash");
static_assert(offsetof(X6BlueprintLibrary_GetStringHash, Str) == 0x000000, "Member 'X6BlueprintLibrary_GetStringHash::Str' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetStringHash, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetStringHash::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetStringMD5
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_GetStringMD5 final
{
public:
	class FString                                 Str;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetStringMD5) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetStringMD5");
static_assert(sizeof(X6BlueprintLibrary_GetStringMD5) == 0x000020, "Wrong size on X6BlueprintLibrary_GetStringMD5");
static_assert(offsetof(X6BlueprintLibrary_GetStringMD5, Str) == 0x000000, "Member 'X6BlueprintLibrary_GetStringMD5::Str' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetStringMD5, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetStringMD5::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetStructFieldsArray
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetStructFieldsArray final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetStructFieldsArray) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetStructFieldsArray");
static_assert(sizeof(X6BlueprintLibrary_GetStructFieldsArray) == 0x000018, "Wrong size on X6BlueprintLibrary_GetStructFieldsArray");
static_assert(offsetof(X6BlueprintLibrary_GetStructFieldsArray, Struct) == 0x000000, "Member 'X6BlueprintLibrary_GetStructFieldsArray::Struct' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetStructFieldsArray, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetStructFieldsArray::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSubWidgetByGuideTag
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetSubWidgetByGuideTag final
{
public:
	class UUserWidget*                            InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InGuideTag;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSubWidgetByGuideTag) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetSubWidgetByGuideTag");
static_assert(sizeof(X6BlueprintLibrary_GetSubWidgetByGuideTag) == 0x000018, "Wrong size on X6BlueprintLibrary_GetSubWidgetByGuideTag");
static_assert(offsetof(X6BlueprintLibrary_GetSubWidgetByGuideTag, InWidget) == 0x000000, "Member 'X6BlueprintLibrary_GetSubWidgetByGuideTag::InWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSubWidgetByGuideTag, InGuideTag) == 0x000008, "Member 'X6BlueprintLibrary_GetSubWidgetByGuideTag::InGuideTag' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSubWidgetByGuideTag, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetSubWidgetByGuideTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSubWidgetWithGuideTag
// 0x0058 (0x0058 - 0x0000)
struct X6BlueprintLibrary_GetSubWidgetWithGuideTag final
{
public:
	class UUserWidget*                            InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UWidget*>             ReturnValue;                                       // 0x0008(0x0050)(ConstParm, ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetSubWidgetWithGuideTag) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetSubWidgetWithGuideTag");
static_assert(sizeof(X6BlueprintLibrary_GetSubWidgetWithGuideTag) == 0x000058, "Wrong size on X6BlueprintLibrary_GetSubWidgetWithGuideTag");
static_assert(offsetof(X6BlueprintLibrary_GetSubWidgetWithGuideTag, InWidget) == 0x000000, "Member 'X6BlueprintLibrary_GetSubWidgetWithGuideTag::InWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSubWidgetWithGuideTag, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetSubWidgetWithGuideTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetSupportedAgentIndex
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetSupportedAgentIndex final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_GetSupportedAgentIndex) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetSupportedAgentIndex");
static_assert(sizeof(X6BlueprintLibrary_GetSupportedAgentIndex) == 0x000010, "Wrong size on X6BlueprintLibrary_GetSupportedAgentIndex");
static_assert(offsetof(X6BlueprintLibrary_GetSupportedAgentIndex, Actor) == 0x000000, "Member 'X6BlueprintLibrary_GetSupportedAgentIndex::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetSupportedAgentIndex, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetSupportedAgentIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetTargetCanFilterAndPriority
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetTargetCanFilterAndPriority final
{
public:
	const class UPrimitiveComponent*              Component;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanFilter;                                        // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PriorityValue;                                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetTargetCanFilterAndPriority) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetTargetCanFilterAndPriority");
static_assert(sizeof(X6BlueprintLibrary_GetTargetCanFilterAndPriority) == 0x000010, "Wrong size on X6BlueprintLibrary_GetTargetCanFilterAndPriority");
static_assert(offsetof(X6BlueprintLibrary_GetTargetCanFilterAndPriority, Component) == 0x000000, "Member 'X6BlueprintLibrary_GetTargetCanFilterAndPriority::Component' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetTargetCanFilterAndPriority, bCanFilter) == 0x000008, "Member 'X6BlueprintLibrary_GetTargetCanFilterAndPriority::bCanFilter' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetTargetCanFilterAndPriority, PriorityValue) == 0x00000C, "Member 'X6BlueprintLibrary_GetTargetCanFilterAndPriority::PriorityValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetTargetFilterHitComponents
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetTargetFilterHitComponents final
{
public:
	const class AActor*                           InTargetActor;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            X6CombatHitComponents;                             // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetTargetFilterHitComponents) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetTargetFilterHitComponents");
static_assert(sizeof(X6BlueprintLibrary_GetTargetFilterHitComponents) == 0x000018, "Wrong size on X6BlueprintLibrary_GetTargetFilterHitComponents");
static_assert(offsetof(X6BlueprintLibrary_GetTargetFilterHitComponents, InTargetActor) == 0x000000, "Member 'X6BlueprintLibrary_GetTargetFilterHitComponents::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetTargetFilterHitComponents, X6CombatHitComponents) == 0x000008, "Member 'X6BlueprintLibrary_GetTargetFilterHitComponents::X6CombatHitComponents' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetVelocityAndPredictPath_CustomArc
// 0x0078 (0x0078 - 0x0000)
struct X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLaunchVelocity;                                 // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        OutPathPositions;                                  // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimTime;                                        // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideGravityZ;                                  // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcParam;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc");
static_assert(sizeof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc) == 0x000078, "Wrong size on X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, OutLaunchVelocity) == 0x000008, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::OutLaunchVelocity' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, OutPathPositions) == 0x000020, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::OutPathPositions' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, StartPos) == 0x000030, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::StartPos' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, EndPos) == 0x000048, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::EndPos' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, SimFrequency) == 0x000060, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::SimFrequency' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, MaxSimTime) == 0x000064, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::MaxSimTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, DrawDebugType) == 0x000068, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, DrawDebugTime) == 0x00006C, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::DrawDebugTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, OverrideGravityZ) == 0x000070, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::OverrideGravityZ' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc, ArcParam) == 0x000074, "Member 'X6BlueprintLibrary_GetVelocityAndPredictPath_CustomArc::ArcParam' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetWidgetByGuideTag
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_GetWidgetByGuideTag final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InGuideTag;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetWidgetByGuideTag) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetWidgetByGuideTag");
static_assert(sizeof(X6BlueprintLibrary_GetWidgetByGuideTag) == 0x000018, "Wrong size on X6BlueprintLibrary_GetWidgetByGuideTag");
static_assert(offsetof(X6BlueprintLibrary_GetWidgetByGuideTag, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetWidgetByGuideTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetWidgetByGuideTag, InGuideTag) == 0x000008, "Member 'X6BlueprintLibrary_GetWidgetByGuideTag::InGuideTag' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetWidgetByGuideTag, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_GetWidgetByGuideTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetWidgetInViewport
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_GetWidgetInViewport final
{
public:
	class UObject*                                InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        OutHierarchyWidgets;                               // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UUserWidget*                            ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetWidgetInViewport) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetWidgetInViewport");
static_assert(sizeof(X6BlueprintLibrary_GetWidgetInViewport) == 0x000020, "Wrong size on X6BlueprintLibrary_GetWidgetInViewport");
static_assert(offsetof(X6BlueprintLibrary_GetWidgetInViewport, InWidget) == 0x000000, "Member 'X6BlueprintLibrary_GetWidgetInViewport::InWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetWidgetInViewport, OutHierarchyWidgets) == 0x000008, "Member 'X6BlueprintLibrary_GetWidgetInViewport::OutHierarchyWidgets' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetWidgetInViewport, ReturnValue) == 0x000018, "Member 'X6BlueprintLibrary_GetWidgetInViewport::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetX6GameInstance
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetX6GameInstance final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6GameInstance*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetX6GameInstance) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetX6GameInstance");
static_assert(sizeof(X6BlueprintLibrary_GetX6GameInstance) == 0x000010, "Wrong size on X6BlueprintLibrary_GetX6GameInstance");
static_assert(offsetof(X6BlueprintLibrary_GetX6GameInstance, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetX6GameInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetX6GameInstance, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetX6GameInstance::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.GetX6PlayerController
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_GetX6PlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AX6PlayerControllerBase*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_GetX6PlayerController) == 0x000008, "Wrong alignment on X6BlueprintLibrary_GetX6PlayerController");
static_assert(sizeof(X6BlueprintLibrary_GetX6PlayerController) == 0x000010, "Wrong size on X6BlueprintLibrary_GetX6PlayerController");
static_assert(offsetof(X6BlueprintLibrary_GetX6PlayerController, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_GetX6PlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_GetX6PlayerController, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_GetX6PlayerController::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.HasRootMotion
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_HasRootMotion final
{
public:
	class UAnimSequenceBase*                      AnimSequenceBase;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_HasRootMotion) == 0x000008, "Wrong alignment on X6BlueprintLibrary_HasRootMotion");
static_assert(sizeof(X6BlueprintLibrary_HasRootMotion) == 0x000010, "Wrong size on X6BlueprintLibrary_HasRootMotion");
static_assert(offsetof(X6BlueprintLibrary_HasRootMotion, AnimSequenceBase) == 0x000000, "Member 'X6BlueprintLibrary_HasRootMotion::AnimSequenceBase' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_HasRootMotion, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_HasRootMotion::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsActorPlayingGivenAnimation
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_IsActorPlayingGivenAnimation final
{
public:
	class AActor*                                 ActorObject;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                AnimationSoftRefs;                                 // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsActorPlayingGivenAnimation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsActorPlayingGivenAnimation");
static_assert(sizeof(X6BlueprintLibrary_IsActorPlayingGivenAnimation) == 0x000020, "Wrong size on X6BlueprintLibrary_IsActorPlayingGivenAnimation");
static_assert(offsetof(X6BlueprintLibrary_IsActorPlayingGivenAnimation, ActorObject) == 0x000000, "Member 'X6BlueprintLibrary_IsActorPlayingGivenAnimation::ActorObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsActorPlayingGivenAnimation, AnimationSoftRefs) == 0x000008, "Member 'X6BlueprintLibrary_IsActorPlayingGivenAnimation::AnimationSoftRefs' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsActorPlayingGivenAnimation, ReturnValue) == 0x000018, "Member 'X6BlueprintLibrary_IsActorPlayingGivenAnimation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsAnyGamePadConnected
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_IsAnyGamePadConnected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_IsAnyGamePadConnected) == 0x000001, "Wrong alignment on X6BlueprintLibrary_IsAnyGamePadConnected");
static_assert(sizeof(X6BlueprintLibrary_IsAnyGamePadConnected) == 0x000001, "Wrong size on X6BlueprintLibrary_IsAnyGamePadConnected");
static_assert(offsetof(X6BlueprintLibrary_IsAnyGamePadConnected, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_IsAnyGamePadConnected::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsInViewport
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_IsInViewport final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsInViewport) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsInViewport");
static_assert(sizeof(X6BlueprintLibrary_IsInViewport) == 0x000018, "Wrong size on X6BlueprintLibrary_IsInViewport");
static_assert(offsetof(X6BlueprintLibrary_IsInViewport, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_IsInViewport::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsInViewport, Actor) == 0x000008, "Member 'X6BlueprintLibrary_IsInViewport::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsInViewport, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_IsInViewport::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsLoadingScreenFinished
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_IsLoadingScreenFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_IsLoadingScreenFinished) == 0x000001, "Wrong alignment on X6BlueprintLibrary_IsLoadingScreenFinished");
static_assert(sizeof(X6BlueprintLibrary_IsLoadingScreenFinished) == 0x000001, "Wrong size on X6BlueprintLibrary_IsLoadingScreenFinished");
static_assert(offsetof(X6BlueprintLibrary_IsLoadingScreenFinished, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_IsLoadingScreenFinished::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsLocalPlayerController
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_IsLocalPlayerController final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsLocalPlayerController) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsLocalPlayerController");
static_assert(sizeof(X6BlueprintLibrary_IsLocalPlayerController) == 0x000010, "Wrong size on X6BlueprintLibrary_IsLocalPlayerController");
static_assert(offsetof(X6BlueprintLibrary_IsLocalPlayerController, Actor) == 0x000000, "Member 'X6BlueprintLibrary_IsLocalPlayerController::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsLocalPlayerController, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_IsLocalPlayerController::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsMontageSlotActivated
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_IsMontageSlotActivated final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPlaying;                                     // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsMontageSlotActivated) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsMontageSlotActivated");
static_assert(sizeof(X6BlueprintLibrary_IsMontageSlotActivated) == 0x000018, "Wrong size on X6BlueprintLibrary_IsMontageSlotActivated");
static_assert(offsetof(X6BlueprintLibrary_IsMontageSlotActivated, AnimInstance) == 0x000000, "Member 'X6BlueprintLibrary_IsMontageSlotActivated::AnimInstance' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsMontageSlotActivated, SlotNodeName) == 0x000008, "Member 'X6BlueprintLibrary_IsMontageSlotActivated::SlotNodeName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsMontageSlotActivated, bCheckPlaying) == 0x000010, "Member 'X6BlueprintLibrary_IsMontageSlotActivated::bCheckPlaying' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsMontageSlotActivated, ReturnValue) == 0x000011, "Member 'X6BlueprintLibrary_IsMontageSlotActivated::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsPlayerEyeBlinking
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_IsPlayerEyeBlinking final
{
public:
	class AActor*                                 InPlayerActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsPlayerEyeBlinking) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsPlayerEyeBlinking");
static_assert(sizeof(X6BlueprintLibrary_IsPlayerEyeBlinking) == 0x000010, "Wrong size on X6BlueprintLibrary_IsPlayerEyeBlinking");
static_assert(offsetof(X6BlueprintLibrary_IsPlayerEyeBlinking, InPlayerActor) == 0x000000, "Member 'X6BlueprintLibrary_IsPlayerEyeBlinking::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsPlayerEyeBlinking, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_IsPlayerEyeBlinking::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsPlayingInEditor
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_IsPlayingInEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_IsPlayingInEditor) == 0x000001, "Wrong alignment on X6BlueprintLibrary_IsPlayingInEditor");
static_assert(sizeof(X6BlueprintLibrary_IsPlayingInEditor) == 0x000001, "Wrong size on X6BlueprintLibrary_IsPlayingInEditor");
static_assert(offsetof(X6BlueprintLibrary_IsPlayingInEditor, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_IsPlayingInEditor::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsPointInsideBoxComponent
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_IsPointInsideBoxComponent final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComponent;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsPointInsideBoxComponent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsPointInsideBoxComponent");
static_assert(sizeof(X6BlueprintLibrary_IsPointInsideBoxComponent) == 0x000028, "Wrong size on X6BlueprintLibrary_IsPointInsideBoxComponent");
static_assert(offsetof(X6BlueprintLibrary_IsPointInsideBoxComponent, Point) == 0x000000, "Member 'X6BlueprintLibrary_IsPointInsideBoxComponent::Point' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsPointInsideBoxComponent, BoxComponent) == 0x000018, "Member 'X6BlueprintLibrary_IsPointInsideBoxComponent::BoxComponent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsPointInsideBoxComponent, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_IsPointInsideBoxComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsPSOPrecompiling
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_IsPSOPrecompiling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_IsPSOPrecompiling) == 0x000001, "Wrong alignment on X6BlueprintLibrary_IsPSOPrecompiling");
static_assert(sizeof(X6BlueprintLibrary_IsPSOPrecompiling) == 0x000001, "Wrong size on X6BlueprintLibrary_IsPSOPrecompiling");
static_assert(offsetof(X6BlueprintLibrary_IsPSOPrecompiling, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_IsPSOPrecompiling::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsThisApplicationForeground
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_IsThisApplicationForeground final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_IsThisApplicationForeground) == 0x000001, "Wrong alignment on X6BlueprintLibrary_IsThisApplicationForeground");
static_assert(sizeof(X6BlueprintLibrary_IsThisApplicationForeground) == 0x000001, "Wrong size on X6BlueprintLibrary_IsThisApplicationForeground");
static_assert(offsetof(X6BlueprintLibrary_IsThisApplicationForeground, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_IsThisApplicationForeground::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsWidgetChildOf
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_IsWidgetChildOf final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                PossibleParent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsWidgetChildOf) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsWidgetChildOf");
static_assert(sizeof(X6BlueprintLibrary_IsWidgetChildOf) == 0x000018, "Wrong size on X6BlueprintLibrary_IsWidgetChildOf");
static_assert(offsetof(X6BlueprintLibrary_IsWidgetChildOf, Widget) == 0x000000, "Member 'X6BlueprintLibrary_IsWidgetChildOf::Widget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsWidgetChildOf, PossibleParent) == 0x000008, "Member 'X6BlueprintLibrary_IsWidgetChildOf::PossibleParent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsWidgetChildOf, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_IsWidgetChildOf::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsWidgetRealVisible
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_IsWidgetRealVisible final
{
public:
	class UWidget*                                InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsWidgetRealVisible) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsWidgetRealVisible");
static_assert(sizeof(X6BlueprintLibrary_IsWidgetRealVisible) == 0x000010, "Wrong size on X6BlueprintLibrary_IsWidgetRealVisible");
static_assert(offsetof(X6BlueprintLibrary_IsWidgetRealVisible, InWidget) == 0x000000, "Member 'X6BlueprintLibrary_IsWidgetRealVisible::InWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsWidgetRealVisible, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_IsWidgetRealVisible::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsWithEditor
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_IsWithEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_IsWithEditor) == 0x000001, "Wrong alignment on X6BlueprintLibrary_IsWithEditor");
static_assert(sizeof(X6BlueprintLibrary_IsWithEditor) == 0x000001, "Wrong size on X6BlueprintLibrary_IsWithEditor");
static_assert(offsetof(X6BlueprintLibrary_IsWithEditor, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_IsWithEditor::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.IsWorldPositionInViewport
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_IsWorldPositionInViewport final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerViewportRelative;                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_IsWorldPositionInViewport) == 0x000008, "Wrong alignment on X6BlueprintLibrary_IsWorldPositionInViewport");
static_assert(sizeof(X6BlueprintLibrary_IsWorldPositionInViewport) == 0x000028, "Wrong size on X6BlueprintLibrary_IsWorldPositionInViewport");
static_assert(offsetof(X6BlueprintLibrary_IsWorldPositionInViewport, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_IsWorldPositionInViewport::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsWorldPositionInViewport, Position) == 0x000008, "Member 'X6BlueprintLibrary_IsWorldPositionInViewport::Position' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsWorldPositionInViewport, bPlayerViewportRelative) == 0x000020, "Member 'X6BlueprintLibrary_IsWorldPositionInViewport::bPlayerViewportRelative' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_IsWorldPositionInViewport, ReturnValue) == 0x000021, "Member 'X6BlueprintLibrary_IsWorldPositionInViewport::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.LineBoxIntersection
// 0x0088 (0x0088 - 0x0000)
struct X6BlueprintLibrary_LineBoxIntersection final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0050(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0068(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0080(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_LineBoxIntersection) == 0x000008, "Wrong alignment on X6BlueprintLibrary_LineBoxIntersection");
static_assert(sizeof(X6BlueprintLibrary_LineBoxIntersection) == 0x000088, "Wrong size on X6BlueprintLibrary_LineBoxIntersection");
static_assert(offsetof(X6BlueprintLibrary_LineBoxIntersection, Box) == 0x000000, "Member 'X6BlueprintLibrary_LineBoxIntersection::Box' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_LineBoxIntersection, Start) == 0x000038, "Member 'X6BlueprintLibrary_LineBoxIntersection::Start' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_LineBoxIntersection, End) == 0x000050, "Member 'X6BlueprintLibrary_LineBoxIntersection::End' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_LineBoxIntersection, Direction) == 0x000068, "Member 'X6BlueprintLibrary_LineBoxIntersection::Direction' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_LineBoxIntersection, ReturnValue) == 0x000080, "Member 'X6BlueprintLibrary_LineBoxIntersection::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.LoadAndActivateGameFeaturePlugin
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin final
{
public:
	class FString                                 InGameFeaturePluginName;                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin) == 0x000008, "Wrong alignment on X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin");
static_assert(sizeof(X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin) == 0x000010, "Wrong size on X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin");
static_assert(offsetof(X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin, InGameFeaturePluginName) == 0x000000, "Member 'X6BlueprintLibrary_LoadAndActivateGameFeaturePlugin::InGameFeaturePluginName' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.LoadPropertiesFromConfig
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_LoadPropertiesFromConfig final
{
public:
	class UObject*                                obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Instance_ID;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_LoadPropertiesFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_LoadPropertiesFromConfig");
static_assert(sizeof(X6BlueprintLibrary_LoadPropertiesFromConfig) == 0x000020, "Wrong size on X6BlueprintLibrary_LoadPropertiesFromConfig");
static_assert(offsetof(X6BlueprintLibrary_LoadPropertiesFromConfig, obj) == 0x000000, "Member 'X6BlueprintLibrary_LoadPropertiesFromConfig::obj' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_LoadPropertiesFromConfig, Filename) == 0x000008, "Member 'X6BlueprintLibrary_LoadPropertiesFromConfig::Filename' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_LoadPropertiesFromConfig, Instance_ID) == 0x000018, "Member 'X6BlueprintLibrary_LoadPropertiesFromConfig::Instance_ID' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.MarkAsGarbageByObject
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_MarkAsGarbageByObject final
{
public:
	const class UObject*                          InObject;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_MarkAsGarbageByObject) == 0x000008, "Wrong alignment on X6BlueprintLibrary_MarkAsGarbageByObject");
static_assert(sizeof(X6BlueprintLibrary_MarkAsGarbageByObject) == 0x000008, "Wrong size on X6BlueprintLibrary_MarkAsGarbageByObject");
static_assert(offsetof(X6BlueprintLibrary_MarkAsGarbageByObject, InObject) == 0x000000, "Member 'X6BlueprintLibrary_MarkAsGarbageByObject::InObject' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.MarkAsGarbageByPath
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_MarkAsGarbageByPath final
{
public:
	class FString                                 InPackagePath;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_MarkAsGarbageByPath) == 0x000008, "Wrong alignment on X6BlueprintLibrary_MarkAsGarbageByPath");
static_assert(sizeof(X6BlueprintLibrary_MarkAsGarbageByPath) == 0x000010, "Wrong size on X6BlueprintLibrary_MarkAsGarbageByPath");
static_assert(offsetof(X6BlueprintLibrary_MarkAsGarbageByPath, InPackagePath) == 0x000000, "Member 'X6BlueprintLibrary_MarkAsGarbageByPath::InPackagePath' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.MatchesTagDepth
// 0x0014 (0x0014 - 0x0000)
struct X6BlueprintLibrary_MatchesTagDepth final
{
public:
	struct FGameplayTag                           TagOne;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagTwo;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_MatchesTagDepth) == 0x000004, "Wrong alignment on X6BlueprintLibrary_MatchesTagDepth");
static_assert(sizeof(X6BlueprintLibrary_MatchesTagDepth) == 0x000014, "Wrong size on X6BlueprintLibrary_MatchesTagDepth");
static_assert(offsetof(X6BlueprintLibrary_MatchesTagDepth, TagOne) == 0x000000, "Member 'X6BlueprintLibrary_MatchesTagDepth::TagOne' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_MatchesTagDepth, TagTwo) == 0x000008, "Member 'X6BlueprintLibrary_MatchesTagDepth::TagTwo' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_MatchesTagDepth, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_MatchesTagDepth::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.NumPSOPrecompilesRemaining
// 0x0004 (0x0004 - 0x0000)
struct X6BlueprintLibrary_NumPSOPrecompilesRemaining final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_NumPSOPrecompilesRemaining) == 0x000004, "Wrong alignment on X6BlueprintLibrary_NumPSOPrecompilesRemaining");
static_assert(sizeof(X6BlueprintLibrary_NumPSOPrecompilesRemaining) == 0x000004, "Wrong size on X6BlueprintLibrary_NumPSOPrecompilesRemaining");
static_assert(offsetof(X6BlueprintLibrary_NumPSOPrecompilesRemaining, ReturnValue) == 0x000000, "Member 'X6BlueprintLibrary_NumPSOPrecompilesRemaining::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PaperDynamicLinkAnimClassLayers
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers final
{
public:
	class USkeletalMeshComponent*                 SKMeshComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              NewLinkAnimClass;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers");
static_assert(sizeof(X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers) == 0x000018, "Wrong size on X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers");
static_assert(offsetof(X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers, SKMeshComp) == 0x000000, "Member 'X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers::SKMeshComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers, NewLinkAnimClass) == 0x000008, "Member 'X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers::NewLinkAnimClass' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_PaperDynamicLinkAnimClassLayers::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PaperDynamicSetAnimInstanceClass
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass final
{
public:
	class USkeletalMeshComponent*                 SKMeshComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              NewAnimClass;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass");
static_assert(sizeof(X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass) == 0x000018, "Wrong size on X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass");
static_assert(offsetof(X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass, SKMeshComp) == 0x000000, "Member 'X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass::SKMeshComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass, NewAnimClass) == 0x000008, "Member 'X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass::NewAnimClass' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_PaperDynamicSetAnimInstanceClass::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorCancelLookAtActor
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_PlayerActorCancelLookAtActor final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0019(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorCancelLookAtActor) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorCancelLookAtActor");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorCancelLookAtActor) == 0x000020, "Wrong size on X6BlueprintLibrary_PlayerActorCancelLookAtActor");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtActor, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtActor::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtActor, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtActor::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtActor, InTargetActor) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtActor::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtActor, bClearAll) == 0x000018, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtActor::bClearAll' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtActor, bNeedNetSync) == 0x000019, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtActor::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorCancelLookAtLocation
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_PlayerActorCancelLookAtLocation final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorCancelLookAtLocation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorCancelLookAtLocation");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorCancelLookAtLocation) == 0x000018, "Wrong size on X6BlueprintLibrary_PlayerActorCancelLookAtLocation");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtLocation, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtLocation::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtLocation, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtLocation::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtLocation, bClearAll) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtLocation::bClearAll' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancelLookAtLocation, bNeedNetSync) == 0x000011, "Member 'X6BlueprintLibrary_PlayerActorCancelLookAtLocation::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorCancleLookAtEventsByType
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAll;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType) == 0x000018, "Wrong size on X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType, bClearAll) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType::bClearAll' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType, bNeedNetSync) == 0x000011, "Member 'X6BlueprintLibrary_PlayerActorCancleLookAtEventsByType::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorLookAtActor
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_PlayerActorLookAtActor final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTriggerTurn;                                  // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideTriggerTurnAngle;                          // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorLookAtActor) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorLookAtActor");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorLookAtActor) == 0x000028, "Wrong size on X6BlueprintLibrary_PlayerActorLookAtActor");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActor, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorLookAtActor::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActor, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorLookAtActor::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActor, InTargetActor) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorLookAtActor::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActor, bNeedTriggerTurn) == 0x000018, "Member 'X6BlueprintLibrary_PlayerActorLookAtActor::bNeedTriggerTurn' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActor, OverrideTriggerTurnAngle) == 0x00001C, "Member 'X6BlueprintLibrary_PlayerActorLookAtActor::OverrideTriggerTurnAngle' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActor, bNeedNetSync) == 0x000020, "Member 'X6BlueprintLibrary_PlayerActorLookAtActor::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorLookAtActorWithParams
// 0x0040 (0x0040 - 0x0000)
struct X6BlueprintLibrary_PlayerActorLookAtActorWithParams final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   LookAtRequestParams;                               // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0038(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorLookAtActorWithParams");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams) == 0x000040, "Wrong size on X6BlueprintLibrary_PlayerActorLookAtActorWithParams");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorLookAtActorWithParams::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorLookAtActorWithParams::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams, InTargetActor) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorLookAtActorWithParams::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams, LookAtRequestParams) == 0x000018, "Member 'X6BlueprintLibrary_PlayerActorLookAtActorWithParams::LookAtRequestParams' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtActorWithParams, bNeedNetSync) == 0x000038, "Member 'X6BlueprintLibrary_PlayerActorLookAtActorWithParams::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorLookAtLocation
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_PlayerActorLookAtLocation final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InTargetLocation;                                  // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTriggerTurn;                                  // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideTriggerTurnAngle;                          // 0x002C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorLookAtLocation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorLookAtLocation");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorLookAtLocation) == 0x000038, "Wrong size on X6BlueprintLibrary_PlayerActorLookAtLocation");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocation, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocation::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocation, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocation::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocation, InTargetLocation) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocation::InTargetLocation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocation, bNeedTriggerTurn) == 0x000028, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocation::bNeedTriggerTurn' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocation, OverrideTriggerTurnAngle) == 0x00002C, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocation::OverrideTriggerTurnAngle' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocation, bNeedNetSync) == 0x000030, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocation::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorLookAtLocationWithParams
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_PlayerActorLookAtLocationWithParams final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InTargetLocation;                                  // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   LookAtRequestParams;                               // 0x0028(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNeedNetSync;                                      // 0x0048(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorLookAtLocationWithParams");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams) == 0x000050, "Wrong size on X6BlueprintLibrary_PlayerActorLookAtLocationWithParams");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams, InEventType) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocationWithParams::InEventType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams, InPlayerActor) == 0x000008, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocationWithParams::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams, InTargetLocation) == 0x000010, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocationWithParams::InTargetLocation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams, LookAtRequestParams) == 0x000028, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocationWithParams::LookAtRequestParams' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorLookAtLocationWithParams, bNeedNetSync) == 0x000048, "Member 'X6BlueprintLibrary_PlayerActorLookAtLocationWithParams::bNeedNetSync' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorPauseLookAt
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_PlayerActorPauseLookAt final
{
public:
	class AActor*                                 InPlayerActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorPauseLookAt) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorPauseLookAt");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorPauseLookAt) == 0x000008, "Wrong size on X6BlueprintLibrary_PlayerActorPauseLookAt");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorPauseLookAt, InPlayerActor) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorPauseLookAt::InPlayerActor' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerActorResumeLookAt
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_PlayerActorResumeLookAt final
{
public:
	class AActor*                                 InPlayerActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_PlayerActorResumeLookAt) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerActorResumeLookAt");
static_assert(sizeof(X6BlueprintLibrary_PlayerActorResumeLookAt) == 0x000008, "Wrong size on X6BlueprintLibrary_PlayerActorResumeLookAt");
static_assert(offsetof(X6BlueprintLibrary_PlayerActorResumeLookAt, InPlayerActor) == 0x000000, "Member 'X6BlueprintLibrary_PlayerActorResumeLookAt::InPlayerActor' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerEyeBlinkOnce
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_PlayerEyeBlinkOnce final
{
public:
	class AActor*                                 InPlayerActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomBlink;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PlayerEyeBlinkOnce) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerEyeBlinkOnce");
static_assert(sizeof(X6BlueprintLibrary_PlayerEyeBlinkOnce) == 0x000010, "Wrong size on X6BlueprintLibrary_PlayerEyeBlinkOnce");
static_assert(offsetof(X6BlueprintLibrary_PlayerEyeBlinkOnce, InPlayerActor) == 0x000000, "Member 'X6BlueprintLibrary_PlayerEyeBlinkOnce::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerEyeBlinkOnce, bRandomBlink) == 0x000008, "Member 'X6BlueprintLibrary_PlayerEyeBlinkOnce::bRandomBlink' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerEyeBlinkOnce, bForce) == 0x000009, "Member 'X6BlueprintLibrary_PlayerEyeBlinkOnce::bForce' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PlayerMoveToLocationAfterFlushLevelStreaming
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming");
static_assert(sizeof(X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming) == 0x000020, "Wrong size on X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming");
static_assert(offsetof(X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming, InLocation) == 0x000008, "Member 'X6BlueprintLibrary_PlayerMoveToLocationAfterFlushLevelStreaming::InLocation' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.PrestreamTextures
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_PrestreamTextures final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Seconds;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStreaming;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CinematicTextureGroups;                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_PrestreamTextures) == 0x000008, "Wrong alignment on X6BlueprintLibrary_PrestreamTextures");
static_assert(sizeof(X6BlueprintLibrary_PrestreamTextures) == 0x000018, "Wrong size on X6BlueprintLibrary_PrestreamTextures");
static_assert(offsetof(X6BlueprintLibrary_PrestreamTextures, Actor) == 0x000000, "Member 'X6BlueprintLibrary_PrestreamTextures::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PrestreamTextures, Seconds) == 0x000008, "Member 'X6BlueprintLibrary_PrestreamTextures::Seconds' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PrestreamTextures, bEnableStreaming) == 0x00000C, "Member 'X6BlueprintLibrary_PrestreamTextures::bEnableStreaming' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_PrestreamTextures, CinematicTextureGroups) == 0x000010, "Member 'X6BlueprintLibrary_PrestreamTextures::CinematicTextureGroups' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RegisterAndAddComponent
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_RegisterAndAddComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        NewComponent;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachmentRules;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InSocketName;                                      // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_RegisterAndAddComponent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_RegisterAndAddComponent");
static_assert(sizeof(X6BlueprintLibrary_RegisterAndAddComponent) == 0x000020, "Wrong size on X6BlueprintLibrary_RegisterAndAddComponent");
static_assert(offsetof(X6BlueprintLibrary_RegisterAndAddComponent, Actor) == 0x000000, "Member 'X6BlueprintLibrary_RegisterAndAddComponent::Actor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterAndAddComponent, NewComponent) == 0x000008, "Member 'X6BlueprintLibrary_RegisterAndAddComponent::NewComponent' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterAndAddComponent, AttachmentRules) == 0x000010, "Member 'X6BlueprintLibrary_RegisterAndAddComponent::AttachmentRules' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterAndAddComponent, InSocketName) == 0x000014, "Member 'X6BlueprintLibrary_RegisterAndAddComponent::InSocketName' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterAndAddComponent, ReturnValue) == 0x00001C, "Member 'X6BlueprintLibrary_RegisterAndAddComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RegisterClickNotification
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_RegisterClickNotification final
{
public:
	class UWidget*                                InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClickNotification*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_RegisterClickNotification) == 0x000008, "Wrong alignment on X6BlueprintLibrary_RegisterClickNotification");
static_assert(sizeof(X6BlueprintLibrary_RegisterClickNotification) == 0x000010, "Wrong size on X6BlueprintLibrary_RegisterClickNotification");
static_assert(offsetof(X6BlueprintLibrary_RegisterClickNotification, InWidget) == 0x000000, "Member 'X6BlueprintLibrary_RegisterClickNotification::InWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterClickNotification, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_RegisterClickNotification::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RegisterGameViewportActivationChangedEvent
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool bActivated)>              Callback;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent");
static_assert(sizeof(X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent) == 0x000020, "Wrong size on X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent");
static_assert(offsetof(X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent, Callback) == 0x000008, "Member 'X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent::Callback' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent, ReturnValue) == 0x000018, "Member 'X6BlueprintLibrary_RegisterGameViewportActivationChangedEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RegisterViewportFocusChangingEvent
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_RegisterViewportFocusChangingEvent final
{
public:
	TDelegate<void(bool IsFocused, bool IsInFocusPath)> Callback;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_RegisterViewportFocusChangingEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_RegisterViewportFocusChangingEvent");
static_assert(sizeof(X6BlueprintLibrary_RegisterViewportFocusChangingEvent) == 0x000018, "Wrong size on X6BlueprintLibrary_RegisterViewportFocusChangingEvent");
static_assert(offsetof(X6BlueprintLibrary_RegisterViewportFocusChangingEvent, Callback) == 0x000000, "Member 'X6BlueprintLibrary_RegisterViewportFocusChangingEvent::Callback' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RegisterViewportFocusChangingEvent, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_RegisterViewportFocusChangingEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RemoveEffectOutlineOnActor
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_RemoveEffectOutlineOnActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_RemoveEffectOutlineOnActor) == 0x000008, "Wrong alignment on X6BlueprintLibrary_RemoveEffectOutlineOnActor");
static_assert(sizeof(X6BlueprintLibrary_RemoveEffectOutlineOnActor) == 0x000008, "Wrong size on X6BlueprintLibrary_RemoveEffectOutlineOnActor");
static_assert(offsetof(X6BlueprintLibrary_RemoveEffectOutlineOnActor, InActor) == 0x000000, "Member 'X6BlueprintLibrary_RemoveEffectOutlineOnActor::InActor' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RemoveTransformUpdatedEvent
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_RemoveTransformUpdatedEvent final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Handle;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_RemoveTransformUpdatedEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_RemoveTransformUpdatedEvent");
static_assert(sizeof(X6BlueprintLibrary_RemoveTransformUpdatedEvent) == 0x000018, "Wrong size on X6BlueprintLibrary_RemoveTransformUpdatedEvent");
static_assert(offsetof(X6BlueprintLibrary_RemoveTransformUpdatedEvent, Target) == 0x000000, "Member 'X6BlueprintLibrary_RemoveTransformUpdatedEvent::Target' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RemoveTransformUpdatedEvent, Handle) == 0x000008, "Member 'X6BlueprintLibrary_RemoveTransformUpdatedEvent::Handle' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RemoveTransformUpdatedEvent, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_RemoveTransformUpdatedEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ReplaceVisibleTextWidgetsToKey
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey");
static_assert(sizeof(X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey) == 0x000008, "Wrong size on X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey");
static_assert(offsetof(X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_ReplaceVisibleTextWidgetsToKey::InWorldContextObject' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.RequestGameplayTag
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_RequestGameplayTag final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_RequestGameplayTag) == 0x000004, "Wrong alignment on X6BlueprintLibrary_RequestGameplayTag");
static_assert(sizeof(X6BlueprintLibrary_RequestGameplayTag) == 0x000010, "Wrong size on X6BlueprintLibrary_RequestGameplayTag");
static_assert(offsetof(X6BlueprintLibrary_RequestGameplayTag, Name_0) == 0x000000, "Member 'X6BlueprintLibrary_RequestGameplayTag::Name_0' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_RequestGameplayTag, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_RequestGameplayTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ResetAdvancedCameraRotation
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_ResetAdvancedCameraRotation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ResetAdvancedCameraRotation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ResetAdvancedCameraRotation");
static_assert(sizeof(X6BlueprintLibrary_ResetAdvancedCameraRotation) == 0x000008, "Wrong size on X6BlueprintLibrary_ResetAdvancedCameraRotation");
static_assert(offsetof(X6BlueprintLibrary_ResetAdvancedCameraRotation, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_ResetAdvancedCameraRotation::WorldContextObject' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ResizeRenderTarget
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_ResizeRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ResizeRenderTarget) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ResizeRenderTarget");
static_assert(sizeof(X6BlueprintLibrary_ResizeRenderTarget) == 0x000010, "Wrong size on X6BlueprintLibrary_ResizeRenderTarget");
static_assert(offsetof(X6BlueprintLibrary_ResizeRenderTarget, RenderTarget) == 0x000000, "Member 'X6BlueprintLibrary_ResizeRenderTarget::RenderTarget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ResizeRenderTarget, Width) == 0x000008, "Member 'X6BlueprintLibrary_ResizeRenderTarget::Width' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ResizeRenderTarget, Height) == 0x00000C, "Member 'X6BlueprintLibrary_ResizeRenderTarget::Height' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.ReTargetActorTickToLevel
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_ReTargetActorTickToLevel final
{
public:
	class ULevel*                                 InLevel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InActor;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_ReTargetActorTickToLevel) == 0x000008, "Wrong alignment on X6BlueprintLibrary_ReTargetActorTickToLevel");
static_assert(sizeof(X6BlueprintLibrary_ReTargetActorTickToLevel) == 0x000010, "Wrong size on X6BlueprintLibrary_ReTargetActorTickToLevel");
static_assert(offsetof(X6BlueprintLibrary_ReTargetActorTickToLevel, InLevel) == 0x000000, "Member 'X6BlueprintLibrary_ReTargetActorTickToLevel::InLevel' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_ReTargetActorTickToLevel, InActor) == 0x000008, "Member 'X6BlueprintLibrary_ReTargetActorTickToLevel::InActor' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SavePropertiesToConfig
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_SavePropertiesToConfig final
{
public:
	class UObject*                                obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Instance_ID;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SavePropertiesToConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SavePropertiesToConfig");
static_assert(sizeof(X6BlueprintLibrary_SavePropertiesToConfig) == 0x000020, "Wrong size on X6BlueprintLibrary_SavePropertiesToConfig");
static_assert(offsetof(X6BlueprintLibrary_SavePropertiesToConfig, obj) == 0x000000, "Member 'X6BlueprintLibrary_SavePropertiesToConfig::obj' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SavePropertiesToConfig, Filename) == 0x000008, "Member 'X6BlueprintLibrary_SavePropertiesToConfig::Filename' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SavePropertiesToConfig, Instance_ID) == 0x000018, "Member 'X6BlueprintLibrary_SavePropertiesToConfig::Instance_ID' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SaveRenderTargetToFile
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_SaveRenderTargetToFile final
{
public:
	class UTextureRenderTarget2D*                 rt;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 fileDestination;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithAlpha;                                        // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SaveRenderTargetToFile) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SaveRenderTargetToFile");
static_assert(sizeof(X6BlueprintLibrary_SaveRenderTargetToFile) == 0x000020, "Wrong size on X6BlueprintLibrary_SaveRenderTargetToFile");
static_assert(offsetof(X6BlueprintLibrary_SaveRenderTargetToFile, rt) == 0x000000, "Member 'X6BlueprintLibrary_SaveRenderTargetToFile::rt' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SaveRenderTargetToFile, fileDestination) == 0x000008, "Member 'X6BlueprintLibrary_SaveRenderTargetToFile::fileDestination' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SaveRenderTargetToFile, bWithAlpha) == 0x000018, "Member 'X6BlueprintLibrary_SaveRenderTargetToFile::bWithAlpha' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SaveRenderTargetToFile, ReturnValue) == 0x000019, "Member 'X6BlueprintLibrary_SaveRenderTargetToFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SaveStringToFile
// 0x0028 (0x0028 - 0x0000)
struct X6BlueprintLibrary_SaveStringToFile final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SaveStringToFile) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SaveStringToFile");
static_assert(sizeof(X6BlueprintLibrary_SaveStringToFile) == 0x000028, "Wrong size on X6BlueprintLibrary_SaveStringToFile");
static_assert(offsetof(X6BlueprintLibrary_SaveStringToFile, String) == 0x000000, "Member 'X6BlueprintLibrary_SaveStringToFile::String' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SaveStringToFile, Filename) == 0x000010, "Member 'X6BlueprintLibrary_SaveStringToFile::Filename' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SaveStringToFile, ReturnValue) == 0x000020, "Member 'X6BlueprintLibrary_SaveStringToFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SearchBulletConditionPathTargetResults
// 0x00E8 (0x00E8 - 0x0000)
struct X6BlueprintLibrary_SearchBulletConditionPathTargetResults final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HalfSize;                                          // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPenetrateMonster;                                 // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Orientation;                                       // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0078(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0090(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x00A8(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00B8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00BC(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00CC(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00DC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SearchBulletConditionPathTargetResults");
static_assert(sizeof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults) == 0x0000E8, "Wrong size on X6BlueprintLibrary_SearchBulletConditionPathTargetResults");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, Start) == 0x000008, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::Start' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, End) == 0x000020, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::End' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, Radius) == 0x000038, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::Radius' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, HalfSize) == 0x000040, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::HalfSize' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, bPenetrateMonster) == 0x000058, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::bPenetrateMonster' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, Orientation) == 0x000060, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::Orientation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, ObjectTypes) == 0x000078, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, bTraceComplex) == 0x000088, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::bTraceComplex' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, ActorsToIgnore) == 0x000090, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, DrawDebugType) == 0x0000A0, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, OutHits) == 0x0000A8, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::OutHits' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, bIgnoreSelf) == 0x0000B8, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, TraceColor) == 0x0000BC, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::TraceColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, TraceHitColor) == 0x0000CC, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::TraceHitColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, DrawTime) == 0x0000DC, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::DrawTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchBulletConditionPathTargetResults, ReturnValue) == 0x0000E0, "Member 'X6BlueprintLibrary_SearchBulletConditionPathTargetResults::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SearchFilterConditionAreaTargetResults
// 0x00D0 (0x00D0 - 0x0000)
struct X6BlueprintLibrary_SearchFilterConditionAreaTargetResults final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0050(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0068(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0080(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0098(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00AC(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00BC(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00CC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SearchFilterConditionAreaTargetResults");
static_assert(sizeof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults) == 0x0000D0, "Wrong size on X6BlueprintLibrary_SearchFilterConditionAreaTargetResults");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, Start) == 0x000008, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::Start' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, End) == 0x000020, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::End' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, HalfSize) == 0x000038, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::HalfSize' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, Orientation) == 0x000050, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::Orientation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, ObjectTypes) == 0x000068, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, bTraceComplex) == 0x000078, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::bTraceComplex' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, ActorsToIgnore) == 0x000080, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, DrawDebugType) == 0x000090, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, OutHits) == 0x000098, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::OutHits' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, bIgnoreSelf) == 0x0000A8, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, TraceColor) == 0x0000AC, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::TraceColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, TraceHitColor) == 0x0000BC, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::TraceHitColor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SearchFilterConditionAreaTargetResults, DrawTime) == 0x0000CC, "Member 'X6BlueprintLibrary_SearchFilterConditionAreaTargetResults::DrawTime' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SegmentIntersection2D
// 0x0080 (0x0080 - 0x0000)
struct X6BlueprintLibrary_SegmentIntersection2D final
{
public:
	struct FVector                                SegmentStartA;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentEndA;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentStartB;                                     // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentEndB;                                       // 0x0048(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IntersectionPoint;                                 // 0x0060(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SegmentIntersection2D) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SegmentIntersection2D");
static_assert(sizeof(X6BlueprintLibrary_SegmentIntersection2D) == 0x000080, "Wrong size on X6BlueprintLibrary_SegmentIntersection2D");
static_assert(offsetof(X6BlueprintLibrary_SegmentIntersection2D, SegmentStartA) == 0x000000, "Member 'X6BlueprintLibrary_SegmentIntersection2D::SegmentStartA' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SegmentIntersection2D, SegmentEndA) == 0x000018, "Member 'X6BlueprintLibrary_SegmentIntersection2D::SegmentEndA' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SegmentIntersection2D, SegmentStartB) == 0x000030, "Member 'X6BlueprintLibrary_SegmentIntersection2D::SegmentStartB' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SegmentIntersection2D, SegmentEndB) == 0x000048, "Member 'X6BlueprintLibrary_SegmentIntersection2D::SegmentEndB' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SegmentIntersection2D, IntersectionPoint) == 0x000060, "Member 'X6BlueprintLibrary_SegmentIntersection2D::IntersectionPoint' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SegmentIntersection2D, ReturnValue) == 0x000078, "Member 'X6BlueprintLibrary_SegmentIntersection2D::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetActorRootComponent
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetActorRootComponent final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        InComponent;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetActorRootComponent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetActorRootComponent");
static_assert(sizeof(X6BlueprintLibrary_SetActorRootComponent) == 0x000010, "Wrong size on X6BlueprintLibrary_SetActorRootComponent");
static_assert(offsetof(X6BlueprintLibrary_SetActorRootComponent, InActor) == 0x000000, "Member 'X6BlueprintLibrary_SetActorRootComponent::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetActorRootComponent, InComponent) == 0x000008, "Member 'X6BlueprintLibrary_SetActorRootComponent::InComponent' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetEnableAnimMontageRootRotion
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_SetEnableAnimMontageRootRotion final
{
public:
	class UAnimInstance*                          AnimInstace;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SetEnableAnimMontageRootRotion) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetEnableAnimMontageRootRotion");
static_assert(sizeof(X6BlueprintLibrary_SetEnableAnimMontageRootRotion) == 0x000018, "Wrong size on X6BlueprintLibrary_SetEnableAnimMontageRootRotion");
static_assert(offsetof(X6BlueprintLibrary_SetEnableAnimMontageRootRotion, AnimInstace) == 0x000000, "Member 'X6BlueprintLibrary_SetEnableAnimMontageRootRotion::AnimInstace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetEnableAnimMontageRootRotion, AnimMontage) == 0x000008, "Member 'X6BlueprintLibrary_SetEnableAnimMontageRootRotion::AnimMontage' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetEnableAnimMontageRootRotion, bEnable) == 0x000010, "Member 'X6BlueprintLibrary_SetEnableAnimMontageRootRotion::bEnable' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetGameUIFocusBrushEnable
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_SetGameUIFocusBrushEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetGameUIFocusBrushEnable) == 0x000001, "Wrong alignment on X6BlueprintLibrary_SetGameUIFocusBrushEnable");
static_assert(sizeof(X6BlueprintLibrary_SetGameUIFocusBrushEnable) == 0x000001, "Wrong size on X6BlueprintLibrary_SetGameUIFocusBrushEnable");
static_assert(offsetof(X6BlueprintLibrary_SetGameUIFocusBrushEnable, bEnable) == 0x000000, "Member 'X6BlueprintLibrary_SetGameUIFocusBrushEnable::bEnable' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetGameViewportForceCursorType
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetGameViewportForceCursorType final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseCursor                                  InForceCursorType;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SetGameViewportForceCursorType) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetGameViewportForceCursorType");
static_assert(sizeof(X6BlueprintLibrary_SetGameViewportForceCursorType) == 0x000010, "Wrong size on X6BlueprintLibrary_SetGameViewportForceCursorType");
static_assert(offsetof(X6BlueprintLibrary_SetGameViewportForceCursorType, InWorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_SetGameViewportForceCursorType::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetGameViewportForceCursorType, InForceCursorType) == 0x000008, "Member 'X6BlueprintLibrary_SetGameViewportForceCursorType::InForceCursorType' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetLoadingScreenScale
// 0x0004 (0x0004 - 0x0000)
struct X6BlueprintLibrary_SetLoadingScreenScale final
{
public:
	float                                         DPIScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetLoadingScreenScale) == 0x000004, "Wrong alignment on X6BlueprintLibrary_SetLoadingScreenScale");
static_assert(sizeof(X6BlueprintLibrary_SetLoadingScreenScale) == 0x000004, "Wrong size on X6BlueprintLibrary_SetLoadingScreenScale");
static_assert(offsetof(X6BlueprintLibrary_SetLoadingScreenScale, DPIScale) == 0x000000, "Member 'X6BlueprintLibrary_SetLoadingScreenScale::DPIScale' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetLoadingScreenWidget
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetLoadingScreenWidget final
{
public:
	class UUserWidget*                            InUserWidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLoadingScreenDisplayTime;                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForManualStop;                                // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEngineTick;                                  // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SetLoadingScreenWidget) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetLoadingScreenWidget");
static_assert(sizeof(X6BlueprintLibrary_SetLoadingScreenWidget) == 0x000010, "Wrong size on X6BlueprintLibrary_SetLoadingScreenWidget");
static_assert(offsetof(X6BlueprintLibrary_SetLoadingScreenWidget, InUserWidget) == 0x000000, "Member 'X6BlueprintLibrary_SetLoadingScreenWidget::InUserWidget' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetLoadingScreenWidget, MinimumLoadingScreenDisplayTime) == 0x000008, "Member 'X6BlueprintLibrary_SetLoadingScreenWidget::MinimumLoadingScreenDisplayTime' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetLoadingScreenWidget, bWaitForManualStop) == 0x00000C, "Member 'X6BlueprintLibrary_SetLoadingScreenWidget::bWaitForManualStop' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetLoadingScreenWidget, bAllowEngineTick) == 0x00000D, "Member 'X6BlueprintLibrary_SetLoadingScreenWidget::bAllowEngineTick' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetMouthShapeLanguage
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetMouthShapeLanguage final
{
public:
	class FString                                 InCulture;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetMouthShapeLanguage) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetMouthShapeLanguage");
static_assert(sizeof(X6BlueprintLibrary_SetMouthShapeLanguage) == 0x000010, "Wrong size on X6BlueprintLibrary_SetMouthShapeLanguage");
static_assert(offsetof(X6BlueprintLibrary_SetMouthShapeLanguage, InCulture) == 0x000000, "Member 'X6BlueprintLibrary_SetMouthShapeLanguage::InCulture' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetPlayerActorLookAtLookAtSelectHighestScore
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore final
{
public:
	class AActor*                                 InPlayerActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore");
static_assert(sizeof(X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore) == 0x000008, "Wrong size on X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore");
static_assert(offsetof(X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore, InPlayerActor) == 0x000000, "Member 'X6BlueprintLibrary_SetPlayerActorLookAtLookAtSelectHighestScore::InPlayerActor' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetPlayerActorLookAtSelectLatestWithEventType
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType final
{
public:
	class AActor*                                 InPlayerActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtEventType                              InEventType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType");
static_assert(sizeof(X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType) == 0x000010, "Wrong size on X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType");
static_assert(offsetof(X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType, InPlayerActor) == 0x000000, "Member 'X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType, InEventType) == 0x000008, "Member 'X6BlueprintLibrary_SetPlayerActorLookAtSelectLatestWithEventType::InEventType' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetSafePaddingSymmetric
// 0x0002 (0x0002 - 0x0000)
struct X6BlueprintLibrary_SetSafePaddingSymmetric final
{
public:
	bool                                          bLeftRightSymmetric;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTopBottomSymmetric;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetSafePaddingSymmetric) == 0x000001, "Wrong alignment on X6BlueprintLibrary_SetSafePaddingSymmetric");
static_assert(sizeof(X6BlueprintLibrary_SetSafePaddingSymmetric) == 0x000002, "Wrong size on X6BlueprintLibrary_SetSafePaddingSymmetric");
static_assert(offsetof(X6BlueprintLibrary_SetSafePaddingSymmetric, bLeftRightSymmetric) == 0x000000, "Member 'X6BlueprintLibrary_SetSafePaddingSymmetric::bLeftRightSymmetric' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetSafePaddingSymmetric, bTopBottomSymmetric) == 0x000001, "Member 'X6BlueprintLibrary_SetSafePaddingSymmetric::bTopBottomSymmetric' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetSafeZonePaddingMaxValue
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetSafeZonePaddingMaxValue final
{
public:
	float                                         maxValX;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxValY;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxValZ;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxValW;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetSafeZonePaddingMaxValue) == 0x000004, "Wrong alignment on X6BlueprintLibrary_SetSafeZonePaddingMaxValue");
static_assert(sizeof(X6BlueprintLibrary_SetSafeZonePaddingMaxValue) == 0x000010, "Wrong size on X6BlueprintLibrary_SetSafeZonePaddingMaxValue");
static_assert(offsetof(X6BlueprintLibrary_SetSafeZonePaddingMaxValue, maxValX) == 0x000000, "Member 'X6BlueprintLibrary_SetSafeZonePaddingMaxValue::maxValX' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetSafeZonePaddingMaxValue, maxValY) == 0x000004, "Member 'X6BlueprintLibrary_SetSafeZonePaddingMaxValue::maxValY' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetSafeZonePaddingMaxValue, maxValZ) == 0x000008, "Member 'X6BlueprintLibrary_SetSafeZonePaddingMaxValue::maxValZ' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetSafeZonePaddingMaxValue, maxValW) == 0x00000C, "Member 'X6BlueprintLibrary_SetSafeZonePaddingMaxValue::maxValW' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetSingleAnimPosition
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetSingleAnimPosition final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SetSingleAnimPosition) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetSingleAnimPosition");
static_assert(sizeof(X6BlueprintLibrary_SetSingleAnimPosition) == 0x000010, "Wrong size on X6BlueprintLibrary_SetSingleAnimPosition");
static_assert(offsetof(X6BlueprintLibrary_SetSingleAnimPosition, MeshComp) == 0x000000, "Member 'X6BlueprintLibrary_SetSingleAnimPosition::MeshComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetSingleAnimPosition, Time) == 0x000008, "Member 'X6BlueprintLibrary_SetSingleAnimPosition::Time' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetSkipUpdateAnimation
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SetSkipUpdateAnimation final
{
public:
	class UAnimInstance*                          LinkedAnimInstace;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkipAnimationUpdate;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SetSkipUpdateAnimation) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetSkipUpdateAnimation");
static_assert(sizeof(X6BlueprintLibrary_SetSkipUpdateAnimation) == 0x000010, "Wrong size on X6BlueprintLibrary_SetSkipUpdateAnimation");
static_assert(offsetof(X6BlueprintLibrary_SetSkipUpdateAnimation, LinkedAnimInstace) == 0x000000, "Member 'X6BlueprintLibrary_SetSkipUpdateAnimation::LinkedAnimInstace' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetSkipUpdateAnimation, IsSkipAnimationUpdate) == 0x000008, "Member 'X6BlueprintLibrary_SetSkipUpdateAnimation::IsSkipAnimationUpdate' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetTransformUpdatedEvent
// 0x0020 (0x0020 - 0x0000)
struct X6BlueprintLibrary_SetTransformUpdatedEvent final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class USceneComponent* UpdatedComponent, int32 UpdateTransformFlags, ETeleportType Teleport)> Callback; // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetTransformUpdatedEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SetTransformUpdatedEvent");
static_assert(sizeof(X6BlueprintLibrary_SetTransformUpdatedEvent) == 0x000020, "Wrong size on X6BlueprintLibrary_SetTransformUpdatedEvent");
static_assert(offsetof(X6BlueprintLibrary_SetTransformUpdatedEvent, Target) == 0x000000, "Member 'X6BlueprintLibrary_SetTransformUpdatedEvent::Target' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetTransformUpdatedEvent, Callback) == 0x000008, "Member 'X6BlueprintLibrary_SetTransformUpdatedEvent::Callback' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SetTransformUpdatedEvent, ReturnValue) == 0x000018, "Member 'X6BlueprintLibrary_SetTransformUpdatedEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SetWidgetNavigationEnable
// 0x0001 (0x0001 - 0x0000)
struct X6BlueprintLibrary_SetWidgetNavigationEnable final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_SetWidgetNavigationEnable) == 0x000001, "Wrong alignment on X6BlueprintLibrary_SetWidgetNavigationEnable");
static_assert(sizeof(X6BlueprintLibrary_SetWidgetNavigationEnable) == 0x000001, "Wrong size on X6BlueprintLibrary_SetWidgetNavigationEnable");
static_assert(offsetof(X6BlueprintLibrary_SetWidgetNavigationEnable, bEnabled) == 0x000000, "Member 'X6BlueprintLibrary_SetWidgetNavigationEnable::bEnabled' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.SwitchTranslucentOrMaskedMaterails
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTranslucent;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails) == 0x000008, "Wrong alignment on X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails");
static_assert(sizeof(X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails) == 0x000010, "Wrong size on X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails");
static_assert(offsetof(X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails, InActor) == 0x000000, "Member 'X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails::InActor' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails, bInTranslucent) == 0x000008, "Member 'X6BlueprintLibrary_SwitchTranslucentOrMaskedMaterails::bInTranslucent' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.TestPathSync
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_TestPathSync final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PathfindingContext;                                // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_TestPathSync) == 0x000008, "Wrong alignment on X6BlueprintLibrary_TestPathSync");
static_assert(sizeof(X6BlueprintLibrary_TestPathSync) == 0x000050, "Wrong size on X6BlueprintLibrary_TestPathSync");
static_assert(offsetof(X6BlueprintLibrary_TestPathSync, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_TestPathSync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_TestPathSync, PathStart) == 0x000008, "Member 'X6BlueprintLibrary_TestPathSync::PathStart' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_TestPathSync, PathEnd) == 0x000020, "Member 'X6BlueprintLibrary_TestPathSync::PathEnd' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_TestPathSync, PathfindingContext) == 0x000038, "Member 'X6BlueprintLibrary_TestPathSync::PathfindingContext' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_TestPathSync, FilterClass) == 0x000040, "Member 'X6BlueprintLibrary_TestPathSync::FilterClass' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_TestPathSync, ReturnValue) == 0x000048, "Member 'X6BlueprintLibrary_TestPathSync::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UnloadGameFeaturePlugin
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_UnloadGameFeaturePlugin final
{
public:
	class FString                                 InGameFeaturePluginName;                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_UnloadGameFeaturePlugin) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UnloadGameFeaturePlugin");
static_assert(sizeof(X6BlueprintLibrary_UnloadGameFeaturePlugin) == 0x000010, "Wrong size on X6BlueprintLibrary_UnloadGameFeaturePlugin");
static_assert(offsetof(X6BlueprintLibrary_UnloadGameFeaturePlugin, InGameFeaturePluginName) == 0x000000, "Member 'X6BlueprintLibrary_UnloadGameFeaturePlugin::InGameFeaturePluginName' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UnregisterClickNotification
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_UnregisterClickNotification final
{
public:
	class UClickNotification*                     ClickNotification;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_UnregisterClickNotification) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UnregisterClickNotification");
static_assert(sizeof(X6BlueprintLibrary_UnregisterClickNotification) == 0x000008, "Wrong size on X6BlueprintLibrary_UnregisterClickNotification");
static_assert(offsetof(X6BlueprintLibrary_UnregisterClickNotification, ClickNotification) == 0x000000, "Member 'X6BlueprintLibrary_UnregisterClickNotification::ClickNotification' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UnregisterGameViewportActivationChangedEvent
// 0x0018 (0x0018 - 0x0000)
struct X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Handle;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent");
static_assert(sizeof(X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent) == 0x000018, "Wrong size on X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent");
static_assert(offsetof(X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent, Handle) == 0x000008, "Member 'X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent::Handle' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_UnregisterGameViewportActivationChangedEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UnregisterViewportFocusChangingEvent
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_UnregisterViewportFocusChangingEvent final
{
public:
	int64                                         Handle;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_UnregisterViewportFocusChangingEvent) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UnregisterViewportFocusChangingEvent");
static_assert(sizeof(X6BlueprintLibrary_UnregisterViewportFocusChangingEvent) == 0x000010, "Wrong size on X6BlueprintLibrary_UnregisterViewportFocusChangingEvent");
static_assert(offsetof(X6BlueprintLibrary_UnregisterViewportFocusChangingEvent, Handle) == 0x000000, "Member 'X6BlueprintLibrary_UnregisterViewportFocusChangingEvent::Handle' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_UnregisterViewportFocusChangingEvent, ReturnValue) == 0x000008, "Member 'X6BlueprintLibrary_UnregisterViewportFocusChangingEvent::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UpdateHiddenParts
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_UpdateHiddenParts final
{
public:
	class USkeletalMeshComponent*                 InMainSkMeshComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeMainSM;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_UpdateHiddenParts) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UpdateHiddenParts");
static_assert(sizeof(X6BlueprintLibrary_UpdateHiddenParts) == 0x000010, "Wrong size on X6BlueprintLibrary_UpdateHiddenParts");
static_assert(offsetof(X6BlueprintLibrary_UpdateHiddenParts, InMainSkMeshComp) == 0x000000, "Member 'X6BlueprintLibrary_UpdateHiddenParts::InMainSkMeshComp' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_UpdateHiddenParts, bIncludeMainSM) == 0x000008, "Member 'X6BlueprintLibrary_UpdateHiddenParts::bIncludeMainSM' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UpdateTextureRenderTargetResource
// 0x0010 (0x0010 - 0x0000)
struct X6BlueprintLibrary_UpdateTextureRenderTargetResource final
{
public:
	class UTextureRenderTarget2D*                 rt;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearRenderTarget;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_UpdateTextureRenderTargetResource) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UpdateTextureRenderTargetResource");
static_assert(sizeof(X6BlueprintLibrary_UpdateTextureRenderTargetResource) == 0x000010, "Wrong size on X6BlueprintLibrary_UpdateTextureRenderTargetResource");
static_assert(offsetof(X6BlueprintLibrary_UpdateTextureRenderTargetResource, rt) == 0x000000, "Member 'X6BlueprintLibrary_UpdateTextureRenderTargetResource::rt' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_UpdateTextureRenderTargetResource, bClearRenderTarget) == 0x000008, "Member 'X6BlueprintLibrary_UpdateTextureRenderTargetResource::bClearRenderTarget' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.UpdateTextureResource
// 0x0008 (0x0008 - 0x0000)
struct X6BlueprintLibrary_UpdateTextureResource final
{
public:
	class UTextureRenderTarget2D*                 rt;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_UpdateTextureResource) == 0x000008, "Wrong alignment on X6BlueprintLibrary_UpdateTextureResource");
static_assert(sizeof(X6BlueprintLibrary_UpdateTextureResource) == 0x000008, "Wrong size on X6BlueprintLibrary_UpdateTextureResource");
static_assert(offsetof(X6BlueprintLibrary_UpdateTextureResource, rt) == 0x000000, "Member 'X6BlueprintLibrary_UpdateTextureResource::rt' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6AsyncLoadAssetClassViaSoftObjectPath
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AssetClassPath;                                    // 0x0008(0x0020)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(TSubclassOf<class UObject> Loaded)> OnLoaded;                                     // 0x0028(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0038(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath");
static_assert(sizeof(X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath) == 0x000050, "Wrong size on X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath, AssetClassPath) == 0x000008, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath::AssetClassPath' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath, OnLoaded) == 0x000028, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath::OnLoaded' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath, LatentInfo) == 0x000038, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetClassViaSoftObjectPath::LatentInfo' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6AsyncLoadAssetViaSoftObjectRef
// 0x0058 (0x0058 - 0x0000)
struct X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Asset;                                             // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* Loaded)>        OnLoaded;                                          // 0x0030(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0040(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef");
static_assert(sizeof(X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef) == 0x000058, "Wrong size on X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef, Asset) == 0x000008, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef::Asset' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef, OnLoaded) == 0x000030, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef::OnLoaded' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef, LatentInfo) == 0x000040, "Member 'X6BlueprintLibrary_X6AsyncLoadAssetViaSoftObjectRef::LatentInfo' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6ConvertToTraceType
// 0x0002 (0x0002 - 0x0000)
struct X6BlueprintLibrary_X6ConvertToTraceType final
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6ConvertToTraceType) == 0x000001, "Wrong alignment on X6BlueprintLibrary_X6ConvertToTraceType");
static_assert(sizeof(X6BlueprintLibrary_X6ConvertToTraceType) == 0x000002, "Wrong size on X6BlueprintLibrary_X6ConvertToTraceType");
static_assert(offsetof(X6BlueprintLibrary_X6ConvertToTraceType, CollisionChannel) == 0x000000, "Member 'X6BlueprintLibrary_X6ConvertToTraceType::CollisionChannel' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6ConvertToTraceType, ReturnValue) == 0x000001, "Member 'X6BlueprintLibrary_X6ConvertToTraceType::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6GetArrayFromConfig
// 0x0048 (0x0048 - 0x0000)
struct X6BlueprintLibrary_X6GetArrayFromConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Result;                                            // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bNeedReload;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6GetArrayFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6GetArrayFromConfig");
static_assert(sizeof(X6BlueprintLibrary_X6GetArrayFromConfig) == 0x000048, "Wrong size on X6BlueprintLibrary_X6GetArrayFromConfig");
static_assert(offsetof(X6BlueprintLibrary_X6GetArrayFromConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6GetArrayFromConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetArrayFromConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6GetArrayFromConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetArrayFromConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6GetArrayFromConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetArrayFromConfig, Result) == 0x000030, "Member 'X6BlueprintLibrary_X6GetArrayFromConfig::Result' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetArrayFromConfig, bNeedReload) == 0x000040, "Member 'X6BlueprintLibrary_X6GetArrayFromConfig::bNeedReload' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetArrayFromConfig, ReturnValue) == 0x000044, "Member 'X6BlueprintLibrary_X6GetArrayFromConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6GetBoolFromConfig
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_X6GetBoolFromConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedReload;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0031(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_X6GetBoolFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6GetBoolFromConfig");
static_assert(sizeof(X6BlueprintLibrary_X6GetBoolFromConfig) == 0x000038, "Wrong size on X6BlueprintLibrary_X6GetBoolFromConfig");
static_assert(offsetof(X6BlueprintLibrary_X6GetBoolFromConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6GetBoolFromConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetBoolFromConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6GetBoolFromConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetBoolFromConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6GetBoolFromConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetBoolFromConfig, bNeedReload) == 0x000030, "Member 'X6BlueprintLibrary_X6GetBoolFromConfig::bNeedReload' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetBoolFromConfig, ReturnValue) == 0x000031, "Member 'X6BlueprintLibrary_X6GetBoolFromConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6GetIntFromConfig
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_X6GetIntFromConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedReload;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6GetIntFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6GetIntFromConfig");
static_assert(sizeof(X6BlueprintLibrary_X6GetIntFromConfig) == 0x000038, "Wrong size on X6BlueprintLibrary_X6GetIntFromConfig");
static_assert(offsetof(X6BlueprintLibrary_X6GetIntFromConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6GetIntFromConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetIntFromConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6GetIntFromConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetIntFromConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6GetIntFromConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetIntFromConfig, bNeedReload) == 0x000030, "Member 'X6BlueprintLibrary_X6GetIntFromConfig::bNeedReload' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetIntFromConfig, ReturnValue) == 0x000034, "Member 'X6BlueprintLibrary_X6GetIntFromConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6GetRotatorFromConfig
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_X6GetRotatorFromConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedReload;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6GetRotatorFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6GetRotatorFromConfig");
static_assert(sizeof(X6BlueprintLibrary_X6GetRotatorFromConfig) == 0x000050, "Wrong size on X6BlueprintLibrary_X6GetRotatorFromConfig");
static_assert(offsetof(X6BlueprintLibrary_X6GetRotatorFromConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6GetRotatorFromConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetRotatorFromConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6GetRotatorFromConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetRotatorFromConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6GetRotatorFromConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetRotatorFromConfig, bNeedReload) == 0x000030, "Member 'X6BlueprintLibrary_X6GetRotatorFromConfig::bNeedReload' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetRotatorFromConfig, ReturnValue) == 0x000038, "Member 'X6BlueprintLibrary_X6GetRotatorFromConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6GetStringFromConfig
// 0x0048 (0x0048 - 0x0000)
struct X6BlueprintLibrary_X6GetStringFromConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedReload;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6GetStringFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6GetStringFromConfig");
static_assert(sizeof(X6BlueprintLibrary_X6GetStringFromConfig) == 0x000048, "Wrong size on X6BlueprintLibrary_X6GetStringFromConfig");
static_assert(offsetof(X6BlueprintLibrary_X6GetStringFromConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6GetStringFromConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetStringFromConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6GetStringFromConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetStringFromConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6GetStringFromConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetStringFromConfig, bNeedReload) == 0x000030, "Member 'X6BlueprintLibrary_X6GetStringFromConfig::bNeedReload' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetStringFromConfig, ReturnValue) == 0x000038, "Member 'X6BlueprintLibrary_X6GetStringFromConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6GetVectorFromConfig
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_X6GetVectorFromConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedReload;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6GetVectorFromConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6GetVectorFromConfig");
static_assert(sizeof(X6BlueprintLibrary_X6GetVectorFromConfig) == 0x000050, "Wrong size on X6BlueprintLibrary_X6GetVectorFromConfig");
static_assert(offsetof(X6BlueprintLibrary_X6GetVectorFromConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6GetVectorFromConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetVectorFromConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6GetVectorFromConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetVectorFromConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6GetVectorFromConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetVectorFromConfig, bNeedReload) == 0x000030, "Member 'X6BlueprintLibrary_X6GetVectorFromConfig::bNeedReload' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6GetVectorFromConfig, ReturnValue) == 0x000038, "Member 'X6BlueprintLibrary_X6GetVectorFromConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6MakeBrushFromTexture
// 0x00E0 (0x00E0 - 0x0000)
struct X6BlueprintLibrary_X6MakeBrushFromTexture final
{
public:
	class UObject*                                AssetObject;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ReturnValue;                                       // 0x0010(0x00D0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6MakeBrushFromTexture) == 0x000010, "Wrong alignment on X6BlueprintLibrary_X6MakeBrushFromTexture");
static_assert(sizeof(X6BlueprintLibrary_X6MakeBrushFromTexture) == 0x0000E0, "Wrong size on X6BlueprintLibrary_X6MakeBrushFromTexture");
static_assert(offsetof(X6BlueprintLibrary_X6MakeBrushFromTexture, AssetObject) == 0x000000, "Member 'X6BlueprintLibrary_X6MakeBrushFromTexture::AssetObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6MakeBrushFromTexture, Width) == 0x000008, "Member 'X6BlueprintLibrary_X6MakeBrushFromTexture::Width' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6MakeBrushFromTexture, Height) == 0x00000C, "Member 'X6BlueprintLibrary_X6MakeBrushFromTexture::Height' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6MakeBrushFromTexture, ReturnValue) == 0x000010, "Member 'X6BlueprintLibrary_X6MakeBrushFromTexture::ReturnValue' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6SetBoolToConfig
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_X6SetBoolToConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_X6SetBoolToConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6SetBoolToConfig");
static_assert(sizeof(X6BlueprintLibrary_X6SetBoolToConfig) == 0x000038, "Wrong size on X6BlueprintLibrary_X6SetBoolToConfig");
static_assert(offsetof(X6BlueprintLibrary_X6SetBoolToConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6SetBoolToConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetBoolToConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6SetBoolToConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetBoolToConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6SetBoolToConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetBoolToConfig, Value) == 0x000030, "Member 'X6BlueprintLibrary_X6SetBoolToConfig::Value' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6SetIntToConfig
// 0x0038 (0x0038 - 0x0000)
struct X6BlueprintLibrary_X6SetIntToConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BlueprintLibrary_X6SetIntToConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6SetIntToConfig");
static_assert(sizeof(X6BlueprintLibrary_X6SetIntToConfig) == 0x000038, "Wrong size on X6BlueprintLibrary_X6SetIntToConfig");
static_assert(offsetof(X6BlueprintLibrary_X6SetIntToConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6SetIntToConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetIntToConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6SetIntToConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetIntToConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6SetIntToConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetIntToConfig, Value) == 0x000030, "Member 'X6BlueprintLibrary_X6SetIntToConfig::Value' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6SetStringToConfig
// 0x0040 (0x0040 - 0x0000)
struct X6BlueprintLibrary_X6SetStringToConfig final
{
public:
	class FString                                 Session;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6SetStringToConfig) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6SetStringToConfig");
static_assert(sizeof(X6BlueprintLibrary_X6SetStringToConfig) == 0x000040, "Wrong size on X6BlueprintLibrary_X6SetStringToConfig");
static_assert(offsetof(X6BlueprintLibrary_X6SetStringToConfig, Session) == 0x000000, "Member 'X6BlueprintLibrary_X6SetStringToConfig::Session' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetStringToConfig, Key) == 0x000010, "Member 'X6BlueprintLibrary_X6SetStringToConfig::Key' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetStringToConfig, Path) == 0x000020, "Member 'X6BlueprintLibrary_X6SetStringToConfig::Path' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SetStringToConfig, Value) == 0x000030, "Member 'X6BlueprintLibrary_X6SetStringToConfig::Value' has a wrong offset!");

// Function X6Game.X6BlueprintLibrary.X6SpawnActor
// 0x0050 (0x0050 - 0x0000)
struct X6BlueprintLibrary_X6SpawnActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnPosition;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAddToSoloLevel;                                   // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BlueprintLibrary_X6SpawnActor) == 0x000008, "Wrong alignment on X6BlueprintLibrary_X6SpawnActor");
static_assert(sizeof(X6BlueprintLibrary_X6SpawnActor) == 0x000050, "Wrong size on X6BlueprintLibrary_X6SpawnActor");
static_assert(offsetof(X6BlueprintLibrary_X6SpawnActor, WorldContextObject) == 0x000000, "Member 'X6BlueprintLibrary_X6SpawnActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SpawnActor, SpawnClass) == 0x000008, "Member 'X6BlueprintLibrary_X6SpawnActor::SpawnClass' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SpawnActor, SpawnPosition) == 0x000010, "Member 'X6BlueprintLibrary_X6SpawnActor::SpawnPosition' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SpawnActor, SpawnRotation) == 0x000028, "Member 'X6BlueprintLibrary_X6SpawnActor::SpawnRotation' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SpawnActor, bAddToSoloLevel) == 0x000040, "Member 'X6BlueprintLibrary_X6SpawnActor::bAddToSoloLevel' has a wrong offset!");
static_assert(offsetof(X6BlueprintLibrary_X6SpawnActor, ReturnValue) == 0x000048, "Member 'X6BlueprintLibrary_X6SpawnActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatCameraSynchronizerBase.EnableCombatSynchronize
// 0x0001 (0x0001 - 0x0000)
struct X6CombatCameraSynchronizerBase_EnableCombatSynchronize final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatCameraSynchronizerBase_EnableCombatSynchronize) == 0x000001, "Wrong alignment on X6CombatCameraSynchronizerBase_EnableCombatSynchronize");
static_assert(sizeof(X6CombatCameraSynchronizerBase_EnableCombatSynchronize) == 0x000001, "Wrong size on X6CombatCameraSynchronizerBase_EnableCombatSynchronize");
static_assert(offsetof(X6CombatCameraSynchronizerBase_EnableCombatSynchronize, bEnable) == 0x000000, "Member 'X6CombatCameraSynchronizerBase_EnableCombatSynchronize::bEnable' has a wrong offset!");

// Function X6Game.X6CombatCameraSynchronizerBase.SetCombatSyncSettingValue
// 0x0001 (0x0001 - 0x0000)
struct X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue) == 0x000001, "Wrong alignment on X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue");
static_assert(sizeof(X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue) == 0x000001, "Wrong size on X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue");
static_assert(offsetof(X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue, Value) == 0x000000, "Member 'X6CombatCameraSynchronizerBase_SetCombatSyncSettingValue::Value' has a wrong offset!");

// Function X6Game.X6PlayerControllerBase.SetTouchInputEnable
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerControllerBase_SetTouchInputEnable final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerControllerBase_SetTouchInputEnable) == 0x000001, "Wrong alignment on X6PlayerControllerBase_SetTouchInputEnable");
static_assert(sizeof(X6PlayerControllerBase_SetTouchInputEnable) == 0x000001, "Wrong size on X6PlayerControllerBase_SetTouchInputEnable");
static_assert(offsetof(X6PlayerControllerBase_SetTouchInputEnable, Enable) == 0x000000, "Member 'X6PlayerControllerBase_SetTouchInputEnable::Enable' has a wrong offset!");

// Function X6Game.X6NikkiPlayerController.SetControlPawn
// 0x0008 (0x0008 - 0x0000)
struct X6NikkiPlayerController_SetControlPawn final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiPlayerController_SetControlPawn) == 0x000008, "Wrong alignment on X6NikkiPlayerController_SetControlPawn");
static_assert(sizeof(X6NikkiPlayerController_SetControlPawn) == 0x000008, "Wrong size on X6NikkiPlayerController_SetControlPawn");
static_assert(offsetof(X6NikkiPlayerController_SetControlPawn, InPawn) == 0x000000, "Member 'X6NikkiPlayerController_SetControlPawn::InPawn' has a wrong offset!");

// Function X6Game.X6BossCameraSynchronizer.BlueprintGetYawSyncTargetRotation
// 0x0018 (0x0018 - 0x0000)
struct X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation) == 0x000008, "Wrong alignment on X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation");
static_assert(sizeof(X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation) == 0x000018, "Wrong size on X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation");
static_assert(offsetof(X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation, ReturnValue) == 0x000000, "Member 'X6BossCameraSynchronizer_BlueprintGetYawSyncTargetRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BossCameraSynchronizer.SetRotateTargetBoss
// 0x0008 (0x0008 - 0x0000)
struct X6BossCameraSynchronizer_SetRotateTargetBoss final
{
public:
	class AActor*                                 BossCharacter;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BossCameraSynchronizer_SetRotateTargetBoss) == 0x000008, "Wrong alignment on X6BossCameraSynchronizer_SetRotateTargetBoss");
static_assert(sizeof(X6BossCameraSynchronizer_SetRotateTargetBoss) == 0x000008, "Wrong size on X6BossCameraSynchronizer_SetRotateTargetBoss");
static_assert(offsetof(X6BossCameraSynchronizer_SetRotateTargetBoss, BossCharacter) == 0x000000, "Member 'X6BossCameraSynchronizer_SetRotateTargetBoss::BossCharacter' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserBoolParam
// 0x0018 (0x0018 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutValue;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam) == 0x000018, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam, ReturnValue) == 0x000011, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserBoolParam::ReturnValue' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserFloatParam
// 0x0018 (0x0018 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutValue;                                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam) == 0x000018, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam, ReturnValue) == 0x000014, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserFloatParam::ReturnValue' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserInt32Param
// 0x0018 (0x0018 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutValue;                                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param) == 0x000018, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param, ReturnValue) == 0x000014, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserInt32Param::ReturnValue' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserLinearColorParam
// 0x0028 (0x0028 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutValue;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam) == 0x000028, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam, ReturnValue) == 0x000020, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserLinearColorParam::ReturnValue' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserObjectParam
// 0x0020 (0x0020 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OutValue;                                          // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam) == 0x000020, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam, ReturnValue) == 0x000018, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserObjectParam::ReturnValue' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserVector2Param
// 0x0028 (0x0028 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutValue;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param) == 0x000028, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param, ReturnValue) == 0x000020, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector2Param::ReturnValue' has a wrong offset!");

// Function X6Game.X6NigaraBlueprintLibrary.GetNiagaraUserVector3Param
// 0x0030 (0x0030 - 0x0000)
struct X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param final
{
public:
	class UNiagaraSystem*                         InNiagaraSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InUserParamName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutValue;                                          // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param) == 0x000008, "Wrong alignment on X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param");
static_assert(sizeof(X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param) == 0x000030, "Wrong size on X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param, InNiagaraSystem) == 0x000000, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param::InNiagaraSystem' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param, InUserParamName) == 0x000008, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param::InUserParamName' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param, OutValue) == 0x000010, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param::OutValue' has a wrong offset!");
static_assert(offsetof(X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param, ReturnValue) == 0x000028, "Member 'X6NigaraBlueprintLibrary_GetNiagaraUserVector3Param::ReturnValue' has a wrong offset!");

// Function X6Game.X6BTTask_BlueprintBase.OnBlackboardKeyValueChange
// 0x0010 (0x0010 - 0x0000)
struct X6BTTask_BlueprintBase_OnBlackboardKeyValueChange final
{
public:
	const class UBlackboardComponent*             Blackboard;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KeyName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BTTask_BlueprintBase_OnBlackboardKeyValueChange) == 0x000008, "Wrong alignment on X6BTTask_BlueprintBase_OnBlackboardKeyValueChange");
static_assert(sizeof(X6BTTask_BlueprintBase_OnBlackboardKeyValueChange) == 0x000010, "Wrong size on X6BTTask_BlueprintBase_OnBlackboardKeyValueChange");
static_assert(offsetof(X6BTTask_BlueprintBase_OnBlackboardKeyValueChange, Blackboard) == 0x000000, "Member 'X6BTTask_BlueprintBase_OnBlackboardKeyValueChange::Blackboard' has a wrong offset!");
static_assert(offsetof(X6BTTask_BlueprintBase_OnBlackboardKeyValueChange, KeyName) == 0x000008, "Member 'X6BTTask_BlueprintBase_OnBlackboardKeyValueChange::KeyName' has a wrong offset!");

// Function X6Game.X6BTTask_BlueprintBase.K2_GetCustomDescription
// 0x0020 (0x0020 - 0x0000)
struct X6BTTask_BlueprintBase_K2_GetCustomDescription final
{
public:
	class FString                                 InDescripttion;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BTTask_BlueprintBase_K2_GetCustomDescription) == 0x000008, "Wrong alignment on X6BTTask_BlueprintBase_K2_GetCustomDescription");
static_assert(sizeof(X6BTTask_BlueprintBase_K2_GetCustomDescription) == 0x000020, "Wrong size on X6BTTask_BlueprintBase_K2_GetCustomDescription");
static_assert(offsetof(X6BTTask_BlueprintBase_K2_GetCustomDescription, InDescripttion) == 0x000000, "Member 'X6BTTask_BlueprintBase_K2_GetCustomDescription::InDescripttion' has a wrong offset!");
static_assert(offsetof(X6BTTask_BlueprintBase_K2_GetCustomDescription, ReturnValue) == 0x000010, "Member 'X6BTTask_BlueprintBase_K2_GetCustomDescription::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.ApplyCameraModifierEffectByKey
// 0x0020 (0x0020 - 0x0000)
struct X6PlayerCameraManager_ApplyCameraModifierEffectByKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraModifierSpecHandle              ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerCameraManager_ApplyCameraModifierEffectByKey) == 0x000008, "Wrong alignment on X6PlayerCameraManager_ApplyCameraModifierEffectByKey");
static_assert(sizeof(X6PlayerCameraManager_ApplyCameraModifierEffectByKey) == 0x000020, "Wrong size on X6PlayerCameraManager_ApplyCameraModifierEffectByKey");
static_assert(offsetof(X6PlayerCameraManager_ApplyCameraModifierEffectByKey, Key) == 0x000000, "Member 'X6PlayerCameraManager_ApplyCameraModifierEffectByKey::Key' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_ApplyCameraModifierEffectByKey, ReturnValue) == 0x000010, "Member 'X6PlayerCameraManager_ApplyCameraModifierEffectByKey::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.ApplyRadiusBlurToPostProcessSettings
// 0x0870 (0x0870 - 0x0000)
struct X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings final
{
public:
	float                                         InOffset;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRadius;                                          // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHardness;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSwitchDir;                                       // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   InOutPostProcessSettings;                          // 0x0010(0x0850)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         InBlendWeight;                                     // 0x0860(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_864[0xC];                                      // 0x0864(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings) == 0x000010, "Wrong alignment on X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings");
static_assert(sizeof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings) == 0x000870, "Wrong size on X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings");
static_assert(offsetof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings, InOffset) == 0x000000, "Member 'X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings::InOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings, InRadius) == 0x000004, "Member 'X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings::InRadius' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings, InHardness) == 0x000008, "Member 'X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings::InHardness' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings, InSwitchDir) == 0x00000C, "Member 'X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings::InSwitchDir' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings, InOutPostProcessSettings) == 0x000010, "Member 'X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings::InOutPostProcessSettings' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings, InBlendWeight) == 0x000860, "Member 'X6PlayerCameraManager_ApplyRadiusBlurToPostProcessSettings::InBlendWeight' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.BlendToViewTargetWithParam
// 0x0048 (0x0048 - 0x0000)
struct X6PlayerCameraManager_BlendToViewTargetWithParam final
{
public:
	ECameraState                                  CurrentCameraState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentTarget;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  NewCameraState;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0020(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerCameraManager_BlendToViewTargetWithParam) == 0x000008, "Wrong alignment on X6PlayerCameraManager_BlendToViewTargetWithParam");
static_assert(sizeof(X6PlayerCameraManager_BlendToViewTargetWithParam) == 0x000048, "Wrong size on X6PlayerCameraManager_BlendToViewTargetWithParam");
static_assert(offsetof(X6PlayerCameraManager_BlendToViewTargetWithParam, CurrentCameraState) == 0x000000, "Member 'X6PlayerCameraManager_BlendToViewTargetWithParam::CurrentCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_BlendToViewTargetWithParam, CurrentTarget) == 0x000008, "Member 'X6PlayerCameraManager_BlendToViewTargetWithParam::CurrentTarget' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_BlendToViewTargetWithParam, NewCameraState) == 0x000010, "Member 'X6PlayerCameraManager_BlendToViewTargetWithParam::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_BlendToViewTargetWithParam, NewTarget) == 0x000018, "Member 'X6PlayerCameraManager_BlendToViewTargetWithParam::NewTarget' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_BlendToViewTargetWithParam, TransitionParams) == 0x000020, "Member 'X6PlayerCameraManager_BlendToViewTargetWithParam::TransitionParams' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_BlendToViewTargetWithParam, bOverrideTransitionParams) == 0x000040, "Member 'X6PlayerCameraManager_BlendToViewTargetWithParam::bOverrideTransitionParams' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.CheckIsBlendingToOtherTarget
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerCameraManager_CheckIsBlendingToOtherTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_CheckIsBlendingToOtherTarget) == 0x000001, "Wrong alignment on X6PlayerCameraManager_CheckIsBlendingToOtherTarget");
static_assert(sizeof(X6PlayerCameraManager_CheckIsBlendingToOtherTarget) == 0x000001, "Wrong size on X6PlayerCameraManager_CheckIsBlendingToOtherTarget");
static_assert(offsetof(X6PlayerCameraManager_CheckIsBlendingToOtherTarget, ReturnValue) == 0x000000, "Member 'X6PlayerCameraManager_CheckIsBlendingToOtherTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.DEBUG_GetCameraModifierStackInfo
// 0x0010 (0x0010 - 0x0000)
struct X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo final
{
public:
	TArray<struct FDebugCameraModifierStackInfo>  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo) == 0x000008, "Wrong alignment on X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo");
static_assert(sizeof(X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo) == 0x000010, "Wrong size on X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo");
static_assert(offsetof(X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo, ReturnValue) == 0x000000, "Member 'X6PlayerCameraManager_DEBUG_GetCameraModifierStackInfo::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.DEBUG_GetCameraTransformParam
// 0x0040 (0x0040 - 0x0000)
struct X6PlayerCameraManager_DEBUG_GetCameraTransformParam final
{
public:
	struct FDebugCameraReviseParam                ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_DEBUG_GetCameraTransformParam) == 0x000008, "Wrong alignment on X6PlayerCameraManager_DEBUG_GetCameraTransformParam");
static_assert(sizeof(X6PlayerCameraManager_DEBUG_GetCameraTransformParam) == 0x000040, "Wrong size on X6PlayerCameraManager_DEBUG_GetCameraTransformParam");
static_assert(offsetof(X6PlayerCameraManager_DEBUG_GetCameraTransformParam, ReturnValue) == 0x000000, "Member 'X6PlayerCameraManager_DEBUG_GetCameraTransformParam::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.GetOutOfFrustumValue
// 0x0020 (0x0020 - 0x0000)
struct X6PlayerCameraManager_GetOutOfFrustumValue final
{
public:
	struct FVector                                TargetWorldLoc;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRangeMultiper;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_GetOutOfFrustumValue) == 0x000008, "Wrong alignment on X6PlayerCameraManager_GetOutOfFrustumValue");
static_assert(sizeof(X6PlayerCameraManager_GetOutOfFrustumValue) == 0x000020, "Wrong size on X6PlayerCameraManager_GetOutOfFrustumValue");
static_assert(offsetof(X6PlayerCameraManager_GetOutOfFrustumValue, TargetWorldLoc) == 0x000000, "Member 'X6PlayerCameraManager_GetOutOfFrustumValue::TargetWorldLoc' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_GetOutOfFrustumValue, InRangeMultiper) == 0x000018, "Member 'X6PlayerCameraManager_GetOutOfFrustumValue::InRangeMultiper' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_GetOutOfFrustumValue, ReturnValue) == 0x00001C, "Member 'X6PlayerCameraManager_GetOutOfFrustumValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_ApplyCameraModifierEffectByKey
// 0x0018 (0x0018 - 0x0000)
struct X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey");
static_assert(sizeof(X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey) == 0x000018, "Wrong size on X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey");
static_assert(offsetof(X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey, Key) == 0x000000, "Member 'X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey::Key' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey, ReturnValue) == 0x000010, "Member 'X6PlayerCameraManager_K2_ApplyCameraModifierEffectByKey::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_ChangeCameraStateTo
// 0x0010 (0x0010 - 0x0000)
struct X6PlayerCameraManager_K2_ChangeCameraStateTo final
{
public:
	ECameraState                                  NewCameraState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_ChangeCameraStateTo) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_ChangeCameraStateTo");
static_assert(sizeof(X6PlayerCameraManager_K2_ChangeCameraStateTo) == 0x000010, "Wrong size on X6PlayerCameraManager_K2_ChangeCameraStateTo");
static_assert(offsetof(X6PlayerCameraManager_K2_ChangeCameraStateTo, NewCameraState) == 0x000000, "Member 'X6PlayerCameraManager_K2_ChangeCameraStateTo::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_ChangeCameraStateTo, NewTarget) == 0x000008, "Member 'X6PlayerCameraManager_K2_ChangeCameraStateTo::NewTarget' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_OnCameraModifierEffectToSelf
// 0x000C (0x000C - 0x0000)
struct X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf final
{
public:
	struct FCameraModifierSpecHandle              ActiveHandle;                                      // 0x0000(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf) == 0x000004, "Wrong alignment on X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf");
static_assert(sizeof(X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf) == 0x00000C, "Wrong size on X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf");
static_assert(offsetof(X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf, ActiveHandle) == 0x000000, "Member 'X6PlayerCameraManager_K2_OnCameraModifierEffectToSelf::ActiveHandle' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_PopAndSwitchToLastCameraState
// 0x0028 (0x0028 - 0x0000)
struct X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState final
{
public:
	bool                                          bOverrideTransitionParams;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState");
static_assert(sizeof(X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState) == 0x000028, "Wrong size on X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState");
static_assert(offsetof(X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState, bOverrideTransitionParams) == 0x000000, "Member 'X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState, TransitionParams) == 0x000008, "Member 'X6PlayerCameraManager_K2_PopAndSwitchToLastCameraState::TransitionParams' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_PushAndSwitchToCameraState
// 0x0038 (0x0038 - 0x0000)
struct X6PlayerCameraManager_K2_PushAndSwitchToCameraState final
{
public:
	ECameraState                                  NewCameraState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0018(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_PushAndSwitchToCameraState) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_PushAndSwitchToCameraState");
static_assert(sizeof(X6PlayerCameraManager_K2_PushAndSwitchToCameraState) == 0x000038, "Wrong size on X6PlayerCameraManager_K2_PushAndSwitchToCameraState");
static_assert(offsetof(X6PlayerCameraManager_K2_PushAndSwitchToCameraState, NewCameraState) == 0x000000, "Member 'X6PlayerCameraManager_K2_PushAndSwitchToCameraState::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_PushAndSwitchToCameraState, NewTarget) == 0x000008, "Member 'X6PlayerCameraManager_K2_PushAndSwitchToCameraState::NewTarget' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_PushAndSwitchToCameraState, bOverrideTransitionParams) == 0x000010, "Member 'X6PlayerCameraManager_K2_PushAndSwitchToCameraState::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_PushAndSwitchToCameraState, TransitionParams) == 0x000018, "Member 'X6PlayerCameraManager_K2_PushAndSwitchToCameraState::TransitionParams' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_PushCameraState
// 0x0010 (0x0010 - 0x0000)
struct X6PlayerCameraManager_K2_PushCameraState final
{
public:
	ECameraState                                  NewCameraState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_PushCameraState) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_PushCameraState");
static_assert(sizeof(X6PlayerCameraManager_K2_PushCameraState) == 0x000010, "Wrong size on X6PlayerCameraManager_K2_PushCameraState");
static_assert(offsetof(X6PlayerCameraManager_K2_PushCameraState, NewCameraState) == 0x000000, "Member 'X6PlayerCameraManager_K2_PushCameraState::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_PushCameraState, NewTarget) == 0x000008, "Member 'X6PlayerCameraManager_K2_PushCameraState::NewTarget' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_SetViewTarget
// 0x0028 (0x0028 - 0x0000)
struct X6PlayerCameraManager_K2_SetViewTarget final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_SetViewTarget) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_SetViewTarget");
static_assert(sizeof(X6PlayerCameraManager_K2_SetViewTarget) == 0x000028, "Wrong size on X6PlayerCameraManager_K2_SetViewTarget");
static_assert(offsetof(X6PlayerCameraManager_K2_SetViewTarget, NewViewTarget) == 0x000000, "Member 'X6PlayerCameraManager_K2_SetViewTarget::NewViewTarget' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_SetViewTarget, TransitionParams) == 0x000008, "Member 'X6PlayerCameraManager_K2_SetViewTarget::TransitionParams' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.K2_SwitchToCameraState
// 0x0010 (0x0010 - 0x0000)
struct X6PlayerCameraManager_K2_SwitchToCameraState final
{
public:
	ECameraState                                  NewCameraState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_K2_SwitchToCameraState) == 0x000008, "Wrong alignment on X6PlayerCameraManager_K2_SwitchToCameraState");
static_assert(sizeof(X6PlayerCameraManager_K2_SwitchToCameraState) == 0x000010, "Wrong size on X6PlayerCameraManager_K2_SwitchToCameraState");
static_assert(offsetof(X6PlayerCameraManager_K2_SwitchToCameraState, NewCameraState) == 0x000000, "Member 'X6PlayerCameraManager_K2_SwitchToCameraState::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_K2_SwitchToCameraState, NewTarget) == 0x000008, "Member 'X6PlayerCameraManager_K2_SwitchToCameraState::NewTarget' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.OnAssignViewTarget
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerCameraManager_OnAssignViewTarget final
{
public:
	class AActor*                                 NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_OnAssignViewTarget) == 0x000008, "Wrong alignment on X6PlayerCameraManager_OnAssignViewTarget");
static_assert(sizeof(X6PlayerCameraManager_OnAssignViewTarget) == 0x000008, "Wrong size on X6PlayerCameraManager_OnAssignViewTarget");
static_assert(offsetof(X6PlayerCameraManager_OnAssignViewTarget, NewTarget) == 0x000000, "Member 'X6PlayerCameraManager_OnAssignViewTarget::NewTarget' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.OnSetViewTarget
// 0x0028 (0x0028 - 0x0000)
struct X6PlayerCameraManager_OnSetViewTarget final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_OnSetViewTarget) == 0x000008, "Wrong alignment on X6PlayerCameraManager_OnSetViewTarget");
static_assert(sizeof(X6PlayerCameraManager_OnSetViewTarget) == 0x000028, "Wrong size on X6PlayerCameraManager_OnSetViewTarget");
static_assert(offsetof(X6PlayerCameraManager_OnSetViewTarget, NewViewTarget) == 0x000000, "Member 'X6PlayerCameraManager_OnSetViewTarget::NewViewTarget' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_OnSetViewTarget, TransitionParams) == 0x000008, "Member 'X6PlayerCameraManager_OnSetViewTarget::TransitionParams' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.RemoveCameraModifierEffectByHandle
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerCameraManager_RemoveCameraModifierEffectByHandle final
{
public:
	int32                                         HandleID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_RemoveCameraModifierEffectByHandle) == 0x000004, "Wrong alignment on X6PlayerCameraManager_RemoveCameraModifierEffectByHandle");
static_assert(sizeof(X6PlayerCameraManager_RemoveCameraModifierEffectByHandle) == 0x000004, "Wrong size on X6PlayerCameraManager_RemoveCameraModifierEffectByHandle");
static_assert(offsetof(X6PlayerCameraManager_RemoveCameraModifierEffectByHandle, HandleID) == 0x000000, "Member 'X6PlayerCameraManager_RemoveCameraModifierEffectByHandle::HandleID' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.RemoveCameraState
// 0x0038 (0x0038 - 0x0000)
struct X6PlayerCameraManager_RemoveCameraState final
{
public:
	ECameraState                                  CameraStateToRemove;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetToRemove;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlendToTop;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0018(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_RemoveCameraState) == 0x000008, "Wrong alignment on X6PlayerCameraManager_RemoveCameraState");
static_assert(sizeof(X6PlayerCameraManager_RemoveCameraState) == 0x000038, "Wrong size on X6PlayerCameraManager_RemoveCameraState");
static_assert(offsetof(X6PlayerCameraManager_RemoveCameraState, CameraStateToRemove) == 0x000000, "Member 'X6PlayerCameraManager_RemoveCameraState::CameraStateToRemove' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_RemoveCameraState, TargetToRemove) == 0x000008, "Member 'X6PlayerCameraManager_RemoveCameraState::TargetToRemove' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_RemoveCameraState, BlendToTop) == 0x000010, "Member 'X6PlayerCameraManager_RemoveCameraState::BlendToTop' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_RemoveCameraState, bOverrideTransitionParams) == 0x000011, "Member 'X6PlayerCameraManager_RemoveCameraState::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_RemoveCameraState, TransitionParams) == 0x000018, "Member 'X6PlayerCameraManager_RemoveCameraState::TransitionParams' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.SetKeepCameraCutRotationWhenBlendOut
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut final
{
public:
	bool                                          bInKeepCameraCutRotationWhenBlendOut;              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut) == 0x000001, "Wrong alignment on X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut");
static_assert(sizeof(X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut) == 0x000001, "Wrong size on X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut");
static_assert(offsetof(X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut, bInKeepCameraCutRotationWhenBlendOut) == 0x000000, "Member 'X6PlayerCameraManager_SetKeepCameraCutRotationWhenBlendOut::bInKeepCameraCutRotationWhenBlendOut' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.SetResetCameraCutRotationWhenJumpOut
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut final
{
public:
	bool                                          bInResetCameraCutRotationWhenJumpCut;              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut) == 0x000001, "Wrong alignment on X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut");
static_assert(sizeof(X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut) == 0x000001, "Wrong size on X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut");
static_assert(offsetof(X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut, bInResetCameraCutRotationWhenJumpCut) == 0x000000, "Member 'X6PlayerCameraManager_SetResetCameraCutRotationWhenJumpOut::bInResetCameraCutRotationWhenJumpCut' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.SetViewTargetInSequence
// 0x0028 (0x0028 - 0x0000)
struct X6PlayerCameraManager_SetViewTargetInSequence final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CameraActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoCollisionTest;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunc;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOutgoing;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerCameraManager_SetViewTargetInSequence) == 0x000008, "Wrong alignment on X6PlayerCameraManager_SetViewTargetInSequence");
static_assert(sizeof(X6PlayerCameraManager_SetViewTargetInSequence) == 0x000028, "Wrong size on X6PlayerCameraManager_SetViewTargetInSequence");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, WorldContextObject) == 0x000000, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, CameraActor) == 0x000008, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::CameraActor' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, DoCollisionTest) == 0x000010, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::DoCollisionTest' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, BlendTime) == 0x000014, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::BlendTime' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, BlendFunc) == 0x000018, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::BlendFunc' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, BlendExp) == 0x00001C, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::BlendExp' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_SetViewTargetInSequence, bLockOutgoing) == 0x000020, "Member 'X6PlayerCameraManager_SetViewTargetInSequence::bLockOutgoing' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.CheckCameraTransitionEnable
// 0x0003 (0x0003 - 0x0000)
struct X6PlayerCameraManager_CheckCameraTransitionEnable final
{
public:
	ECameraState                                  SourceCameraState;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  TargetCameraState;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_CheckCameraTransitionEnable) == 0x000001, "Wrong alignment on X6PlayerCameraManager_CheckCameraTransitionEnable");
static_assert(sizeof(X6PlayerCameraManager_CheckCameraTransitionEnable) == 0x000003, "Wrong size on X6PlayerCameraManager_CheckCameraTransitionEnable");
static_assert(offsetof(X6PlayerCameraManager_CheckCameraTransitionEnable, SourceCameraState) == 0x000000, "Member 'X6PlayerCameraManager_CheckCameraTransitionEnable::SourceCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_CheckCameraTransitionEnable, TargetCameraState) == 0x000001, "Member 'X6PlayerCameraManager_CheckCameraTransitionEnable::TargetCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_CheckCameraTransitionEnable, ReturnValue) == 0x000002, "Member 'X6PlayerCameraManager_CheckCameraTransitionEnable::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.GetCurViewTarget
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerCameraManager_GetCurViewTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_GetCurViewTarget) == 0x000008, "Wrong alignment on X6PlayerCameraManager_GetCurViewTarget");
static_assert(sizeof(X6PlayerCameraManager_GetCurViewTarget) == 0x000008, "Wrong size on X6PlayerCameraManager_GetCurViewTarget");
static_assert(offsetof(X6PlayerCameraManager_GetCurViewTarget, ReturnValue) == 0x000000, "Member 'X6PlayerCameraManager_GetCurViewTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.GetDesiredTargetRotation
// 0x0018 (0x0018 - 0x0000)
struct X6PlayerCameraManager_GetDesiredTargetRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_GetDesiredTargetRotation) == 0x000008, "Wrong alignment on X6PlayerCameraManager_GetDesiredTargetRotation");
static_assert(sizeof(X6PlayerCameraManager_GetDesiredTargetRotation) == 0x000018, "Wrong size on X6PlayerCameraManager_GetDesiredTargetRotation");
static_assert(offsetof(X6PlayerCameraManager_GetDesiredTargetRotation, ReturnValue) == 0x000000, "Member 'X6PlayerCameraManager_GetDesiredTargetRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.GetTransitionConfig
// 0x0030 (0x0030 - 0x0000)
struct X6PlayerCameraManager_GetTransitionConfig final
{
public:
	ECameraState                                  SourceCameraState;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  TargetCameraState;                                 // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraTransitionConfig                ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_GetTransitionConfig) == 0x000008, "Wrong alignment on X6PlayerCameraManager_GetTransitionConfig");
static_assert(sizeof(X6PlayerCameraManager_GetTransitionConfig) == 0x000030, "Wrong size on X6PlayerCameraManager_GetTransitionConfig");
static_assert(offsetof(X6PlayerCameraManager_GetTransitionConfig, SourceCameraState) == 0x000000, "Member 'X6PlayerCameraManager_GetTransitionConfig::SourceCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_GetTransitionConfig, TargetCameraState) == 0x000001, "Member 'X6PlayerCameraManager_GetTransitionConfig::TargetCameraState' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_GetTransitionConfig, ReturnValue) == 0x000008, "Member 'X6PlayerCameraManager_GetTransitionConfig::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerCameraManager.IsPossessedByLevelSequence
// 0x0002 (0x0002 - 0x0000)
struct X6PlayerCameraManager_IsPossessedByLevelSequence final
{
public:
	bool                                          bIgnoreViewTargetDifference;                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerCameraManager_IsPossessedByLevelSequence) == 0x000001, "Wrong alignment on X6PlayerCameraManager_IsPossessedByLevelSequence");
static_assert(sizeof(X6PlayerCameraManager_IsPossessedByLevelSequence) == 0x000002, "Wrong size on X6PlayerCameraManager_IsPossessedByLevelSequence");
static_assert(offsetof(X6PlayerCameraManager_IsPossessedByLevelSequence, bIgnoreViewTargetDifference) == 0x000000, "Member 'X6PlayerCameraManager_IsPossessedByLevelSequence::bIgnoreViewTargetDifference' has a wrong offset!");
static_assert(offsetof(X6PlayerCameraManager_IsPossessedByLevelSequence, ReturnValue) == 0x000001, "Member 'X6PlayerCameraManager_IsPossessedByLevelSequence::ReturnValue' has a wrong offset!");

// Function X6Game.X6BTTask_DaMiaoAvoidance.OnPlayAnimationFinished
// 0x0008 (0x0008 - 0x0000)
struct X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished) == 0x000004, "Wrong alignment on X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished");
static_assert(sizeof(X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished) == 0x000008, "Wrong size on X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished");
static_assert(offsetof(X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished, NotifyName) == 0x000000, "Member 'X6BTTask_DaMiaoAvoidance_OnPlayAnimationFinished::NotifyName' has a wrong offset!");

// Function X6Game.X6BulletActorBase.InitData
// 0x0020 (0x0020 - 0x0000)
struct X6BulletActorBase_InitData final
{
public:
	class AActor*                                 InCasterActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6BulletDataAsset*                     InBulletDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        InTargetComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_InitData) == 0x000008, "Wrong alignment on X6BulletActorBase_InitData");
static_assert(sizeof(X6BulletActorBase_InitData) == 0x000020, "Wrong size on X6BulletActorBase_InitData");
static_assert(offsetof(X6BulletActorBase_InitData, InCasterActor) == 0x000000, "Member 'X6BulletActorBase_InitData::InCasterActor' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_InitData, InBulletDataAsset) == 0x000008, "Member 'X6BulletActorBase_InitData::InBulletDataAsset' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_InitData, InTargetComponent) == 0x000010, "Member 'X6BulletActorBase_InitData::InTargetComponent' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_InitData, InTargetActor) == 0x000018, "Member 'X6BulletActorBase_InitData::InTargetActor' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_ClearTargetIfHit
// 0x0008 (0x0008 - 0x0000)
struct X6BulletActorBase_K2_ClearTargetIfHit final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_ClearTargetIfHit) == 0x000008, "Wrong alignment on X6BulletActorBase_K2_ClearTargetIfHit");
static_assert(sizeof(X6BulletActorBase_K2_ClearTargetIfHit) == 0x000008, "Wrong size on X6BulletActorBase_K2_ClearTargetIfHit");
static_assert(offsetof(X6BulletActorBase_K2_ClearTargetIfHit, HitActor) == 0x000000, "Member 'X6BulletActorBase_K2_ClearTargetIfHit::HitActor' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_DoPendingDestroy
// 0x0028 (0x0028 - 0x0000)
struct X6BulletActorBase_K2_DoPendingDestroy final
{
public:
	bool                                          bHitDamage;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActor;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InDestroyHitImpactPoint;                           // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_DoPendingDestroy) == 0x000008, "Wrong alignment on X6BulletActorBase_K2_DoPendingDestroy");
static_assert(sizeof(X6BulletActorBase_K2_DoPendingDestroy) == 0x000028, "Wrong size on X6BulletActorBase_K2_DoPendingDestroy");
static_assert(offsetof(X6BulletActorBase_K2_DoPendingDestroy, bHitDamage) == 0x000000, "Member 'X6BulletActorBase_K2_DoPendingDestroy::bHitDamage' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_DoPendingDestroy, HitActor) == 0x000008, "Member 'X6BulletActorBase_K2_DoPendingDestroy::HitActor' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_DoPendingDestroy, InDestroyHitImpactPoint) == 0x000010, "Member 'X6BulletActorBase_K2_DoPendingDestroy::InDestroyHitImpactPoint' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_OnDestroyBlocked
// 0x0030 (0x0030 - 0x0000)
struct X6BulletActorBase_K2_OnDestroyBlocked final
{
public:
	bool                                          bHitDamage;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           HitActor;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InDestroyHitImpactPoint;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UX6BulletSimpleBasicModifier*     SourceModifier;                                    // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_OnDestroyBlocked) == 0x000008, "Wrong alignment on X6BulletActorBase_K2_OnDestroyBlocked");
static_assert(sizeof(X6BulletActorBase_K2_OnDestroyBlocked) == 0x000030, "Wrong size on X6BulletActorBase_K2_OnDestroyBlocked");
static_assert(offsetof(X6BulletActorBase_K2_OnDestroyBlocked, bHitDamage) == 0x000000, "Member 'X6BulletActorBase_K2_OnDestroyBlocked::bHitDamage' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_OnDestroyBlocked, HitActor) == 0x000008, "Member 'X6BulletActorBase_K2_OnDestroyBlocked::HitActor' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_OnDestroyBlocked, InDestroyHitImpactPoint) == 0x000010, "Member 'X6BulletActorBase_K2_OnDestroyBlocked::InDestroyHitImpactPoint' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_OnDestroyBlocked, SourceModifier) == 0x000028, "Member 'X6BulletActorBase_K2_OnDestroyBlocked::SourceModifier' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_SetIsBlockingDestroy
// 0x0001 (0x0001 - 0x0000)
struct X6BulletActorBase_K2_SetIsBlockingDestroy final
{
public:
	bool                                          bBlock;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_SetIsBlockingDestroy) == 0x000001, "Wrong alignment on X6BulletActorBase_K2_SetIsBlockingDestroy");
static_assert(sizeof(X6BulletActorBase_K2_SetIsBlockingDestroy) == 0x000001, "Wrong size on X6BulletActorBase_K2_SetIsBlockingDestroy");
static_assert(offsetof(X6BulletActorBase_K2_SetIsBlockingDestroy, bBlock) == 0x000000, "Member 'X6BulletActorBase_K2_SetIsBlockingDestroy::bBlock' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_GetAccumulateSeconds
// 0x0004 (0x0004 - 0x0000)
struct X6BulletActorBase_K2_GetAccumulateSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_GetAccumulateSeconds) == 0x000004, "Wrong alignment on X6BulletActorBase_K2_GetAccumulateSeconds");
static_assert(sizeof(X6BulletActorBase_K2_GetAccumulateSeconds) == 0x000004, "Wrong size on X6BulletActorBase_K2_GetAccumulateSeconds");
static_assert(offsetof(X6BulletActorBase_K2_GetAccumulateSeconds, ReturnValue) == 0x000000, "Member 'X6BulletActorBase_K2_GetAccumulateSeconds::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_GetBulletDestroyType
// 0x0010 (0x0010 - 0x0000)
struct X6BulletActorBase_K2_GetBulletDestroyType final
{
public:
	const class AActor*                           HitActor;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitDamage;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6BulletDestroyType                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BulletActorBase_K2_GetBulletDestroyType) == 0x000008, "Wrong alignment on X6BulletActorBase_K2_GetBulletDestroyType");
static_assert(sizeof(X6BulletActorBase_K2_GetBulletDestroyType) == 0x000010, "Wrong size on X6BulletActorBase_K2_GetBulletDestroyType");
static_assert(offsetof(X6BulletActorBase_K2_GetBulletDestroyType, HitActor) == 0x000000, "Member 'X6BulletActorBase_K2_GetBulletDestroyType::HitActor' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_GetBulletDestroyType, bHitDamage) == 0x000008, "Member 'X6BulletActorBase_K2_GetBulletDestroyType::bHitDamage' has a wrong offset!");
static_assert(offsetof(X6BulletActorBase_K2_GetBulletDestroyType, ReturnValue) == 0x000009, "Member 'X6BulletActorBase_K2_GetBulletDestroyType::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_GetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct X6BulletActorBase_K2_GetTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_GetTargetActor) == 0x000008, "Wrong alignment on X6BulletActorBase_K2_GetTargetActor");
static_assert(sizeof(X6BulletActorBase_K2_GetTargetActor) == 0x000008, "Wrong size on X6BulletActorBase_K2_GetTargetActor");
static_assert(offsetof(X6BulletActorBase_K2_GetTargetActor, ReturnValue) == 0x000000, "Member 'X6BulletActorBase_K2_GetTargetActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_IsDestroyFromHit
// 0x0001 (0x0001 - 0x0000)
struct X6BulletActorBase_K2_IsDestroyFromHit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_IsDestroyFromHit) == 0x000001, "Wrong alignment on X6BulletActorBase_K2_IsDestroyFromHit");
static_assert(sizeof(X6BulletActorBase_K2_IsDestroyFromHit) == 0x000001, "Wrong size on X6BulletActorBase_K2_IsDestroyFromHit");
static_assert(offsetof(X6BulletActorBase_K2_IsDestroyFromHit, ReturnValue) == 0x000000, "Member 'X6BulletActorBase_K2_IsDestroyFromHit::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletActorBase.K2_IsPendingDestroy
// 0x0001 (0x0001 - 0x0000)
struct X6BulletActorBase_K2_IsPendingDestroy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletActorBase_K2_IsPendingDestroy) == 0x000001, "Wrong alignment on X6BulletActorBase_K2_IsPendingDestroy");
static_assert(sizeof(X6BulletActorBase_K2_IsPendingDestroy) == 0x000001, "Wrong size on X6BulletActorBase_K2_IsPendingDestroy");
static_assert(offsetof(X6BulletActorBase_K2_IsPendingDestroy, ReturnValue) == 0x000000, "Member 'X6BulletActorBase_K2_IsPendingDestroy::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletModifier.Init
// 0x0010 (0x0010 - 0x0000)
struct X6BulletModifier_Init final
{
public:
	class AX6BulletActorBase*                     InOwnerActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6BulletDataAsset*                     InBulletDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletModifier_Init) == 0x000008, "Wrong alignment on X6BulletModifier_Init");
static_assert(sizeof(X6BulletModifier_Init) == 0x000010, "Wrong size on X6BulletModifier_Init");
static_assert(offsetof(X6BulletModifier_Init, InOwnerActor) == 0x000000, "Member 'X6BulletModifier_Init::InOwnerActor' has a wrong offset!");
static_assert(offsetof(X6BulletModifier_Init, InBulletDataAsset) == 0x000008, "Member 'X6BulletModifier_Init::InBulletDataAsset' has a wrong offset!");

// Function X6Game.X6BulletModifier.SetActive
// 0x0001 (0x0001 - 0x0000)
struct X6BulletModifier_SetActive final
{
public:
	bool                                          Inactive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletModifier_SetActive) == 0x000001, "Wrong alignment on X6BulletModifier_SetActive");
static_assert(sizeof(X6BulletModifier_SetActive) == 0x000001, "Wrong size on X6BulletModifier_SetActive");
static_assert(offsetof(X6BulletModifier_SetActive, Inactive) == 0x000000, "Member 'X6BulletModifier_SetActive::Inactive' has a wrong offset!");

// Function X6Game.X6BulletModifier.Tick
// 0x0004 (0x0004 - 0x0000)
struct X6BulletModifier_Tick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletModifier_Tick) == 0x000004, "Wrong alignment on X6BulletModifier_Tick");
static_assert(sizeof(X6BulletModifier_Tick) == 0x000004, "Wrong size on X6BulletModifier_Tick");
static_assert(offsetof(X6BulletModifier_Tick, DeltaSeconds) == 0x000000, "Member 'X6BulletModifier_Tick::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BulletModifier.IsActive
// 0x0001 (0x0001 - 0x0000)
struct X6BulletModifier_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletModifier_IsActive) == 0x000001, "Wrong alignment on X6BulletModifier_IsActive");
static_assert(sizeof(X6BulletModifier_IsActive) == 0x000001, "Wrong size on X6BulletModifier_IsActive");
static_assert(offsetof(X6BulletModifier_IsActive, ReturnValue) == 0x000000, "Member 'X6BulletModifier_IsActive::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletModifier.K2_Tick
// 0x0004 (0x0004 - 0x0000)
struct X6BulletModifier_K2_Tick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletModifier_K2_Tick) == 0x000004, "Wrong alignment on X6BulletModifier_K2_Tick");
static_assert(sizeof(X6BulletModifier_K2_Tick) == 0x000004, "Wrong size on X6BulletModifier_K2_Tick");
static_assert(offsetof(X6BulletModifier_K2_Tick, DeltaSeconds) == 0x000000, "Member 'X6BulletModifier_K2_Tick::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6RecycableObjectInterface.RejectRecycle
// 0x0001 (0x0001 - 0x0000)
struct X6RecycableObjectInterface_RejectRecycle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RecycableObjectInterface_RejectRecycle) == 0x000001, "Wrong alignment on X6RecycableObjectInterface_RejectRecycle");
static_assert(sizeof(X6RecycableObjectInterface_RejectRecycle) == 0x000001, "Wrong size on X6RecycableObjectInterface_RejectRecycle");
static_assert(offsetof(X6RecycableObjectInterface_RejectRecycle, ReturnValue) == 0x000000, "Member 'X6RecycableObjectInterface_RejectRecycle::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletMovementBasicModifier.K2_GetSpeedRateValue
// 0x0008 (0x0008 - 0x0000)
struct X6BulletMovementBasicModifier_K2_GetSpeedRateValue final
{
public:
	float                                         AccumulateSeconds;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletMovementBasicModifier_K2_GetSpeedRateValue) == 0x000004, "Wrong alignment on X6BulletMovementBasicModifier_K2_GetSpeedRateValue");
static_assert(sizeof(X6BulletMovementBasicModifier_K2_GetSpeedRateValue) == 0x000008, "Wrong size on X6BulletMovementBasicModifier_K2_GetSpeedRateValue");
static_assert(offsetof(X6BulletMovementBasicModifier_K2_GetSpeedRateValue, AccumulateSeconds) == 0x000000, "Member 'X6BulletMovementBasicModifier_K2_GetSpeedRateValue::AccumulateSeconds' has a wrong offset!");
static_assert(offsetof(X6BulletMovementBasicModifier_K2_GetSpeedRateValue, ReturnValue) == 0x000004, "Member 'X6BulletMovementBasicModifier_K2_GetSpeedRateValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletMovementBasicModifier.K2_TickLineMove
// 0x0004 (0x0004 - 0x0000)
struct X6BulletMovementBasicModifier_K2_TickLineMove final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletMovementBasicModifier_K2_TickLineMove) == 0x000004, "Wrong alignment on X6BulletMovementBasicModifier_K2_TickLineMove");
static_assert(sizeof(X6BulletMovementBasicModifier_K2_TickLineMove) == 0x000004, "Wrong size on X6BulletMovementBasicModifier_K2_TickLineMove");
static_assert(offsetof(X6BulletMovementBasicModifier_K2_TickLineMove, DeltaSeconds) == 0x000000, "Member 'X6BulletMovementBasicModifier_K2_TickLineMove::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6BulletCloseToFloorMovementModifier.K2_TickCloseToFloorMove
// 0x0004 (0x0004 - 0x0000)
struct X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove) == 0x000004, "Wrong alignment on X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove");
static_assert(sizeof(X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove) == 0x000004, "Wrong size on X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove");
static_assert(offsetof(X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove, DeltaTime) == 0x000000, "Member 'X6BulletCloseToFloorMovementModifier_K2_TickCloseToFloorMove::DeltaTime' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.CanShapeTrace
// 0x0001 (0x0001 - 0x0000)
struct X6BulletShapeTraceModifier_CanShapeTrace final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_CanShapeTrace) == 0x000001, "Wrong alignment on X6BulletShapeTraceModifier_CanShapeTrace");
static_assert(sizeof(X6BulletShapeTraceModifier_CanShapeTrace) == 0x000001, "Wrong size on X6BulletShapeTraceModifier_CanShapeTrace");
static_assert(offsetof(X6BulletShapeTraceModifier_CanShapeTrace, ReturnValue) == 0x000000, "Member 'X6BulletShapeTraceModifier_CanShapeTrace::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.K2_AddExtraIgnoreActor
// 0x0008 (0x0008 - 0x0000)
struct X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor final
{
public:
	class AActor*                                 IgnoreActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor");
static_assert(sizeof(X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor) == 0x000008, "Wrong size on X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor, IgnoreActor) == 0x000000, "Member 'X6BulletShapeTraceModifier_K2_AddExtraIgnoreActor::IgnoreActor' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.K2_SetDebugInfo
// 0x0024 (0x0024 - 0x0000)
struct X6BulletShapeTraceModifier_K2_SetDebugInfo final
{
public:
	EDrawDebugTrace                               InDebugDraw;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           InDebugTraceColor;                                 // 0x0004(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InDebugTraceHitColor;                              // 0x0014(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_K2_SetDebugInfo) == 0x000004, "Wrong alignment on X6BulletShapeTraceModifier_K2_SetDebugInfo");
static_assert(sizeof(X6BulletShapeTraceModifier_K2_SetDebugInfo) == 0x000024, "Wrong size on X6BulletShapeTraceModifier_K2_SetDebugInfo");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_SetDebugInfo, InDebugDraw) == 0x000000, "Member 'X6BulletShapeTraceModifier_K2_SetDebugInfo::InDebugDraw' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_SetDebugInfo, InDebugTraceColor) == 0x000004, "Member 'X6BulletShapeTraceModifier_K2_SetDebugInfo::InDebugTraceColor' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_SetDebugInfo, InDebugTraceHitColor) == 0x000014, "Member 'X6BulletShapeTraceModifier_K2_SetDebugInfo::InDebugTraceHitColor' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.GetEndLocation
// 0x0018 (0x0018 - 0x0000)
struct X6BulletShapeTraceModifier_GetEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_GetEndLocation) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_GetEndLocation");
static_assert(sizeof(X6BulletShapeTraceModifier_GetEndLocation) == 0x000018, "Wrong size on X6BulletShapeTraceModifier_GetEndLocation");
static_assert(offsetof(X6BulletShapeTraceModifier_GetEndLocation, ReturnValue) == 0x000000, "Member 'X6BulletShapeTraceModifier_GetEndLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.GetIgnoreActors
// 0x0010 (0x0010 - 0x0000)
struct X6BulletShapeTraceModifier_GetIgnoreActors final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_GetIgnoreActors) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_GetIgnoreActors");
static_assert(sizeof(X6BulletShapeTraceModifier_GetIgnoreActors) == 0x000010, "Wrong size on X6BulletShapeTraceModifier_GetIgnoreActors");
static_assert(offsetof(X6BulletShapeTraceModifier_GetIgnoreActors, ReturnValue) == 0x000000, "Member 'X6BulletShapeTraceModifier_GetIgnoreActors::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.GetStartLocation
// 0x0018 (0x0018 - 0x0000)
struct X6BulletShapeTraceModifier_GetStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_GetStartLocation) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_GetStartLocation");
static_assert(sizeof(X6BulletShapeTraceModifier_GetStartLocation) == 0x000018, "Wrong size on X6BulletShapeTraceModifier_GetStartLocation");
static_assert(offsetof(X6BulletShapeTraceModifier_GetStartLocation, ReturnValue) == 0x000000, "Member 'X6BulletShapeTraceModifier_GetStartLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.K2_ProcessHitResults
// 0x0040 (0x0040 - 0x0000)
struct X6BulletShapeTraceModifier_K2_ProcessHitResults final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitResults;                                        // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_K2_ProcessHitResults) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_K2_ProcessHitResults");
static_assert(sizeof(X6BulletShapeTraceModifier_K2_ProcessHitResults) == 0x000040, "Wrong size on X6BulletShapeTraceModifier_K2_ProcessHitResults");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_ProcessHitResults, StartLocation) == 0x000000, "Member 'X6BulletShapeTraceModifier_K2_ProcessHitResults::StartLocation' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_ProcessHitResults, EndLocation) == 0x000018, "Member 'X6BulletShapeTraceModifier_K2_ProcessHitResults::EndLocation' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_ProcessHitResults, HitResults) == 0x000030, "Member 'X6BulletShapeTraceModifier_K2_ProcessHitResults::HitResults' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.K2_SwapTraceCorrection
// 0x0018 (0x0018 - 0x0000)
struct X6BulletShapeTraceModifier_K2_SwapTraceCorrection final
{
public:
	struct FVector                                SwapLocation;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_K2_SwapTraceCorrection) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_K2_SwapTraceCorrection");
static_assert(sizeof(X6BulletShapeTraceModifier_K2_SwapTraceCorrection) == 0x000018, "Wrong size on X6BulletShapeTraceModifier_K2_SwapTraceCorrection");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_SwapTraceCorrection, SwapLocation) == 0x000000, "Member 'X6BulletShapeTraceModifier_K2_SwapTraceCorrection::SwapLocation' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.K2_TraceByObjects
// 0x0098 (0x0098 - 0x0000)
struct X6BulletShapeTraceModifier_K2_TraceByObjects final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0048(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FX6BulletShapeTraceContext             InTraceContext;                                    // 0x0058(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitResults;                                        // 0x0080(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BulletShapeTraceModifier_K2_TraceByObjects) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_K2_TraceByObjects");
static_assert(sizeof(X6BulletShapeTraceModifier_K2_TraceByObjects) == 0x000098, "Wrong size on X6BulletShapeTraceModifier_K2_TraceByObjects");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, StartLocation) == 0x000000, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::StartLocation' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, EndLocation) == 0x000018, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::EndLocation' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, ObjectTypes) == 0x000030, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, DrawDebugType) == 0x000040, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, IgnoreActors) == 0x000048, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::IgnoreActors' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, InTraceContext) == 0x000058, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::InTraceContext' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, HitResults) == 0x000080, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::HitResults' has a wrong offset!");
static_assert(offsetof(X6BulletShapeTraceModifier_K2_TraceByObjects, ReturnValue) == 0x000090, "Member 'X6BulletShapeTraceModifier_K2_TraceByObjects::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletShapeTraceModifier.SwapTraceCorrection
// 0x0018 (0x0018 - 0x0000)
struct X6BulletShapeTraceModifier_SwapTraceCorrection final
{
public:
	struct FVector                                SwapLocation;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletShapeTraceModifier_SwapTraceCorrection) == 0x000008, "Wrong alignment on X6BulletShapeTraceModifier_SwapTraceCorrection");
static_assert(sizeof(X6BulletShapeTraceModifier_SwapTraceCorrection) == 0x000018, "Wrong size on X6BulletShapeTraceModifier_SwapTraceCorrection");
static_assert(offsetof(X6BulletShapeTraceModifier_SwapTraceCorrection, SwapLocation) == 0x000000, "Member 'X6BulletShapeTraceModifier_SwapTraceCorrection::SwapLocation' has a wrong offset!");

// Function X6Game.X6BulletCollisionModifier.K2_IsCollisionDestroy
// 0x0118 (0x0118 - 0x0000)
struct X6BulletCollisionModifier_K2_IsCollisionDestroy final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTriggerSkillReceiver;                             // 0x0100(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UAbilitySystemComponent*          AbilitySystemComponent;                            // 0x0108(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0110(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BulletCollisionModifier_K2_IsCollisionDestroy) == 0x000008, "Wrong alignment on X6BulletCollisionModifier_K2_IsCollisionDestroy");
static_assert(sizeof(X6BulletCollisionModifier_K2_IsCollisionDestroy) == 0x000118, "Wrong size on X6BulletCollisionModifier_K2_IsCollisionDestroy");
static_assert(offsetof(X6BulletCollisionModifier_K2_IsCollisionDestroy, HitActor) == 0x000000, "Member 'X6BulletCollisionModifier_K2_IsCollisionDestroy::HitActor' has a wrong offset!");
static_assert(offsetof(X6BulletCollisionModifier_K2_IsCollisionDestroy, HitResult) == 0x000008, "Member 'X6BulletCollisionModifier_K2_IsCollisionDestroy::HitResult' has a wrong offset!");
static_assert(offsetof(X6BulletCollisionModifier_K2_IsCollisionDestroy, bTriggerSkillReceiver) == 0x000100, "Member 'X6BulletCollisionModifier_K2_IsCollisionDestroy::bTriggerSkillReceiver' has a wrong offset!");
static_assert(offsetof(X6BulletCollisionModifier_K2_IsCollisionDestroy, AbilitySystemComponent) == 0x000108, "Member 'X6BulletCollisionModifier_K2_IsCollisionDestroy::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(X6BulletCollisionModifier_K2_IsCollisionDestroy, ReturnValue) == 0x000110, "Member 'X6BulletCollisionModifier_K2_IsCollisionDestroy::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletCollisionModifier.K2_ShouldDestroyByActor
// 0x0108 (0x0108 - 0x0000)
struct X6BulletCollisionModifier_K2_ShouldDestroyByActor final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6BulletCollisionModifier_K2_ShouldDestroyByActor) == 0x000008, "Wrong alignment on X6BulletCollisionModifier_K2_ShouldDestroyByActor");
static_assert(sizeof(X6BulletCollisionModifier_K2_ShouldDestroyByActor) == 0x000108, "Wrong size on X6BulletCollisionModifier_K2_ShouldDestroyByActor");
static_assert(offsetof(X6BulletCollisionModifier_K2_ShouldDestroyByActor, HitActor) == 0x000000, "Member 'X6BulletCollisionModifier_K2_ShouldDestroyByActor::HitActor' has a wrong offset!");
static_assert(offsetof(X6BulletCollisionModifier_K2_ShouldDestroyByActor, HitResult) == 0x000008, "Member 'X6BulletCollisionModifier_K2_ShouldDestroyByActor::HitResult' has a wrong offset!");
static_assert(offsetof(X6BulletCollisionModifier_K2_ShouldDestroyByActor, ReturnValue) == 0x000100, "Member 'X6BulletCollisionModifier_K2_ShouldDestroyByActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetAngularOffset
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetAngularOffset final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetAngularOffset) == 0x000004, "Wrong alignment on X6RadialSlider_SetAngularOffset");
static_assert(sizeof(X6RadialSlider_SetAngularOffset) == 0x000004, "Wrong size on X6RadialSlider_SetAngularOffset");
static_assert(offsetof(X6RadialSlider_SetAngularOffset, InValue) == 0x000000, "Member 'X6RadialSlider_SetAngularOffset::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetCustomDefaultValue
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetCustomDefaultValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetCustomDefaultValue) == 0x000004, "Wrong alignment on X6RadialSlider_SetCustomDefaultValue");
static_assert(sizeof(X6RadialSlider_SetCustomDefaultValue) == 0x000004, "Wrong size on X6RadialSlider_SetCustomDefaultValue");
static_assert(offsetof(X6RadialSlider_SetCustomDefaultValue, InValue) == 0x000000, "Member 'X6RadialSlider_SetCustomDefaultValue::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetLocked
// 0x0001 (0x0001 - 0x0000)
struct X6RadialSlider_SetLocked final
{
public:
	bool                                          InValue;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetLocked) == 0x000001, "Wrong alignment on X6RadialSlider_SetLocked");
static_assert(sizeof(X6RadialSlider_SetLocked) == 0x000001, "Wrong size on X6RadialSlider_SetLocked");
static_assert(offsetof(X6RadialSlider_SetLocked, InValue) == 0x000000, "Member 'X6RadialSlider_SetLocked::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderBarColor
// 0x0010 (0x0010 - 0x0000)
struct X6RadialSlider_SetSliderBarColor final
{
public:
	struct FLinearColor                           InValue;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderBarColor) == 0x000004, "Wrong alignment on X6RadialSlider_SetSliderBarColor");
static_assert(sizeof(X6RadialSlider_SetSliderBarColor) == 0x000010, "Wrong size on X6RadialSlider_SetSliderBarColor");
static_assert(offsetof(X6RadialSlider_SetSliderBarColor, InValue) == 0x000000, "Member 'X6RadialSlider_SetSliderBarColor::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderHandleColor
// 0x0010 (0x0010 - 0x0000)
struct X6RadialSlider_SetSliderHandleColor final
{
public:
	struct FLinearColor                           InValue;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderHandleColor) == 0x000004, "Wrong alignment on X6RadialSlider_SetSliderHandleColor");
static_assert(sizeof(X6RadialSlider_SetSliderHandleColor) == 0x000010, "Wrong size on X6RadialSlider_SetSliderHandleColor");
static_assert(offsetof(X6RadialSlider_SetSliderHandleColor, InValue) == 0x000000, "Member 'X6RadialSlider_SetSliderHandleColor::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderHandleEndAngle
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetSliderHandleEndAngle final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderHandleEndAngle) == 0x000004, "Wrong alignment on X6RadialSlider_SetSliderHandleEndAngle");
static_assert(sizeof(X6RadialSlider_SetSliderHandleEndAngle) == 0x000004, "Wrong size on X6RadialSlider_SetSliderHandleEndAngle");
static_assert(offsetof(X6RadialSlider_SetSliderHandleEndAngle, InValue) == 0x000000, "Member 'X6RadialSlider_SetSliderHandleEndAngle::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderHandleStartAngle
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetSliderHandleStartAngle final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderHandleStartAngle) == 0x000004, "Wrong alignment on X6RadialSlider_SetSliderHandleStartAngle");
static_assert(sizeof(X6RadialSlider_SetSliderHandleStartAngle) == 0x000004, "Wrong size on X6RadialSlider_SetSliderHandleStartAngle");
static_assert(offsetof(X6RadialSlider_SetSliderHandleStartAngle, InValue) == 0x000000, "Member 'X6RadialSlider_SetSliderHandleStartAngle::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderProgressColor
// 0x0010 (0x0010 - 0x0000)
struct X6RadialSlider_SetSliderProgressColor final
{
public:
	struct FLinearColor                           InValue;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderProgressColor) == 0x000004, "Wrong alignment on X6RadialSlider_SetSliderProgressColor");
static_assert(sizeof(X6RadialSlider_SetSliderProgressColor) == 0x000010, "Wrong size on X6RadialSlider_SetSliderProgressColor");
static_assert(offsetof(X6RadialSlider_SetSliderProgressColor, InValue) == 0x000000, "Member 'X6RadialSlider_SetSliderProgressColor::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderRadius
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetSliderRadius final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderRadius) == 0x000004, "Wrong alignment on X6RadialSlider_SetSliderRadius");
static_assert(sizeof(X6RadialSlider_SetSliderRadius) == 0x000004, "Wrong size on X6RadialSlider_SetSliderRadius");
static_assert(offsetof(X6RadialSlider_SetSliderRadius, InValue) == 0x000000, "Member 'X6RadialSlider_SetSliderRadius::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetSliderRange
// 0x0088 (0x0088 - 0x0000)
struct X6RadialSlider_SetSliderRange final
{
public:
	struct FRuntimeFloatCurve                     InSliderRange;                                     // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetSliderRange) == 0x000008, "Wrong alignment on X6RadialSlider_SetSliderRange");
static_assert(sizeof(X6RadialSlider_SetSliderRange) == 0x000088, "Wrong size on X6RadialSlider_SetSliderRange");
static_assert(offsetof(X6RadialSlider_SetSliderRange, InSliderRange) == 0x000000, "Member 'X6RadialSlider_SetSliderRange::InSliderRange' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetStepSize
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetStepSize final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetStepSize) == 0x000004, "Wrong alignment on X6RadialSlider_SetStepSize");
static_assert(sizeof(X6RadialSlider_SetStepSize) == 0x000004, "Wrong size on X6RadialSlider_SetStepSize");
static_assert(offsetof(X6RadialSlider_SetStepSize, InValue) == 0x000000, "Member 'X6RadialSlider_SetStepSize::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetValue
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_SetValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetValue) == 0x000004, "Wrong alignment on X6RadialSlider_SetValue");
static_assert(sizeof(X6RadialSlider_SetValue) == 0x000004, "Wrong size on X6RadialSlider_SetValue");
static_assert(offsetof(X6RadialSlider_SetValue, InValue) == 0x000000, "Member 'X6RadialSlider_SetValue::InValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.SetValueTags
// 0x0010 (0x0010 - 0x0000)
struct X6RadialSlider_SetValueTags final
{
public:
	TArray<float>                                 InValueTags;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_SetValueTags) == 0x000008, "Wrong alignment on X6RadialSlider_SetValueTags");
static_assert(sizeof(X6RadialSlider_SetValueTags) == 0x000010, "Wrong size on X6RadialSlider_SetValueTags");
static_assert(offsetof(X6RadialSlider_SetValueTags, InValueTags) == 0x000000, "Member 'X6RadialSlider_SetValueTags::InValueTags' has a wrong offset!");

// Function X6Game.X6RadialSlider.GetCustomDefaultValue
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_GetCustomDefaultValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_GetCustomDefaultValue) == 0x000004, "Wrong alignment on X6RadialSlider_GetCustomDefaultValue");
static_assert(sizeof(X6RadialSlider_GetCustomDefaultValue) == 0x000004, "Wrong size on X6RadialSlider_GetCustomDefaultValue");
static_assert(offsetof(X6RadialSlider_GetCustomDefaultValue, ReturnValue) == 0x000000, "Member 'X6RadialSlider_GetCustomDefaultValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.GetNormalizedSliderHandlePosition
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_GetNormalizedSliderHandlePosition final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_GetNormalizedSliderHandlePosition) == 0x000004, "Wrong alignment on X6RadialSlider_GetNormalizedSliderHandlePosition");
static_assert(sizeof(X6RadialSlider_GetNormalizedSliderHandlePosition) == 0x000004, "Wrong size on X6RadialSlider_GetNormalizedSliderHandlePosition");
static_assert(offsetof(X6RadialSlider_GetNormalizedSliderHandlePosition, ReturnValue) == 0x000000, "Member 'X6RadialSlider_GetNormalizedSliderHandlePosition::ReturnValue' has a wrong offset!");

// Function X6Game.X6RadialSlider.GetValue
// 0x0004 (0x0004 - 0x0000)
struct X6RadialSlider_GetValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RadialSlider_GetValue) == 0x000004, "Wrong alignment on X6RadialSlider_GetValue");
static_assert(sizeof(X6RadialSlider_GetValue) == 0x000004, "Wrong size on X6RadialSlider_GetValue");
static_assert(offsetof(X6RadialSlider_GetValue, ReturnValue) == 0x000000, "Member 'X6RadialSlider_GetValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletEffectWindZoneModifier.K2_SetCacheCasterActor
// 0x0008 (0x0008 - 0x0000)
struct X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor final
{
public:
	class AActor*                                 InCasterActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor) == 0x000008, "Wrong alignment on X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor");
static_assert(sizeof(X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor) == 0x000008, "Wrong size on X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor");
static_assert(offsetof(X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor, InCasterActor) == 0x000000, "Member 'X6BulletEffectWindZoneModifier_K2_SetCacheCasterActor::InCasterActor' has a wrong offset!");

// Function X6Game.X6BulletFilterTargetingPresetModifier.K2_ProcessHitResults
// 0x0010 (0x0010 - 0x0000)
struct X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults final
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults) == 0x000008, "Wrong alignment on X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults");
static_assert(sizeof(X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults) == 0x000010, "Wrong size on X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults");
static_assert(offsetof(X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults, HitResults) == 0x000000, "Member 'X6BulletFilterTargetingPresetModifier_K2_ProcessHitResults::HitResults' has a wrong offset!");

// Function X6Game.X6SimpleTargetingSortTask.BP_GetScoreForTarget
// 0x0110 (0x0110 - 0x0000)
struct X6SimpleTargetingSortTask_BP_GetScoreForTarget final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetingDefaultResultData            TargetData;                                        // 0x0008(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0108(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SimpleTargetingSortTask_BP_GetScoreForTarget) == 0x000008, "Wrong alignment on X6SimpleTargetingSortTask_BP_GetScoreForTarget");
static_assert(sizeof(X6SimpleTargetingSortTask_BP_GetScoreForTarget) == 0x000110, "Wrong size on X6SimpleTargetingSortTask_BP_GetScoreForTarget");
static_assert(offsetof(X6SimpleTargetingSortTask_BP_GetScoreForTarget, TargetingHandle) == 0x000000, "Member 'X6SimpleTargetingSortTask_BP_GetScoreForTarget::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6SimpleTargetingSortTask_BP_GetScoreForTarget, TargetData) == 0x000008, "Member 'X6SimpleTargetingSortTask_BP_GetScoreForTarget::TargetData' has a wrong offset!");
static_assert(offsetof(X6SimpleTargetingSortTask_BP_GetScoreForTarget, ReturnValue) == 0x000108, "Member 'X6SimpleTargetingSortTask_BP_GetScoreForTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.Blueprint_PostUpdateRegularMovementBehavior
// 0x0004 (0x0004 - 0x0000)
struct X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior) == 0x000004, "Wrong alignment on X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior");
static_assert(sizeof(X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior) == 0x000004, "Wrong size on X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior");
static_assert(offsetof(X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior, DeltaSeconds) == 0x000000, "Member 'X6RMInAirComponent_Blueprint_PostUpdateRegularMovementBehavior::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.Blueprint_PreUpdateRegularMovementBehavior
// 0x0004 (0x0004 - 0x0000)
struct X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior) == 0x000004, "Wrong alignment on X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior");
static_assert(sizeof(X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior) == 0x000004, "Wrong size on X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior");
static_assert(offsetof(X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior, DeltaSeconds) == 0x000000, "Member 'X6RMInAirComponent_Blueprint_PreUpdateRegularMovementBehavior::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.GetCurRMBaseLogicProcessor
// 0x0008 (0x0008 - 0x0000)
struct X6RMInAirComponent_GetCurRMBaseLogicProcessor final
{
public:
	class URMBaseLogicProcessor*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_GetCurRMBaseLogicProcessor) == 0x000008, "Wrong alignment on X6RMInAirComponent_GetCurRMBaseLogicProcessor");
static_assert(sizeof(X6RMInAirComponent_GetCurRMBaseLogicProcessor) == 0x000008, "Wrong size on X6RMInAirComponent_GetCurRMBaseLogicProcessor");
static_assert(offsetof(X6RMInAirComponent_GetCurRMBaseLogicProcessor, ReturnValue) == 0x000000, "Member 'X6RMInAirComponent_GetCurRMBaseLogicProcessor::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.InitRMBaseLogicProcessor
// 0x0008 (0x0008 - 0x0000)
struct X6RMInAirComponent_InitRMBaseLogicProcessor final
{
public:
	class URMBaseLogicProcessor*                  RMBaseLogicProcessor;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_InitRMBaseLogicProcessor) == 0x000008, "Wrong alignment on X6RMInAirComponent_InitRMBaseLogicProcessor");
static_assert(sizeof(X6RMInAirComponent_InitRMBaseLogicProcessor) == 0x000008, "Wrong size on X6RMInAirComponent_InitRMBaseLogicProcessor");
static_assert(offsetof(X6RMInAirComponent_InitRMBaseLogicProcessor, RMBaseLogicProcessor) == 0x000000, "Member 'X6RMInAirComponent_InitRMBaseLogicProcessor::RMBaseLogicProcessor' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.IsValidReplicatedMovingDirection
// 0x0001 (0x0001 - 0x0000)
struct X6RMInAirComponent_IsValidReplicatedMovingDirection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_IsValidReplicatedMovingDirection) == 0x000001, "Wrong alignment on X6RMInAirComponent_IsValidReplicatedMovingDirection");
static_assert(sizeof(X6RMInAirComponent_IsValidReplicatedMovingDirection) == 0x000001, "Wrong size on X6RMInAirComponent_IsValidReplicatedMovingDirection");
static_assert(offsetof(X6RMInAirComponent_IsValidReplicatedMovingDirection, ReturnValue) == 0x000000, "Member 'X6RMInAirComponent_IsValidReplicatedMovingDirection::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.MulticastRPC_ChangeJumpStage
// 0x0002 (0x0002 - 0x0000)
struct X6RMInAirComponent_MulticastRPC_ChangeJumpStage final
{
public:
	ERegularFloatingJumpStage                     NewStage;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_MulticastRPC_ChangeJumpStage) == 0x000001, "Wrong alignment on X6RMInAirComponent_MulticastRPC_ChangeJumpStage");
static_assert(sizeof(X6RMInAirComponent_MulticastRPC_ChangeJumpStage) == 0x000002, "Wrong size on X6RMInAirComponent_MulticastRPC_ChangeJumpStage");
static_assert(offsetof(X6RMInAirComponent_MulticastRPC_ChangeJumpStage, NewStage) == 0x000000, "Member 'X6RMInAirComponent_MulticastRPC_ChangeJumpStage::NewStage' has a wrong offset!");
static_assert(offsetof(X6RMInAirComponent_MulticastRPC_ChangeJumpStage, bForceUpdate) == 0x000001, "Member 'X6RMInAirComponent_MulticastRPC_ChangeJumpStage::bForceUpdate' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.ReceivePostPhysicsTick
// 0x0004 (0x0004 - 0x0000)
struct X6RMInAirComponent_ReceivePostPhysicsTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_ReceivePostPhysicsTick) == 0x000004, "Wrong alignment on X6RMInAirComponent_ReceivePostPhysicsTick");
static_assert(sizeof(X6RMInAirComponent_ReceivePostPhysicsTick) == 0x000004, "Wrong size on X6RMInAirComponent_ReceivePostPhysicsTick");
static_assert(offsetof(X6RMInAirComponent_ReceivePostPhysicsTick, DeltaTime) == 0x000000, "Member 'X6RMInAirComponent_ReceivePostPhysicsTick::DeltaTime' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.ResetInputActionProcessor
// 0x0008 (0x0008 - 0x0000)
struct X6RMInAirComponent_ResetInputActionProcessor final
{
public:
	TSubclassOf<class URMInputActionProcessor_InAir> inInputActionProcessorClass;                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_ResetInputActionProcessor) == 0x000008, "Wrong alignment on X6RMInAirComponent_ResetInputActionProcessor");
static_assert(sizeof(X6RMInAirComponent_ResetInputActionProcessor) == 0x000008, "Wrong size on X6RMInAirComponent_ResetInputActionProcessor");
static_assert(offsetof(X6RMInAirComponent_ResetInputActionProcessor, inInputActionProcessorClass) == 0x000000, "Member 'X6RMInAirComponent_ResetInputActionProcessor::inInputActionProcessorClass' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.SetPostPhysicsTickFunctionEnable
// 0x0001 (0x0001 - 0x0000)
struct X6RMInAirComponent_SetPostPhysicsTickFunctionEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_SetPostPhysicsTickFunctionEnable) == 0x000001, "Wrong alignment on X6RMInAirComponent_SetPostPhysicsTickFunctionEnable");
static_assert(sizeof(X6RMInAirComponent_SetPostPhysicsTickFunctionEnable) == 0x000001, "Wrong size on X6RMInAirComponent_SetPostPhysicsTickFunctionEnable");
static_assert(offsetof(X6RMInAirComponent_SetPostPhysicsTickFunctionEnable, bEnable) == 0x000000, "Member 'X6RMInAirComponent_SetPostPhysicsTickFunctionEnable::bEnable' has a wrong offset!");

// Function X6Game.X6RMInAirComponent.UpdateDynamicMovementSettings
// 0x0001 (0x0001 - 0x0000)
struct X6RMInAirComponent_UpdateDynamicMovementSettings final
{
public:
	bool                                          bForceUpdate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMInAirComponent_UpdateDynamicMovementSettings) == 0x000001, "Wrong alignment on X6RMInAirComponent_UpdateDynamicMovementSettings");
static_assert(sizeof(X6RMInAirComponent_UpdateDynamicMovementSettings) == 0x000001, "Wrong size on X6RMInAirComponent_UpdateDynamicMovementSettings");
static_assert(offsetof(X6RMInAirComponent_UpdateDynamicMovementSettings, bForceUpdate) == 0x000000, "Member 'X6RMInAirComponent_UpdateDynamicMovementSettings::bForceUpdate' has a wrong offset!");

// Function X6Game.X6BulletHitDamageModifier.IsHitDestroyExtraTrace
// 0x0001 (0x0001 - 0x0000)
struct X6BulletHitDamageModifier_IsHitDestroyExtraTrace final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletHitDamageModifier_IsHitDestroyExtraTrace) == 0x000001, "Wrong alignment on X6BulletHitDamageModifier_IsHitDestroyExtraTrace");
static_assert(sizeof(X6BulletHitDamageModifier_IsHitDestroyExtraTrace) == 0x000001, "Wrong size on X6BulletHitDamageModifier_IsHitDestroyExtraTrace");
static_assert(offsetof(X6BulletHitDamageModifier_IsHitDestroyExtraTrace, ReturnValue) == 0x000000, "Member 'X6BulletHitDamageModifier_IsHitDestroyExtraTrace::ReturnValue' has a wrong offset!");

// Function X6Game.X6BulletWindComponent.SetCacheCasterActor
// 0x0008 (0x0008 - 0x0000)
struct X6BulletWindComponent_SetCacheCasterActor final
{
public:
	class AActor*                                 InCasterActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BulletWindComponent_SetCacheCasterActor) == 0x000008, "Wrong alignment on X6BulletWindComponent_SetCacheCasterActor");
static_assert(sizeof(X6BulletWindComponent_SetCacheCasterActor) == 0x000008, "Wrong size on X6BulletWindComponent_SetCacheCasterActor");
static_assert(offsetof(X6BulletWindComponent_SetCacheCasterActor, InCasterActor) == 0x000000, "Member 'X6BulletWindComponent_SetCacheCasterActor::InCasterActor' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.ActiveUpdateActorLocation
// 0x0001 (0x0001 - 0x0000)
struct X6BuoyancyEffectComponent_ActiveUpdateActorLocation final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_ActiveUpdateActorLocation) == 0x000001, "Wrong alignment on X6BuoyancyEffectComponent_ActiveUpdateActorLocation");
static_assert(sizeof(X6BuoyancyEffectComponent_ActiveUpdateActorLocation) == 0x000001, "Wrong size on X6BuoyancyEffectComponent_ActiveUpdateActorLocation");
static_assert(offsetof(X6BuoyancyEffectComponent_ActiveUpdateActorLocation, bActive) == 0x000000, "Member 'X6BuoyancyEffectComponent_ActiveUpdateActorLocation::bActive' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.GetActorBuoyancyState
// 0x0001 (0x0001 - 0x0000)
struct X6BuoyancyEffectComponent_GetActorBuoyancyState final
{
public:
	EActorBuoyancyState                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_GetActorBuoyancyState) == 0x000001, "Wrong alignment on X6BuoyancyEffectComponent_GetActorBuoyancyState");
static_assert(sizeof(X6BuoyancyEffectComponent_GetActorBuoyancyState) == 0x000001, "Wrong size on X6BuoyancyEffectComponent_GetActorBuoyancyState");
static_assert(offsetof(X6BuoyancyEffectComponent_GetActorBuoyancyState, ReturnValue) == 0x000000, "Member 'X6BuoyancyEffectComponent_GetActorBuoyancyState::ReturnValue' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.GetActorCurrentDensity
// 0x0004 (0x0004 - 0x0000)
struct X6BuoyancyEffectComponent_GetActorCurrentDensity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_GetActorCurrentDensity) == 0x000004, "Wrong alignment on X6BuoyancyEffectComponent_GetActorCurrentDensity");
static_assert(sizeof(X6BuoyancyEffectComponent_GetActorCurrentDensity) == 0x000004, "Wrong size on X6BuoyancyEffectComponent_GetActorCurrentDensity");
static_assert(offsetof(X6BuoyancyEffectComponent_GetActorCurrentDensity, ReturnValue) == 0x000000, "Member 'X6BuoyancyEffectComponent_GetActorCurrentDensity::ReturnValue' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.IsActorFloatingOnWaterSurface
// 0x0001 (0x0001 - 0x0000)
struct X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface) == 0x000001, "Wrong alignment on X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface");
static_assert(sizeof(X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface) == 0x000001, "Wrong size on X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface");
static_assert(offsetof(X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface, ReturnValue) == 0x000000, "Member 'X6BuoyancyEffectComponent_IsActorFloatingOnWaterSurface::ReturnValue' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.OnActorBeginEnterWater
// 0x0020 (0x0020 - 0x0000)
struct X6BuoyancyEffectComponent_OnActorBeginEnterWater final
{
public:
	float                                         WaterDensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterSurfaceHeight;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentVelocity;                                   // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_OnActorBeginEnterWater) == 0x000008, "Wrong alignment on X6BuoyancyEffectComponent_OnActorBeginEnterWater");
static_assert(sizeof(X6BuoyancyEffectComponent_OnActorBeginEnterWater) == 0x000020, "Wrong size on X6BuoyancyEffectComponent_OnActorBeginEnterWater");
static_assert(offsetof(X6BuoyancyEffectComponent_OnActorBeginEnterWater, WaterDensity) == 0x000000, "Member 'X6BuoyancyEffectComponent_OnActorBeginEnterWater::WaterDensity' has a wrong offset!");
static_assert(offsetof(X6BuoyancyEffectComponent_OnActorBeginEnterWater, WaterSurfaceHeight) == 0x000004, "Member 'X6BuoyancyEffectComponent_OnActorBeginEnterWater::WaterSurfaceHeight' has a wrong offset!");
static_assert(offsetof(X6BuoyancyEffectComponent_OnActorBeginEnterWater, CurrentVelocity) == 0x000008, "Member 'X6BuoyancyEffectComponent_OnActorBeginEnterWater::CurrentVelocity' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.OnWaterDensityUdpated
// 0x0004 (0x0004 - 0x0000)
struct X6BuoyancyEffectComponent_OnWaterDensityUdpated final
{
public:
	float                                         CurrentDensity;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_OnWaterDensityUdpated) == 0x000004, "Wrong alignment on X6BuoyancyEffectComponent_OnWaterDensityUdpated");
static_assert(sizeof(X6BuoyancyEffectComponent_OnWaterDensityUdpated) == 0x000004, "Wrong size on X6BuoyancyEffectComponent_OnWaterDensityUdpated");
static_assert(offsetof(X6BuoyancyEffectComponent_OnWaterDensityUdpated, CurrentDensity) == 0x000000, "Member 'X6BuoyancyEffectComponent_OnWaterDensityUdpated::CurrentDensity' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.OnWaterSurfaceHightUdpated
// 0x0004 (0x0004 - 0x0000)
struct X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated final
{
public:
	float                                         currentHgithInWorldCoordinate;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated) == 0x000004, "Wrong alignment on X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated");
static_assert(sizeof(X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated) == 0x000004, "Wrong size on X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated");
static_assert(offsetof(X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated, currentHgithInWorldCoordinate) == 0x000000, "Member 'X6BuoyancyEffectComponent_OnWaterSurfaceHightUdpated::currentHgithInWorldCoordinate' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.OnWaterUpdateIceState
// 0x0001 (0x0001 - 0x0000)
struct X6BuoyancyEffectComponent_OnWaterUpdateIceState final
{
public:
	bool                                          bEnterOrExitIce;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_OnWaterUpdateIceState) == 0x000001, "Wrong alignment on X6BuoyancyEffectComponent_OnWaterUpdateIceState");
static_assert(sizeof(X6BuoyancyEffectComponent_OnWaterUpdateIceState) == 0x000001, "Wrong size on X6BuoyancyEffectComponent_OnWaterUpdateIceState");
static_assert(offsetof(X6BuoyancyEffectComponent_OnWaterUpdateIceState, bEnterOrExitIce) == 0x000000, "Member 'X6BuoyancyEffectComponent_OnWaterUpdateIceState::bEnterOrExitIce' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.SetActorCanSimulateBuoyancy
// 0x0001 (0x0001 - 0x0000)
struct X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy final
{
public:
	bool                                          CanSimulate;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy) == 0x000001, "Wrong alignment on X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy");
static_assert(sizeof(X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy) == 0x000001, "Wrong size on X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy");
static_assert(offsetof(X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy, CanSimulate) == 0x000000, "Member 'X6BuoyancyEffectComponent_SetActorCanSimulateBuoyancy::CanSimulate' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.SetupWaterParameter
// 0x0028 (0x0028 - 0x0000)
struct X6BuoyancyEffectComponent_SetupWaterParameter final
{
public:
	class AActor*                                 WaterActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimulateWaterFlowType                        WaterFlowType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SimulateFlowSpline;                                // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSimulateWaterFlowKeyPoint>     TrackKeyPoints;                                    // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_SetupWaterParameter) == 0x000008, "Wrong alignment on X6BuoyancyEffectComponent_SetupWaterParameter");
static_assert(sizeof(X6BuoyancyEffectComponent_SetupWaterParameter) == 0x000028, "Wrong size on X6BuoyancyEffectComponent_SetupWaterParameter");
static_assert(offsetof(X6BuoyancyEffectComponent_SetupWaterParameter, WaterActor) == 0x000000, "Member 'X6BuoyancyEffectComponent_SetupWaterParameter::WaterActor' has a wrong offset!");
static_assert(offsetof(X6BuoyancyEffectComponent_SetupWaterParameter, WaterFlowType) == 0x000008, "Member 'X6BuoyancyEffectComponent_SetupWaterParameter::WaterFlowType' has a wrong offset!");
static_assert(offsetof(X6BuoyancyEffectComponent_SetupWaterParameter, SimulateFlowSpline) == 0x000010, "Member 'X6BuoyancyEffectComponent_SetupWaterParameter::SimulateFlowSpline' has a wrong offset!");
static_assert(offsetof(X6BuoyancyEffectComponent_SetupWaterParameter, TrackKeyPoints) == 0x000018, "Member 'X6BuoyancyEffectComponent_SetupWaterParameter::TrackKeyPoints' has a wrong offset!");

// Function X6Game.X6BuoyancyEffectComponent.UpdateActorDensity
// 0x0004 (0x0004 - 0x0000)
struct X6BuoyancyEffectComponent_UpdateActorDensity final
{
public:
	float                                         NewDensity;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6BuoyancyEffectComponent_UpdateActorDensity) == 0x000004, "Wrong alignment on X6BuoyancyEffectComponent_UpdateActorDensity");
static_assert(sizeof(X6BuoyancyEffectComponent_UpdateActorDensity) == 0x000004, "Wrong size on X6BuoyancyEffectComponent_UpdateActorDensity");
static_assert(offsetof(X6BuoyancyEffectComponent_UpdateActorDensity, NewDensity) == 0x000000, "Member 'X6BuoyancyEffectComponent_UpdateActorDensity::NewDensity' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.AddBindingWithNamesAndActors
// 0x0058 (0x0058 - 0x0000)
struct X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors final
{
public:
	class ALevelSequenceActor*                    InLSActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class AActor*>            InActorsAndNames;                                  // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors");
static_assert(sizeof(X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors) == 0x000058, "Wrong size on X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors");
static_assert(offsetof(X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors, InLSActor) == 0x000000, "Member 'X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors::InLSActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors, InActorsAndNames) == 0x000008, "Member 'X6SequencerBlueprintLibrary_AddBindingWithNamesAndActors::InActorsAndNames' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.CinematicActorLookAtActor
// 0x0038 (0x0038 - 0x0000)
struct X6SequencerBlueprintLibrary_CinematicActorLookAtActor final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   Params_0;                                          // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_CinematicActorLookAtActor) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_CinematicActorLookAtActor");
static_assert(sizeof(X6SequencerBlueprintLibrary_CinematicActorLookAtActor) == 0x000038, "Wrong size on X6SequencerBlueprintLibrary_CinematicActorLookAtActor");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtActor, InEventType) == 0x000000, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtActor::InEventType' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtActor, InPlayerActor) == 0x000008, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtActor::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtActor, InTargetActor) == 0x000010, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtActor::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtActor, Params_0) == 0x000018, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtActor::Params_0' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.CinematicActorLookAtLocation
// 0x0048 (0x0048 - 0x0000)
struct X6SequencerBlueprintLibrary_CinematicActorLookAtLocation final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InTargetLocation;                                  // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   Params_0;                                          // 0x0028(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_CinematicActorLookAtLocation) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_CinematicActorLookAtLocation");
static_assert(sizeof(X6SequencerBlueprintLibrary_CinematicActorLookAtLocation) == 0x000048, "Wrong size on X6SequencerBlueprintLibrary_CinematicActorLookAtLocation");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtLocation, InEventType) == 0x000000, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtLocation::InEventType' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtLocation, InPlayerActor) == 0x000008, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtLocation::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtLocation, InTargetLocation) == 0x000010, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtLocation::InTargetLocation' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_CinematicActorLookAtLocation, Params_0) == 0x000028, "Member 'X6SequencerBlueprintLibrary_CinematicActorLookAtLocation::Params_0' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.GetAllSections
// 0x0018 (0x0018 - 0x0000)
struct X6SequencerBlueprintLibrary_GetAllSections final
{
public:
	const class UMovieSceneSequence*              MovieSceneSequence;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             OutSections;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_GetAllSections) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_GetAllSections");
static_assert(sizeof(X6SequencerBlueprintLibrary_GetAllSections) == 0x000018, "Wrong size on X6SequencerBlueprintLibrary_GetAllSections");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetAllSections, MovieSceneSequence) == 0x000000, "Member 'X6SequencerBlueprintLibrary_GetAllSections::MovieSceneSequence' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetAllSections, OutSections) == 0x000008, "Member 'X6SequencerBlueprintLibrary_GetAllSections::OutSections' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.GetAllTracks
// 0x0018 (0x0018 - 0x0000)
struct X6SequencerBlueprintLibrary_GetAllTracks final
{
public:
	const class UMovieSceneSequence*              MovieSceneSequence;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneTrack*>               OutTracks;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_GetAllTracks) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_GetAllTracks");
static_assert(sizeof(X6SequencerBlueprintLibrary_GetAllTracks) == 0x000018, "Wrong size on X6SequencerBlueprintLibrary_GetAllTracks");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetAllTracks, MovieSceneSequence) == 0x000000, "Member 'X6SequencerBlueprintLibrary_GetAllTracks::MovieSceneSequence' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetAllTracks, OutTracks) == 0x000008, "Member 'X6SequencerBlueprintLibrary_GetAllTracks::OutTracks' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.GetCastNamesInLevelSequenceByTag
// 0x0020 (0x0020 - 0x0000)
struct X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag final
{
public:
	const class ALevelSequenceActor*              InLSActor;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InTag;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutNames;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag");
static_assert(sizeof(X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag) == 0x000020, "Wrong size on X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag, InLSActor) == 0x000000, "Member 'X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag::InLSActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag, InTag) == 0x000008, "Member 'X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag::InTag' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag, OutNames) == 0x000010, "Member 'X6SequencerBlueprintLibrary_GetCastNamesInLevelSequenceByTag::OutNames' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.GetMasterTrackContents
// 0x0020 (0x0020 - 0x0000)
struct X6SequencerBlueprintLibrary_GetMasterTrackContents final
{
public:
	const class ULevelSequence*                   LevelSequence;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMovieSceneTrack>           TrackClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FX6TrackContent>                ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_GetMasterTrackContents) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_GetMasterTrackContents");
static_assert(sizeof(X6SequencerBlueprintLibrary_GetMasterTrackContents) == 0x000020, "Wrong size on X6SequencerBlueprintLibrary_GetMasterTrackContents");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetMasterTrackContents, LevelSequence) == 0x000000, "Member 'X6SequencerBlueprintLibrary_GetMasterTrackContents::LevelSequence' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetMasterTrackContents, TrackClass) == 0x000008, "Member 'X6SequencerBlueprintLibrary_GetMasterTrackContents::TrackClass' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_GetMasterTrackContents, ReturnValue) == 0x000010, "Member 'X6SequencerBlueprintLibrary_GetMasterTrackContents::ReturnValue' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.HasTrack
// 0x0020 (0x0020 - 0x0000)
struct X6SequencerBlueprintLibrary_HasTrack final
{
public:
	const class ALevelSequenceActor*              LevelSequenceActor;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMovieSceneTrack>           TrackClass;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SequencerBlueprintLibrary_HasTrack) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_HasTrack");
static_assert(sizeof(X6SequencerBlueprintLibrary_HasTrack) == 0x000020, "Wrong size on X6SequencerBlueprintLibrary_HasTrack");
static_assert(offsetof(X6SequencerBlueprintLibrary_HasTrack, LevelSequenceActor) == 0x000000, "Member 'X6SequencerBlueprintLibrary_HasTrack::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_HasTrack, Actor) == 0x000008, "Member 'X6SequencerBlueprintLibrary_HasTrack::Actor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_HasTrack, TrackClass) == 0x000010, "Member 'X6SequencerBlueprintLibrary_HasTrack::TrackClass' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_HasTrack, ReturnValue) == 0x000018, "Member 'X6SequencerBlueprintLibrary_HasTrack::ReturnValue' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.PreLoadLevelSequence
// 0x0010 (0x0010 - 0x0000)
struct X6SequencerBlueprintLibrary_PreLoadLevelSequence final
{
public:
	class ULevelSequence*                         LevelSequence;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SequencerBlueprintLibrary_PreLoadLevelSequence) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_PreLoadLevelSequence");
static_assert(sizeof(X6SequencerBlueprintLibrary_PreLoadLevelSequence) == 0x000010, "Wrong size on X6SequencerBlueprintLibrary_PreLoadLevelSequence");
static_assert(offsetof(X6SequencerBlueprintLibrary_PreLoadLevelSequence, LevelSequence) == 0x000000, "Member 'X6SequencerBlueprintLibrary_PreLoadLevelSequence::LevelSequence' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_PreLoadLevelSequence, ReturnValue) == 0x000008, "Member 'X6SequencerBlueprintLibrary_PreLoadLevelSequence::ReturnValue' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.RemoveCinematicActorLookAt
// 0x0018 (0x0018 - 0x0000)
struct X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt final
{
public:
	ELookAtEventType                              InEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InPlayerActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LookAtTargetActor;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt");
static_assert(sizeof(X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt) == 0x000018, "Wrong size on X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt");
static_assert(offsetof(X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt, InEventType) == 0x000000, "Member 'X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt::InEventType' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt, InPlayerActor) == 0x000008, "Member 'X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt::InPlayerActor' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt, LookAtTargetActor) == 0x000010, "Member 'X6SequencerBlueprintLibrary_RemoveCinematicActorLookAt::LookAtTargetActor' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.SetPreAnimatedPreviewCameraRotation
// 0x0018 (0x0018 - 0x0000)
struct X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation final
{
public:
	struct FRotator                               InRotation;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation");
static_assert(sizeof(X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation) == 0x000018, "Wrong size on X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation");
static_assert(offsetof(X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation, InRotation) == 0x000000, "Member 'X6SequencerBlueprintLibrary_SetPreAnimatedPreviewCameraRotation::InRotation' has a wrong offset!");

// Function X6Game.X6SequencerBlueprintLibrary.SetSectionIsActiveByNetPolicy
// 0x0010 (0x0010 - 0x0000)
struct X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy final
{
public:
	class UMovieSceneSequence*                    MovieSceneSequence;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovieSceneNetPolicy                          MovieSceneNetPolicy;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy) == 0x000008, "Wrong alignment on X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy");
static_assert(sizeof(X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy) == 0x000010, "Wrong size on X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy");
static_assert(offsetof(X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy, MovieSceneSequence) == 0x000000, "Member 'X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy::MovieSceneSequence' has a wrong offset!");
static_assert(offsetof(X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy, MovieSceneNetPolicy) == 0x000008, "Member 'X6SequencerBlueprintLibrary_SetSectionIsActiveByNetPolicy::MovieSceneNetPolicy' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.AddActorCustomDissolveSocket
// 0x0030 (0x0030 - 0x0000)
struct X6CameraBlueprintLibrary_AddActorCustomDissolveSocket final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecifyDissolveCondition;                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDissolveCondition                     InDissolveCondition;                               // 0x0018(0x0018)(Parm, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_AddActorCustomDissolveSocket) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_AddActorCustomDissolveSocket");
static_assert(sizeof(X6CameraBlueprintLibrary_AddActorCustomDissolveSocket) == 0x000030, "Wrong size on X6CameraBlueprintLibrary_AddActorCustomDissolveSocket");
static_assert(offsetof(X6CameraBlueprintLibrary_AddActorCustomDissolveSocket, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_AddActorCustomDissolveSocket::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_AddActorCustomDissolveSocket, InSocketName) == 0x000008, "Member 'X6CameraBlueprintLibrary_AddActorCustomDissolveSocket::InSocketName' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_AddActorCustomDissolveSocket, bSpecifyDissolveCondition) == 0x000010, "Member 'X6CameraBlueprintLibrary_AddActorCustomDissolveSocket::bSpecifyDissolveCondition' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_AddActorCustomDissolveSocket, InDissolveCondition) == 0x000018, "Member 'X6CameraBlueprintLibrary_AddActorCustomDissolveSocket::InDissolveCondition' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ApplyCameraModifierByKey
// 0x0020 (0x0020 - 0x0000)
struct X6CameraBlueprintLibrary_ApplyCameraModifierByKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConfigKey;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_ApplyCameraModifierByKey) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ApplyCameraModifierByKey");
static_assert(sizeof(X6CameraBlueprintLibrary_ApplyCameraModifierByKey) == 0x000020, "Wrong size on X6CameraBlueprintLibrary_ApplyCameraModifierByKey");
static_assert(offsetof(X6CameraBlueprintLibrary_ApplyCameraModifierByKey, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_ApplyCameraModifierByKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ApplyCameraModifierByKey, ConfigKey) == 0x000008, "Member 'X6CameraBlueprintLibrary_ApplyCameraModifierByKey::ConfigKey' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ApplyCameraModifierByKey, ReturnValue) == 0x000018, "Member 'X6CameraBlueprintLibrary_ApplyCameraModifierByKey::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.BlendBackToFollow
// 0x0028 (0x0028 - 0x0000)
struct X6CameraBlueprintLibrary_BlendBackToFollow final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            CameraBlendParams;                                 // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_BlendBackToFollow) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_BlendBackToFollow");
static_assert(sizeof(X6CameraBlueprintLibrary_BlendBackToFollow) == 0x000028, "Wrong size on X6CameraBlueprintLibrary_BlendBackToFollow");
static_assert(offsetof(X6CameraBlueprintLibrary_BlendBackToFollow, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_BlendBackToFollow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_BlendBackToFollow, CameraBlendParams) == 0x000008, "Member 'X6CameraBlueprintLibrary_BlendBackToFollow::CameraBlendParams' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.BlendBackToViewTarget
// 0x0028 (0x0028 - 0x0000)
struct X6CameraBlueprintLibrary_BlendBackToViewTarget final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_BlendBackToViewTarget) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_BlendBackToViewTarget");
static_assert(sizeof(X6CameraBlueprintLibrary_BlendBackToViewTarget) == 0x000028, "Wrong size on X6CameraBlueprintLibrary_BlendBackToViewTarget");
static_assert(offsetof(X6CameraBlueprintLibrary_BlendBackToViewTarget, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_BlendBackToViewTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_BlendBackToViewTarget, TransitionParams) == 0x000008, "Member 'X6CameraBlueprintLibrary_BlendBackToViewTarget::TransitionParams' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CameraComponentFromActor
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_CameraComponentFromActor final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_CameraComponentFromActor) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_CameraComponentFromActor");
static_assert(sizeof(X6CameraBlueprintLibrary_CameraComponentFromActor) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_CameraComponentFromActor");
static_assert(offsetof(X6CameraBlueprintLibrary_CameraComponentFromActor, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_CameraComponentFromActor::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CameraComponentFromActor, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_CameraComponentFromActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CastVOscillatorToOffsetZero
// 0x0048 (0x0048 - 0x0000)
struct X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero final
{
public:
	struct FVOscillator                           InVOscillator;                                     // 0x0000(0x0024)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           ReturnValue;                                       // 0x0024(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero) == 0x000004, "Wrong alignment on X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero");
static_assert(sizeof(X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero) == 0x000048, "Wrong size on X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero");
static_assert(offsetof(X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero, InVOscillator) == 0x000000, "Member 'X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero::InVOscillator' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero, ReturnValue) == 0x000024, "Member 'X6CameraBlueprintLibrary_CastVOscillatorToOffsetZero::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ChangeCameraState
// 0x0060 (0x0060 - 0x0000)
struct X6CameraBlueprintLibrary_ChangeCameraState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDataSpeed;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SocketOffset;                                      // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Armlength;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_ChangeCameraState) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ChangeCameraState");
static_assert(sizeof(X6CameraBlueprintLibrary_ChangeCameraState) == 0x000060, "Wrong size on X6CameraBlueprintLibrary_ChangeCameraState");
static_assert(offsetof(X6CameraBlueprintLibrary_ChangeCameraState, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_ChangeCameraState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ChangeCameraState, LerpDataSpeed) == 0x000008, "Member 'X6CameraBlueprintLibrary_ChangeCameraState::LerpDataSpeed' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ChangeCameraState, SocketOffset) == 0x000010, "Member 'X6CameraBlueprintLibrary_ChangeCameraState::SocketOffset' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ChangeCameraState, TargetOffset) == 0x000028, "Member 'X6CameraBlueprintLibrary_ChangeCameraState::TargetOffset' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ChangeCameraState, Armlength) == 0x000040, "Member 'X6CameraBlueprintLibrary_ChangeCameraState::Armlength' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ChangeCameraState, Rotation) == 0x000048, "Member 'X6CameraBlueprintLibrary_ChangeCameraState::Rotation' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CheckActorIsInScreen
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_CheckActorIsInScreen final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_CheckActorIsInScreen) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_CheckActorIsInScreen");
static_assert(sizeof(X6CameraBlueprintLibrary_CheckActorIsInScreen) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_CheckActorIsInScreen");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckActorIsInScreen, TargetActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_CheckActorIsInScreen::TargetActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckActorIsInScreen, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_CheckActorIsInScreen::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CheckAndMoveCurrentCameraToLocation
// 0x0028 (0x0028 - 0x0000)
struct X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation final
{
public:
	class UObject*                                CurrentWorld;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SettingPitch;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SettingYaw;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SettingArmLength;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleTolerance;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmLengthTolerance;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation");
static_assert(sizeof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation) == 0x000028, "Wrong size on X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, CurrentWorld) == 0x000000, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::CurrentWorld' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, SettingPitch) == 0x000008, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::SettingPitch' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, SettingYaw) == 0x00000C, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::SettingYaw' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, SettingArmLength) == 0x000010, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::SettingArmLength' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, AngleTolerance) == 0x000014, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::AngleTolerance' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, ArmLengthTolerance) == 0x000018, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::ArmLengthTolerance' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, InterpSpeed) == 0x00001C, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::InterpSpeed' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation, ReturnValue) == 0x000020, "Member 'X6CameraBlueprintLibrary_CheckAndMoveCurrentCameraToLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CheckBoundingBoxAndCenterIsInScreen
// 0x0040 (0x0040 - 0x0000)
struct X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundingBoxCenter;                                 // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundingBoxExtend;                                 // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen");
static_assert(sizeof(X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen) == 0x000040, "Wrong size on X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen, BoundingBoxCenter) == 0x000008, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen::BoundingBoxCenter' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen, BoundingBoxExtend) == 0x000020, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen::BoundingBoxExtend' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen, ReturnValue) == 0x000038, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxAndCenterIsInScreen::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CheckBoundingBoxIsInScreen
// 0x0040 (0x0040 - 0x0000)
struct X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundingBoxCenter;                                 // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundingBoxExtend;                                 // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen");
static_assert(sizeof(X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen) == 0x000040, "Wrong size on X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen, BoundingBoxCenter) == 0x000008, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen::BoundingBoxCenter' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen, BoundingBoxExtend) == 0x000020, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen::BoundingBoxExtend' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen, ReturnValue) == 0x000038, "Member 'X6CameraBlueprintLibrary_CheckBoundingBoxIsInScreen::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.CheckCameraPossessedByLevelSequence
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence");
static_assert(sizeof(X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_CheckCameraPossessedByLevelSequence::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.DoesActorImplementCameraMode
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_DoesActorImplementCameraMode final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_DoesActorImplementCameraMode) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_DoesActorImplementCameraMode");
static_assert(sizeof(X6CameraBlueprintLibrary_DoesActorImplementCameraMode) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_DoesActorImplementCameraMode");
static_assert(offsetof(X6CameraBlueprintLibrary_DoesActorImplementCameraMode, TargetActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_DoesActorImplementCameraMode::TargetActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_DoesActorImplementCameraMode, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_DoesActorImplementCameraMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.FindMostOpenSpaceRotation
// 0x0090 (0x0090 - 0x0000)
struct X6CameraBlueprintLibrary_FindMostOpenSpaceRotation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTrans;                                     // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutDeltaRot;                                       // 0x0070(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_FindMostOpenSpaceRotation) == 0x000010, "Wrong alignment on X6CameraBlueprintLibrary_FindMostOpenSpaceRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_FindMostOpenSpaceRotation) == 0x000090, "Wrong size on X6CameraBlueprintLibrary_FindMostOpenSpaceRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_FindMostOpenSpaceRotation, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_FindMostOpenSpaceRotation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_FindMostOpenSpaceRotation, RelativeTrans) == 0x000010, "Member 'X6CameraBlueprintLibrary_FindMostOpenSpaceRotation::RelativeTrans' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_FindMostOpenSpaceRotation, OutDeltaRot) == 0x000070, "Member 'X6CameraBlueprintLibrary_FindMostOpenSpaceRotation::OutDeltaRot' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_FindMostOpenSpaceRotation, ReturnValue) == 0x000088, "Member 'X6CameraBlueprintLibrary_FindMostOpenSpaceRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.FindOrAddModifierByClass
// 0x0018 (0x0018 - 0x0000)
struct X6CameraBlueprintLibrary_FindOrAddModifierByClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraModifier>            ModifierClass;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraModifier*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_FindOrAddModifierByClass) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_FindOrAddModifierByClass");
static_assert(sizeof(X6CameraBlueprintLibrary_FindOrAddModifierByClass) == 0x000018, "Wrong size on X6CameraBlueprintLibrary_FindOrAddModifierByClass");
static_assert(offsetof(X6CameraBlueprintLibrary_FindOrAddModifierByClass, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_FindOrAddModifierByClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_FindOrAddModifierByClass, ModifierClass) == 0x000008, "Member 'X6CameraBlueprintLibrary_FindOrAddModifierByClass::ModifierClass' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_FindOrAddModifierByClass, ReturnValue) == 0x000010, "Member 'X6CameraBlueprintLibrary_FindOrAddModifierByClass::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ForceUpdateCamera
// 0x0008 (0x0008 - 0x0000)
struct X6CameraBlueprintLibrary_ForceUpdateCamera final
{
public:
	class UObject*                                TargetObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_ForceUpdateCamera) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ForceUpdateCamera");
static_assert(sizeof(X6CameraBlueprintLibrary_ForceUpdateCamera) == 0x000008, "Wrong size on X6CameraBlueprintLibrary_ForceUpdateCamera");
static_assert(offsetof(X6CameraBlueprintLibrary_ForceUpdateCamera, TargetObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_ForceUpdateCamera::TargetObject' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.GetActorScreenLocation
// 0x0020 (0x0020 - 0x0000)
struct X6CameraBlueprintLibrary_GetActorScreenLocation final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_GetActorScreenLocation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_GetActorScreenLocation");
static_assert(sizeof(X6CameraBlueprintLibrary_GetActorScreenLocation) == 0x000020, "Wrong size on X6CameraBlueprintLibrary_GetActorScreenLocation");
static_assert(offsetof(X6CameraBlueprintLibrary_GetActorScreenLocation, TargetActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_GetActorScreenLocation::TargetActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetActorScreenLocation, Controller) == 0x000008, "Member 'X6CameraBlueprintLibrary_GetActorScreenLocation::Controller' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetActorScreenLocation, ReturnValue) == 0x000010, "Member 'X6CameraBlueprintLibrary_GetActorScreenLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.GetAdvancedCameraComponent
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_GetAdvancedCameraComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAdvancedCamera*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_GetAdvancedCameraComponent) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_GetAdvancedCameraComponent");
static_assert(sizeof(X6CameraBlueprintLibrary_GetAdvancedCameraComponent) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_GetAdvancedCameraComponent");
static_assert(offsetof(X6CameraBlueprintLibrary_GetAdvancedCameraComponent, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_GetAdvancedCameraComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetAdvancedCameraComponent, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_GetAdvancedCameraComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.GetGameScreenSize
// 0x0018 (0x0018 - 0x0000)
struct X6CameraBlueprintLibrary_GetGameScreenSize final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_GetGameScreenSize) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_GetGameScreenSize");
static_assert(sizeof(X6CameraBlueprintLibrary_GetGameScreenSize) == 0x000018, "Wrong size on X6CameraBlueprintLibrary_GetGameScreenSize");
static_assert(offsetof(X6CameraBlueprintLibrary_GetGameScreenSize, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_GetGameScreenSize::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetGameScreenSize, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_GetGameScreenSize::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.GetRotateTimeWithAngleSpeed
// 0x0040 (0x0040 - 0x0000)
struct X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed final
{
public:
	float                                         AngleSpeed;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StartRotation;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed");
static_assert(sizeof(X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed) == 0x000040, "Wrong size on X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed");
static_assert(offsetof(X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed, AngleSpeed) == 0x000000, "Member 'X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed::AngleSpeed' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed, StartRotation) == 0x000008, "Member 'X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed::StartRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed, EndRotation) == 0x000020, "Member 'X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed::EndRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed, ReturnValue) == 0x000038, "Member 'X6CameraBlueprintLibrary_GetRotateTimeWithAngleSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.GetX6PlayerCameraManager
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_GetX6PlayerCameraManager final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AX6PlayerCameraManager*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_GetX6PlayerCameraManager) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_GetX6PlayerCameraManager");
static_assert(sizeof(X6CameraBlueprintLibrary_GetX6PlayerCameraManager) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_GetX6PlayerCameraManager");
static_assert(offsetof(X6CameraBlueprintLibrary_GetX6PlayerCameraManager, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_GetX6PlayerCameraManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_GetX6PlayerCameraManager, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_GetX6PlayerCameraManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.IsActorLevelSequenceCameraCut
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut");
static_assert(sizeof(X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut");
static_assert(offsetof(X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut, ReturnValue) == 0x000008, "Member 'X6CameraBlueprintLibrary_IsActorLevelSequenceCameraCut::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.PopAndSwitchToLastCameraState
// 0x0030 (0x0030 - 0x0000)
struct X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0010(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState");
static_assert(sizeof(X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState) == 0x000030, "Wrong size on X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState");
static_assert(offsetof(X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState, bOverrideTransitionParams) == 0x000008, "Member 'X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState, TransitionParams) == 0x000010, "Member 'X6CameraBlueprintLibrary_PopAndSwitchToLastCameraState::TransitionParams' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.PushAndSwitchToCameraState
// 0x0040 (0x0040 - 0x0000)
struct X6CameraBlueprintLibrary_PushAndSwitchToCameraState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  NewCameraState;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0020(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_PushAndSwitchToCameraState");
static_assert(sizeof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState) == 0x000040, "Wrong size on X6CameraBlueprintLibrary_PushAndSwitchToCameraState");
static_assert(offsetof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_PushAndSwitchToCameraState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState, NewCameraState) == 0x000008, "Member 'X6CameraBlueprintLibrary_PushAndSwitchToCameraState::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState, NewTarget) == 0x000010, "Member 'X6CameraBlueprintLibrary_PushAndSwitchToCameraState::NewTarget' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState, bOverrideTransitionParams) == 0x000018, "Member 'X6CameraBlueprintLibrary_PushAndSwitchToCameraState::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushAndSwitchToCameraState, TransitionParams) == 0x000020, "Member 'X6CameraBlueprintLibrary_PushAndSwitchToCameraState::TransitionParams' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.PushCustomRotationRangeConfigForActor
// 0x0060 (0x0060 - 0x0000)
struct X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OriginRotation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinYaw;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw;                                            // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitch;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0038(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0058(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor");
static_assert(sizeof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor) == 0x000060, "Wrong size on X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, OriginRotation) == 0x000008, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::OriginRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, MinYaw) == 0x000020, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::MinYaw' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, MaxYaw) == 0x000024, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::MaxYaw' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, MinPitch) == 0x000028, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::MinPitch' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, MaxPitch) == 0x00002C, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::MaxPitch' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, bOverrideTransitionParams) == 0x000030, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, TransitionParams) == 0x000038, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::TransitionParams' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor, ReturnValue) == 0x000058, "Member 'X6CameraBlueprintLibrary_PushCustomRotationRangeConfigForActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.RecalculateCameraTransformIgnoreLag
// 0x0008 (0x0008 - 0x0000)
struct X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag final
{
public:
	class AActor*                                 ViewTarget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag");
static_assert(sizeof(X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag) == 0x000008, "Wrong size on X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag");
static_assert(offsetof(X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag, ViewTarget) == 0x000000, "Member 'X6CameraBlueprintLibrary_RecalculateCameraTransformIgnoreLag::ViewTarget' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.RemoveActorCustomDissolveSocket
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket");
static_assert(sizeof(X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket, InSocketName) == 0x000008, "Member 'X6CameraBlueprintLibrary_RemoveActorCustomDissolveSocket::InSocketName' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.RemoveCameraConfigForActor
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_RemoveCameraConfigForActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexToRemove;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_RemoveCameraConfigForActor) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_RemoveCameraConfigForActor");
static_assert(sizeof(X6CameraBlueprintLibrary_RemoveCameraConfigForActor) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_RemoveCameraConfigForActor");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraConfigForActor, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_RemoveCameraConfigForActor::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraConfigForActor, IndexToRemove) == 0x000008, "Member 'X6CameraBlueprintLibrary_RemoveCameraConfigForActor::IndexToRemove' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.RemoveCameraModifierEffectByHandle
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Handle;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle");
static_assert(sizeof(X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle, Handle) == 0x000008, "Member 'X6CameraBlueprintLibrary_RemoveCameraModifierEffectByHandle::Handle' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.RemoveCameraState
// 0x0040 (0x0040 - 0x0000)
struct X6CameraBlueprintLibrary_RemoveCameraState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  CameraStateToRemove;                               // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetToRemove;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendToTop;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTransitionParams;                         // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0020(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_RemoveCameraState) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_RemoveCameraState");
static_assert(sizeof(X6CameraBlueprintLibrary_RemoveCameraState) == 0x000040, "Wrong size on X6CameraBlueprintLibrary_RemoveCameraState");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraState, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_RemoveCameraState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraState, CameraStateToRemove) == 0x000008, "Member 'X6CameraBlueprintLibrary_RemoveCameraState::CameraStateToRemove' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraState, TargetToRemove) == 0x000010, "Member 'X6CameraBlueprintLibrary_RemoveCameraState::TargetToRemove' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraState, bBlendToTop) == 0x000018, "Member 'X6CameraBlueprintLibrary_RemoveCameraState::bBlendToTop' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraState, bOverrideTransitionParams) == 0x000019, "Member 'X6CameraBlueprintLibrary_RemoveCameraState::bOverrideTransitionParams' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RemoveCameraState, TransitionParams) == 0x000020, "Member 'X6CameraBlueprintLibrary_RemoveCameraState::TransitionParams' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ResetAdvancedCameraRotation
// 0x0008 (0x0008 - 0x0000)
struct X6CameraBlueprintLibrary_ResetAdvancedCameraRotation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_ResetAdvancedCameraRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ResetAdvancedCameraRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_ResetAdvancedCameraRotation) == 0x000008, "Wrong size on X6CameraBlueprintLibrary_ResetAdvancedCameraRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_ResetAdvancedCameraRotation, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_ResetAdvancedCameraRotation::WorldContextObject' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ResetArmLengthAndRotation
// 0x0008 (0x0008 - 0x0000)
struct X6CameraBlueprintLibrary_ResetArmLengthAndRotation final
{
public:
	class UObject*                                CurrentWorld;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_ResetArmLengthAndRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ResetArmLengthAndRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_ResetArmLengthAndRotation) == 0x000008, "Wrong size on X6CameraBlueprintLibrary_ResetArmLengthAndRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_ResetArmLengthAndRotation, CurrentWorld) == 0x000000, "Member 'X6CameraBlueprintLibrary_ResetArmLengthAndRotation::CurrentWorld' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ResetFollowCamera
// 0x0008 (0x0008 - 0x0000)
struct X6CameraBlueprintLibrary_ResetFollowCamera final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_ResetFollowCamera) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ResetFollowCamera");
static_assert(sizeof(X6CameraBlueprintLibrary_ResetFollowCamera) == 0x000008, "Wrong size on X6CameraBlueprintLibrary_ResetFollowCamera");
static_assert(offsetof(X6CameraBlueprintLibrary_ResetFollowCamera, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_ResetFollowCamera::WorldContextObject' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.ResetToDefaultRelativeRotation
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation final
{
public:
	class AActor*                                 ViewTarget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyImmediate;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation, ViewTarget) == 0x000000, "Member 'X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation::ViewTarget' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation, bApplyImmediate) == 0x000008, "Member 'X6CameraBlueprintLibrary_ResetToDefaultRelativeRotation::bApplyImmediate' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.RotatorClamp
// 0x0030 (0x0030 - 0x0000)
struct X6CameraBlueprintLibrary_RotatorClamp final
{
public:
	struct FRotator                               Rotator;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_RotatorClamp) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_RotatorClamp");
static_assert(sizeof(X6CameraBlueprintLibrary_RotatorClamp) == 0x000030, "Wrong size on X6CameraBlueprintLibrary_RotatorClamp");
static_assert(offsetof(X6CameraBlueprintLibrary_RotatorClamp, Rotator) == 0x000000, "Member 'X6CameraBlueprintLibrary_RotatorClamp::Rotator' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_RotatorClamp, ReturnValue) == 0x000018, "Member 'X6CameraBlueprintLibrary_RotatorClamp::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetActorCameraDesireRotation
// 0x0028 (0x0028 - 0x0000)
struct X6CameraBlueprintLibrary_SetActorCameraDesireRotation final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewDesireRotation;                                 // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Teleport;                                          // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetActorCameraDesireRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetActorCameraDesireRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_SetActorCameraDesireRotation) == 0x000028, "Wrong size on X6CameraBlueprintLibrary_SetActorCameraDesireRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraDesireRotation, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetActorCameraDesireRotation::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraDesireRotation, NewDesireRotation) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetActorCameraDesireRotation::NewDesireRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraDesireRotation, Teleport) == 0x000020, "Member 'X6CameraBlueprintLibrary_SetActorCameraDesireRotation::Teleport' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetActorCameraRotationLookAtTrackActor
// 0x0030 (0x0030 - 0x0000)
struct X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           ActorToTrack;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeOffset;                                    // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyImmediately;                                 // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor");
static_assert(sizeof(X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor) == 0x000030, "Wrong size on X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor, ActorToTrack) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor::ActorToTrack' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor, RelativeOffset) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor::RelativeOffset' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor, bApplyImmediately) == 0x000028, "Member 'X6CameraBlueprintLibrary_SetActorCameraRotationLookAtTrackActor::bApplyImmediately' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetActorDissolveByMesh
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_SetActorDissolveByMesh final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDissolveByMesh;                                   // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Reason;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_SetActorDissolveByMesh) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetActorDissolveByMesh");
static_assert(sizeof(X6CameraBlueprintLibrary_SetActorDissolveByMesh) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_SetActorDissolveByMesh");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveByMesh, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetActorDissolveByMesh::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveByMesh, bDissolveByMesh) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetActorDissolveByMesh::bDissolveByMesh' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveByMesh, Reason) == 0x00000C, "Member 'X6CameraBlueprintLibrary_SetActorDissolveByMesh::Reason' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetActorDissolveEnable
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_SetActorDissolveEnable final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearCurrentEffect;                               // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetActorDissolveEnable) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetActorDissolveEnable");
static_assert(sizeof(X6CameraBlueprintLibrary_SetActorDissolveEnable) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_SetActorDissolveEnable");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnable, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnable::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnable, bEnable) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnable::bEnable' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnable, bClearCurrentEffect) == 0x000009, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnable::bClearCurrentEffect' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetActorDissolveEnableByReason
// 0x0018 (0x0018 - 0x0000)
struct X6CameraBlueprintLibrary_SetActorDissolveEnableByReason final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Reason;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearCurrentEffect;                               // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetActorDissolveEnableByReason) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetActorDissolveEnableByReason");
static_assert(sizeof(X6CameraBlueprintLibrary_SetActorDissolveEnableByReason) == 0x000018, "Wrong size on X6CameraBlueprintLibrary_SetActorDissolveEnableByReason");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnableByReason, InActor) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnableByReason::InActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnableByReason, bEnable) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnableByReason::bEnable' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnableByReason, Reason) == 0x00000C, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnableByReason::Reason' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetActorDissolveEnableByReason, bClearCurrentEffect) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetActorDissolveEnableByReason::bClearCurrentEffect' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetCameraDrawDebug
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_SetCameraDrawDebug final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugEnable;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_SetCameraDrawDebug) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetCameraDrawDebug");
static_assert(sizeof(X6CameraBlueprintLibrary_SetCameraDrawDebug) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_SetCameraDrawDebug");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCameraDrawDebug, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetCameraDrawDebug::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCameraDrawDebug, bDebugEnable) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetCameraDrawDebug::bDebugEnable' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCameraDrawDebug, DrawDebugTime) == 0x00000C, "Member 'X6CameraBlueprintLibrary_SetCameraDrawDebug::DrawDebugTime' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetCamerarInputEnable
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_SetCamerarInputEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputEnable;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetCamerarInputEnable) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetCamerarInputEnable");
static_assert(sizeof(X6CameraBlueprintLibrary_SetCamerarInputEnable) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_SetCamerarInputEnable");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCamerarInputEnable, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetCamerarInputEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCamerarInputEnable, bInputEnable) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetCamerarInputEnable::bInputEnable' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetCameraViewPointWithBlend
// 0x09A0 (0x09A0 - 0x0000)
struct X6CameraBlueprintLibrary_SetCameraViewPointWithBlend final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       ViewInfo;                                          // 0x0010(0x0970)(Parm, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0980(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_SetCameraViewPointWithBlend) == 0x000010, "Wrong alignment on X6CameraBlueprintLibrary_SetCameraViewPointWithBlend");
static_assert(sizeof(X6CameraBlueprintLibrary_SetCameraViewPointWithBlend) == 0x0009A0, "Wrong size on X6CameraBlueprintLibrary_SetCameraViewPointWithBlend");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCameraViewPointWithBlend, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetCameraViewPointWithBlend::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCameraViewPointWithBlend, ViewInfo) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetCameraViewPointWithBlend::ViewInfo' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCameraViewPointWithBlend, TransitionParams) == 0x000980, "Member 'X6CameraBlueprintLibrary_SetCameraViewPointWithBlend::TransitionParams' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetCharacterFollowCameraRotation
// 0x0028 (0x0028 - 0x0000)
struct X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewDesireRotation;                                 // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Teleport;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation) == 0x000028, "Wrong size on X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation, Actor) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation::Actor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation, NewDesireRotation) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation::NewDesireRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation, Teleport) == 0x000020, "Member 'X6CameraBlueprintLibrary_SetCharacterFollowCameraRotation::Teleport' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetDesireRotation
// 0x0028 (0x0028 - 0x0000)
struct X6CameraBlueprintLibrary_SetDesireRotation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewDesireRotation;                                 // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Teleport;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetDesireRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetDesireRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_SetDesireRotation) == 0x000028, "Wrong size on X6CameraBlueprintLibrary_SetDesireRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_SetDesireRotation, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetDesireRotation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetDesireRotation, NewDesireRotation) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetDesireRotation::NewDesireRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetDesireRotation, Teleport) == 0x000020, "Member 'X6CameraBlueprintLibrary_SetDesireRotation::Teleport' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetDissolveEnable
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_SetDissolveEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Dissolve;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetDissolveEnable) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetDissolveEnable");
static_assert(sizeof(X6CameraBlueprintLibrary_SetDissolveEnable) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_SetDissolveEnable");
static_assert(offsetof(X6CameraBlueprintLibrary_SetDissolveEnable, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetDissolveEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetDissolveEnable, Dissolve) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetDissolveEnable::Dissolve' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetGlobalDissolveEnable
// 0x0010 (0x0010 - 0x0000)
struct X6CameraBlueprintLibrary_SetGlobalDissolveEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Dissolve;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetGlobalDissolveEnable) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetGlobalDissolveEnable");
static_assert(sizeof(X6CameraBlueprintLibrary_SetGlobalDissolveEnable) == 0x000010, "Wrong size on X6CameraBlueprintLibrary_SetGlobalDissolveEnable");
static_assert(offsetof(X6CameraBlueprintLibrary_SetGlobalDissolveEnable, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetGlobalDissolveEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetGlobalDissolveEnable, Dissolve) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetGlobalDissolveEnable::Dissolve' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetPassiveDesiredRotation
// 0x0030 (0x0030 - 0x0000)
struct X6CameraBlueprintLibrary_SetPassiveDesiredRotation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewDesireRotation;                                 // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AngularSpeed;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetPassiveDesiredRotation");
static_assert(sizeof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation) == 0x000030, "Wrong size on X6CameraBlueprintLibrary_SetPassiveDesiredRotation");
static_assert(offsetof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetPassiveDesiredRotation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation, NewDesireRotation) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetPassiveDesiredRotation::NewDesireRotation' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation, AngularSpeed) == 0x000020, "Member 'X6CameraBlueprintLibrary_SetPassiveDesiredRotation::AngularSpeed' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation, BlendFunction) == 0x000024, "Member 'X6CameraBlueprintLibrary_SetPassiveDesiredRotation::BlendFunction' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetPassiveDesiredRotation, BlendExp) == 0x000028, "Member 'X6CameraBlueprintLibrary_SetPassiveDesiredRotation::BlendExp' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetViewTargetAngularSpeed
// 0x0018 (0x0018 - 0x0000)
struct X6CameraBlueprintLibrary_SetViewTargetAngularSpeed final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularSpeed;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendExp;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetViewTargetAngularSpeed) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetViewTargetAngularSpeed");
static_assert(sizeof(X6CameraBlueprintLibrary_SetViewTargetAngularSpeed) == 0x000018, "Wrong size on X6CameraBlueprintLibrary_SetViewTargetAngularSpeed");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetAngularSpeed, NewViewTarget) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetViewTargetAngularSpeed::NewViewTarget' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetAngularSpeed, AngularSpeed) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetViewTargetAngularSpeed::AngularSpeed' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetAngularSpeed, BlendExp) == 0x00000C, "Member 'X6CameraBlueprintLibrary_SetViewTargetAngularSpeed::BlendExp' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetAngularSpeed, BlendFunction) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetViewTargetAngularSpeed::BlendFunction' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetViewTargetInSequence
// 0x0020 (0x0020 - 0x0000)
struct X6CameraBlueprintLibrary_SetViewTargetInSequence final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CameraActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunc;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOutgoing;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetViewTargetInSequence) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetViewTargetInSequence");
static_assert(sizeof(X6CameraBlueprintLibrary_SetViewTargetInSequence) == 0x000020, "Wrong size on X6CameraBlueprintLibrary_SetViewTargetInSequence");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetInSequence, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetViewTargetInSequence::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetInSequence, CameraActor) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetViewTargetInSequence::CameraActor' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetInSequence, BlendTime) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetViewTargetInSequence::BlendTime' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetInSequence, BlendFunc) == 0x000014, "Member 'X6CameraBlueprintLibrary_SetViewTargetInSequence::BlendFunc' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetInSequence, BlendExp) == 0x000018, "Member 'X6CameraBlueprintLibrary_SetViewTargetInSequence::BlendExp' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetInSequence, bLockOutgoing) == 0x00001C, "Member 'X6CameraBlueprintLibrary_SetViewTargetInSequence::bLockOutgoing' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetViewTargetLineSpeed
// 0x0018 (0x0018 - 0x0000)
struct X6CameraBlueprintLibrary_SetViewTargetLineSpeed final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineSpeed;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendExp;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetViewTargetLineSpeed) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetViewTargetLineSpeed");
static_assert(sizeof(X6CameraBlueprintLibrary_SetViewTargetLineSpeed) == 0x000018, "Wrong size on X6CameraBlueprintLibrary_SetViewTargetLineSpeed");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetLineSpeed, NewViewTarget) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetViewTargetLineSpeed::NewViewTarget' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetLineSpeed, LineSpeed) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetViewTargetLineSpeed::LineSpeed' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetLineSpeed, BlendExp) == 0x00000C, "Member 'X6CameraBlueprintLibrary_SetViewTargetLineSpeed::BlendExp' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetLineSpeed, BlendFunction) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetViewTargetLineSpeed::BlendFunction' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetViewTargetTeleport
// 0x0008 (0x0008 - 0x0000)
struct X6CameraBlueprintLibrary_SetViewTargetTeleport final
{
public:
	class AActor*                                 NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_SetViewTargetTeleport) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetViewTargetTeleport");
static_assert(sizeof(X6CameraBlueprintLibrary_SetViewTargetTeleport) == 0x000008, "Wrong size on X6CameraBlueprintLibrary_SetViewTargetTeleport");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetTeleport, NewTarget) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetViewTargetTeleport::NewTarget' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetViewTargetWithBlend
// 0x0020 (0x0020 - 0x0000)
struct X6CameraBlueprintLibrary_SetViewTargetWithBlend final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunc;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOutgoing;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InBlendCurve;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_SetViewTargetWithBlend) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetViewTargetWithBlend");
static_assert(sizeof(X6CameraBlueprintLibrary_SetViewTargetWithBlend) == 0x000020, "Wrong size on X6CameraBlueprintLibrary_SetViewTargetWithBlend");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithBlend, NewViewTarget) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithBlend::NewViewTarget' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithBlend, BlendTime) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithBlend::BlendTime' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithBlend, BlendFunc) == 0x00000C, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithBlend::BlendFunc' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithBlend, BlendExp) == 0x000010, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithBlend::BlendExp' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithBlend, bLockOutgoing) == 0x000014, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithBlend::bLockOutgoing' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithBlend, InBlendCurve) == 0x000018, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithBlend::InBlendCurve' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SetViewTargetWithParabolaPath
// 0x0040 (0x0040 - 0x0000)
struct X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetCurveTransitionParams       TransitionParams;                                  // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FrontViewAngleScope;                               // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHeight;                                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HeightTakePrecedence;                              // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath");
static_assert(sizeof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath) == 0x000040, "Wrong size on X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, Target) == 0x000000, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::Target' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, TransitionParams) == 0x000008, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::TransitionParams' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, FrontViewAngleScope) == 0x000028, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::FrontViewAngleScope' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, MinHeight) == 0x00002C, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::MinHeight' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, MaxHeight) == 0x000030, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::MaxHeight' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, SimFrequency) == 0x000034, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::SimFrequency' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath, HeightTakePrecedence) == 0x000038, "Member 'X6CameraBlueprintLibrary_SetViewTargetWithParabolaPath::HeightTakePrecedence' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.StartCustomizeCameraShake
// 0x0068 (0x0068 - 0x0000)
struct X6CameraBlueprintLibrary_StartCustomizeCameraShake final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FROscillator                           ROscillator;                                       // 0x0014(0x0024)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           VOscillator;                                       // 0x0038(0x0024)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FFOscillator                           Oscillator;                                        // 0x005C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_StartCustomizeCameraShake) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_StartCustomizeCameraShake");
static_assert(sizeof(X6CameraBlueprintLibrary_StartCustomizeCameraShake) == 0x000068, "Wrong size on X6CameraBlueprintLibrary_StartCustomizeCameraShake");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, Duration) == 0x000008, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::Duration' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, BlendInTime) == 0x00000C, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::BlendInTime' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, BlendOutTime) == 0x000010, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::BlendOutTime' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, ROscillator) == 0x000014, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::ROscillator' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, VOscillator) == 0x000038, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::VOscillator' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_StartCustomizeCameraShake, Oscillator) == 0x00005C, "Member 'X6CameraBlueprintLibrary_StartCustomizeCameraShake::Oscillator' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.SwitchToCameraState
// 0x0018 (0x0018 - 0x0000)
struct X6CameraBlueprintLibrary_SwitchToCameraState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  NewCameraState;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NewTarget;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_SwitchToCameraState) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_SwitchToCameraState");
static_assert(sizeof(X6CameraBlueprintLibrary_SwitchToCameraState) == 0x000018, "Wrong size on X6CameraBlueprintLibrary_SwitchToCameraState");
static_assert(offsetof(X6CameraBlueprintLibrary_SwitchToCameraState, WorldContextObject) == 0x000000, "Member 'X6CameraBlueprintLibrary_SwitchToCameraState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SwitchToCameraState, NewCameraState) == 0x000008, "Member 'X6CameraBlueprintLibrary_SwitchToCameraState::NewCameraState' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_SwitchToCameraState, NewTarget) == 0x000010, "Member 'X6CameraBlueprintLibrary_SwitchToCameraState::NewTarget' has a wrong offset!");

// Function X6Game.X6CameraBlueprintLibrary.WorldLocation2Screen
// 0x0030 (0x0030 - 0x0000)
struct X6CameraBlueprintLibrary_WorldLocation2Screen final
{
public:
	struct FVector                                WorldLocaion;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraBlueprintLibrary_WorldLocation2Screen) == 0x000008, "Wrong alignment on X6CameraBlueprintLibrary_WorldLocation2Screen");
static_assert(sizeof(X6CameraBlueprintLibrary_WorldLocation2Screen) == 0x000030, "Wrong size on X6CameraBlueprintLibrary_WorldLocation2Screen");
static_assert(offsetof(X6CameraBlueprintLibrary_WorldLocation2Screen, WorldLocaion) == 0x000000, "Member 'X6CameraBlueprintLibrary_WorldLocation2Screen::WorldLocaion' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_WorldLocation2Screen, Controller) == 0x000018, "Member 'X6CameraBlueprintLibrary_WorldLocation2Screen::Controller' has a wrong offset!");
static_assert(offsetof(X6CameraBlueprintLibrary_WorldLocation2Screen, ReturnValue) == 0x000020, "Member 'X6CameraBlueprintLibrary_WorldLocation2Screen::ReturnValue' has a wrong offset!");

// Function X6Game.X6CameraSpringArmComponent.AddCollisionIgnoreActor
// 0x0008 (0x0008 - 0x0000)
struct X6CameraSpringArmComponent_AddCollisionIgnoreActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraSpringArmComponent_AddCollisionIgnoreActor) == 0x000008, "Wrong alignment on X6CameraSpringArmComponent_AddCollisionIgnoreActor");
static_assert(sizeof(X6CameraSpringArmComponent_AddCollisionIgnoreActor) == 0x000008, "Wrong size on X6CameraSpringArmComponent_AddCollisionIgnoreActor");
static_assert(offsetof(X6CameraSpringArmComponent_AddCollisionIgnoreActor, InActor) == 0x000000, "Member 'X6CameraSpringArmComponent_AddCollisionIgnoreActor::InActor' has a wrong offset!");

// Function X6Game.X6CameraSpringArmComponent.RemoveCollisionIgnoreActor
// 0x0008 (0x0008 - 0x0000)
struct X6CameraSpringArmComponent_RemoveCollisionIgnoreActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraSpringArmComponent_RemoveCollisionIgnoreActor) == 0x000008, "Wrong alignment on X6CameraSpringArmComponent_RemoveCollisionIgnoreActor");
static_assert(sizeof(X6CameraSpringArmComponent_RemoveCollisionIgnoreActor) == 0x000008, "Wrong size on X6CameraSpringArmComponent_RemoveCollisionIgnoreActor");
static_assert(offsetof(X6CameraSpringArmComponent_RemoveCollisionIgnoreActor, InActor) == 0x000000, "Member 'X6CameraSpringArmComponent_RemoveCollisionIgnoreActor::InActor' has a wrong offset!");

// Function X6Game.X6CameraVolume.GetShapeBounds
// 0x0038 (0x0038 - 0x0000)
struct X6CameraVolume_GetShapeBounds final
{
public:
	struct FBoxSphereBounds                       ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CameraVolume_GetShapeBounds) == 0x000008, "Wrong alignment on X6CameraVolume_GetShapeBounds");
static_assert(sizeof(X6CameraVolume_GetShapeBounds) == 0x000038, "Wrong size on X6CameraVolume_GetShapeBounds");
static_assert(offsetof(X6CameraVolume_GetShapeBounds, ReturnValue) == 0x000000, "Member 'X6CameraVolume_GetShapeBounds::ReturnValue' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.AddCacheEntity
// 0x0038 (0x0038 - 0x0000)
struct X6SpawnOnViewSubsystem_AddCacheEntity final
{
public:
	int64                                         EntityID;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SpawnerID;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GroupID;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SpawnDistSqr;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_AddCacheEntity) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_AddCacheEntity");
static_assert(sizeof(X6SpawnOnViewSubsystem_AddCacheEntity) == 0x000038, "Wrong size on X6SpawnOnViewSubsystem_AddCacheEntity");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddCacheEntity, EntityID) == 0x000000, "Member 'X6SpawnOnViewSubsystem_AddCacheEntity::EntityID' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddCacheEntity, SpawnerID) == 0x000008, "Member 'X6SpawnOnViewSubsystem_AddCacheEntity::SpawnerID' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddCacheEntity, GroupID) == 0x000010, "Member 'X6SpawnOnViewSubsystem_AddCacheEntity::GroupID' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddCacheEntity, SpawnLocation) == 0x000018, "Member 'X6SpawnOnViewSubsystem_AddCacheEntity::SpawnLocation' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddCacheEntity, SpawnDistSqr) == 0x000030, "Member 'X6SpawnOnViewSubsystem_AddCacheEntity::SpawnDistSqr' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.AddSpawner
// 0x0020 (0x0020 - 0x0000)
struct X6SpawnOnViewSubsystem_AddSpawner final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SpawnerID;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EntityID;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cat;                                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_AddSpawner) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_AddSpawner");
static_assert(sizeof(X6SpawnOnViewSubsystem_AddSpawner) == 0x000020, "Wrong size on X6SpawnOnViewSubsystem_AddSpawner");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddSpawner, Actor) == 0x000000, "Member 'X6SpawnOnViewSubsystem_AddSpawner::Actor' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddSpawner, SpawnerID) == 0x000008, "Member 'X6SpawnOnViewSubsystem_AddSpawner::SpawnerID' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddSpawner, EntityID) == 0x000010, "Member 'X6SpawnOnViewSubsystem_AddSpawner::EntityID' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_AddSpawner, Cat) == 0x000018, "Member 'X6SpawnOnViewSubsystem_AddSpawner::Cat' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.CheckEntitySpawnOnView
// 0x0010 (0x0010 - 0x0000)
struct X6SpawnOnViewSubsystem_CheckEntitySpawnOnView final
{
public:
	TArray<int64>                                 NeedSpawnEntities;                                 // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_CheckEntitySpawnOnView) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_CheckEntitySpawnOnView");
static_assert(sizeof(X6SpawnOnViewSubsystem_CheckEntitySpawnOnView) == 0x000010, "Wrong size on X6SpawnOnViewSubsystem_CheckEntitySpawnOnView");
static_assert(offsetof(X6SpawnOnViewSubsystem_CheckEntitySpawnOnView, NeedSpawnEntities) == 0x000000, "Member 'X6SpawnOnViewSubsystem_CheckEntitySpawnOnView::NeedSpawnEntities' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.ForceRemoveCahceEntity
// 0x0008 (0x0008 - 0x0000)
struct X6SpawnOnViewSubsystem_ForceRemoveCahceEntity final
{
public:
	int64                                         EntityID;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_ForceRemoveCahceEntity) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_ForceRemoveCahceEntity");
static_assert(sizeof(X6SpawnOnViewSubsystem_ForceRemoveCahceEntity) == 0x000008, "Wrong size on X6SpawnOnViewSubsystem_ForceRemoveCahceEntity");
static_assert(offsetof(X6SpawnOnViewSubsystem_ForceRemoveCahceEntity, EntityID) == 0x000000, "Member 'X6SpawnOnViewSubsystem_ForceRemoveCahceEntity::EntityID' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.GetSpawnSystemStatistics
// 0x0010 (0x0010 - 0x0000)
struct X6SpawnOnViewSubsystem_GetSpawnSystemStatistics final
{
public:
	int64                                         SpawnerNum;                                        // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SkippedNum;                                        // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_GetSpawnSystemStatistics) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_GetSpawnSystemStatistics");
static_assert(sizeof(X6SpawnOnViewSubsystem_GetSpawnSystemStatistics) == 0x000010, "Wrong size on X6SpawnOnViewSubsystem_GetSpawnSystemStatistics");
static_assert(offsetof(X6SpawnOnViewSubsystem_GetSpawnSystemStatistics, SpawnerNum) == 0x000000, "Member 'X6SpawnOnViewSubsystem_GetSpawnSystemStatistics::SpawnerNum' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_GetSpawnSystemStatistics, SkippedNum) == 0x000008, "Member 'X6SpawnOnViewSubsystem_GetSpawnSystemStatistics::SkippedNum' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.RemoveSpawner
// 0x0010 (0x0010 - 0x0000)
struct X6SpawnOnViewSubsystem_RemoveSpawner final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cat;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_RemoveSpawner) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_RemoveSpawner");
static_assert(sizeof(X6SpawnOnViewSubsystem_RemoveSpawner) == 0x000010, "Wrong size on X6SpawnOnViewSubsystem_RemoveSpawner");
static_assert(offsetof(X6SpawnOnViewSubsystem_RemoveSpawner, Actor) == 0x000000, "Member 'X6SpawnOnViewSubsystem_RemoveSpawner::Actor' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_RemoveSpawner, Cat) == 0x000008, "Member 'X6SpawnOnViewSubsystem_RemoveSpawner::Cat' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.ResetSpawnerGroup
// 0x0018 (0x0018 - 0x0000)
struct X6SpawnOnViewSubsystem_ResetSpawnerGroup final
{
public:
	int64                                         GroupID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 SpawnerIDS;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_ResetSpawnerGroup) == 0x000008, "Wrong alignment on X6SpawnOnViewSubsystem_ResetSpawnerGroup");
static_assert(sizeof(X6SpawnOnViewSubsystem_ResetSpawnerGroup) == 0x000018, "Wrong size on X6SpawnOnViewSubsystem_ResetSpawnerGroup");
static_assert(offsetof(X6SpawnOnViewSubsystem_ResetSpawnerGroup, GroupID) == 0x000000, "Member 'X6SpawnOnViewSubsystem_ResetSpawnerGroup::GroupID' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_ResetSpawnerGroup, SpawnerIDS) == 0x000008, "Member 'X6SpawnOnViewSubsystem_ResetSpawnerGroup::SpawnerIDS' has a wrong offset!");

// Function X6Game.X6SpawnOnViewSubsystem.SetSystemParams
// 0x0008 (0x0008 - 0x0000)
struct X6SpawnOnViewSubsystem_SetSystemParams final
{
public:
	int32                                         OnScreenLimitHiddenFlag;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearSpawnerDist;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SpawnOnViewSubsystem_SetSystemParams) == 0x000004, "Wrong alignment on X6SpawnOnViewSubsystem_SetSystemParams");
static_assert(sizeof(X6SpawnOnViewSubsystem_SetSystemParams) == 0x000008, "Wrong size on X6SpawnOnViewSubsystem_SetSystemParams");
static_assert(offsetof(X6SpawnOnViewSubsystem_SetSystemParams, OnScreenLimitHiddenFlag) == 0x000000, "Member 'X6SpawnOnViewSubsystem_SetSystemParams::OnScreenLimitHiddenFlag' has a wrong offset!");
static_assert(offsetof(X6SpawnOnViewSubsystem_SetSystemParams, NearSpawnerDist) == 0x000004, "Member 'X6SpawnOnViewSubsystem_SetSystemParams::NearSpawnerDist' has a wrong offset!");

// Function X6Game.X6CarrierCharacterBase.GetMoveGoalReachTestInternal
// 0x0040 (0x0040 - 0x0000)
struct X6CarrierCharacterBase_GetMoveGoalReachTestInternal final
{
public:
	const class AActor*                           MovingActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveOffset;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalOffset;                                        // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalRadius;                                        // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalHalfHeight;                                    // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal) == 0x000008, "Wrong alignment on X6CarrierCharacterBase_GetMoveGoalReachTestInternal");
static_assert(sizeof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal) == 0x000040, "Wrong size on X6CarrierCharacterBase_GetMoveGoalReachTestInternal");
static_assert(offsetof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal, MovingActor) == 0x000000, "Member 'X6CarrierCharacterBase_GetMoveGoalReachTestInternal::MovingActor' has a wrong offset!");
static_assert(offsetof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal, MoveOffset) == 0x000008, "Member 'X6CarrierCharacterBase_GetMoveGoalReachTestInternal::MoveOffset' has a wrong offset!");
static_assert(offsetof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal, GoalOffset) == 0x000020, "Member 'X6CarrierCharacterBase_GetMoveGoalReachTestInternal::GoalOffset' has a wrong offset!");
static_assert(offsetof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal, GoalRadius) == 0x000038, "Member 'X6CarrierCharacterBase_GetMoveGoalReachTestInternal::GoalRadius' has a wrong offset!");
static_assert(offsetof(X6CarrierCharacterBase_GetMoveGoalReachTestInternal, GoalHalfHeight) == 0x00003C, "Member 'X6CarrierCharacterBase_GetMoveGoalReachTestInternal::GoalHalfHeight' has a wrong offset!");

// Function X6Game.X6RootMotionModifier_SkewWarpWithMirror.AddRootMotionModifierSkewWarpWithMirror
// 0x00B0 (0x00B0 - 0x0000)
struct X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror final
{
public:
	class UMotionWarpingComponent*                InMotionWarpingComp;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimSequenceBase*                InAnimation;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStartTime;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InEndTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InWarpTargetName;                                  // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWarpPointAnimProvider                        InWarpPointAnimProvider;                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InWarpPointAnimTransform;                          // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InWarpPointAnimBoneName;                           // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInWarpTranslation;                                // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIgnoreZAxis;                                    // 0x0099(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInWarpRotation;                                   // 0x009A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionWarpRotationType                       InRotationType;                                    // 0x009B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionWarpRotationMethod                     InRotationMethod;                                  // 0x009C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InWarpRotationTimeMultiplier;                      // 0x00A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWarpMaxRotationRate;                             // 0x00A4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6RootMotionModifier_SkewWarpWithMirror* ReturnValue;                                     // 0x00A8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror) == 0x000010, "Wrong alignment on X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror");
static_assert(sizeof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror) == 0x0000B0, "Wrong size on X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InMotionWarpingComp) == 0x000000, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InMotionWarpingComp' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InAnimation) == 0x000008, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InAnimation' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InStartTime) == 0x000010, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InStartTime' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InEndTime) == 0x000014, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InEndTime' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InWarpTargetName) == 0x000018, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InWarpTargetName' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InWarpPointAnimProvider) == 0x000020, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InWarpPointAnimProvider' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InWarpPointAnimTransform) == 0x000030, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InWarpPointAnimTransform' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InWarpPointAnimBoneName) == 0x000090, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InWarpPointAnimBoneName' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, bInWarpTranslation) == 0x000098, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::bInWarpTranslation' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, bInIgnoreZAxis) == 0x000099, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::bInIgnoreZAxis' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, bInWarpRotation) == 0x00009A, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::bInWarpRotation' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InRotationType) == 0x00009B, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InRotationType' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InRotationMethod) == 0x00009C, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InRotationMethod' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InWarpRotationTimeMultiplier) == 0x0000A0, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InWarpRotationTimeMultiplier' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, InWarpMaxRotationRate) == 0x0000A4, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::InWarpMaxRotationRate' has a wrong offset!");
static_assert(offsetof(X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror, ReturnValue) == 0x0000A8, "Member 'X6RootMotionModifier_SkewWarpWithMirror_AddRootMotionModifierSkewWarpWithMirror::ReturnValue' has a wrong offset!");

// Function X6Game.X6UtcPlayerInputComponent.HandleTouchEvent
// 0x0020 (0x0020 - 0x0000)
struct X6UtcPlayerInputComponent_HandleTouchEvent final
{
public:
	EX6InputTouchEvent                            X6InputTouchEvent;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETouchIndex                                   FingerIndex;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6UtcPlayerInputComponent_HandleTouchEvent) == 0x000008, "Wrong alignment on X6UtcPlayerInputComponent_HandleTouchEvent");
static_assert(sizeof(X6UtcPlayerInputComponent_HandleTouchEvent) == 0x000020, "Wrong size on X6UtcPlayerInputComponent_HandleTouchEvent");
static_assert(offsetof(X6UtcPlayerInputComponent_HandleTouchEvent, X6InputTouchEvent) == 0x000000, "Member 'X6UtcPlayerInputComponent_HandleTouchEvent::X6InputTouchEvent' has a wrong offset!");
static_assert(offsetof(X6UtcPlayerInputComponent_HandleTouchEvent, FingerIndex) == 0x000001, "Member 'X6UtcPlayerInputComponent_HandleTouchEvent::FingerIndex' has a wrong offset!");
static_assert(offsetof(X6UtcPlayerInputComponent_HandleTouchEvent, Location) == 0x000008, "Member 'X6UtcPlayerInputComponent_HandleTouchEvent::Location' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.AddCustomDissolveSocket
// 0x0028 (0x0028 - 0x0000)
struct X6CharacterVisualEffectComponent_AddCustomDissolveSocket final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecifyDissolveCondition;                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDissolveCondition                     InDissolveCondition;                               // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_AddCustomDissolveSocket) == 0x000008, "Wrong alignment on X6CharacterVisualEffectComponent_AddCustomDissolveSocket");
static_assert(sizeof(X6CharacterVisualEffectComponent_AddCustomDissolveSocket) == 0x000028, "Wrong size on X6CharacterVisualEffectComponent_AddCustomDissolveSocket");
static_assert(offsetof(X6CharacterVisualEffectComponent_AddCustomDissolveSocket, InSocketName) == 0x000000, "Member 'X6CharacterVisualEffectComponent_AddCustomDissolveSocket::InSocketName' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_AddCustomDissolveSocket, bSpecifyDissolveCondition) == 0x000008, "Member 'X6CharacterVisualEffectComponent_AddCustomDissolveSocket::bSpecifyDissolveCondition' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_AddCustomDissolveSocket, InDissolveCondition) == 0x000010, "Member 'X6CharacterVisualEffectComponent_AddCustomDissolveSocket::InDissolveCondition' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.AppendCustomDissolveSocket
// 0x0050 (0x0050 - 0x0000)
struct X6CharacterVisualEffectComponent_AppendCustomDissolveSocket final
{
public:
	TMap<class FName, struct FDissolveCondition>  InDissolveSocketMap;                               // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_AppendCustomDissolveSocket) == 0x000008, "Wrong alignment on X6CharacterVisualEffectComponent_AppendCustomDissolveSocket");
static_assert(sizeof(X6CharacterVisualEffectComponent_AppendCustomDissolveSocket) == 0x000050, "Wrong size on X6CharacterVisualEffectComponent_AppendCustomDissolveSocket");
static_assert(offsetof(X6CharacterVisualEffectComponent_AppendCustomDissolveSocket, InDissolveSocketMap) == 0x000000, "Member 'X6CharacterVisualEffectComponent_AppendCustomDissolveSocket::InDissolveSocketMap' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.RemoveCustomDissolveSocket
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket) == 0x000004, "Wrong alignment on X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket");
static_assert(sizeof(X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket) == 0x000008, "Wrong size on X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket");
static_assert(offsetof(X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket, InSocketName) == 0x000000, "Member 'X6CharacterVisualEffectComponent_RemoveCustomDissolveSocket::InSocketName' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.SetDissolveByMesh
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterVisualEffectComponent_SetDissolveByMesh final
{
public:
	bool                                          bInDissolveByMesh;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Reason;                                            // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_SetDissolveByMesh) == 0x000004, "Wrong alignment on X6CharacterVisualEffectComponent_SetDissolveByMesh");
static_assert(sizeof(X6CharacterVisualEffectComponent_SetDissolveByMesh) == 0x000008, "Wrong size on X6CharacterVisualEffectComponent_SetDissolveByMesh");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveByMesh, bInDissolveByMesh) == 0x000000, "Member 'X6CharacterVisualEffectComponent_SetDissolveByMesh::bInDissolveByMesh' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveByMesh, Reason) == 0x000004, "Member 'X6CharacterVisualEffectComponent_SetDissolveByMesh::Reason' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.SetDissolveEnable
// 0x0002 (0x0002 - 0x0000)
struct X6CharacterVisualEffectComponent_SetDissolveEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearCurrentEffect;                               // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_SetDissolveEnable) == 0x000001, "Wrong alignment on X6CharacterVisualEffectComponent_SetDissolveEnable");
static_assert(sizeof(X6CharacterVisualEffectComponent_SetDissolveEnable) == 0x000002, "Wrong size on X6CharacterVisualEffectComponent_SetDissolveEnable");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveEnable, bEnable) == 0x000000, "Member 'X6CharacterVisualEffectComponent_SetDissolveEnable::bEnable' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveEnable, bClearCurrentEffect) == 0x000001, "Member 'X6CharacterVisualEffectComponent_SetDissolveEnable::bClearCurrentEffect' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.SetDissolveEnableByReason
// 0x000C (0x000C - 0x0000)
struct X6CharacterVisualEffectComponent_SetDissolveEnableByReason final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Reason;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearCurrentEffect;                               // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterVisualEffectComponent_SetDissolveEnableByReason) == 0x000004, "Wrong alignment on X6CharacterVisualEffectComponent_SetDissolveEnableByReason");
static_assert(sizeof(X6CharacterVisualEffectComponent_SetDissolveEnableByReason) == 0x00000C, "Wrong size on X6CharacterVisualEffectComponent_SetDissolveEnableByReason");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveEnableByReason, bEnable) == 0x000000, "Member 'X6CharacterVisualEffectComponent_SetDissolveEnableByReason::bEnable' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveEnableByReason, Reason) == 0x000004, "Member 'X6CharacterVisualEffectComponent_SetDissolveEnableByReason::Reason' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_SetDissolveEnableByReason, bClearCurrentEffect) == 0x000008, "Member 'X6CharacterVisualEffectComponent_SetDissolveEnableByReason::bClearCurrentEffect' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.UpdateDissolveEffect
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterVisualEffectComponent_UpdateDissolveEffect final
{
public:
	float                                         InDissolveValue;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_UpdateDissolveEffect) == 0x000004, "Wrong alignment on X6CharacterVisualEffectComponent_UpdateDissolveEffect");
static_assert(sizeof(X6CharacterVisualEffectComponent_UpdateDissolveEffect) == 0x000004, "Wrong size on X6CharacterVisualEffectComponent_UpdateDissolveEffect");
static_assert(offsetof(X6CharacterVisualEffectComponent_UpdateDissolveEffect, InDissolveValue) == 0x000000, "Member 'X6CharacterVisualEffectComponent_UpdateDissolveEffect::InDissolveValue' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.UpdateDissolveEffectInTime
// 0x0008 (0x0008 - 0x0000)
struct X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime final
{
public:
	float                                         InDissolveValue;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolveTime;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime) == 0x000004, "Wrong alignment on X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime");
static_assert(sizeof(X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime) == 0x000008, "Wrong size on X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime");
static_assert(offsetof(X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime, InDissolveValue) == 0x000000, "Member 'X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime::InDissolveValue' has a wrong offset!");
static_assert(offsetof(X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime, DissolveTime) == 0x000004, "Member 'X6CharacterVisualEffectComponent_UpdateDissolveEffectInTime::DissolveTime' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.GetDissolveByMeshReasons
// 0x0050 (0x0050 - 0x0000)
struct X6CharacterVisualEffectComponent_GetDissolveByMeshReasons final
{
public:
	TSet<int32>                                   ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_GetDissolveByMeshReasons) == 0x000008, "Wrong alignment on X6CharacterVisualEffectComponent_GetDissolveByMeshReasons");
static_assert(sizeof(X6CharacterVisualEffectComponent_GetDissolveByMeshReasons) == 0x000050, "Wrong size on X6CharacterVisualEffectComponent_GetDissolveByMeshReasons");
static_assert(offsetof(X6CharacterVisualEffectComponent_GetDissolveByMeshReasons, ReturnValue) == 0x000000, "Member 'X6CharacterVisualEffectComponent_GetDissolveByMeshReasons::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterVisualEffectComponent.GetDissolveDisableReasons
// 0x0050 (0x0050 - 0x0000)
struct X6CharacterVisualEffectComponent_GetDissolveDisableReasons final
{
public:
	TSet<int32>                                   ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterVisualEffectComponent_GetDissolveDisableReasons) == 0x000008, "Wrong alignment on X6CharacterVisualEffectComponent_GetDissolveDisableReasons");
static_assert(sizeof(X6CharacterVisualEffectComponent_GetDissolveDisableReasons) == 0x000050, "Wrong size on X6CharacterVisualEffectComponent_GetDissolveDisableReasons");
static_assert(offsetof(X6CharacterVisualEffectComponent_GetDissolveDisableReasons, ReturnValue) == 0x000000, "Member 'X6CharacterVisualEffectComponent_GetDissolveDisableReasons::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.AddDisplayDebugValue
// 0x0020 (0x0020 - 0x0000)
struct X6CharacterEffectComponent_AddDisplayDebugValue final
{
public:
	class FString                                 ValueName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ValueString;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_AddDisplayDebugValue) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_AddDisplayDebugValue");
static_assert(sizeof(X6CharacterEffectComponent_AddDisplayDebugValue) == 0x000020, "Wrong size on X6CharacterEffectComponent_AddDisplayDebugValue");
static_assert(offsetof(X6CharacterEffectComponent_AddDisplayDebugValue, ValueName) == 0x000000, "Member 'X6CharacterEffectComponent_AddDisplayDebugValue::ValueName' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_AddDisplayDebugValue, ValueString) == 0x000010, "Member 'X6CharacterEffectComponent_AddDisplayDebugValue::ValueString' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.DestroyOwnerDecalComponent
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterEffectComponent_DestroyOwnerDecalComponent final
{
public:
	bool                                          bDestroyImmediately;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_DestroyOwnerDecalComponent) == 0x000001, "Wrong alignment on X6CharacterEffectComponent_DestroyOwnerDecalComponent");
static_assert(sizeof(X6CharacterEffectComponent_DestroyOwnerDecalComponent) == 0x000001, "Wrong size on X6CharacterEffectComponent_DestroyOwnerDecalComponent");
static_assert(offsetof(X6CharacterEffectComponent_DestroyOwnerDecalComponent, bDestroyImmediately) == 0x000000, "Member 'X6CharacterEffectComponent_DestroyOwnerDecalComponent::bDestroyImmediately' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.GetFootstepEffectConfigInWater
// 0x0090 (0x0090 - 0x0000)
struct X6CharacterEffectComponent_GetFootstepEffectConfigInWater final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              InSurfaceType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          OutNiagaraSystemRef;                               // 0x0010(0x0028)(Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFootprintConfig                       OutFootprintConfig;                                // 0x0038(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          OutConstantEffect;                                 // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_GetFootstepEffectConfigInWater");
static_assert(sizeof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater) == 0x000090, "Wrong size on X6CharacterEffectComponent_GetFootstepEffectConfigInWater");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater, RowName) == 0x000000, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigInWater::RowName' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater, InSurfaceType) == 0x000008, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigInWater::InSurfaceType' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater, OutNiagaraSystemRef) == 0x000010, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigInWater::OutNiagaraSystemRef' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater, OutFootprintConfig) == 0x000038, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigInWater::OutFootprintConfig' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigInWater, OutConstantEffect) == 0x000088, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigInWater::OutConstantEffect' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.GetFootstepEffectConfigOnGround
// 0x0088 (0x0088 - 0x0000)
struct X6CharacterEffectComponent_GetFootstepEffectConfigOnGround final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              InSurfaceType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          OutNiagaraSystemRef;                               // 0x0010(0x0028)(Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFootprintConfig                       OutFootprintConfig;                                // 0x0038(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_GetFootstepEffectConfigOnGround) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_GetFootstepEffectConfigOnGround");
static_assert(sizeof(X6CharacterEffectComponent_GetFootstepEffectConfigOnGround) == 0x000088, "Wrong size on X6CharacterEffectComponent_GetFootstepEffectConfigOnGround");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigOnGround, RowName) == 0x000000, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigOnGround::RowName' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigOnGround, InSurfaceType) == 0x000008, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigOnGround::InSurfaceType' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigOnGround, OutNiagaraSystemRef) == 0x000010, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigOnGround::OutNiagaraSystemRef' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepEffectConfigOnGround, OutFootprintConfig) == 0x000038, "Member 'X6CharacterEffectComponent_GetFootstepEffectConfigOnGround::OutFootprintConfig' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.GetOwnerFloorSurfaceType
// 0x0120 (0x0120 - 0x0000)
struct X6CharacterEffectComponent_GetOwnerFloorSurfaceType final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAccurateTraceLocation;                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHitResult;                                      // 0x0020(0x00F8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EPhysicalSurface                              OutSurfaceType;                                    // 0x0118(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0119(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_GetOwnerFloorSurfaceType");
static_assert(sizeof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType) == 0x000120, "Wrong size on X6CharacterEffectComponent_GetOwnerFloorSurfaceType");
static_assert(offsetof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType, InLocation) == 0x000000, "Member 'X6CharacterEffectComponent_GetOwnerFloorSurfaceType::InLocation' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType, bUseAccurateTraceLocation) == 0x000018, "Member 'X6CharacterEffectComponent_GetOwnerFloorSurfaceType::bUseAccurateTraceLocation' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType, OutHitResult) == 0x000020, "Member 'X6CharacterEffectComponent_GetOwnerFloorSurfaceType::OutHitResult' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType, OutSurfaceType) == 0x000118, "Member 'X6CharacterEffectComponent_GetOwnerFloorSurfaceType::OutSurfaceType' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_GetOwnerFloorSurfaceType, ReturnValue) == 0x000119, "Member 'X6CharacterEffectComponent_GetOwnerFloorSurfaceType::ReturnValue' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.OnEnterShrubArea
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterEffectComponent_OnEnterShrubArea final
{
public:
	int32                                         InShrubType;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_OnEnterShrubArea) == 0x000004, "Wrong alignment on X6CharacterEffectComponent_OnEnterShrubArea");
static_assert(sizeof(X6CharacterEffectComponent_OnEnterShrubArea) == 0x000004, "Wrong size on X6CharacterEffectComponent_OnEnterShrubArea");
static_assert(offsetof(X6CharacterEffectComponent_OnEnterShrubArea, InShrubType) == 0x000000, "Member 'X6CharacterEffectComponent_OnEnterShrubArea::InShrubType' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.PlayFootstepEffect
// 0x0068 (0x0068 - 0x0000)
struct X6CharacterEffectComponent_PlayFootstepEffect final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RowName;                                           // 0x005C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CharacterEffectComponent_PlayFootstepEffect) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_PlayFootstepEffect");
static_assert(sizeof(X6CharacterEffectComponent_PlayFootstepEffect) == 0x000068, "Wrong size on X6CharacterEffectComponent_PlayFootstepEffect");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, MeshComponent) == 0x000000, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::MeshComponent' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, SocketName) == 0x000008, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::SocketName' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, LocationOffset) == 0x000010, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, RotationOffset) == 0x000028, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, Scale) == 0x000040, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::Scale' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, bAttached) == 0x000058, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::bAttached' has a wrong offset!");
static_assert(offsetof(X6CharacterEffectComponent_PlayFootstepEffect, RowName) == 0x00005C, "Member 'X6CharacterEffectComponent_PlayFootstepEffect::RowName' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.SetConfigDeepWaterDepth
// 0x0004 (0x0004 - 0x0000)
struct X6CharacterEffectComponent_SetConfigDeepWaterDepth final
{
public:
	float                                         InDepth;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_SetConfigDeepWaterDepth) == 0x000004, "Wrong alignment on X6CharacterEffectComponent_SetConfigDeepWaterDepth");
static_assert(sizeof(X6CharacterEffectComponent_SetConfigDeepWaterDepth) == 0x000004, "Wrong size on X6CharacterEffectComponent_SetConfigDeepWaterDepth");
static_assert(offsetof(X6CharacterEffectComponent_SetConfigDeepWaterDepth, InDepth) == 0x000000, "Member 'X6CharacterEffectComponent_SetConfigDeepWaterDepth::InDepth' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.SetCurrentEnvironmentType
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterEffectComponent_SetCurrentEnvironmentType final
{
public:
	EFootstepEffectEnvironmentType                InEnvironmentType;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_SetCurrentEnvironmentType) == 0x000001, "Wrong alignment on X6CharacterEffectComponent_SetCurrentEnvironmentType");
static_assert(sizeof(X6CharacterEffectComponent_SetCurrentEnvironmentType) == 0x000001, "Wrong size on X6CharacterEffectComponent_SetCurrentEnvironmentType");
static_assert(offsetof(X6CharacterEffectComponent_SetCurrentEnvironmentType, InEnvironmentType) == 0x000000, "Member 'X6CharacterEffectComponent_SetCurrentEnvironmentType::InEnvironmentType' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.SetCurrentShoeType
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterEffectComponent_SetCurrentShoeType final
{
public:
	EFootstepEffectShoeType                       InShoeType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_SetCurrentShoeType) == 0x000001, "Wrong alignment on X6CharacterEffectComponent_SetCurrentShoeType");
static_assert(sizeof(X6CharacterEffectComponent_SetCurrentShoeType) == 0x000001, "Wrong size on X6CharacterEffectComponent_SetCurrentShoeType");
static_assert(offsetof(X6CharacterEffectComponent_SetCurrentShoeType, InShoeType) == 0x000000, "Member 'X6CharacterEffectComponent_SetCurrentShoeType::InShoeType' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.SetCurrentSurfaceType
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterEffectComponent_SetCurrentSurfaceType final
{
public:
	EPhysicalSurface                              InSurfaceType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_SetCurrentSurfaceType) == 0x000001, "Wrong alignment on X6CharacterEffectComponent_SetCurrentSurfaceType");
static_assert(sizeof(X6CharacterEffectComponent_SetCurrentSurfaceType) == 0x000001, "Wrong size on X6CharacterEffectComponent_SetCurrentSurfaceType");
static_assert(offsetof(X6CharacterEffectComponent_SetCurrentSurfaceType, InSurfaceType) == 0x000000, "Member 'X6CharacterEffectComponent_SetCurrentSurfaceType::InSurfaceType' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.SetEnableFootstepDebug
// 0x0001 (0x0001 - 0x0000)
struct X6CharacterEffectComponent_SetEnableFootstepDebug final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_SetEnableFootstepDebug) == 0x000001, "Wrong alignment on X6CharacterEffectComponent_SetEnableFootstepDebug");
static_assert(sizeof(X6CharacterEffectComponent_SetEnableFootstepDebug) == 0x000001, "Wrong size on X6CharacterEffectComponent_SetEnableFootstepDebug");
static_assert(offsetof(X6CharacterEffectComponent_SetEnableFootstepDebug, bEnable) == 0x000000, "Member 'X6CharacterEffectComponent_SetEnableFootstepDebug::bEnable' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.UpdateFootstepNiagaraSystemParamOverrideMap
// 0x0050 (0x0050 - 0x0000)
struct X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap final
{
public:
	TMap<class FName, float>                      InParamMap;                                        // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap");
static_assert(sizeof(X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap) == 0x000050, "Wrong size on X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap");
static_assert(offsetof(X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap, InParamMap) == 0x000000, "Member 'X6CharacterEffectComponent_UpdateFootstepNiagaraSystemParamOverrideMap::InParamMap' has a wrong offset!");

// Function X6Game.X6CharacterEffectComponent.GetFootstepNiagaraSystemParamOverrideMap
// 0x0050 (0x0050 - 0x0000)
struct X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap final
{
public:
	TMap<class FName, float>                      ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap) == 0x000008, "Wrong alignment on X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap");
static_assert(sizeof(X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap) == 0x000050, "Wrong size on X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap");
static_assert(offsetof(X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap, ReturnValue) == 0x000000, "Member 'X6CharacterEffectComponent_GetFootstepNiagaraSystemParamOverrideMap::ReturnValue' has a wrong offset!");

// Function X6Game.X6StrafeMovementComponent.K2_UpdateMovingState
// 0x0001 (0x0001 - 0x0000)
struct X6StrafeMovementComponent_K2_UpdateMovingState final
{
public:
	bool                                          bNewMoveFlag;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6StrafeMovementComponent_K2_UpdateMovingState) == 0x000001, "Wrong alignment on X6StrafeMovementComponent_K2_UpdateMovingState");
static_assert(sizeof(X6StrafeMovementComponent_K2_UpdateMovingState) == 0x000001, "Wrong size on X6StrafeMovementComponent_K2_UpdateMovingState");
static_assert(offsetof(X6StrafeMovementComponent_K2_UpdateMovingState, bNewMoveFlag) == 0x000000, "Member 'X6StrafeMovementComponent_K2_UpdateMovingState::bNewMoveFlag' has a wrong offset!");

// Function X6Game.X6StrafeMovementComponent.CalcTurnAroundAngle
// 0x0038 (0x0038 - 0x0000)
struct X6StrafeMovementComponent_CalcTurnAroundAngle final
{
public:
	struct FVector                                InputDirection;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardVector;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6StrafeMovementComponent_CalcTurnAroundAngle) == 0x000008, "Wrong alignment on X6StrafeMovementComponent_CalcTurnAroundAngle");
static_assert(sizeof(X6StrafeMovementComponent_CalcTurnAroundAngle) == 0x000038, "Wrong size on X6StrafeMovementComponent_CalcTurnAroundAngle");
static_assert(offsetof(X6StrafeMovementComponent_CalcTurnAroundAngle, InputDirection) == 0x000000, "Member 'X6StrafeMovementComponent_CalcTurnAroundAngle::InputDirection' has a wrong offset!");
static_assert(offsetof(X6StrafeMovementComponent_CalcTurnAroundAngle, ForwardVector) == 0x000018, "Member 'X6StrafeMovementComponent_CalcTurnAroundAngle::ForwardVector' has a wrong offset!");
static_assert(offsetof(X6StrafeMovementComponent_CalcTurnAroundAngle, ReturnValue) == 0x000030, "Member 'X6StrafeMovementComponent_CalcTurnAroundAngle::ReturnValue' has a wrong offset!");

// Function X6Game.X6CheatManager.X6ChangeSize
// 0x0004 (0x0004 - 0x0000)
struct X6CheatManager_X6ChangeSize final
{
public:
	float                                         F;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CheatManager_X6ChangeSize) == 0x000004, "Wrong alignment on X6CheatManager_X6ChangeSize");
static_assert(sizeof(X6CheatManager_X6ChangeSize) == 0x000004, "Wrong size on X6CheatManager_X6ChangeSize");
static_assert(offsetof(X6CheatManager_X6ChangeSize, F) == 0x000000, "Member 'X6CheatManager_X6ChangeSize::F' has a wrong offset!");

// Function X6Game.X6CheatManager.X6ForceMove
// 0x0001 (0x0001 - 0x0000)
struct X6CheatManager_X6ForceMove final
{
public:
	bool                                          ForceIgnoreNikki;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CheatManager_X6ForceMove) == 0x000001, "Wrong alignment on X6CheatManager_X6ForceMove");
static_assert(sizeof(X6CheatManager_X6ForceMove) == 0x000001, "Wrong size on X6CheatManager_X6ForceMove");
static_assert(offsetof(X6CheatManager_X6ForceMove, ForceIgnoreNikki) == 0x000000, "Member 'X6CheatManager_X6ForceMove::ForceIgnoreNikki' has a wrong offset!");

// Function X6Game.X6AbilityTask_ApplyRootMotionAccelOrForward.ApplyRootMotionAccelOrForward
// 0x0058 (0x0058 - 0x0000)
struct X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed_0;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength_0;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration_0;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdditive_0;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime_0;                                // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 VelocityOnFinishMode;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetVelocityOnFinish;                               // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampVelocityOnFinish;                             // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity_0;                                  // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTask_ApplyRootMotionAccelOrForward* ReturnValue;                                 // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward) == 0x000008, "Wrong alignment on X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward");
static_assert(sizeof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward) == 0x000058, "Wrong size on X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, OwningAbility) == 0x000000, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, TaskInstanceName) == 0x000008, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, InterpSpeed_0) == 0x000010, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::InterpSpeed_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, Strength_0) == 0x000014, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::Strength_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, Duration_0) == 0x000018, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::Duration_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, bIsAdditive_0) == 0x00001C, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::bIsAdditive_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, StrengthOverTime_0) == 0x000020, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::StrengthOverTime_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, VelocityOnFinishMode) == 0x000028, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::VelocityOnFinishMode' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, SetVelocityOnFinish) == 0x000030, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::SetVelocityOnFinish' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, ClampVelocityOnFinish) == 0x000048, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::ClampVelocityOnFinish' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, bEnableGravity_0) == 0x00004C, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::bEnableGravity_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward, ReturnValue) == 0x000050, "Member 'X6AbilityTask_ApplyRootMotionAccelOrForward_ApplyRootMotionAccelOrForward::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.AddItem
// 0x0008 (0x0008 - 0x0000)
struct X6CircularListView_AddItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_AddItem) == 0x000008, "Wrong alignment on X6CircularListView_AddItem");
static_assert(sizeof(X6CircularListView_AddItem) == 0x000008, "Wrong size on X6CircularListView_AddItem");
static_assert(offsetof(X6CircularListView_AddItem, Item) == 0x000000, "Member 'X6CircularListView_AddItem::Item' has a wrong offset!");

// Function X6Game.X6CircularListView.BP_ScrollItemIntoView
// 0x0008 (0x0008 - 0x0000)
struct X6CircularListView_BP_ScrollItemIntoView final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_BP_ScrollItemIntoView) == 0x000008, "Wrong alignment on X6CircularListView_BP_ScrollItemIntoView");
static_assert(sizeof(X6CircularListView_BP_ScrollItemIntoView) == 0x000008, "Wrong size on X6CircularListView_BP_ScrollItemIntoView");
static_assert(offsetof(X6CircularListView_BP_ScrollItemIntoView, Item) == 0x000000, "Member 'X6CircularListView_BP_ScrollItemIntoView::Item' has a wrong offset!");

// Function X6Game.X6CircularListView.BP_SetItemSelection
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_BP_SetItemSelection final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CircularListView_BP_SetItemSelection) == 0x000008, "Wrong alignment on X6CircularListView_BP_SetItemSelection");
static_assert(sizeof(X6CircularListView_BP_SetItemSelection) == 0x000010, "Wrong size on X6CircularListView_BP_SetItemSelection");
static_assert(offsetof(X6CircularListView_BP_SetItemSelection, Item) == 0x000000, "Member 'X6CircularListView_BP_SetItemSelection::Item' has a wrong offset!");
static_assert(offsetof(X6CircularListView_BP_SetItemSelection, bSelected) == 0x000008, "Member 'X6CircularListView_BP_SetItemSelection::bSelected' has a wrong offset!");

// Function X6Game.X6CircularListView.BP_SetListItems
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_BP_SetListItems final
{
public:
	TArray<class UObject*>                        InListItems;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_BP_SetListItems) == 0x000008, "Wrong alignment on X6CircularListView_BP_SetListItems");
static_assert(sizeof(X6CircularListView_BP_SetListItems) == 0x000010, "Wrong size on X6CircularListView_BP_SetListItems");
static_assert(offsetof(X6CircularListView_BP_SetListItems, InListItems) == 0x000000, "Member 'X6CircularListView_BP_SetListItems::InListItems' has a wrong offset!");

// Function X6Game.X6CircularListView.BP_SetSelectedItem
// 0x0008 (0x0008 - 0x0000)
struct X6CircularListView_BP_SetSelectedItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_BP_SetSelectedItem) == 0x000008, "Wrong alignment on X6CircularListView_BP_SetSelectedItem");
static_assert(sizeof(X6CircularListView_BP_SetSelectedItem) == 0x000008, "Wrong size on X6CircularListView_BP_SetSelectedItem");
static_assert(offsetof(X6CircularListView_BP_SetSelectedItem, Item) == 0x000000, "Member 'X6CircularListView_BP_SetSelectedItem::Item' has a wrong offset!");

// Function X6Game.X6CircularListView.RemoveItem
// 0x0008 (0x0008 - 0x0000)
struct X6CircularListView_RemoveItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_RemoveItem) == 0x000008, "Wrong alignment on X6CircularListView_RemoveItem");
static_assert(sizeof(X6CircularListView_RemoveItem) == 0x000008, "Wrong size on X6CircularListView_RemoveItem");
static_assert(offsetof(X6CircularListView_RemoveItem, Item) == 0x000000, "Member 'X6CircularListView_RemoveItem::Item' has a wrong offset!");

// Function X6Game.X6CircularListView.ScrollIndexIntoView
// 0x0004 (0x0004 - 0x0000)
struct X6CircularListView_ScrollIndexIntoView final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_ScrollIndexIntoView) == 0x000004, "Wrong alignment on X6CircularListView_ScrollIndexIntoView");
static_assert(sizeof(X6CircularListView_ScrollIndexIntoView) == 0x000004, "Wrong size on X6CircularListView_ScrollIndexIntoView");
static_assert(offsetof(X6CircularListView_ScrollIndexIntoView, Index_0) == 0x000000, "Member 'X6CircularListView_ScrollIndexIntoView::Index_0' has a wrong offset!");

// Function X6Game.X6CircularListView.SetScrollbarVisibility
// 0x0001 (0x0001 - 0x0000)
struct X6CircularListView_SetScrollbarVisibility final
{
public:
	ESlateVisibility                              InVisibility;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_SetScrollbarVisibility) == 0x000001, "Wrong alignment on X6CircularListView_SetScrollbarVisibility");
static_assert(sizeof(X6CircularListView_SetScrollbarVisibility) == 0x000001, "Wrong size on X6CircularListView_SetScrollbarVisibility");
static_assert(offsetof(X6CircularListView_SetScrollbarVisibility, InVisibility) == 0x000000, "Member 'X6CircularListView_SetScrollbarVisibility::InVisibility' has a wrong offset!");

// Function X6Game.X6CircularListView.SetScrollOffset
// 0x0004 (0x0004 - 0x0000)
struct X6CircularListView_SetScrollOffset final
{
public:
	float                                         InScrollOffset;                                    // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_SetScrollOffset) == 0x000004, "Wrong alignment on X6CircularListView_SetScrollOffset");
static_assert(sizeof(X6CircularListView_SetScrollOffset) == 0x000004, "Wrong size on X6CircularListView_SetScrollOffset");
static_assert(offsetof(X6CircularListView_SetScrollOffset, InScrollOffset) == 0x000000, "Member 'X6CircularListView_SetScrollOffset::InScrollOffset' has a wrong offset!");

// Function X6Game.X6CircularListView.SetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct X6CircularListView_SetSelectedIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_SetSelectedIndex) == 0x000004, "Wrong alignment on X6CircularListView_SetSelectedIndex");
static_assert(sizeof(X6CircularListView_SetSelectedIndex) == 0x000004, "Wrong size on X6CircularListView_SetSelectedIndex");
static_assert(offsetof(X6CircularListView_SetSelectedIndex, Index_0) == 0x000000, "Member 'X6CircularListView_SetSelectedIndex::Index_0' has a wrong offset!");

// Function X6Game.X6CircularListView.SetWheelScrollMultiplier
// 0x0004 (0x0004 - 0x0000)
struct X6CircularListView_SetWheelScrollMultiplier final
{
public:
	float                                         NewWheelScrollMultiplier;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_SetWheelScrollMultiplier) == 0x000004, "Wrong alignment on X6CircularListView_SetWheelScrollMultiplier");
static_assert(sizeof(X6CircularListView_SetWheelScrollMultiplier) == 0x000004, "Wrong size on X6CircularListView_SetWheelScrollMultiplier");
static_assert(offsetof(X6CircularListView_SetWheelScrollMultiplier, NewWheelScrollMultiplier) == 0x000000, "Member 'X6CircularListView_SetWheelScrollMultiplier::NewWheelScrollMultiplier' has a wrong offset!");

// Function X6Game.X6CircularListView.BP_GetSelectedItem
// 0x0008 (0x0008 - 0x0000)
struct X6CircularListView_BP_GetSelectedItem final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_BP_GetSelectedItem) == 0x000008, "Wrong alignment on X6CircularListView_BP_GetSelectedItem");
static_assert(sizeof(X6CircularListView_BP_GetSelectedItem) == 0x000008, "Wrong size on X6CircularListView_BP_GetSelectedItem");
static_assert(offsetof(X6CircularListView_BP_GetSelectedItem, ReturnValue) == 0x000000, "Member 'X6CircularListView_BP_GetSelectedItem::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.BP_IsItemVisible
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_BP_IsItemVisible final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CircularListView_BP_IsItemVisible) == 0x000008, "Wrong alignment on X6CircularListView_BP_IsItemVisible");
static_assert(sizeof(X6CircularListView_BP_IsItemVisible) == 0x000010, "Wrong size on X6CircularListView_BP_IsItemVisible");
static_assert(offsetof(X6CircularListView_BP_IsItemVisible, Item) == 0x000000, "Member 'X6CircularListView_BP_IsItemVisible::Item' has a wrong offset!");
static_assert(offsetof(X6CircularListView_BP_IsItemVisible, ReturnValue) == 0x000008, "Member 'X6CircularListView_BP_IsItemVisible::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.GetDisplayedEntryWidgets
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_GetDisplayedEntryWidgets final
{
public:
	TArray<class UUserWidget*>                    ReturnValue;                                       // 0x0000(0x0010)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_GetDisplayedEntryWidgets) == 0x000008, "Wrong alignment on X6CircularListView_GetDisplayedEntryWidgets");
static_assert(sizeof(X6CircularListView_GetDisplayedEntryWidgets) == 0x000010, "Wrong size on X6CircularListView_GetDisplayedEntryWidgets");
static_assert(offsetof(X6CircularListView_GetDisplayedEntryWidgets, ReturnValue) == 0x000000, "Member 'X6CircularListView_GetDisplayedEntryWidgets::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.GetIndexForItem
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_GetIndexForItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CircularListView_GetIndexForItem) == 0x000008, "Wrong alignment on X6CircularListView_GetIndexForItem");
static_assert(sizeof(X6CircularListView_GetIndexForItem) == 0x000010, "Wrong size on X6CircularListView_GetIndexForItem");
static_assert(offsetof(X6CircularListView_GetIndexForItem, Item) == 0x000000, "Member 'X6CircularListView_GetIndexForItem::Item' has a wrong offset!");
static_assert(offsetof(X6CircularListView_GetIndexForItem, ReturnValue) == 0x000008, "Member 'X6CircularListView_GetIndexForItem::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.GetItemAt
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_GetItemAt final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_GetItemAt) == 0x000008, "Wrong alignment on X6CircularListView_GetItemAt");
static_assert(sizeof(X6CircularListView_GetItemAt) == 0x000010, "Wrong size on X6CircularListView_GetItemAt");
static_assert(offsetof(X6CircularListView_GetItemAt, Index_0) == 0x000000, "Member 'X6CircularListView_GetItemAt::Index_0' has a wrong offset!");
static_assert(offsetof(X6CircularListView_GetItemAt, ReturnValue) == 0x000008, "Member 'X6CircularListView_GetItemAt::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.GetListItems
// 0x0010 (0x0010 - 0x0000)
struct X6CircularListView_GetListItems final
{
public:
	TArray<class UObject*>                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_GetListItems) == 0x000008, "Wrong alignment on X6CircularListView_GetListItems");
static_assert(sizeof(X6CircularListView_GetListItems) == 0x000010, "Wrong size on X6CircularListView_GetListItems");
static_assert(offsetof(X6CircularListView_GetListItems, ReturnValue) == 0x000000, "Member 'X6CircularListView_GetListItems::ReturnValue' has a wrong offset!");

// Function X6Game.X6CircularListView.GetNumItems
// 0x0004 (0x0004 - 0x0000)
struct X6CircularListView_GetNumItems final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CircularListView_GetNumItems) == 0x000004, "Wrong alignment on X6CircularListView_GetNumItems");
static_assert(sizeof(X6CircularListView_GetNumItems) == 0x000004, "Wrong size on X6CircularListView_GetNumItems");
static_assert(offsetof(X6CircularListView_GetNumItems, ReturnValue) == 0x000000, "Member 'X6CircularListView_GetNumItems::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatBossSlotMgrComponent.GetSlotRelativeTransformByIndex
// 0x0070 (0x0070 - 0x0000)
struct X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex) == 0x000010, "Wrong alignment on X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex");
static_assert(sizeof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex) == 0x000070, "Wrong size on X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex, SlotIndex) == 0x000000, "Member 'X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex::SlotIndex' has a wrong offset!");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex, ReturnValue) == 0x000010, "Member 'X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatBossSlotMgrComponent.GetSlotRelativeTransformByTagName
// 0x0018 (0x0018 - 0x0000)
struct X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName final
{
public:
	class FName                                   TagName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName) == 0x000008, "Wrong alignment on X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName");
static_assert(sizeof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName) == 0x000018, "Wrong size on X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName, TagName) == 0x000000, "Member 'X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName::TagName' has a wrong offset!");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName, ReturnValue) == 0x000008, "Member 'X6CombatBossSlotMgrComponent_GetSlotRelativeTransformByTagName::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatBossSlotMgrComponent.GetSlots
// 0x0010 (0x0010 - 0x0000)
struct X6CombatBossSlotMgrComponent_GetSlots final
{
public:
	TArray<struct FAttachSlotDefinition>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatBossSlotMgrComponent_GetSlots) == 0x000008, "Wrong alignment on X6CombatBossSlotMgrComponent_GetSlots");
static_assert(sizeof(X6CombatBossSlotMgrComponent_GetSlots) == 0x000010, "Wrong size on X6CombatBossSlotMgrComponent_GetSlots");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlots, ReturnValue) == 0x000000, "Member 'X6CombatBossSlotMgrComponent_GetSlots::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatBossSlotMgrComponent.GetSlotTransformByIndex
// 0x0070 (0x0070 - 0x0000)
struct X6CombatBossSlotMgrComponent_GetSlotTransformByIndex final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatBossSlotMgrComponent_GetSlotTransformByIndex) == 0x000010, "Wrong alignment on X6CombatBossSlotMgrComponent_GetSlotTransformByIndex");
static_assert(sizeof(X6CombatBossSlotMgrComponent_GetSlotTransformByIndex) == 0x000070, "Wrong size on X6CombatBossSlotMgrComponent_GetSlotTransformByIndex");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotTransformByIndex, SlotIndex) == 0x000000, "Member 'X6CombatBossSlotMgrComponent_GetSlotTransformByIndex::SlotIndex' has a wrong offset!");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotTransformByIndex, ReturnValue) == 0x000010, "Member 'X6CombatBossSlotMgrComponent_GetSlotTransformByIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatBossSlotMgrComponent.GetSlotTransformByTagName
// 0x0018 (0x0018 - 0x0000)
struct X6CombatBossSlotMgrComponent_GetSlotTransformByTagName final
{
public:
	class FName                                   TagName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatBossSlotMgrComponent_GetSlotTransformByTagName) == 0x000008, "Wrong alignment on X6CombatBossSlotMgrComponent_GetSlotTransformByTagName");
static_assert(sizeof(X6CombatBossSlotMgrComponent_GetSlotTransformByTagName) == 0x000018, "Wrong size on X6CombatBossSlotMgrComponent_GetSlotTransformByTagName");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotTransformByTagName, TagName) == 0x000000, "Member 'X6CombatBossSlotMgrComponent_GetSlotTransformByTagName::TagName' has a wrong offset!");
static_assert(offsetof(X6CombatBossSlotMgrComponent_GetSlotTransformByTagName, ReturnValue) == 0x000008, "Member 'X6CombatBossSlotMgrComponent_GetSlotTransformByTagName::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatCameraSynchronizer.SetRotationTargetCandidates
// 0x0010 (0x0010 - 0x0000)
struct X6CombatCameraSynchronizer_SetRotationTargetCandidates final
{
public:
	TArray<class AActor*>                         CandidatesArray;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatCameraSynchronizer_SetRotationTargetCandidates) == 0x000008, "Wrong alignment on X6CombatCameraSynchronizer_SetRotationTargetCandidates");
static_assert(sizeof(X6CombatCameraSynchronizer_SetRotationTargetCandidates) == 0x000010, "Wrong size on X6CombatCameraSynchronizer_SetRotationTargetCandidates");
static_assert(offsetof(X6CombatCameraSynchronizer_SetRotationTargetCandidates, CandidatesArray) == 0x000000, "Member 'X6CombatCameraSynchronizer_SetRotationTargetCandidates::CandidatesArray' has a wrong offset!");

// Function X6Game.X6CombatComponent.SetAbilityDataAsset
// 0x0008 (0x0008 - 0x0000)
struct X6CombatComponent_SetAbilityDataAsset final
{
public:
	const class UX6AbilitySet*                    InAbilitySet;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatComponent_SetAbilityDataAsset) == 0x000008, "Wrong alignment on X6CombatComponent_SetAbilityDataAsset");
static_assert(sizeof(X6CombatComponent_SetAbilityDataAsset) == 0x000008, "Wrong size on X6CombatComponent_SetAbilityDataAsset");
static_assert(offsetof(X6CombatComponent_SetAbilityDataAsset, InAbilitySet) == 0x000000, "Member 'X6CombatComponent_SetAbilityDataAsset::InAbilitySet' has a wrong offset!");

// Function X6Game.X6CombatMovementComponent.K2_UpdateMovingState
// 0x0001 (0x0001 - 0x0000)
struct X6CombatMovementComponent_K2_UpdateMovingState final
{
public:
	bool                                          bNewMoveFlag;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatMovementComponent_K2_UpdateMovingState) == 0x000001, "Wrong alignment on X6CombatMovementComponent_K2_UpdateMovingState");
static_assert(sizeof(X6CombatMovementComponent_K2_UpdateMovingState) == 0x000001, "Wrong size on X6CombatMovementComponent_K2_UpdateMovingState");
static_assert(offsetof(X6CombatMovementComponent_K2_UpdateMovingState, bNewMoveFlag) == 0x000000, "Member 'X6CombatMovementComponent_K2_UpdateMovingState::bNewMoveFlag' has a wrong offset!");

// Function X6Game.X6CombatMovementComponent.UpdateMovingData
// 0x0038 (0x0038 - 0x0000)
struct X6CombatMovementComponent_UpdateMovingData final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewMoveFlag;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NewMoveDir;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatMovementComponent_UpdateMovingData) == 0x000008, "Wrong alignment on X6CombatMovementComponent_UpdateMovingData");
static_assert(sizeof(X6CombatMovementComponent_UpdateMovingData) == 0x000038, "Wrong size on X6CombatMovementComponent_UpdateMovingData");
static_assert(offsetof(X6CombatMovementComponent_UpdateMovingData, DeltaTime) == 0x000000, "Member 'X6CombatMovementComponent_UpdateMovingData::DeltaTime' has a wrong offset!");
static_assert(offsetof(X6CombatMovementComponent_UpdateMovingData, bNewMoveFlag) == 0x000004, "Member 'X6CombatMovementComponent_UpdateMovingData::bNewMoveFlag' has a wrong offset!");
static_assert(offsetof(X6CombatMovementComponent_UpdateMovingData, NewMoveDir) == 0x000008, "Member 'X6CombatMovementComponent_UpdateMovingData::NewMoveDir' has a wrong offset!");
static_assert(offsetof(X6CombatMovementComponent_UpdateMovingData, ReturnValue) == 0x000020, "Member 'X6CombatMovementComponent_UpdateMovingData::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatPerformanceProcessorComponent.K2_GetABPConfigs
// 0x0008 (0x0008 - 0x0000)
struct X6CombatPerformanceProcessorComponent_K2_GetABPConfigs final
{
public:
	class UDataAsset*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatPerformanceProcessorComponent_K2_GetABPConfigs) == 0x000008, "Wrong alignment on X6CombatPerformanceProcessorComponent_K2_GetABPConfigs");
static_assert(sizeof(X6CombatPerformanceProcessorComponent_K2_GetABPConfigs) == 0x000008, "Wrong size on X6CombatPerformanceProcessorComponent_K2_GetABPConfigs");
static_assert(offsetof(X6CombatPerformanceProcessorComponent_K2_GetABPConfigs, ReturnValue) == 0x000000, "Member 'X6CombatPerformanceProcessorComponent_K2_GetABPConfigs::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageAndWait.CreatePlayMontageAndWaitProxy
// 0x0040 (0x0040 - 0x0000)
struct X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay_0;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate_0;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSection_0;                                    // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAbilityEnds_0;                            // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimRootMotionTranslationScale_0;                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTimeSeconds_0;                                // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirror_0;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayWithShadow_0;                                 // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTask_PlayMontageAndWait*      ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy");
static_assert(sizeof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy) == 0x000040, "Wrong size on X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, OwningAbility) == 0x000000, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, TaskInstanceName) == 0x000008, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, MontageToPlay_0) == 0x000010, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::MontageToPlay_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, Rate_0) == 0x000018, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::Rate_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, StartSection_0) == 0x00001C, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::StartSection_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, bStopWhenAbilityEnds_0) == 0x000024, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::bStopWhenAbilityEnds_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, AnimRootMotionTranslationScale_0) == 0x000028, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::AnimRootMotionTranslationScale_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, StartTimeSeconds_0) == 0x00002C, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::StartTimeSeconds_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, bMirror_0) == 0x000030, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::bMirror_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, bPlayWithShadow_0) == 0x000031, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::bPlayWithShadow_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy, ReturnValue) == 0x000038, "Member 'X6AbilityTask_PlayMontageAndWait_CreatePlayMontageAndWaitProxy::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageAndWait.OnMontageBlendingOut
// 0x0010 (0x0010 - 0x0000)
struct X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut");
static_assert(sizeof(X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut) == 0x000010, "Wrong size on X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut, Montage) == 0x000000, "Member 'X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut::Montage' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut, bInterrupted) == 0x000008, "Member 'X6AbilityTask_PlayMontageAndWait_OnMontageBlendingOut::bInterrupted' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageAndWait.OnMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct X6AbilityTask_PlayMontageAndWait_OnMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilityTask_PlayMontageAndWait_OnMontageEnded) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageAndWait_OnMontageEnded");
static_assert(sizeof(X6AbilityTask_PlayMontageAndWait_OnMontageEnded) == 0x000010, "Wrong size on X6AbilityTask_PlayMontageAndWait_OnMontageEnded");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnMontageEnded, Montage) == 0x000000, "Member 'X6AbilityTask_PlayMontageAndWait_OnMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnMontageEnded, bInterrupted) == 0x000008, "Member 'X6AbilityTask_PlayMontageAndWait_OnMontageEnded::bInterrupted' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageAndWait.OnNotifyBeginReceived
// 0x0028 (0x0028 - 0x0000)
struct X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived");
static_assert(sizeof(X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived) == 0x000028, "Wrong size on X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived, NotifyName) == 0x000000, "Member 'X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'X6AbilityTask_PlayMontageAndWait_OnNotifyBeginReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function X6Game.X6AbilityTask_PlayMontageAndWait.OnNotifyEndReceived
// 0x0028 (0x0028 - 0x0000)
struct X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived) == 0x000008, "Wrong alignment on X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived");
static_assert(sizeof(X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived) == 0x000028, "Wrong size on X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived, NotifyName) == 0x000000, "Member 'X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'X6AbilityTask_PlayMontageAndWait_OnNotifyEndReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.GetPointToLeave
// 0x0010 (0x0010 - 0x0000)
struct X6WaterSimulationComponent_GetPointToLeave final
{
public:
	struct FSimulateWaterFlowKeyPoint             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_GetPointToLeave) == 0x000008, "Wrong alignment on X6WaterSimulationComponent_GetPointToLeave");
static_assert(sizeof(X6WaterSimulationComponent_GetPointToLeave) == 0x000010, "Wrong size on X6WaterSimulationComponent_GetPointToLeave");
static_assert(offsetof(X6WaterSimulationComponent_GetPointToLeave, ReturnValue) == 0x000000, "Member 'X6WaterSimulationComponent_GetPointToLeave::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.GetTargetPointToToward
// 0x0010 (0x0010 - 0x0000)
struct X6WaterSimulationComponent_GetTargetPointToToward final
{
public:
	struct FSimulateWaterFlowKeyPoint             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_GetTargetPointToToward) == 0x000008, "Wrong alignment on X6WaterSimulationComponent_GetTargetPointToToward");
static_assert(sizeof(X6WaterSimulationComponent_GetTargetPointToToward) == 0x000010, "Wrong size on X6WaterSimulationComponent_GetTargetPointToToward");
static_assert(offsetof(X6WaterSimulationComponent_GetTargetPointToToward, ReturnValue) == 0x000000, "Member 'X6WaterSimulationComponent_GetTargetPointToToward::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.GetWaterCurrentDensity
// 0x0004 (0x0004 - 0x0000)
struct X6WaterSimulationComponent_GetWaterCurrentDensity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_GetWaterCurrentDensity) == 0x000004, "Wrong alignment on X6WaterSimulationComponent_GetWaterCurrentDensity");
static_assert(sizeof(X6WaterSimulationComponent_GetWaterCurrentDensity) == 0x000004, "Wrong size on X6WaterSimulationComponent_GetWaterCurrentDensity");
static_assert(offsetof(X6WaterSimulationComponent_GetWaterCurrentDensity, ReturnValue) == 0x000000, "Member 'X6WaterSimulationComponent_GetWaterCurrentDensity::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.GetWaterSurfaceHeightInWorldCoordinate
// 0x0004 (0x0004 - 0x0000)
struct X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate) == 0x000004, "Wrong alignment on X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate");
static_assert(sizeof(X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate) == 0x000004, "Wrong size on X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate");
static_assert(offsetof(X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate, ReturnValue) == 0x000000, "Member 'X6WaterSimulationComponent_GetWaterSurfaceHeightInWorldCoordinate::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.UpdateWaterDensity
// 0x0004 (0x0004 - 0x0000)
struct X6WaterSimulationComponent_UpdateWaterDensity final
{
public:
	float                                         NewDensity;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_UpdateWaterDensity) == 0x000004, "Wrong alignment on X6WaterSimulationComponent_UpdateWaterDensity");
static_assert(sizeof(X6WaterSimulationComponent_UpdateWaterDensity) == 0x000004, "Wrong size on X6WaterSimulationComponent_UpdateWaterDensity");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterDensity, NewDensity) == 0x000000, "Member 'X6WaterSimulationComponent_UpdateWaterDensity::NewDensity' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.UpdateWaterIceState
// 0x0001 (0x0001 - 0x0000)
struct X6WaterSimulationComponent_UpdateWaterIceState final
{
public:
	bool                                          ToIceOrExit;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_UpdateWaterIceState) == 0x000001, "Wrong alignment on X6WaterSimulationComponent_UpdateWaterIceState");
static_assert(sizeof(X6WaterSimulationComponent_UpdateWaterIceState) == 0x000001, "Wrong size on X6WaterSimulationComponent_UpdateWaterIceState");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterIceState, ToIceOrExit) == 0x000000, "Member 'X6WaterSimulationComponent_UpdateWaterIceState::ToIceOrExit' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.UpdateWaterSurfaceHeight
// 0x0004 (0x0004 - 0x0000)
struct X6WaterSimulationComponent_UpdateWaterSurfaceHeight final
{
public:
	float                                         HeightOfffsetToUpdate;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_UpdateWaterSurfaceHeight) == 0x000004, "Wrong alignment on X6WaterSimulationComponent_UpdateWaterSurfaceHeight");
static_assert(sizeof(X6WaterSimulationComponent_UpdateWaterSurfaceHeight) == 0x000004, "Wrong size on X6WaterSimulationComponent_UpdateWaterSurfaceHeight");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterSurfaceHeight, HeightOfffsetToUpdate) == 0x000000, "Member 'X6WaterSimulationComponent_UpdateWaterSurfaceHeight::HeightOfffsetToUpdate' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.UpdateWaterSurfaceHeightInTime
// 0x0008 (0x0008 - 0x0000)
struct X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime final
{
public:
	float                                         TimeDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalHeightToUpdate;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime) == 0x000004, "Wrong alignment on X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime");
static_assert(sizeof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime) == 0x000008, "Wrong size on X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime, TimeDuration) == 0x000000, "Member 'X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime::TimeDuration' has a wrong offset!");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime, TotalHeightToUpdate) == 0x000004, "Member 'X6WaterSimulationComponent_UpdateWaterSurfaceHeightInTime::TotalHeightToUpdate' has a wrong offset!");

// Function X6Game.X6WaterSimulationComponent.UpdateWaterSurfaceHeightWithSpeed
// 0x0008 (0x0008 - 0x0000)
struct X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed final
{
public:
	float                                         UpdateHeightSpeed;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalHeightToUpdate;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed) == 0x000004, "Wrong alignment on X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed");
static_assert(sizeof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed) == 0x000008, "Wrong size on X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed, UpdateHeightSpeed) == 0x000000, "Member 'X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed::UpdateHeightSpeed' has a wrong offset!");
static_assert(offsetof(X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed, TotalHeightToUpdate) == 0x000004, "Member 'X6WaterSimulationComponent_UpdateWaterSurfaceHeightWithSpeed::TotalHeightToUpdate' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.AddAreaListenerTarget
// 0x0008 (0x0008 - 0x0000)
struct X6CombatTargetingFilterSubsystem_AddAreaListenerTarget final
{
public:
	class AActor*                                 InTargetActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_AddAreaListenerTarget) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_AddAreaListenerTarget");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_AddAreaListenerTarget) == 0x000008, "Wrong size on X6CombatTargetingFilterSubsystem_AddAreaListenerTarget");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_AddAreaListenerTarget, InTargetActor) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_AddAreaListenerTarget::InTargetActor' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.K2_ExecuteNormalTargetingPreset
// 0x0010 (0x0010 - 0x0000)
struct X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset final
{
public:
	const class UTargetingPreset*                 InFilterTargetingPreset;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UTargetingPreset*                 InOnlyOutlineTargetingPreset;                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset) == 0x000010, "Wrong size on X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset, InFilterTargetingPreset) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset::InFilterTargetingPreset' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset, InOnlyOutlineTargetingPreset) == 0x000008, "Member 'X6CombatTargetingFilterSubsystem_K2_ExecuteNormalTargetingPreset::InOnlyOutlineTargetingPreset' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.K2_GetTargetingResults
// 0x0018 (0x0018 - 0x0000)
struct X6CombatTargetingFilterSubsystem_K2_GetTargetingResults final
{
public:
	const class UTargetingPreset*                 InTargetingPreset;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutTargets;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_K2_GetTargetingResults) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_K2_GetTargetingResults");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_K2_GetTargetingResults) == 0x000018, "Wrong size on X6CombatTargetingFilterSubsystem_K2_GetTargetingResults");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_GetTargetingResults, InTargetingPreset) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_K2_GetTargetingResults::InTargetingPreset' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_GetTargetingResults, OutTargets) == 0x000008, "Member 'X6CombatTargetingFilterSubsystem_K2_GetTargetingResults::OutTargets' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.K2_ResetPerfumeTargetingPreset
// 0x0001 (0x0001 - 0x0000)
struct X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset final
{
public:
	bool                                          bReinforce;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset) == 0x000001, "Wrong alignment on X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset) == 0x000001, "Wrong size on X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset, bReinforce) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_K2_ResetPerfumeTargetingPreset::bReinforce' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.K2_SetRunningCrashTargetingPreset
// 0x0008 (0x0008 - 0x0000)
struct X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset final
{
public:
	class UTargetingPreset*                       InTargetingPreset;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset) == 0x000008, "Wrong size on X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset, InTargetingPreset) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_K2_SetRunningCrashTargetingPreset::InTargetingPreset' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.K2_SetRunningPerfumeTargetingPreset
// 0x0018 (0x0018 - 0x0000)
struct X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset final
{
public:
	class UTargetingPreset*                       InTargetingPreset;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetingPreset*                       InChargeUpPreTargetingPreset;                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetingPreset*                       InChargeUpFinishTargetingPreset;                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset) == 0x000018, "Wrong size on X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset, InTargetingPreset) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset::InTargetingPreset' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset, InChargeUpPreTargetingPreset) == 0x000008, "Member 'X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset::InChargeUpPreTargetingPreset' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset, InChargeUpFinishTargetingPreset) == 0x000010, "Member 'X6CombatTargetingFilterSubsystem_K2_SetRunningPerfumeTargetingPreset::InChargeUpFinishTargetingPreset' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.OnControlMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct X6CombatTargetingFilterSubsystem_OnControlMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_OnControlMovementModeChange) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_OnControlMovementModeChange");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_OnControlMovementModeChange) == 0x000010, "Wrong size on X6CombatTargetingFilterSubsystem_OnControlMovementModeChange");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_OnControlMovementModeChange, Character) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_OnControlMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_OnControlMovementModeChange, PrevMovementMode) == 0x000008, "Member 'X6CombatTargetingFilterSubsystem_OnControlMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_OnControlMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'X6CombatTargetingFilterSubsystem_OnControlMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.RemoveAreaListenerTarget
// 0x0008 (0x0008 - 0x0000)
struct X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget final
{
public:
	class AActor*                                 InTargetActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget) == 0x000008, "Wrong size on X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget, InTargetActor) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_RemoveAreaListenerTarget::InTargetActor' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.SetActiveOutlineCameraBlend
// 0x000C (0x000C - 0x0000)
struct X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InFlag;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFlag;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend) == 0x000004, "Wrong alignment on X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend) == 0x00000C, "Wrong size on X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend, bActive) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend::bActive' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend, InFlag) == 0x000004, "Member 'X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend::InFlag' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend, bClearFlag) == 0x000008, "Member 'X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend::bClearFlag' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend, ReturnValue) == 0x000009, "Member 'X6CombatTargetingFilterSubsystem_SetActiveOutlineCameraBlend::ReturnValue' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.SetActiveTargetingFilter
// 0x0001 (0x0001 - 0x0000)
struct X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter) == 0x000001, "Wrong alignment on X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter) == 0x000001, "Wrong size on X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter, bActive) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_SetActiveTargetingFilter::bActive' has a wrong offset!");

// Function X6Game.X6CombatTargetingFilterSubsystem.IsAreaExistTarget
// 0x0040 (0x0040 - 0x0000)
struct X6CombatTargetingFilterSubsystem_IsAreaExistTarget final
{
public:
	struct FBox                                   BoxArea;                                           // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6CombatTargetingFilterSubsystem_IsAreaExistTarget) == 0x000008, "Wrong alignment on X6CombatTargetingFilterSubsystem_IsAreaExistTarget");
static_assert(sizeof(X6CombatTargetingFilterSubsystem_IsAreaExistTarget) == 0x000040, "Wrong size on X6CombatTargetingFilterSubsystem_IsAreaExistTarget");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_IsAreaExistTarget, BoxArea) == 0x000000, "Member 'X6CombatTargetingFilterSubsystem_IsAreaExistTarget::BoxArea' has a wrong offset!");
static_assert(offsetof(X6CombatTargetingFilterSubsystem_IsAreaExistTarget, ReturnValue) == 0x000038, "Member 'X6CombatTargetingFilterSubsystem_IsAreaExistTarget::ReturnValue' has a wrong offset!");

// Function X6Game.X6CustomLevelSequenceActor.ReceiveLevelSequenceActorBeginAttach
// 0x0008 (0x0008 - 0x0000)
struct X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach final
{
public:
	class AActor*                                 AttachActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach) == 0x000008, "Wrong alignment on X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach");
static_assert(sizeof(X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach) == 0x000008, "Wrong size on X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach");
static_assert(offsetof(X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach, AttachActor) == 0x000000, "Member 'X6CustomLevelSequenceActor_ReceiveLevelSequenceActorBeginAttach::AttachActor' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorDoesContainerMatchTagQuery
// 0x0058 (0x0058 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery) == 0x000058, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery, TagQuery) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery::TagQuery' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery, ReturnValue) == 0x000050, "Member 'X6AbilitySystemBlueprintLibrary_ActorDoesContainerMatchTagQuery::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorHasAllGameplayTags
// 0x0030 (0x0030 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags) == 0x000030, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags, TagContainer) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags::TagContainer' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags, ReturnValue) == 0x000028, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasAllGameplayTags::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorHasAnyGameplayTags
// 0x0030 (0x0030 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags) == 0x000030, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags, TagContainer) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags::TagContainer' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags, ReturnValue) == 0x000028, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasAnyGameplayTags::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorHasGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagToCheck;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag, TagToCheck) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag::TagToCheck' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag, ReturnValue) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_ActorHasGameplayTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorIsBoss
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorIsBoss final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorIsBoss) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorIsBoss");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorIsBoss) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorIsBoss");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsBoss, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsBoss::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsBoss, ReturnValue) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsBoss::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorIsEliteMonster
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster, ReturnValue) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsEliteMonster::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorIsMonster
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorIsMonster final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorIsMonster) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorIsMonster");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorIsMonster) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorIsMonster");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsMonster, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsMonster::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsMonster, ReturnValue) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsMonster::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ActorIsNormalMonster
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster, ReturnValue) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ActorIsNormalMonster::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.AddLooseGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag, GameplayTag) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag, ReturnValue) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_AddLooseGameplayTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.AddLooseGameplayTagName
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameplayTagName;                                   // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName, GameplayTagName) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName::GameplayTagName' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName, ReturnValue) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_AddLooseGameplayTagName::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.ApplyConstantForceRootMotion
// 0x0058 (0x0058 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionAccumulateMode                     AccumulateMode;                                    // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInLocalSpace;                                     // 0x002D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 FinishMode;                                        // 0x002E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampVelocity;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetVelocity;                                       // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePartialEndTick;                            // 0x0051(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSensitiveLiftoffCheck;                         // 0x0052(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0054(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion) == 0x000058, "Wrong size on X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, Force) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::Force' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, StrengthOverTime) == 0x000020, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, Duration) == 0x000028, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::Duration' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, AccumulateMode) == 0x00002C, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::AccumulateMode' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, bInLocalSpace) == 0x00002D, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::bInLocalSpace' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, FinishMode) == 0x00002E, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::FinishMode' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, ClampVelocity) == 0x000030, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::ClampVelocity' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, SetVelocity) == 0x000038, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::SetVelocity' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, bEnableGravity) == 0x000050, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::bEnableGravity' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, bDisablePartialEndTick) == 0x000051, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::bDisablePartialEndTick' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, bUseSensitiveLiftoffCheck) == 0x000052, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::bUseSensitiveLiftoffCheck' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion, ReturnValue) == 0x000054, "Member 'X6AbilitySystemBlueprintLibrary_ApplyConstantForceRootMotion::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.CheckActorCanBeSeen
// 0x0020 (0x0020 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreTraceActors;                                 // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen) == 0x000020, "Wrong size on X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen, IgnoreTraceActors) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen::IgnoreTraceActors' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen, ReturnValue) == 0x000018, "Member 'X6AbilitySystemBlueprintLibrary_CheckActorCanBeSeen::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.CurrentMontageJumpToSection
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection, InSkeletalMeshComponent) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection, SectionName) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_CurrentMontageJumpToSection::SectionName' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.DrawTargetingSelectionTaskAOE
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UTargetingPreset*                 TargetingPreset;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 InnerRingColor;                                    // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE, TargetingPreset) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE::TargetingPreset' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE, Color) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE::Color' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE, InnerRingColor) == 0x000014, "Member 'X6AbilitySystemBlueprintLibrary_DrawTargetingSelectionTaskAOE::InnerRingColor' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.GetRandomPointsFromSquare
// 0x0040 (0x0040 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare final
{
public:
	struct FVector                                SquareCenter;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XLength;                                           // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YLength;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XNum;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YNum;                                              // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare) == 0x000040, "Wrong size on X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, SquareCenter) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::SquareCenter' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, YawAngle) == 0x000018, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::YawAngle' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, XLength) == 0x00001C, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::XLength' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, YLength) == 0x000020, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::YLength' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, XNum) == 0x000024, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::XNum' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, YNum) == 0x000028, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::YNum' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare, ReturnValue) == 0x000030, "Member 'X6AbilitySystemBlueprintLibrary_GetRandomPointsFromSquare::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.GetX6AbilitySystemComponent
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6AbilitySystemComponent*              ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent, ReturnValue) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_GetX6AbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.MakeTargetingSourceContextWithParam
// 0x0048 (0x0048 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam final
{
public:
	struct FTargetingSourceContext                ReturnValue;                                       // 0x0000(0x0048)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam) == 0x000048, "Wrong size on X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam, ReturnValue) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_MakeTargetingSourceContextWithParam::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.RemoveLooseGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag, GameplayTag) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag, ReturnValue) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.RemoveLooseGameplayTagName
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameplayTagName;                                   // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName, GameplayTagName) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName::GameplayTagName' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName, ReturnValue) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_RemoveLooseGameplayTagName::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.RemoveRootMotionBySourceID
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID) == 0x000010, "Wrong size on X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID, SourceId) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_RemoveRootMotionBySourceID::SourceId' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.SendGameplayEventToActorWithRet
// 0x00C8 (0x00C8 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet) == 0x0000C8, "Wrong size on X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet, EventTag) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet::EventTag' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet, Payload) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet::Payload' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet, ReturnValue) == 0x0000C0, "Member 'X6AbilitySystemBlueprintLibrary_SendGameplayEventToActorWithRet::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.StopAnimMontage
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_StopAnimMontage final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideBlendOutTime;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_StopAnimMontage) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_StopAnimMontage");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_StopAnimMontage) == 0x000018, "Wrong size on X6AbilitySystemBlueprintLibrary_StopAnimMontage");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_StopAnimMontage, InSkeletalMeshComponent) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_StopAnimMontage::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_StopAnimMontage, Montage) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_StopAnimMontage::Montage' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_StopAnimMontage, OverrideBlendOutTime) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_StopAnimMontage::OverrideBlendOutTime' has a wrong offset!");

// Function X6Game.X6AbilitySystemBlueprintLibrary.UpdateConstantForceBySourceID
// 0x0028 (0x0028 - 0x0000)
struct X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceId;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NewForce;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID) == 0x000008, "Wrong alignment on X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID");
static_assert(sizeof(X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID) == 0x000028, "Wrong size on X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID, Actor) == 0x000000, "Member 'X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID::Actor' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID, SourceId) == 0x000008, "Member 'X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID::SourceId' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID, NewForce) == 0x000010, "Member 'X6AbilitySystemBlueprintLibrary_UpdateConstantForceBySourceID::NewForce' has a wrong offset!");

// Function X6Game.X6DaMiaoMainAnimInstance.PrepareInitializationData
// 0x0001 (0x0001 - 0x0000)
struct X6DaMiaoMainAnimInstance_PrepareInitializationData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6DaMiaoMainAnimInstance_PrepareInitializationData) == 0x000001, "Wrong alignment on X6DaMiaoMainAnimInstance_PrepareInitializationData");
static_assert(sizeof(X6DaMiaoMainAnimInstance_PrepareInitializationData) == 0x000001, "Wrong size on X6DaMiaoMainAnimInstance_PrepareInitializationData");
static_assert(offsetof(X6DaMiaoMainAnimInstance_PrepareInitializationData, ReturnValue) == 0x000000, "Member 'X6DaMiaoMainAnimInstance_PrepareInitializationData::ReturnValue' has a wrong offset!");

// Function X6Game.X6DaMiaoMainAnimInstance.GetCurFootIKFeatureTargetData
// 0x00A0 (0x00A0 - 0x0000)
struct X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData final
{
public:
	struct FFootIKFeatureTargetDataV2             ReturnValue;                                       // 0x0000(0x00A0)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData) == 0x000008, "Wrong alignment on X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData");
static_assert(sizeof(X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData) == 0x0000A0, "Wrong size on X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData");
static_assert(offsetof(X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData, ReturnValue) == 0x000000, "Member 'X6DaMiaoMainAnimInstance_GetCurFootIKFeatureTargetData::ReturnValue' has a wrong offset!");

// Function X6Game.X6DispatchInputComponent.BindInputByPlayerController
// 0x0008 (0x0008 - 0x0000)
struct X6DispatchInputComponent_BindInputByPlayerController final
{
public:
	class APlayerController*                      InPlayerController;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6DispatchInputComponent_BindInputByPlayerController) == 0x000008, "Wrong alignment on X6DispatchInputComponent_BindInputByPlayerController");
static_assert(sizeof(X6DispatchInputComponent_BindInputByPlayerController) == 0x000008, "Wrong size on X6DispatchInputComponent_BindInputByPlayerController");
static_assert(offsetof(X6DispatchInputComponent_BindInputByPlayerController, InPlayerController) == 0x000000, "Member 'X6DispatchInputComponent_BindInputByPlayerController::InPlayerController' has a wrong offset!");

// Function X6Game.X6DispatchInputComponent.UnBindInput
// 0x0001 (0x0001 - 0x0000)
struct X6DispatchInputComponent_UnBindInput final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6DispatchInputComponent_UnBindInput) == 0x000001, "Wrong alignment on X6DispatchInputComponent_UnBindInput");
static_assert(sizeof(X6DispatchInputComponent_UnBindInput) == 0x000001, "Wrong size on X6DispatchInputComponent_UnBindInput");
static_assert(offsetof(X6DispatchInputComponent_UnBindInput, ReturnValue) == 0x000000, "Member 'X6DispatchInputComponent_UnBindInput::ReturnValue' has a wrong offset!");

// Function X6Game.X6EditableText.SetTextWithCursorStay
// 0x0010 (0x0010 - 0x0000)
struct X6EditableText_SetTextWithCursorStay final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6EditableText_SetTextWithCursorStay) == 0x000008, "Wrong alignment on X6EditableText_SetTextWithCursorStay");
static_assert(sizeof(X6EditableText_SetTextWithCursorStay) == 0x000010, "Wrong size on X6EditableText_SetTextWithCursorStay");
static_assert(offsetof(X6EditableText_SetTextWithCursorStay, InText) == 0x000000, "Member 'X6EditableText_SetTextWithCursorStay::InText' has a wrong offset!");

// Function X6Game.X6EditableText.IsComposing
// 0x0001 (0x0001 - 0x0000)
struct X6EditableText_IsComposing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6EditableText_IsComposing) == 0x000001, "Wrong alignment on X6EditableText_IsComposing");
static_assert(sizeof(X6EditableText_IsComposing) == 0x000001, "Wrong size on X6EditableText_IsComposing");
static_assert(offsetof(X6EditableText_IsComposing, ReturnValue) == 0x000000, "Member 'X6EditableText_IsComposing::ReturnValue' has a wrong offset!");

// Function X6Game.X6EditableTextBox.IsComposing
// 0x0001 (0x0001 - 0x0000)
struct X6EditableTextBox_IsComposing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6EditableTextBox_IsComposing) == 0x000001, "Wrong alignment on X6EditableTextBox_IsComposing");
static_assert(sizeof(X6EditableTextBox_IsComposing) == 0x000001, "Wrong size on X6EditableTextBox_IsComposing");
static_assert(offsetof(X6EditableTextBox_IsComposing, ReturnValue) == 0x000000, "Member 'X6EditableTextBox_IsComposing::ReturnValue' has a wrong offset!");

// Function X6Game.MotionModifier_AdjustmentBlendWarp.GetAdjustmentBlendIKBoneTransformAndAlpha
// 0x0080 (0x0080 - 0x0000)
struct MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha final
{
public:
	const class USkeletalMeshComponent*           OwnerComp;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x0010(0x0060)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutAlpha;                                          // 0x0070(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha) == 0x000010, "Wrong alignment on MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha");
static_assert(sizeof(MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha) == 0x000080, "Wrong size on MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha");
static_assert(offsetof(MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha, OwnerComp) == 0x000000, "Member 'MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha::OwnerComp' has a wrong offset!");
static_assert(offsetof(MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha, BoneName) == 0x000008, "Member 'MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha::BoneName' has a wrong offset!");
static_assert(offsetof(MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha, OutTransform) == 0x000010, "Member 'MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha::OutTransform' has a wrong offset!");
static_assert(offsetof(MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha, OutAlpha) == 0x000070, "Member 'MotionModifier_AdjustmentBlendWarp_GetAdjustmentBlendIKBoneTransformAndAlpha::OutAlpha' has a wrong offset!");

// Function X6Game.X6EffectWindZone.GetInfluenceActor
// 0x0008 (0x0008 - 0x0000)
struct X6EffectWindZone_GetInfluenceActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6EffectWindZone_GetInfluenceActor) == 0x000008, "Wrong alignment on X6EffectWindZone_GetInfluenceActor");
static_assert(sizeof(X6EffectWindZone_GetInfluenceActor) == 0x000008, "Wrong size on X6EffectWindZone_GetInfluenceActor");
static_assert(offsetof(X6EffectWindZone_GetInfluenceActor, ReturnValue) == 0x000000, "Member 'X6EffectWindZone_GetInfluenceActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6EffectWindZone.SetInfluenceActor
// 0x0008 (0x0008 - 0x0000)
struct X6EffectWindZone_SetInfluenceActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6EffectWindZone_SetInfluenceActor) == 0x000008, "Wrong alignment on X6EffectWindZone_SetInfluenceActor");
static_assert(sizeof(X6EffectWindZone_SetInfluenceActor) == 0x000008, "Wrong size on X6EffectWindZone_SetInfluenceActor");
static_assert(offsetof(X6EffectWindZone_SetInfluenceActor, InActor) == 0x000000, "Member 'X6EffectWindZone_SetInfluenceActor::InActor' has a wrong offset!");

// Function X6Game.X6EffectWindZone.SetWindDirection
// 0x0018 (0x0018 - 0x0000)
struct X6EffectWindZone_SetWindDirection final
{
public:
	struct FVector                                InWindDirection;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6EffectWindZone_SetWindDirection) == 0x000008, "Wrong alignment on X6EffectWindZone_SetWindDirection");
static_assert(sizeof(X6EffectWindZone_SetWindDirection) == 0x000018, "Wrong size on X6EffectWindZone_SetWindDirection");
static_assert(offsetof(X6EffectWindZone_SetWindDirection, InWindDirection) == 0x000000, "Member 'X6EffectWindZone_SetWindDirection::InWindDirection' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.AESDecrypt
// 0x0030 (0x0030 - 0x0000)
struct X6FileBlueprintLibrary_AESDecrypt final
{
public:
	class FString                                 InMessageNeedDecrypt;                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_AESDecrypt) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_AESDecrypt");
static_assert(sizeof(X6FileBlueprintLibrary_AESDecrypt) == 0x000030, "Wrong size on X6FileBlueprintLibrary_AESDecrypt");
static_assert(offsetof(X6FileBlueprintLibrary_AESDecrypt, InMessageNeedDecrypt) == 0x000000, "Member 'X6FileBlueprintLibrary_AESDecrypt::InMessageNeedDecrypt' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_AESDecrypt, Key) == 0x000010, "Member 'X6FileBlueprintLibrary_AESDecrypt::Key' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_AESDecrypt, ReturnValue) == 0x000020, "Member 'X6FileBlueprintLibrary_AESDecrypt::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.AESEncrypt
// 0x0030 (0x0030 - 0x0000)
struct X6FileBlueprintLibrary_AESEncrypt final
{
public:
	class FString                                 InMessageNeedEncrypt;                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_AESEncrypt) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_AESEncrypt");
static_assert(sizeof(X6FileBlueprintLibrary_AESEncrypt) == 0x000030, "Wrong size on X6FileBlueprintLibrary_AESEncrypt");
static_assert(offsetof(X6FileBlueprintLibrary_AESEncrypt, InMessageNeedEncrypt) == 0x000000, "Member 'X6FileBlueprintLibrary_AESEncrypt::InMessageNeedEncrypt' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_AESEncrypt, Key) == 0x000010, "Member 'X6FileBlueprintLibrary_AESEncrypt::Key' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_AESEncrypt, ReturnValue) == 0x000020, "Member 'X6FileBlueprintLibrary_AESEncrypt::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.CompressImageWithEncryption
// 0x0038 (0x0038 - 0x0000)
struct X6FileBlueprintLibrary_CompressImageWithEncryption final
{
public:
	class FString                                 SourceImgPath;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestPath;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EncryionKey;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_CompressImageWithEncryption) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_CompressImageWithEncryption");
static_assert(sizeof(X6FileBlueprintLibrary_CompressImageWithEncryption) == 0x000038, "Wrong size on X6FileBlueprintLibrary_CompressImageWithEncryption");
static_assert(offsetof(X6FileBlueprintLibrary_CompressImageWithEncryption, SourceImgPath) == 0x000000, "Member 'X6FileBlueprintLibrary_CompressImageWithEncryption::SourceImgPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_CompressImageWithEncryption, DestPath) == 0x000010, "Member 'X6FileBlueprintLibrary_CompressImageWithEncryption::DestPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_CompressImageWithEncryption, EncryionKey) == 0x000020, "Member 'X6FileBlueprintLibrary_CompressImageWithEncryption::EncryionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_CompressImageWithEncryption, Quality) == 0x000030, "Member 'X6FileBlueprintLibrary_CompressImageWithEncryption::Quality' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_CompressImageWithEncryption, ReturnValue) == 0x000034, "Member 'X6FileBlueprintLibrary_CompressImageWithEncryption::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.DeleteInternalFile
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_DeleteInternalFile final
{
public:
	class FString                                 DeleteFilePath;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_DeleteInternalFile) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_DeleteInternalFile");
static_assert(sizeof(X6FileBlueprintLibrary_DeleteInternalFile) == 0x000018, "Wrong size on X6FileBlueprintLibrary_DeleteInternalFile");
static_assert(offsetof(X6FileBlueprintLibrary_DeleteInternalFile, DeleteFilePath) == 0x000000, "Member 'X6FileBlueprintLibrary_DeleteInternalFile::DeleteFilePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_DeleteInternalFile, ReturnValue) == 0x000010, "Member 'X6FileBlueprintLibrary_DeleteInternalFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.DeleteInternalFileAsync
// 0x0020 (0x0020 - 0x0000)
struct X6FileBlueprintLibrary_DeleteInternalFileAsync final
{
public:
	class FString                                 DeleteFilePaths;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool Ret, const class FString& Path)> Callback;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_DeleteInternalFileAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_DeleteInternalFileAsync");
static_assert(sizeof(X6FileBlueprintLibrary_DeleteInternalFileAsync) == 0x000020, "Wrong size on X6FileBlueprintLibrary_DeleteInternalFileAsync");
static_assert(offsetof(X6FileBlueprintLibrary_DeleteInternalFileAsync, DeleteFilePaths) == 0x000000, "Member 'X6FileBlueprintLibrary_DeleteInternalFileAsync::DeleteFilePaths' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_DeleteInternalFileAsync, Callback) == 0x000010, "Member 'X6FileBlueprintLibrary_DeleteInternalFileAsync::Callback' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ForceDestroyAsyncCreatedTexture2D
// 0x0008 (0x0008 - 0x0000)
struct X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D final
{
public:
	class UTexture2D*                             InTexture;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D");
static_assert(sizeof(X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D) == 0x000008, "Wrong size on X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D");
static_assert(offsetof(X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D, InTexture) == 0x000000, "Member 'X6FileBlueprintLibrary_ForceDestroyAsyncCreatedTexture2D::InTexture' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetCroppedTexture
// 0x0028 (0x0028 - 0x0000)
struct X6FileBlueprintLibrary_GetCroppedTexture final
{
public:
	class UTexture2D*                             Tex;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPos;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_GetCroppedTexture) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetCroppedTexture");
static_assert(sizeof(X6FileBlueprintLibrary_GetCroppedTexture) == 0x000028, "Wrong size on X6FileBlueprintLibrary_GetCroppedTexture");
static_assert(offsetof(X6FileBlueprintLibrary_GetCroppedTexture, Tex) == 0x000000, "Member 'X6FileBlueprintLibrary_GetCroppedTexture::Tex' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetCroppedTexture, StartPos) == 0x000008, "Member 'X6FileBlueprintLibrary_GetCroppedTexture::StartPos' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetCroppedTexture, Width) == 0x000018, "Member 'X6FileBlueprintLibrary_GetCroppedTexture::Width' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetCroppedTexture, Height) == 0x00001C, "Member 'X6FileBlueprintLibrary_GetCroppedTexture::Height' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetCroppedTexture, ReturnValue) == 0x000020, "Member 'X6FileBlueprintLibrary_GetCroppedTexture::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetCustomDataFromPhotos
// 0x0030 (0x0030 - 0x0000)
struct X6FileBlueprintLibrary_GetCustomDataFromPhotos final
{
public:
	TArray<class FString>                         InPhotoPathList;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 EncryptionKey;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_GetCustomDataFromPhotos) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetCustomDataFromPhotos");
static_assert(sizeof(X6FileBlueprintLibrary_GetCustomDataFromPhotos) == 0x000030, "Wrong size on X6FileBlueprintLibrary_GetCustomDataFromPhotos");
static_assert(offsetof(X6FileBlueprintLibrary_GetCustomDataFromPhotos, InPhotoPathList) == 0x000000, "Member 'X6FileBlueprintLibrary_GetCustomDataFromPhotos::InPhotoPathList' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetCustomDataFromPhotos, EncryptionKey) == 0x000010, "Member 'X6FileBlueprintLibrary_GetCustomDataFromPhotos::EncryptionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetCustomDataFromPhotos, ReturnValue) == 0x000020, "Member 'X6FileBlueprintLibrary_GetCustomDataFromPhotos::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetFileModificationTime
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_GetFileModificationTime final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_GetFileModificationTime) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetFileModificationTime");
static_assert(sizeof(X6FileBlueprintLibrary_GetFileModificationTime) == 0x000018, "Wrong size on X6FileBlueprintLibrary_GetFileModificationTime");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileModificationTime, InPath) == 0x000000, "Member 'X6FileBlueprintLibrary_GetFileModificationTime::InPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileModificationTime, ReturnValue) == 0x000010, "Member 'X6FileBlueprintLibrary_GetFileModificationTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetFileNames
// 0x0028 (0x0028 - 0x0000)
struct X6FileBlueprintLibrary_GetFileNames final
{
public:
	class FString                                 InDirPath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutFileNames;                                      // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_GetFileNames) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetFileNames");
static_assert(sizeof(X6FileBlueprintLibrary_GetFileNames) == 0x000028, "Wrong size on X6FileBlueprintLibrary_GetFileNames");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileNames, InDirPath) == 0x000000, "Member 'X6FileBlueprintLibrary_GetFileNames::InDirPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileNames, OutFileNames) == 0x000010, "Member 'X6FileBlueprintLibrary_GetFileNames::OutFileNames' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileNames, ReturnValue) == 0x000020, "Member 'X6FileBlueprintLibrary_GetFileNames::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetFileSizeInKBOfPath
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_GetFileSizeInKBOfPath final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_GetFileSizeInKBOfPath) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetFileSizeInKBOfPath");
static_assert(sizeof(X6FileBlueprintLibrary_GetFileSizeInKBOfPath) == 0x000018, "Wrong size on X6FileBlueprintLibrary_GetFileSizeInKBOfPath");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileSizeInKBOfPath, InPath) == 0x000000, "Member 'X6FileBlueprintLibrary_GetFileSizeInKBOfPath::InPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetFileSizeInKBOfPath, ReturnValue) == 0x000010, "Member 'X6FileBlueprintLibrary_GetFileSizeInKBOfPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetGamePath
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_GetGamePath final
{
public:
	EGameSavedDirType                             DirType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_GetGamePath) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetGamePath");
static_assert(sizeof(X6FileBlueprintLibrary_GetGamePath) == 0x000018, "Wrong size on X6FileBlueprintLibrary_GetGamePath");
static_assert(offsetof(X6FileBlueprintLibrary_GetGamePath, DirType) == 0x000000, "Member 'X6FileBlueprintLibrary_GetGamePath::DirType' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetGamePath, ReturnValue) == 0x000008, "Member 'X6FileBlueprintLibrary_GetGamePath::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.GetStorageSizeInMBOfPath
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_GetStorageSizeInMBOfPath final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_GetStorageSizeInMBOfPath) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_GetStorageSizeInMBOfPath");
static_assert(sizeof(X6FileBlueprintLibrary_GetStorageSizeInMBOfPath) == 0x000018, "Wrong size on X6FileBlueprintLibrary_GetStorageSizeInMBOfPath");
static_assert(offsetof(X6FileBlueprintLibrary_GetStorageSizeInMBOfPath, InPath) == 0x000000, "Member 'X6FileBlueprintLibrary_GetStorageSizeInMBOfPath::InPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_GetStorageSizeInMBOfPath, ReturnValue) == 0x000010, "Member 'X6FileBlueprintLibrary_GetStorageSizeInMBOfPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsResizedTexture
// 0x0020 (0x0020 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsResizedTexture final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsResizedTexture) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsResizedTexture");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsResizedTexture) == 0x000020, "Wrong size on X6FileBlueprintLibrary_ReadAsResizedTexture");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTexture, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsResizedTexture::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTexture, Ratio) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsResizedTexture::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTexture, bSingleUse) == 0x000014, "Member 'X6FileBlueprintLibrary_ReadAsResizedTexture::bSingleUse' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTexture, ReturnValue) == 0x000018, "Member 'X6FileBlueprintLibrary_ReadAsResizedTexture::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsResizedTextureAsync
// 0x0028 (0x0028 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsResizedTextureAsync final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback;                      // 0x0014(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsResizedTextureAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsResizedTextureAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsResizedTextureAsync) == 0x000028, "Wrong size on X6FileBlueprintLibrary_ReadAsResizedTextureAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureAsync, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureAsync::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureAsync, Ratio) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureAsync::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureAsync, Callback) == 0x000014, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureAsync::Callback' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureAsync, bSingleUse) == 0x000024, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureAsync::bSingleUse' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsResizedTextureWithEncryptionCheck
// 0x0038 (0x0038 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EncryptionKey;                                     // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck) == 0x000038, "Wrong size on X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck, Ratio) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck, EncryptionKey) == 0x000018, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck::EncryptionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck, bSingleUse) == 0x000028, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck::bSingleUse' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck, ReturnValue) == 0x000030, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsResizedTextureWithEncryptionCheckAsync
// 0x0040 (0x0040 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EncryptionKey;                                     // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback;                      // 0x0028(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync) == 0x000040, "Wrong size on X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync, Ratio) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync, EncryptionKey) == 0x000018, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync::EncryptionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync, Callback) == 0x000028, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync::Callback' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync, bSingleUse) == 0x000038, "Member 'X6FileBlueprintLibrary_ReadAsResizedTextureWithEncryptionCheckAsync::bSingleUse' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsTexture
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsTexture final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsTexture) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsTexture");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsTexture) == 0x000018, "Wrong size on X6FileBlueprintLibrary_ReadAsTexture");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTexture, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsTexture::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTexture, ReturnValue) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsTexture::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsTextureAsync
// 0x0020 (0x0020 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsTextureAsync final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback;                      // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsTextureAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsTextureAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsTextureAsync) == 0x000020, "Wrong size on X6FileBlueprintLibrary_ReadAsTextureAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTextureAsync, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsTextureAsync::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTextureAsync, Callback) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsTextureAsync::Callback' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadAsTextureWithEncryptionCheckAsync
// 0x0038 (0x0038 - 0x0000)
struct X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync final
{
public:
	class FString                                 TexPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EncryptionKey;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback;                      // 0x0020(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync) == 0x000038, "Wrong size on X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync, TexPath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync::TexPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync, EncryptionKey) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync::EncryptionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync, Callback) == 0x000020, "Member 'X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync::Callback' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync, bSingleUse) == 0x000030, "Member 'X6FileBlueprintLibrary_ReadAsTextureWithEncryptionCheckAsync::bSingleUse' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadFile
// 0x0028 (0x0028 - 0x0000)
struct X6FileBlueprintLibrary_ReadFile final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Result;                                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_ReadFile) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadFile");
static_assert(sizeof(X6FileBlueprintLibrary_ReadFile) == 0x000028, "Wrong size on X6FileBlueprintLibrary_ReadFile");
static_assert(offsetof(X6FileBlueprintLibrary_ReadFile, FilePath) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadFile::FilePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadFile, Result) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadFile::Result' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadFile, ReturnValue) == 0x000020, "Member 'X6FileBlueprintLibrary_ReadFile::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadPhotosAsResizedTextureAsync
// 0x0028 (0x0028 - 0x0000)
struct X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync final
{
public:
	TArray<class FString>                         PhotoPaths;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback; // 0x0014(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync) == 0x000028, "Wrong size on X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync, PhotoPaths) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync::PhotoPaths' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync, Ratio) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync, Callback) == 0x000014, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync::Callback' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync, bSingleUse) == 0x000024, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureAsync::bSingleUse' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadPhotosAsResizedTextureWithEncryptionCheckAsync
// 0x0040 (0x0040 - 0x0000)
struct X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync final
{
public:
	TArray<class FString>                         PhotoPaths;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EncryptionKey;                                     // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback; // 0x0028(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleUse;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync) == 0x000040, "Wrong size on X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync, PhotoPaths) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync::PhotoPaths' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync, Ratio) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync, EncryptionKey) == 0x000018, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync::EncryptionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync, Callback) == 0x000028, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync::Callback' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync, bSingleUse) == 0x000038, "Member 'X6FileBlueprintLibrary_ReadPhotosAsResizedTextureWithEncryptionCheckAsync::bSingleUse' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadPhotosAsTextureAsync
// 0x0020 (0x0020 - 0x0000)
struct X6FileBlueprintLibrary_ReadPhotosAsTextureAsync final
{
public:
	TArray<class FString>                         PhotoPaths;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback; // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ReadPhotosAsTextureAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadPhotosAsTextureAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadPhotosAsTextureAsync) == 0x000020, "Wrong size on X6FileBlueprintLibrary_ReadPhotosAsTextureAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsTextureAsync, PhotoPaths) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadPhotosAsTextureAsync::PhotoPaths' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsTextureAsync, Callback) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadPhotosAsTextureAsync::Callback' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ReadPhotosAsTextureWithEncryptionCheckAsync
// 0x0030 (0x0030 - 0x0000)
struct X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync final
{
public:
	TArray<class FString>                         PhotoPaths;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 EncryptionKey;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback; // 0x0020(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync");
static_assert(sizeof(X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync) == 0x000030, "Wrong size on X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync, PhotoPaths) == 0x000000, "Member 'X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync::PhotoPaths' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync, EncryptionKey) == 0x000010, "Member 'X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync::EncryptionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync, Callback) == 0x000020, "Member 'X6FileBlueprintLibrary_ReadPhotosAsTextureWithEncryptionCheckAsync::Callback' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.ResizeAndSaveTextureWithEncryption
// 0x0048 (0x0048 - 0x0000)
struct X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InPath;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EncryionKey;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomData;                                        // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption");
static_assert(sizeof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption) == 0x000048, "Wrong size on X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption");
static_assert(offsetof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption, Texture) == 0x000000, "Member 'X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption::Texture' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption, InPath) == 0x000008, "Member 'X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption::InPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption, Ratio) == 0x000018, "Member 'X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption::Ratio' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption, EncryionKey) == 0x000020, "Member 'X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption::EncryionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption, Quality) == 0x000030, "Member 'X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption::Quality' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption, CustomData) == 0x000038, "Member 'X6FileBlueprintLibrary_ResizeAndSaveTextureWithEncryption::CustomData' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SaveImageToAlbum
// 0x0048 (0x0048 - 0x0000)
struct X6FileBlueprintLibrary_SaveImageToAlbum final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FromPath;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetDir;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewFileName;                                       // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool Result)>                  Delegate;                                          // 0x0038(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_SaveImageToAlbum) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SaveImageToAlbum");
static_assert(sizeof(X6FileBlueprintLibrary_SaveImageToAlbum) == 0x000048, "Wrong size on X6FileBlueprintLibrary_SaveImageToAlbum");
static_assert(offsetof(X6FileBlueprintLibrary_SaveImageToAlbum, Context) == 0x000000, "Member 'X6FileBlueprintLibrary_SaveImageToAlbum::Context' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveImageToAlbum, FromPath) == 0x000008, "Member 'X6FileBlueprintLibrary_SaveImageToAlbum::FromPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveImageToAlbum, TargetDir) == 0x000018, "Member 'X6FileBlueprintLibrary_SaveImageToAlbum::TargetDir' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveImageToAlbum, NewFileName) == 0x000028, "Member 'X6FileBlueprintLibrary_SaveImageToAlbum::NewFileName' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveImageToAlbum, Delegate) == 0x000038, "Member 'X6FileBlueprintLibrary_SaveImageToAlbum::Delegate' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SaveRenderTexture
// 0x0020 (0x0020 - 0x0000)
struct X6FileBlueprintLibrary_SaveRenderTexture final
{
public:
	class FString                                 SavePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 Tex;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_SaveRenderTexture) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SaveRenderTexture");
static_assert(sizeof(X6FileBlueprintLibrary_SaveRenderTexture) == 0x000020, "Wrong size on X6FileBlueprintLibrary_SaveRenderTexture");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTexture, SavePath) == 0x000000, "Member 'X6FileBlueprintLibrary_SaveRenderTexture::SavePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTexture, Tex) == 0x000010, "Member 'X6FileBlueprintLibrary_SaveRenderTexture::Tex' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTexture, Quality) == 0x000018, "Member 'X6FileBlueprintLibrary_SaveRenderTexture::Quality' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SaveRenderTextureWithEncryption
// 0x0040 (0x0040 - 0x0000)
struct X6FileBlueprintLibrary_SaveRenderTextureWithEncryption final
{
public:
	class FString                                 SavePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 Tex;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EncryionKey;                                       // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomData;                                        // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SaveRenderTextureWithEncryption");
static_assert(sizeof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption) == 0x000040, "Wrong size on X6FileBlueprintLibrary_SaveRenderTextureWithEncryption");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption, SavePath) == 0x000000, "Member 'X6FileBlueprintLibrary_SaveRenderTextureWithEncryption::SavePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption, Tex) == 0x000010, "Member 'X6FileBlueprintLibrary_SaveRenderTextureWithEncryption::Tex' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption, EncryionKey) == 0x000018, "Member 'X6FileBlueprintLibrary_SaveRenderTextureWithEncryption::EncryionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption, Quality) == 0x000028, "Member 'X6FileBlueprintLibrary_SaveRenderTextureWithEncryption::Quality' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveRenderTextureWithEncryption, CustomData) == 0x000030, "Member 'X6FileBlueprintLibrary_SaveRenderTextureWithEncryption::CustomData' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SaveTexture
// 0x0020 (0x0020 - 0x0000)
struct X6FileBlueprintLibrary_SaveTexture final
{
public:
	class FString                                 SavePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Tex;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_SaveTexture) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SaveTexture");
static_assert(sizeof(X6FileBlueprintLibrary_SaveTexture) == 0x000020, "Wrong size on X6FileBlueprintLibrary_SaveTexture");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTexture, SavePath) == 0x000000, "Member 'X6FileBlueprintLibrary_SaveTexture::SavePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTexture, Tex) == 0x000010, "Member 'X6FileBlueprintLibrary_SaveTexture::Tex' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTexture, Quality) == 0x000018, "Member 'X6FileBlueprintLibrary_SaveTexture::Quality' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTexture, ReturnValue) == 0x00001C, "Member 'X6FileBlueprintLibrary_SaveTexture::ReturnValue' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SaveTextureAsync
// 0x0030 (0x0030 - 0x0000)
struct X6FileBlueprintLibrary_SaveTextureAsync final
{
public:
	class FString                                 SavePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Tex;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool Ret, const class FString& Path)> Callback;                                   // 0x001C(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_SaveTextureAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SaveTextureAsync");
static_assert(sizeof(X6FileBlueprintLibrary_SaveTextureAsync) == 0x000030, "Wrong size on X6FileBlueprintLibrary_SaveTextureAsync");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureAsync, SavePath) == 0x000000, "Member 'X6FileBlueprintLibrary_SaveTextureAsync::SavePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureAsync, Tex) == 0x000010, "Member 'X6FileBlueprintLibrary_SaveTextureAsync::Tex' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureAsync, Quality) == 0x000018, "Member 'X6FileBlueprintLibrary_SaveTextureAsync::Quality' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureAsync, Callback) == 0x00001C, "Member 'X6FileBlueprintLibrary_SaveTextureAsync::Callback' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SaveTextureWithEncryptionAsync
// 0x0050 (0x0050 - 0x0000)
struct X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync final
{
public:
	class FString                                 SavePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Tex;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EncryionKey;                                       // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomData;                                        // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool Ret, const class FString& Path)> Callback;                                   // 0x0040(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync");
static_assert(sizeof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync) == 0x000050, "Wrong size on X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync, SavePath) == 0x000000, "Member 'X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync::SavePath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync, Tex) == 0x000010, "Member 'X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync::Tex' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync, EncryionKey) == 0x000018, "Member 'X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync::EncryionKey' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync, Quality) == 0x000028, "Member 'X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync::Quality' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync, CustomData) == 0x000030, "Member 'X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync::CustomData' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync, Callback) == 0x000040, "Member 'X6FileBlueprintLibrary_SaveTextureWithEncryptionAsync::Callback' has a wrong offset!");

// Function X6Game.X6FileBlueprintLibrary.SetFileHidden_WindowsOnly
// 0x0018 (0x0018 - 0x0000)
struct X6FileBlueprintLibrary_SetFileHidden_WindowsOnly final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InHidden;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FileBlueprintLibrary_SetFileHidden_WindowsOnly) == 0x000008, "Wrong alignment on X6FileBlueprintLibrary_SetFileHidden_WindowsOnly");
static_assert(sizeof(X6FileBlueprintLibrary_SetFileHidden_WindowsOnly) == 0x000018, "Wrong size on X6FileBlueprintLibrary_SetFileHidden_WindowsOnly");
static_assert(offsetof(X6FileBlueprintLibrary_SetFileHidden_WindowsOnly, InPath) == 0x000000, "Member 'X6FileBlueprintLibrary_SetFileHidden_WindowsOnly::InPath' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SetFileHidden_WindowsOnly, InHidden) == 0x000010, "Member 'X6FileBlueprintLibrary_SetFileHidden_WindowsOnly::InHidden' has a wrong offset!");
static_assert(offsetof(X6FileBlueprintLibrary_SetFileHidden_WindowsOnly, ReturnValue) == 0x000011, "Member 'X6FileBlueprintLibrary_SetFileHidden_WindowsOnly::ReturnValue' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.GetSpeedRateValue
// 0x0008 (0x0008 - 0x0000)
struct X6FlyItemLogicComponent_GetSpeedRateValue final
{
public:
	float                                         RateValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FlyItemLogicComponent_GetSpeedRateValue) == 0x000004, "Wrong alignment on X6FlyItemLogicComponent_GetSpeedRateValue");
static_assert(sizeof(X6FlyItemLogicComponent_GetSpeedRateValue) == 0x000008, "Wrong size on X6FlyItemLogicComponent_GetSpeedRateValue");
static_assert(offsetof(X6FlyItemLogicComponent_GetSpeedRateValue, RateValue) == 0x000000, "Member 'X6FlyItemLogicComponent_GetSpeedRateValue::RateValue' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_GetSpeedRateValue, ReturnValue) == 0x000004, "Member 'X6FlyItemLogicComponent_GetSpeedRateValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.InitData
// 0x00C0 (0x00C0 - 0x0000)
struct X6FlyItemLogicComponent_InitData final
{
public:
	class UCurveFloat*                            InSpeedCurve;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBaseSpeed;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         inDuration;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSpeedUpTime;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6FlyItemTraceContext                 InCollisionTraceContext;                           // 0x0018(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FX6FlyItemTraceContext                 InHitTraceContext;                                 // 0x0040(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InRadius;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFloorAngle;                                      // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWallAngle;                                       // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InToLevelOffset;                                   // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        InTargetComponent;                                 // 0x0078(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0080(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFollowRefreshInterval;                           // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InFollowTargetRotator;                             // 0x0090(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               InFollowCanRotator;                                // 0x00A8(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FlyItemLogicComponent_InitData) == 0x000008, "Wrong alignment on X6FlyItemLogicComponent_InitData");
static_assert(sizeof(X6FlyItemLogicComponent_InitData) == 0x0000C0, "Wrong size on X6FlyItemLogicComponent_InitData");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InSpeedCurve) == 0x000000, "Member 'X6FlyItemLogicComponent_InitData::InSpeedCurve' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InBaseSpeed) == 0x000008, "Member 'X6FlyItemLogicComponent_InitData::InBaseSpeed' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, inDuration) == 0x00000C, "Member 'X6FlyItemLogicComponent_InitData::inDuration' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InSpeedUpTime) == 0x000010, "Member 'X6FlyItemLogicComponent_InitData::InSpeedUpTime' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InCollisionTraceContext) == 0x000018, "Member 'X6FlyItemLogicComponent_InitData::InCollisionTraceContext' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InHitTraceContext) == 0x000040, "Member 'X6FlyItemLogicComponent_InitData::InHitTraceContext' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InRadius) == 0x000068, "Member 'X6FlyItemLogicComponent_InitData::InRadius' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InFloorAngle) == 0x00006C, "Member 'X6FlyItemLogicComponent_InitData::InFloorAngle' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InWallAngle) == 0x000070, "Member 'X6FlyItemLogicComponent_InitData::InWallAngle' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InToLevelOffset) == 0x000074, "Member 'X6FlyItemLogicComponent_InitData::InToLevelOffset' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InTargetComponent) == 0x000078, "Member 'X6FlyItemLogicComponent_InitData::InTargetComponent' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InTargetActor) == 0x000080, "Member 'X6FlyItemLogicComponent_InitData::InTargetActor' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InFollowRefreshInterval) == 0x000088, "Member 'X6FlyItemLogicComponent_InitData::InFollowRefreshInterval' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InFollowTargetRotator) == 0x000090, "Member 'X6FlyItemLogicComponent_InitData::InFollowTargetRotator' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_InitData, InFollowCanRotator) == 0x0000A8, "Member 'X6FlyItemLogicComponent_InitData::InFollowCanRotator' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.K2_DoPendingDestroy
// 0x0010 (0x0010 - 0x0000)
struct X6FlyItemLogicComponent_K2_DoPendingDestroy final
{
public:
	bool                                          bHitDamage;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActor;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FlyItemLogicComponent_K2_DoPendingDestroy) == 0x000008, "Wrong alignment on X6FlyItemLogicComponent_K2_DoPendingDestroy");
static_assert(sizeof(X6FlyItemLogicComponent_K2_DoPendingDestroy) == 0x000010, "Wrong size on X6FlyItemLogicComponent_K2_DoPendingDestroy");
static_assert(offsetof(X6FlyItemLogicComponent_K2_DoPendingDestroy, bHitDamage) == 0x000000, "Member 'X6FlyItemLogicComponent_K2_DoPendingDestroy::bHitDamage' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_K2_DoPendingDestroy, HitActor) == 0x000008, "Member 'X6FlyItemLogicComponent_K2_DoPendingDestroy::HitActor' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.SetCacheDamiaoActor
// 0x0008 (0x0008 - 0x0000)
struct X6FlyItemLogicComponent_SetCacheDamiaoActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FlyItemLogicComponent_SetCacheDamiaoActor) == 0x000008, "Wrong alignment on X6FlyItemLogicComponent_SetCacheDamiaoActor");
static_assert(sizeof(X6FlyItemLogicComponent_SetCacheDamiaoActor) == 0x000008, "Wrong size on X6FlyItemLogicComponent_SetCacheDamiaoActor");
static_assert(offsetof(X6FlyItemLogicComponent_SetCacheDamiaoActor, InActor) == 0x000000, "Member 'X6FlyItemLogicComponent_SetCacheDamiaoActor::InActor' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.TickCollision
// 0x0030 (0x0030 - 0x0000)
struct X6FlyItemLogicComponent_TickCollision final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FlyItemLogicComponent_TickCollision) == 0x000008, "Wrong alignment on X6FlyItemLogicComponent_TickCollision");
static_assert(sizeof(X6FlyItemLogicComponent_TickCollision) == 0x000030, "Wrong size on X6FlyItemLogicComponent_TickCollision");
static_assert(offsetof(X6FlyItemLogicComponent_TickCollision, StartLocation) == 0x000000, "Member 'X6FlyItemLogicComponent_TickCollision::StartLocation' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_TickCollision, EndLocation) == 0x000018, "Member 'X6FlyItemLogicComponent_TickCollision::EndLocation' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.K2_ShouldDestroyByActor
// 0x0010 (0x0010 - 0x0000)
struct X6FlyItemLogicComponent_K2_ShouldDestroyByActor final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FlyItemLogicComponent_K2_ShouldDestroyByActor) == 0x000008, "Wrong alignment on X6FlyItemLogicComponent_K2_ShouldDestroyByActor");
static_assert(sizeof(X6FlyItemLogicComponent_K2_ShouldDestroyByActor) == 0x000010, "Wrong size on X6FlyItemLogicComponent_K2_ShouldDestroyByActor");
static_assert(offsetof(X6FlyItemLogicComponent_K2_ShouldDestroyByActor, HitActor) == 0x000000, "Member 'X6FlyItemLogicComponent_K2_ShouldDestroyByActor::HitActor' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_K2_ShouldDestroyByActor, ReturnValue) == 0x000008, "Member 'X6FlyItemLogicComponent_K2_ShouldDestroyByActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6FlyItemLogicComponent.K2_TickHit
// 0x0028 (0x0028 - 0x0000)
struct X6FlyItemLogicComponent_K2_TickHit final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitResults;                                        // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FlyItemLogicComponent_K2_TickHit) == 0x000008, "Wrong alignment on X6FlyItemLogicComponent_K2_TickHit");
static_assert(sizeof(X6FlyItemLogicComponent_K2_TickHit) == 0x000028, "Wrong size on X6FlyItemLogicComponent_K2_TickHit");
static_assert(offsetof(X6FlyItemLogicComponent_K2_TickHit, StartLocation) == 0x000000, "Member 'X6FlyItemLogicComponent_K2_TickHit::StartLocation' has a wrong offset!");
static_assert(offsetof(X6FlyItemLogicComponent_K2_TickHit, HitResults) == 0x000018, "Member 'X6FlyItemLogicComponent_K2_TickHit::HitResults' has a wrong offset!");

// Function X6Game.X6AnimNotifyState_TimedNiagaraEffect.GetSpawnedEffect
// 0x0010 (0x0010 - 0x0000)
struct X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect final
{
public:
	class UMeshComponent*                         MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect) == 0x000008, "Wrong alignment on X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect");
static_assert(sizeof(X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect) == 0x000010, "Wrong size on X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect");
static_assert(offsetof(X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect, MeshComp) == 0x000000, "Member 'X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect::MeshComp' has a wrong offset!");
static_assert(offsetof(X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect, ReturnValue) == 0x000008, "Member 'X6AnimNotifyState_TimedNiagaraEffect_GetSpawnedEffect::ReturnValue' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.GetSplineBoundBox
// 0x0038 (0x0038 - 0x0000)
struct X6FollowSplineMovementComponent_GetSplineBoundBox final
{
public:
	struct FBoxSphereBounds                       ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_GetSplineBoundBox) == 0x000008, "Wrong alignment on X6FollowSplineMovementComponent_GetSplineBoundBox");
static_assert(sizeof(X6FollowSplineMovementComponent_GetSplineBoundBox) == 0x000038, "Wrong size on X6FollowSplineMovementComponent_GetSplineBoundBox");
static_assert(offsetof(X6FollowSplineMovementComponent_GetSplineBoundBox, ReturnValue) == 0x000000, "Member 'X6FollowSplineMovementComponent_GetSplineBoundBox::ReturnValue' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.RequestKeepOffLocation
// 0x0018 (0x0018 - 0x0000)
struct X6FollowSplineMovementComponent_RequestKeepOffLocation final
{
public:
	struct FVector                                InWorldLocation;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_RequestKeepOffLocation) == 0x000008, "Wrong alignment on X6FollowSplineMovementComponent_RequestKeepOffLocation");
static_assert(sizeof(X6FollowSplineMovementComponent_RequestKeepOffLocation) == 0x000018, "Wrong size on X6FollowSplineMovementComponent_RequestKeepOffLocation");
static_assert(offsetof(X6FollowSplineMovementComponent_RequestKeepOffLocation, InWorldLocation) == 0x000000, "Member 'X6FollowSplineMovementComponent_RequestKeepOffLocation::InWorldLocation' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetAllowRootMotionTickPose
// 0x0001 (0x0001 - 0x0000)
struct X6FollowSplineMovementComponent_SetAllowRootMotionTickPose final
{
public:
	bool                                          bNewAllowRootMotionTickPose;                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetAllowRootMotionTickPose) == 0x000001, "Wrong alignment on X6FollowSplineMovementComponent_SetAllowRootMotionTickPose");
static_assert(sizeof(X6FollowSplineMovementComponent_SetAllowRootMotionTickPose) == 0x000001, "Wrong size on X6FollowSplineMovementComponent_SetAllowRootMotionTickPose");
static_assert(offsetof(X6FollowSplineMovementComponent_SetAllowRootMotionTickPose, bNewAllowRootMotionTickPose) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetAllowRootMotionTickPose::bNewAllowRootMotionTickPose' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetFastMovingTurnSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6FollowSplineMovementComponent_SetFastMovingTurnSpeed final
{
public:
	float                                         InFastMovingTurnSpeed;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetFastMovingTurnSpeed) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_SetFastMovingTurnSpeed");
static_assert(sizeof(X6FollowSplineMovementComponent_SetFastMovingTurnSpeed) == 0x000004, "Wrong size on X6FollowSplineMovementComponent_SetFastMovingTurnSpeed");
static_assert(offsetof(X6FollowSplineMovementComponent_SetFastMovingTurnSpeed, InFastMovingTurnSpeed) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetFastMovingTurnSpeed::InFastMovingTurnSpeed' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetMoveConfig
// 0x0018 (0x0018 - 0x0000)
struct X6FollowSplineMovementComponent_SetMoveConfig final
{
public:
	float                                         InMovingTurnSpeed;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFastMovingTurnSpeed;                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAvoidOffsetDistance;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAvoidTraceCapsuleHalfHeightScale;                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAvoidCheckSweepAngle;                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAvoidReturnCenterThreshold;                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetMoveConfig) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_SetMoveConfig");
static_assert(sizeof(X6FollowSplineMovementComponent_SetMoveConfig) == 0x000018, "Wrong size on X6FollowSplineMovementComponent_SetMoveConfig");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveConfig, InMovingTurnSpeed) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetMoveConfig::InMovingTurnSpeed' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveConfig, InFastMovingTurnSpeed) == 0x000004, "Member 'X6FollowSplineMovementComponent_SetMoveConfig::InFastMovingTurnSpeed' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveConfig, InAvoidOffsetDistance) == 0x000008, "Member 'X6FollowSplineMovementComponent_SetMoveConfig::InAvoidOffsetDistance' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveConfig, InAvoidTraceCapsuleHalfHeightScale) == 0x00000C, "Member 'X6FollowSplineMovementComponent_SetMoveConfig::InAvoidTraceCapsuleHalfHeightScale' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveConfig, InAvoidCheckSweepAngle) == 0x000010, "Member 'X6FollowSplineMovementComponent_SetMoveConfig::InAvoidCheckSweepAngle' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveConfig, InAvoidReturnCenterThreshold) == 0x000014, "Member 'X6FollowSplineMovementComponent_SetMoveConfig::InAvoidReturnCenterThreshold' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetMoveSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6FollowSplineMovementComponent_SetMoveSpeed final
{
public:
	float                                         InMoveSpeed;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetMoveSpeed) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_SetMoveSpeed");
static_assert(sizeof(X6FollowSplineMovementComponent_SetMoveSpeed) == 0x000004, "Wrong size on X6FollowSplineMovementComponent_SetMoveSpeed");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveSpeed, InMoveSpeed) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetMoveSpeed::InMoveSpeed' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetMoveVerticalSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6FollowSplineMovementComponent_SetMoveVerticalSpeed final
{
public:
	float                                         InMoveVerticalSpeed;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetMoveVerticalSpeed) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_SetMoveVerticalSpeed");
static_assert(sizeof(X6FollowSplineMovementComponent_SetMoveVerticalSpeed) == 0x000004, "Wrong size on X6FollowSplineMovementComponent_SetMoveVerticalSpeed");
static_assert(offsetof(X6FollowSplineMovementComponent_SetMoveVerticalSpeed, InMoveVerticalSpeed) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetMoveVerticalSpeed::InMoveVerticalSpeed' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetPathNodeInfo
// 0x0050 (0x0050 - 0x0000)
struct X6FollowSplineMovementComponent_SetPathNodeInfo final
{
public:
	TMap<int32, struct FSplinePathNodeInfo>       PathNodeInfo;                                      // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetPathNodeInfo) == 0x000008, "Wrong alignment on X6FollowSplineMovementComponent_SetPathNodeInfo");
static_assert(sizeof(X6FollowSplineMovementComponent_SetPathNodeInfo) == 0x000050, "Wrong size on X6FollowSplineMovementComponent_SetPathNodeInfo");
static_assert(offsetof(X6FollowSplineMovementComponent_SetPathNodeInfo, PathNodeInfo) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetPathNodeInfo::PathNodeInfo' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetShouldReturnWhenEnd
// 0x0001 (0x0001 - 0x0000)
struct X6FollowSplineMovementComponent_SetShouldReturnWhenEnd final
{
public:
	bool                                          bNewReturn;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetShouldReturnWhenEnd) == 0x000001, "Wrong alignment on X6FollowSplineMovementComponent_SetShouldReturnWhenEnd");
static_assert(sizeof(X6FollowSplineMovementComponent_SetShouldReturnWhenEnd) == 0x000001, "Wrong size on X6FollowSplineMovementComponent_SetShouldReturnWhenEnd");
static_assert(offsetof(X6FollowSplineMovementComponent_SetShouldReturnWhenEnd, bNewReturn) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetShouldReturnWhenEnd::bNewReturn' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetTargetSplinePath
// 0x0008 (0x0008 - 0x0000)
struct X6FollowSplineMovementComponent_SetTargetSplinePath final
{
public:
	const class USplineComponent*                 InTargetSplinePathComponent;                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetTargetSplinePath) == 0x000008, "Wrong alignment on X6FollowSplineMovementComponent_SetTargetSplinePath");
static_assert(sizeof(X6FollowSplineMovementComponent_SetTargetSplinePath) == 0x000008, "Wrong size on X6FollowSplineMovementComponent_SetTargetSplinePath");
static_assert(offsetof(X6FollowSplineMovementComponent_SetTargetSplinePath, InTargetSplinePathComponent) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetTargetSplinePath::InTargetSplinePathComponent' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.SetTriggerFastTurnYawDistance
// 0x0004 (0x0004 - 0x0000)
struct X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance final
{
public:
	float                                         InTriggerFastTurnYawDistance;                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance");
static_assert(sizeof(X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance) == 0x000004, "Wrong size on X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance");
static_assert(offsetof(X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance, InTriggerFastTurnYawDistance) == 0x000000, "Member 'X6FollowSplineMovementComponent_SetTriggerFastTurnYawDistance::InTriggerFastTurnYawDistance' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.TriggerReactToNikki
// 0x000C (0x000C - 0x0000)
struct X6FollowSplineMovementComponent_TriggerReactToNikki final
{
public:
	float                                         TurnToNikkiYaw;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactTimeLength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          inbReactWithoutTurn;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6FollowSplineMovementComponent_TriggerReactToNikki) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_TriggerReactToNikki");
static_assert(sizeof(X6FollowSplineMovementComponent_TriggerReactToNikki) == 0x00000C, "Wrong size on X6FollowSplineMovementComponent_TriggerReactToNikki");
static_assert(offsetof(X6FollowSplineMovementComponent_TriggerReactToNikki, TurnToNikkiYaw) == 0x000000, "Member 'X6FollowSplineMovementComponent_TriggerReactToNikki::TurnToNikkiYaw' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_TriggerReactToNikki, ReactTimeLength) == 0x000004, "Member 'X6FollowSplineMovementComponent_TriggerReactToNikki::ReactTimeLength' has a wrong offset!");
static_assert(offsetof(X6FollowSplineMovementComponent_TriggerReactToNikki, inbReactWithoutTurn) == 0x000008, "Member 'X6FollowSplineMovementComponent_TriggerReactToNikki::inbReactWithoutTurn' has a wrong offset!");

// Function X6Game.X6FollowSplineMovementComponent.TriggerTurnInReact
// 0x0004 (0x0004 - 0x0000)
struct X6FollowSplineMovementComponent_TriggerTurnInReact final
{
public:
	float                                         TurnToNikkiYaw;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6FollowSplineMovementComponent_TriggerTurnInReact) == 0x000004, "Wrong alignment on X6FollowSplineMovementComponent_TriggerTurnInReact");
static_assert(sizeof(X6FollowSplineMovementComponent_TriggerTurnInReact) == 0x000004, "Wrong size on X6FollowSplineMovementComponent_TriggerTurnInReact");
static_assert(offsetof(X6FollowSplineMovementComponent_TriggerTurnInReact, TurnToNikkiYaw) == 0x000000, "Member 'X6FollowSplineMovementComponent_TriggerTurnInReact::TurnToNikkiYaw' has a wrong offset!");

// Function X6Game.X6GameInstance.GetActorsByTag
// 0x0020 (0x0020 - 0x0000)
struct X6GameInstance_GetActorsByTag final
{
public:
	class FString                                 Tag;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetActorsByTag) == 0x000008, "Wrong alignment on X6GameInstance_GetActorsByTag");
static_assert(sizeof(X6GameInstance_GetActorsByTag) == 0x000020, "Wrong size on X6GameInstance_GetActorsByTag");
static_assert(offsetof(X6GameInstance_GetActorsByTag, Tag) == 0x000000, "Member 'X6GameInstance_GetActorsByTag::Tag' has a wrong offset!");
static_assert(offsetof(X6GameInstance_GetActorsByTag, ReturnValue) == 0x000010, "Member 'X6GameInstance_GetActorsByTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.GetAirPathfindManager
// 0x0008 (0x0008 - 0x0000)
struct X6GameInstance_GetAirPathfindManager final
{
public:
	class ADonNavigationManagerUnbound*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetAirPathfindManager) == 0x000008, "Wrong alignment on X6GameInstance_GetAirPathfindManager");
static_assert(sizeof(X6GameInstance_GetAirPathfindManager) == 0x000008, "Wrong size on X6GameInstance_GetAirPathfindManager");
static_assert(offsetof(X6GameInstance_GetAirPathfindManager, ReturnValue) == 0x000000, "Member 'X6GameInstance_GetAirPathfindManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.GetInputProcessorHelper
// 0x0008 (0x0008 - 0x0000)
struct X6GameInstance_GetInputProcessorHelper final
{
public:
	class UX6InputProcessorHelper*                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetInputProcessorHelper) == 0x000008, "Wrong alignment on X6GameInstance_GetInputProcessorHelper");
static_assert(sizeof(X6GameInstance_GetInputProcessorHelper) == 0x000008, "Wrong size on X6GameInstance_GetInputProcessorHelper");
static_assert(offsetof(X6GameInstance_GetInputProcessorHelper, ReturnValue) == 0x000000, "Member 'X6GameInstance_GetInputProcessorHelper::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.GetPaperDissolveManager
// 0x0008 (0x0008 - 0x0000)
struct X6GameInstance_GetPaperDissolveManager final
{
public:
	class APaperDissolveManager*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetPaperDissolveManager) == 0x000008, "Wrong alignment on X6GameInstance_GetPaperDissolveManager");
static_assert(sizeof(X6GameInstance_GetPaperDissolveManager) == 0x000008, "Wrong size on X6GameInstance_GetPaperDissolveManager");
static_assert(offsetof(X6GameInstance_GetPaperDissolveManager, ReturnValue) == 0x000000, "Member 'X6GameInstance_GetPaperDissolveManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.GetUIMultiFoliageInteractionManager
// 0x0008 (0x0008 - 0x0000)
struct X6GameInstance_GetUIMultiFoliageInteractionManager final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetUIMultiFoliageInteractionManager) == 0x000008, "Wrong alignment on X6GameInstance_GetUIMultiFoliageInteractionManager");
static_assert(sizeof(X6GameInstance_GetUIMultiFoliageInteractionManager) == 0x000008, "Wrong size on X6GameInstance_GetUIMultiFoliageInteractionManager");
static_assert(offsetof(X6GameInstance_GetUIMultiFoliageInteractionManager, ReturnValue) == 0x000000, "Member 'X6GameInstance_GetUIMultiFoliageInteractionManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.GetUIPFManager
// 0x0010 (0x0010 - 0x0000)
struct X6GameInstance_GetUIPFManager final
{
public:
	EUIPFManagerType                              UIPFManagerType;                                   // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIPFManager*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetUIPFManager) == 0x000008, "Wrong alignment on X6GameInstance_GetUIPFManager");
static_assert(sizeof(X6GameInstance_GetUIPFManager) == 0x000010, "Wrong size on X6GameInstance_GetUIPFManager");
static_assert(offsetof(X6GameInstance_GetUIPFManager, UIPFManagerType) == 0x000000, "Member 'X6GameInstance_GetUIPFManager::UIPFManagerType' has a wrong offset!");
static_assert(offsetof(X6GameInstance_GetUIPFManager, ReturnValue) == 0x000008, "Member 'X6GameInstance_GetUIPFManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.GetUIWSManager
// 0x0008 (0x0008 - 0x0000)
struct X6GameInstance_GetUIWSManager final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_GetUIWSManager) == 0x000008, "Wrong alignment on X6GameInstance_GetUIWSManager");
static_assert(sizeof(X6GameInstance_GetUIWSManager) == 0x000008, "Wrong size on X6GameInstance_GetUIWSManager");
static_assert(offsetof(X6GameInstance_GetUIWSManager, ReturnValue) == 0x000000, "Member 'X6GameInstance_GetUIWSManager::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameInstance.OnSetSpawnerCachedata
// 0x0008 (0x0008 - 0x0000)
struct X6GameInstance_OnSetSpawnerCachedata final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameInstance_OnSetSpawnerCachedata) == 0x000008, "Wrong alignment on X6GameInstance_OnSetSpawnerCachedata");
static_assert(sizeof(X6GameInstance_OnSetSpawnerCachedata) == 0x000008, "Wrong size on X6GameInstance_OnSetSpawnerCachedata");
static_assert(offsetof(X6GameInstance_OnSetSpawnerCachedata, Actor) == 0x000000, "Member 'X6GameInstance_OnSetSpawnerCachedata::Actor' has a wrong offset!");

// Function X6Game.X6Pawn.AttributeChange
// 0x0010 (0x0010 - 0x0000)
struct X6Pawn_AttributeChange final
{
public:
	class FString                                 AttributeName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Pawn_AttributeChange) == 0x000008, "Wrong alignment on X6Pawn_AttributeChange");
static_assert(sizeof(X6Pawn_AttributeChange) == 0x000010, "Wrong size on X6Pawn_AttributeChange");
static_assert(offsetof(X6Pawn_AttributeChange, AttributeName) == 0x000000, "Member 'X6Pawn_AttributeChange::AttributeName' has a wrong offset!");

// Function X6Game.X6Pawn.PostServerInit
// 0x0001 (0x0001 - 0x0000)
struct X6Pawn_PostServerInit final
{
public:
	bool                                          bServer;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Pawn_PostServerInit) == 0x000001, "Wrong alignment on X6Pawn_PostServerInit");
static_assert(sizeof(X6Pawn_PostServerInit) == 0x000001, "Wrong size on X6Pawn_PostServerInit");
static_assert(offsetof(X6Pawn_PostServerInit, bServer) == 0x000000, "Member 'X6Pawn_PostServerInit::bServer' has a wrong offset!");

// Function X6Game.X6Pawn.ServerInit
// 0x0001 (0x0001 - 0x0000)
struct X6Pawn_ServerInit final
{
public:
	bool                                          bServer;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Pawn_ServerInit) == 0x000001, "Wrong alignment on X6Pawn_ServerInit");
static_assert(sizeof(X6Pawn_ServerInit) == 0x000001, "Wrong size on X6Pawn_ServerInit");
static_assert(offsetof(X6Pawn_ServerInit, bServer) == 0x000000, "Member 'X6Pawn_ServerInit::bServer' has a wrong offset!");

// Function X6Game.X6Pawn.X6_AddTag
// 0x0010 (0x0010 - 0x0000)
struct X6Pawn_X6_AddTag final
{
public:
	TArray<class FName>                           NewX6Tags;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Pawn_X6_AddTag) == 0x000008, "Wrong alignment on X6Pawn_X6_AddTag");
static_assert(sizeof(X6Pawn_X6_AddTag) == 0x000010, "Wrong size on X6Pawn_X6_AddTag");
static_assert(offsetof(X6Pawn_X6_AddTag, NewX6Tags) == 0x000000, "Member 'X6Pawn_X6_AddTag::NewX6Tags' has a wrong offset!");

// Function X6Game.X6Pawn.X6_DeleteTag
// 0x0010 (0x0010 - 0x0000)
struct X6Pawn_X6_DeleteTag final
{
public:
	class FString                                 strTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Pawn_X6_DeleteTag) == 0x000008, "Wrong alignment on X6Pawn_X6_DeleteTag");
static_assert(sizeof(X6Pawn_X6_DeleteTag) == 0x000010, "Wrong size on X6Pawn_X6_DeleteTag");
static_assert(offsetof(X6Pawn_X6_DeleteTag, strTag) == 0x000000, "Member 'X6Pawn_X6_DeleteTag::strTag' has a wrong offset!");

// Function X6Game.X6Pawn.X6_GetActorHiddenFlags
// 0x0058 (0x0058 - 0x0000)
struct X6Pawn_X6_GetActorHiddenFlags final
{
public:
	TSet<int32>                                   OutFlags;                                          // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Pawn_X6_GetActorHiddenFlags) == 0x000008, "Wrong alignment on X6Pawn_X6_GetActorHiddenFlags");
static_assert(sizeof(X6Pawn_X6_GetActorHiddenFlags) == 0x000058, "Wrong size on X6Pawn_X6_GetActorHiddenFlags");
static_assert(offsetof(X6Pawn_X6_GetActorHiddenFlags, OutFlags) == 0x000000, "Member 'X6Pawn_X6_GetActorHiddenFlags::OutFlags' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_GetActorHiddenFlags, ReturnValue) == 0x000050, "Member 'X6Pawn_X6_GetActorHiddenFlags::ReturnValue' has a wrong offset!");

// Function X6Game.X6Pawn.X6_GetTag
// 0x0010 (0x0010 - 0x0000)
struct X6Pawn_X6_GetTag final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6Pawn_X6_GetTag) == 0x000008, "Wrong alignment on X6Pawn_X6_GetTag");
static_assert(sizeof(X6Pawn_X6_GetTag) == 0x000010, "Wrong size on X6Pawn_X6_GetTag");
static_assert(offsetof(X6Pawn_X6_GetTag, ReturnValue) == 0x000000, "Member 'X6Pawn_X6_GetTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6Pawn.X6_HasTag
// 0x0018 (0x0018 - 0x0000)
struct X6Pawn_X6_HasTag final
{
public:
	class FString                                 strTag;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Pawn_X6_HasTag) == 0x000008, "Wrong alignment on X6Pawn_X6_HasTag");
static_assert(sizeof(X6Pawn_X6_HasTag) == 0x000018, "Wrong size on X6Pawn_X6_HasTag");
static_assert(offsetof(X6Pawn_X6_HasTag, strTag) == 0x000000, "Member 'X6Pawn_X6_HasTag::strTag' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_HasTag, ReturnValue) == 0x000010, "Member 'X6Pawn_X6_HasTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6Pawn.X6_RequireActorFade
// 0x000C (0x000C - 0x0000)
struct X6Pawn_X6_RequireActorFade final
{
public:
	bool                                          bFadeIn;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FadeOutHiddenFlag;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInView;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Pawn_X6_RequireActorFade) == 0x000004, "Wrong alignment on X6Pawn_X6_RequireActorFade");
static_assert(sizeof(X6Pawn_X6_RequireActorFade) == 0x00000C, "Wrong size on X6Pawn_X6_RequireActorFade");
static_assert(offsetof(X6Pawn_X6_RequireActorFade, bFadeIn) == 0x000000, "Member 'X6Pawn_X6_RequireActorFade::bFadeIn' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_RequireActorFade, FadeOutHiddenFlag) == 0x000004, "Member 'X6Pawn_X6_RequireActorFade::FadeOutHiddenFlag' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_RequireActorFade, bInView) == 0x000008, "Member 'X6Pawn_X6_RequireActorFade::bInView' has a wrong offset!");

// Function X6Game.X6Pawn.X6_SetActorHiddenInGame
// 0x000C (0x000C - 0x0000)
struct X6Pawn_X6_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Flag;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFlag;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6Pawn_X6_SetActorHiddenInGame) == 0x000004, "Wrong alignment on X6Pawn_X6_SetActorHiddenInGame");
static_assert(sizeof(X6Pawn_X6_SetActorHiddenInGame) == 0x00000C, "Wrong size on X6Pawn_X6_SetActorHiddenInGame");
static_assert(offsetof(X6Pawn_X6_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'X6Pawn_X6_SetActorHiddenInGame::bNewHidden' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_SetActorHiddenInGame, Flag) == 0x000004, "Member 'X6Pawn_X6_SetActorHiddenInGame::Flag' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_SetActorHiddenInGame, bClearFlag) == 0x000008, "Member 'X6Pawn_X6_SetActorHiddenInGame::bClearFlag' has a wrong offset!");
static_assert(offsetof(X6Pawn_X6_SetActorHiddenInGame, ReturnValue) == 0x000009, "Member 'X6Pawn_X6_SetActorHiddenInGame::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.CapsuleHasLargeEnoughAreaCheck
// 0x0048 (0x0048 - 0x0000)
struct X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck final
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusOffset;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck");
static_assert(sizeof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck) == 0x000048, "Wrong size on X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck, CapsuleComponent) == 0x000000, "Member 'X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck, TargetLocation) == 0x000008, "Member 'X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck::TargetLocation' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck, HeightOffset) == 0x000020, "Member 'X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck::HeightOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck, RadiusOffset) == 0x000024, "Member 'X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck::RadiusOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck, TargetRotation) == 0x000028, "Member 'X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck::TargetRotation' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck, ReturnValue) == 0x000040, "Member 'X6PlayerMantleComponent_CapsuleHasLargeEnoughAreaCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.CapsuleHasRoomCheck
// 0x0030 (0x0030 - 0x0000)
struct X6PlayerMantleComponent_CapsuleHasRoomCheck final
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusOffset;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_CapsuleHasRoomCheck) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_CapsuleHasRoomCheck");
static_assert(sizeof(X6PlayerMantleComponent_CapsuleHasRoomCheck) == 0x000030, "Wrong size on X6PlayerMantleComponent_CapsuleHasRoomCheck");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasRoomCheck, CapsuleComponent) == 0x000000, "Member 'X6PlayerMantleComponent_CapsuleHasRoomCheck::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasRoomCheck, TargetLocation) == 0x000008, "Member 'X6PlayerMantleComponent_CapsuleHasRoomCheck::TargetLocation' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasRoomCheck, HeightOffset) == 0x000020, "Member 'X6PlayerMantleComponent_CapsuleHasRoomCheck::HeightOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasRoomCheck, RadiusOffset) == 0x000024, "Member 'X6PlayerMantleComponent_CapsuleHasRoomCheck::RadiusOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_CapsuleHasRoomCheck, ReturnValue) == 0x000028, "Member 'X6PlayerMantleComponent_CapsuleHasRoomCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.GetCapsuleBaseLocation
// 0x0020 (0x0020 - 0x0000)
struct X6PlayerMantleComponent_GetCapsuleBaseLocation final
{
public:
	float                                         ZOffset;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_GetCapsuleBaseLocation) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_GetCapsuleBaseLocation");
static_assert(sizeof(X6PlayerMantleComponent_GetCapsuleBaseLocation) == 0x000020, "Wrong size on X6PlayerMantleComponent_GetCapsuleBaseLocation");
static_assert(offsetof(X6PlayerMantleComponent_GetCapsuleBaseLocation, ZOffset) == 0x000000, "Member 'X6PlayerMantleComponent_GetCapsuleBaseLocation::ZOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_GetCapsuleBaseLocation, ReturnValue) == 0x000008, "Member 'X6PlayerMantleComponent_GetCapsuleBaseLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.GetCapsuleTopLocation
// 0x0020 (0x0020 - 0x0000)
struct X6PlayerMantleComponent_GetCapsuleTopLocation final
{
public:
	float                                         ZOffset;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_GetCapsuleTopLocation) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_GetCapsuleTopLocation");
static_assert(sizeof(X6PlayerMantleComponent_GetCapsuleTopLocation) == 0x000020, "Wrong size on X6PlayerMantleComponent_GetCapsuleTopLocation");
static_assert(offsetof(X6PlayerMantleComponent_GetCapsuleTopLocation, ZOffset) == 0x000000, "Member 'X6PlayerMantleComponent_GetCapsuleTopLocation::ZOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_GetCapsuleTopLocation, ReturnValue) == 0x000008, "Member 'X6PlayerMantleComponent_GetCapsuleTopLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.GetCurrentReachDistance
// 0x0038 (0x0038 - 0x0000)
struct X6PlayerMantleComponent_GetCurrentReachDistance final
{
public:
	EMovementMode                                 CurMovementMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurInputDirection;                                 // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_GetCurrentReachDistance) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_GetCurrentReachDistance");
static_assert(sizeof(X6PlayerMantleComponent_GetCurrentReachDistance) == 0x000038, "Wrong size on X6PlayerMantleComponent_GetCurrentReachDistance");
static_assert(offsetof(X6PlayerMantleComponent_GetCurrentReachDistance, CurMovementMode) == 0x000000, "Member 'X6PlayerMantleComponent_GetCurrentReachDistance::CurMovementMode' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_GetCurrentReachDistance, CurInputDirection) == 0x000008, "Member 'X6PlayerMantleComponent_GetCurrentReachDistance::CurInputDirection' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_GetCurrentReachDistance, ReturnValue) == 0x000020, "Member 'X6PlayerMantleComponent_GetCurrentReachDistance::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.GetMantleTypeByHeightAndMovementMode
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode final
{
public:
	float                                         MantleHeight;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMantleTypeNative                             ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode");
static_assert(sizeof(X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode) == 0x000008, "Wrong size on X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode");
static_assert(offsetof(X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode, MantleHeight) == 0x000000, "Member 'X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode::MantleHeight' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode, MovementMode) == 0x000004, "Member 'X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode::MovementMode' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode, ReturnValue) == 0x000005, "Member 'X6PlayerMantleComponent_GetMantleTypeByHeightAndMovementMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.GetOwnerCharacter
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerMantleComponent_GetOwnerCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_GetOwnerCharacter) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_GetOwnerCharacter");
static_assert(sizeof(X6PlayerMantleComponent_GetOwnerCharacter) == 0x000008, "Wrong size on X6PlayerMantleComponent_GetOwnerCharacter");
static_assert(offsetof(X6PlayerMantleComponent_GetOwnerCharacter, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_GetOwnerCharacter::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Internal_MantleMainCheckInFalling
// 0x0058 (0x0058 - 0x0000)
struct X6PlayerMantleComponent_Internal_MantleMainCheckInFalling final
{
public:
	struct FVector                                CapsuleBaseLocation;                               // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentPlayerInputVector;                          // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurActorLocation;                                  // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLedgeHeight;                                    // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLedgeHeight;                                    // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustCheck;                                        // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0055(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_Internal_MantleMainCheckInFalling");
static_assert(sizeof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling) == 0x000058, "Wrong size on X6PlayerMantleComponent_Internal_MantleMainCheckInFalling");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, CapsuleBaseLocation) == 0x000000, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::CapsuleBaseLocation' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, CurrentPlayerInputVector) == 0x000018, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::CurrentPlayerInputVector' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, CurActorLocation) == 0x000030, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::CurActorLocation' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, MinLedgeHeight) == 0x000048, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::MinLedgeHeight' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, MaxLedgeHeight) == 0x00004C, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::MaxLedgeHeight' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, ZOffset) == 0x000050, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::ZOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, bJustCheck) == 0x000054, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::bJustCheck' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Internal_MantleMainCheckInFalling, ReturnValue) == 0x000055, "Member 'X6PlayerMantleComponent_Internal_MantleMainCheckInFalling::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.IsValidMantleTraceChannel
// 0x0010 (0x0010 - 0x0000)
struct X6PlayerMantleComponent_IsValidMantleTraceChannel final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_IsValidMantleTraceChannel) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_IsValidMantleTraceChannel");
static_assert(sizeof(X6PlayerMantleComponent_IsValidMantleTraceChannel) == 0x000010, "Wrong size on X6PlayerMantleComponent_IsValidMantleTraceChannel");
static_assert(offsetof(X6PlayerMantleComponent_IsValidMantleTraceChannel, PrimitiveComponent) == 0x000000, "Member 'X6PlayerMantleComponent_IsValidMantleTraceChannel::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_IsValidMantleTraceChannel, TraceChannel) == 0x000008, "Member 'X6PlayerMantleComponent_IsValidMantleTraceChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_IsValidMantleTraceChannel, ReturnValue) == 0x000009, "Member 'X6PlayerMantleComponent_IsValidMantleTraceChannel::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_CurMantleInfoExist
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_Lua_CurMantleInfoExist final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_CurMantleInfoExist) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_Lua_CurMantleInfoExist");
static_assert(sizeof(X6PlayerMantleComponent_Lua_CurMantleInfoExist) == 0x000001, "Wrong size on X6PlayerMantleComponent_Lua_CurMantleInfoExist");
static_assert(offsetof(X6PlayerMantleComponent_Lua_CurMantleInfoExist, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_CurMantleInfoExist::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_GetCurMantleInfo_KeyOperationIsRequired
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired");
static_assert(sizeof(X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired) == 0x000001, "Wrong size on X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired");
static_assert(offsetof(X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_GetCurMantleInfo_KeyOperationIsRequired::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_GetCurMantleInfo_MontageAdjustHeightTime
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime");
static_assert(sizeof(X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime) == 0x000004, "Wrong size on X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime");
static_assert(offsetof(X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_GetCurMantleInfo_MontageAdjustHeightTime::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_GetCurrentMantleInfoByName
// 0x0018 (0x0018 - 0x0000)
struct X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName");
static_assert(sizeof(X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName) == 0x000018, "Wrong size on X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName");
static_assert(offsetof(X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName, Name_0) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName::Name_0' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName, MovementMode) == 0x000010, "Member 'X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName::MovementMode' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName, ReturnValue) == 0x000014, "Member 'X6PlayerMantleComponent_Lua_GetCurrentMantleInfoByName::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_IsCurWorldTypeInDoor
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor");
static_assert(sizeof(X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor) == 0x000001, "Wrong size on X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor");
static_assert(offsetof(X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_IsCurWorldTypeInDoor::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_MantleJumpStart
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerMantleComponent_Lua_MantleJumpStart final
{
public:
	float                                         MantleHeight;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_MantleJumpStart) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_Lua_MantleJumpStart");
static_assert(sizeof(X6PlayerMantleComponent_Lua_MantleJumpStart) == 0x000008, "Wrong size on X6PlayerMantleComponent_Lua_MantleJumpStart");
static_assert(offsetof(X6PlayerMantleComponent_Lua_MantleJumpStart, MantleHeight) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_MantleJumpStart::MantleHeight' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Lua_MantleJumpStart, ReturnValue) == 0x000004, "Member 'X6PlayerMantleComponent_Lua_MantleJumpStart::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_MantlePreCheck_InAir
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_Lua_MantlePreCheck_InAir final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_MantlePreCheck_InAir) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_Lua_MantlePreCheck_InAir");
static_assert(sizeof(X6PlayerMantleComponent_Lua_MantlePreCheck_InAir) == 0x000001, "Wrong size on X6PlayerMantleComponent_Lua_MantlePreCheck_InAir");
static_assert(offsetof(X6PlayerMantleComponent_Lua_MantlePreCheck_InAir, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_MantlePreCheck_InAir::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_MantleQuicklyStart
// 0x000C (0x000C - 0x0000)
struct X6PlayerMantleComponent_Lua_MantleQuicklyStart final
{
public:
	float                                         MantleHeight;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_MantleQuicklyStart) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_Lua_MantleQuicklyStart");
static_assert(sizeof(X6PlayerMantleComponent_Lua_MantleQuicklyStart) == 0x00000C, "Wrong size on X6PlayerMantleComponent_Lua_MantleQuicklyStart");
static_assert(offsetof(X6PlayerMantleComponent_Lua_MantleQuicklyStart, MantleHeight) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_MantleQuicklyStart::MantleHeight' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Lua_MantleQuicklyStart, DeltaTime) == 0x000004, "Member 'X6PlayerMantleComponent_Lua_MantleQuicklyStart::DeltaTime' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_Lua_MantleQuicklyStart, ReturnValue) == 0x000008, "Member 'X6PlayerMantleComponent_Lua_MantleQuicklyStart::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_OnCurrentMantleTypeChanged
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged");
static_assert(sizeof(X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged) == 0x000004, "Wrong size on X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged");
static_assert(offsetof(X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_OnCurrentMantleTypeChanged::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_OwnerMantleConfigExist
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_Lua_OwnerMantleConfigExist final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_OwnerMantleConfigExist) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_Lua_OwnerMantleConfigExist");
static_assert(sizeof(X6PlayerMantleComponent_Lua_OwnerMantleConfigExist) == 0x000001, "Wrong size on X6PlayerMantleComponent_Lua_OwnerMantleConfigExist");
static_assert(offsetof(X6PlayerMantleComponent_Lua_OwnerMantleConfigExist, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_OwnerMantleConfigExist::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.Lua_TryGetCurInputDirection
// 0x0018 (0x0018 - 0x0000)
struct X6PlayerMantleComponent_Lua_TryGetCurInputDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_Lua_TryGetCurInputDirection) == 0x000008, "Wrong alignment on X6PlayerMantleComponent_Lua_TryGetCurInputDirection");
static_assert(sizeof(X6PlayerMantleComponent_Lua_TryGetCurInputDirection) == 0x000018, "Wrong size on X6PlayerMantleComponent_Lua_TryGetCurInputDirection");
static_assert(offsetof(X6PlayerMantleComponent_Lua_TryGetCurInputDirection, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_Lua_TryGetCurInputDirection::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleAllCheck
// 0x0002 (0x0002 - 0x0000)
struct X6PlayerMantleComponent_MantleAllCheck final
{
public:
	bool                                          ReceivedInput;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantleAllCheck) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_MantleAllCheck");
static_assert(sizeof(X6PlayerMantleComponent_MantleAllCheck) == 0x000002, "Wrong size on X6PlayerMantleComponent_MantleAllCheck");
static_assert(offsetof(X6PlayerMantleComponent_MantleAllCheck, ReceivedInput) == 0x000000, "Member 'X6PlayerMantleComponent_MantleAllCheck::ReceivedInput' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_MantleAllCheck, ReturnValue) == 0x000001, "Member 'X6PlayerMantleComponent_MantleAllCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleJumpStart
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerMantleComponent_MantleJumpStart final
{
public:
	float                                         MantleHeight;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantleJumpStart) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_MantleJumpStart");
static_assert(sizeof(X6PlayerMantleComponent_MantleJumpStart) == 0x000004, "Wrong size on X6PlayerMantleComponent_MantleJumpStart");
static_assert(offsetof(X6PlayerMantleComponent_MantleJumpStart, MantleHeight) == 0x000000, "Member 'X6PlayerMantleComponent_MantleJumpStart::MantleHeight' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleMainCheck
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerMantleComponent_MantleMainCheck final
{
public:
	float                                         ZOffset;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_MantleMainCheck) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_MantleMainCheck");
static_assert(sizeof(X6PlayerMantleComponent_MantleMainCheck) == 0x000008, "Wrong size on X6PlayerMantleComponent_MantleMainCheck");
static_assert(offsetof(X6PlayerMantleComponent_MantleMainCheck, ZOffset) == 0x000000, "Member 'X6PlayerMantleComponent_MantleMainCheck::ZOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_MantleMainCheck, ReturnValue) == 0x000004, "Member 'X6PlayerMantleComponent_MantleMainCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleMainCheckInFalling
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerMantleComponent_MantleMainCheckInFalling final
{
public:
	float                                         ZOffset;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6PlayerMantleComponent_MantleMainCheckInFalling) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_MantleMainCheckInFalling");
static_assert(sizeof(X6PlayerMantleComponent_MantleMainCheckInFalling) == 0x000008, "Wrong size on X6PlayerMantleComponent_MantleMainCheckInFalling");
static_assert(offsetof(X6PlayerMantleComponent_MantleMainCheckInFalling, ZOffset) == 0x000000, "Member 'X6PlayerMantleComponent_MantleMainCheckInFalling::ZOffset' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_MantleMainCheckInFalling, ReturnValue) == 0x000004, "Member 'X6PlayerMantleComponent_MantleMainCheckInFalling::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantlePostCheck
// 0x0002 (0x0002 - 0x0000)
struct X6PlayerMantleComponent_MantlePostCheck final
{
public:
	bool                                          ReceivedInput;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantlePostCheck) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_MantlePostCheck");
static_assert(sizeof(X6PlayerMantleComponent_MantlePostCheck) == 0x000002, "Wrong size on X6PlayerMantleComponent_MantlePostCheck");
static_assert(offsetof(X6PlayerMantleComponent_MantlePostCheck, ReceivedInput) == 0x000000, "Member 'X6PlayerMantleComponent_MantlePostCheck::ReceivedInput' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_MantlePostCheck, ReturnValue) == 0x000001, "Member 'X6PlayerMantleComponent_MantlePostCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantlePreCheck
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_MantlePreCheck final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantlePreCheck) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_MantlePreCheck");
static_assert(sizeof(X6PlayerMantleComponent_MantlePreCheck) == 0x000001, "Wrong size on X6PlayerMantleComponent_MantlePreCheck");
static_assert(offsetof(X6PlayerMantleComponent_MantlePreCheck, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_MantlePreCheck::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleQuicklyStart
// 0x0008 (0x0008 - 0x0000)
struct X6PlayerMantleComponent_MantleQuicklyStart final
{
public:
	float                                         MantleHeight;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantleQuicklyStart) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_MantleQuicklyStart");
static_assert(sizeof(X6PlayerMantleComponent_MantleQuicklyStart) == 0x000008, "Wrong size on X6PlayerMantleComponent_MantleQuicklyStart");
static_assert(offsetof(X6PlayerMantleComponent_MantleQuicklyStart, MantleHeight) == 0x000000, "Member 'X6PlayerMantleComponent_MantleQuicklyStart::MantleHeight' has a wrong offset!");
static_assert(offsetof(X6PlayerMantleComponent_MantleQuicklyStart, DeltaTime) == 0x000004, "Member 'X6PlayerMantleComponent_MantleQuicklyStart::DeltaTime' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleUpdate
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerMantleComponent_MantleUpdate final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantleUpdate) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_MantleUpdate");
static_assert(sizeof(X6PlayerMantleComponent_MantleUpdate) == 0x000004, "Wrong size on X6PlayerMantleComponent_MantleUpdate");
static_assert(offsetof(X6PlayerMantleComponent_MantleUpdate, DeltaSeconds) == 0x000000, "Member 'X6PlayerMantleComponent_MantleUpdate::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.MantleUpdateMotionWarping
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerMantleComponent_MantleUpdateMotionWarping final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_MantleUpdateMotionWarping) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_MantleUpdateMotionWarping");
static_assert(sizeof(X6PlayerMantleComponent_MantleUpdateMotionWarping) == 0x000004, "Wrong size on X6PlayerMantleComponent_MantleUpdateMotionWarping");
static_assert(offsetof(X6PlayerMantleComponent_MantleUpdateMotionWarping, DeltaSeconds) == 0x000000, "Member 'X6PlayerMantleComponent_MantleUpdateMotionWarping::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.ProcessTransitionMantle
// 0x0001 (0x0001 - 0x0000)
struct X6PlayerMantleComponent_ProcessTransitionMantle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_ProcessTransitionMantle) == 0x000001, "Wrong alignment on X6PlayerMantleComponent_ProcessTransitionMantle");
static_assert(sizeof(X6PlayerMantleComponent_ProcessTransitionMantle) == 0x000001, "Wrong size on X6PlayerMantleComponent_ProcessTransitionMantle");
static_assert(offsetof(X6PlayerMantleComponent_ProcessTransitionMantle, ReturnValue) == 0x000000, "Member 'X6PlayerMantleComponent_ProcessTransitionMantle::ReturnValue' has a wrong offset!");

// Function X6Game.X6PlayerMantleComponent.UpdateMovingToAnimStartTarget
// 0x0004 (0x0004 - 0x0000)
struct X6PlayerMantleComponent_UpdateMovingToAnimStartTarget final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PlayerMantleComponent_UpdateMovingToAnimStartTarget) == 0x000004, "Wrong alignment on X6PlayerMantleComponent_UpdateMovingToAnimStartTarget");
static_assert(sizeof(X6PlayerMantleComponent_UpdateMovingToAnimStartTarget) == 0x000004, "Wrong size on X6PlayerMantleComponent_UpdateMovingToAnimStartTarget");
static_assert(offsetof(X6PlayerMantleComponent_UpdateMovingToAnimStartTarget, DeltaSeconds) == 0x000000, "Member 'X6PlayerMantleComponent_UpdateMovingToAnimStartTarget::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.AddReachSegmentDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6PathFollowingComponent_AddReachSegmentDelegate final
{
public:
	int32                                         SegmentIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SegmentIndex)>           ReachSegmentDelegate;                              // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_AddReachSegmentDelegate) == 0x000004, "Wrong alignment on X6PathFollowingComponent_AddReachSegmentDelegate");
static_assert(sizeof(X6PathFollowingComponent_AddReachSegmentDelegate) == 0x000014, "Wrong size on X6PathFollowingComponent_AddReachSegmentDelegate");
static_assert(offsetof(X6PathFollowingComponent_AddReachSegmentDelegate, SegmentIndex) == 0x000000, "Member 'X6PathFollowingComponent_AddReachSegmentDelegate::SegmentIndex' has a wrong offset!");
static_assert(offsetof(X6PathFollowingComponent_AddReachSegmentDelegate, ReachSegmentDelegate) == 0x000004, "Member 'X6PathFollowingComponent_AddReachSegmentDelegate::ReachSegmentDelegate' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.GetCurrentTargetPosition
// 0x0018 (0x0018 - 0x0000)
struct X6PathFollowingComponent_GetCurrentTargetPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_GetCurrentTargetPosition) == 0x000008, "Wrong alignment on X6PathFollowingComponent_GetCurrentTargetPosition");
static_assert(sizeof(X6PathFollowingComponent_GetCurrentTargetPosition) == 0x000018, "Wrong size on X6PathFollowingComponent_GetCurrentTargetPosition");
static_assert(offsetof(X6PathFollowingComponent_GetCurrentTargetPosition, ReturnValue) == 0x000000, "Member 'X6PathFollowingComponent_GetCurrentTargetPosition::ReturnValue' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.GetSmoothPathEnable
// 0x0001 (0x0001 - 0x0000)
struct X6PathFollowingComponent_GetSmoothPathEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_GetSmoothPathEnable) == 0x000001, "Wrong alignment on X6PathFollowingComponent_GetSmoothPathEnable");
static_assert(sizeof(X6PathFollowingComponent_GetSmoothPathEnable) == 0x000001, "Wrong size on X6PathFollowingComponent_GetSmoothPathEnable");
static_assert(offsetof(X6PathFollowingComponent_GetSmoothPathEnable, ReturnValue) == 0x000000, "Member 'X6PathFollowingComponent_GetSmoothPathEnable::ReturnValue' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.K2_SetBlockDetectionState
// 0x0001 (0x0001 - 0x0000)
struct X6PathFollowingComponent_K2_SetBlockDetectionState final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_K2_SetBlockDetectionState) == 0x000001, "Wrong alignment on X6PathFollowingComponent_K2_SetBlockDetectionState");
static_assert(sizeof(X6PathFollowingComponent_K2_SetBlockDetectionState) == 0x000001, "Wrong size on X6PathFollowingComponent_K2_SetBlockDetectionState");
static_assert(offsetof(X6PathFollowingComponent_K2_SetBlockDetectionState, bEnable) == 0x000000, "Member 'X6PathFollowingComponent_K2_SetBlockDetectionState::bEnable' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.RemoveReachSegmentDelegate
// 0x0014 (0x0014 - 0x0000)
struct X6PathFollowingComponent_RemoveReachSegmentDelegate final
{
public:
	int32                                         SegmentIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SegmentIndex)>           ReachSegmentDelegate;                              // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_RemoveReachSegmentDelegate) == 0x000004, "Wrong alignment on X6PathFollowingComponent_RemoveReachSegmentDelegate");
static_assert(sizeof(X6PathFollowingComponent_RemoveReachSegmentDelegate) == 0x000014, "Wrong size on X6PathFollowingComponent_RemoveReachSegmentDelegate");
static_assert(offsetof(X6PathFollowingComponent_RemoveReachSegmentDelegate, SegmentIndex) == 0x000000, "Member 'X6PathFollowingComponent_RemoveReachSegmentDelegate::SegmentIndex' has a wrong offset!");
static_assert(offsetof(X6PathFollowingComponent_RemoveReachSegmentDelegate, ReachSegmentDelegate) == 0x000004, "Member 'X6PathFollowingComponent_RemoveReachSegmentDelegate::ReachSegmentDelegate' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.SetCustomNavLinkMove
// 0x0008 (0x0008 - 0x0000)
struct X6PathFollowingComponent_SetCustomNavLinkMove final
{
public:
	class UObject*                                LinkMove;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_SetCustomNavLinkMove) == 0x000008, "Wrong alignment on X6PathFollowingComponent_SetCustomNavLinkMove");
static_assert(sizeof(X6PathFollowingComponent_SetCustomNavLinkMove) == 0x000008, "Wrong size on X6PathFollowingComponent_SetCustomNavLinkMove");
static_assert(offsetof(X6PathFollowingComponent_SetCustomNavLinkMove, LinkMove) == 0x000000, "Member 'X6PathFollowingComponent_SetCustomNavLinkMove::LinkMove' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.SetSmoothInterval
// 0x0004 (0x0004 - 0x0000)
struct X6PathFollowingComponent_SetSmoothInterval final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_SetSmoothInterval) == 0x000004, "Wrong alignment on X6PathFollowingComponent_SetSmoothInterval");
static_assert(sizeof(X6PathFollowingComponent_SetSmoothInterval) == 0x000004, "Wrong size on X6PathFollowingComponent_SetSmoothInterval");
static_assert(offsetof(X6PathFollowingComponent_SetSmoothInterval, Interval) == 0x000000, "Member 'X6PathFollowingComponent_SetSmoothInterval::Interval' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.SetSmoothPathDirectMoveParams
// 0x0018 (0x0018 - 0x0000)
struct X6PathFollowingComponent_SetSmoothPathDirectMoveParams final
{
public:
	struct FDirectMoveParams                      NewSmoothPathDirectMoveParams;                     // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_SetSmoothPathDirectMoveParams) == 0x000004, "Wrong alignment on X6PathFollowingComponent_SetSmoothPathDirectMoveParams");
static_assert(sizeof(X6PathFollowingComponent_SetSmoothPathDirectMoveParams) == 0x000018, "Wrong size on X6PathFollowingComponent_SetSmoothPathDirectMoveParams");
static_assert(offsetof(X6PathFollowingComponent_SetSmoothPathDirectMoveParams, NewSmoothPathDirectMoveParams) == 0x000000, "Member 'X6PathFollowingComponent_SetSmoothPathDirectMoveParams::NewSmoothPathDirectMoveParams' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.SetSmoothPathEnable
// 0x0001 (0x0001 - 0x0000)
struct X6PathFollowingComponent_SetSmoothPathEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_SetSmoothPathEnable) == 0x000001, "Wrong alignment on X6PathFollowingComponent_SetSmoothPathEnable");
static_assert(sizeof(X6PathFollowingComponent_SetSmoothPathEnable) == 0x000001, "Wrong size on X6PathFollowingComponent_SetSmoothPathEnable");
static_assert(offsetof(X6PathFollowingComponent_SetSmoothPathEnable, bEnable) == 0x000000, "Member 'X6PathFollowingComponent_SetSmoothPathEnable::bEnable' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.SetSmoothPathParams
// 0x0020 (0x0020 - 0x0000)
struct X6PathFollowingComponent_SetSmoothPathParams final
{
public:
	struct FSmoothPathParams                      NewSmoothPathParams;                               // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_SetSmoothPathParams) == 0x000004, "Wrong alignment on X6PathFollowingComponent_SetSmoothPathParams");
static_assert(sizeof(X6PathFollowingComponent_SetSmoothPathParams) == 0x000020, "Wrong size on X6PathFollowingComponent_SetSmoothPathParams");
static_assert(offsetof(X6PathFollowingComponent_SetSmoothPathParams, NewSmoothPathParams) == 0x000000, "Member 'X6PathFollowingComponent_SetSmoothPathParams::NewSmoothPathParams' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.SetTargetMoveSegment
// 0x0004 (0x0004 - 0x0000)
struct X6PathFollowingComponent_SetTargetMoveSegment final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_SetTargetMoveSegment) == 0x000004, "Wrong alignment on X6PathFollowingComponent_SetTargetMoveSegment");
static_assert(sizeof(X6PathFollowingComponent_SetTargetMoveSegment) == 0x000004, "Wrong size on X6PathFollowingComponent_SetTargetMoveSegment");
static_assert(offsetof(X6PathFollowingComponent_SetTargetMoveSegment, TargetIndex) == 0x000000, "Member 'X6PathFollowingComponent_SetTargetMoveSegment::TargetIndex' has a wrong offset!");

// Function X6Game.X6PathFollowingComponent.GetFinalRotation
// 0x0018 (0x0018 - 0x0000)
struct X6PathFollowingComponent_GetFinalRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PathFollowingComponent_GetFinalRotation) == 0x000008, "Wrong alignment on X6PathFollowingComponent_GetFinalRotation");
static_assert(sizeof(X6PathFollowingComponent_GetFinalRotation) == 0x000018, "Wrong size on X6PathFollowingComponent_GetFinalRotation");
static_assert(offsetof(X6PathFollowingComponent_GetFinalRotation, ReturnValue) == 0x000000, "Member 'X6PathFollowingComponent_GetFinalRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.ApplyResolutionQualityRate
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_ApplyResolutionQualityRate final
{
public:
	float                                         ResolutionQualityRate;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_ApplyResolutionQualityRate) == 0x000004, "Wrong alignment on X6GameUserSettings_ApplyResolutionQualityRate");
static_assert(sizeof(X6GameUserSettings_ApplyResolutionQualityRate) == 0x000004, "Wrong size on X6GameUserSettings_ApplyResolutionQualityRate");
static_assert(offsetof(X6GameUserSettings_ApplyResolutionQualityRate, ResolutionQualityRate) == 0x000000, "Member 'X6GameUserSettings_ApplyResolutionQualityRate::ResolutionQualityRate' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetAkMaxNumVoicesLimit
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetAkMaxNumVoicesLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetAkMaxNumVoicesLimit) == 0x000004, "Wrong alignment on X6GameUserSettings_GetAkMaxNumVoicesLimit");
static_assert(sizeof(X6GameUserSettings_GetAkMaxNumVoicesLimit) == 0x000004, "Wrong size on X6GameUserSettings_GetAkMaxNumVoicesLimit");
static_assert(offsetof(X6GameUserSettings_GetAkMaxNumVoicesLimit, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetAkMaxNumVoicesLimit::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetAnimCurveMDIParamDistance
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetAnimCurveMDIParamDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetAnimCurveMDIParamDistance) == 0x000004, "Wrong alignment on X6GameUserSettings_GetAnimCurveMDIParamDistance");
static_assert(sizeof(X6GameUserSettings_GetAnimCurveMDIParamDistance) == 0x000004, "Wrong size on X6GameUserSettings_GetAnimCurveMDIParamDistance");
static_assert(offsetof(X6GameUserSettings_GetAnimCurveMDIParamDistance, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetAnimCurveMDIParamDistance::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetBenchmarkResultFromDeviceList
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetBenchmarkResultFromDeviceList final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetBenchmarkResultFromDeviceList) == 0x000001, "Wrong alignment on X6GameUserSettings_GetBenchmarkResultFromDeviceList");
static_assert(sizeof(X6GameUserSettings_GetBenchmarkResultFromDeviceList) == 0x000001, "Wrong size on X6GameUserSettings_GetBenchmarkResultFromDeviceList");
static_assert(offsetof(X6GameUserSettings_GetBenchmarkResultFromDeviceList, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetBenchmarkResultFromDeviceList::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetCustomUpScaleRate
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetCustomUpScaleRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetCustomUpScaleRate) == 0x000004, "Wrong alignment on X6GameUserSettings_GetCustomUpScaleRate");
static_assert(sizeof(X6GameUserSettings_GetCustomUpScaleRate) == 0x000004, "Wrong size on X6GameUserSettings_GetCustomUpScaleRate");
static_assert(offsetof(X6GameUserSettings_GetCustomUpScaleRate, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetCustomUpScaleRate::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableAbilityPreload
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableAbilityPreload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableAbilityPreload) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableAbilityPreload");
static_assert(sizeof(X6GameUserSettings_GetEnableAbilityPreload) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableAbilityPreload");
static_assert(offsetof(X6GameUserSettings_GetEnableAbilityPreload, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableAbilityPreload::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableAllPreloadFeature
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableAllPreloadFeature final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableAllPreloadFeature) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableAllPreloadFeature");
static_assert(sizeof(X6GameUserSettings_GetEnableAllPreloadFeature) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableAllPreloadFeature");
static_assert(offsetof(X6GameUserSettings_GetEnableAllPreloadFeature, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableAllPreloadFeature::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableClothesPreload
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableClothesPreload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableClothesPreload) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableClothesPreload");
static_assert(sizeof(X6GameUserSettings_GetEnableClothesPreload) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableClothesPreload");
static_assert(offsetof(X6GameUserSettings_GetEnableClothesPreload, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableClothesPreload::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableCombatPreload
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableCombatPreload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableCombatPreload) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableCombatPreload");
static_assert(sizeof(X6GameUserSettings_GetEnableCombatPreload) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableCombatPreload");
static_assert(offsetof(X6GameUserSettings_GetEnableCombatPreload, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableCombatPreload::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableDressupFeature
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableDressupFeature final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableDressupFeature) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableDressupFeature");
static_assert(sizeof(X6GameUserSettings_GetEnableDressupFeature) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableDressupFeature");
static_assert(offsetof(X6GameUserSettings_GetEnableDressupFeature, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableDressupFeature::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableGraphPreload
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableGraphPreload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableGraphPreload) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableGraphPreload");
static_assert(sizeof(X6GameUserSettings_GetEnableGraphPreload) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableGraphPreload");
static_assert(offsetof(X6GameUserSettings_GetEnableGraphPreload, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableGraphPreload::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableNPCSimpleLocomotion
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableNPCSimpleLocomotion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableNPCSimpleLocomotion) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableNPCSimpleLocomotion");
static_assert(sizeof(X6GameUserSettings_GetEnableNPCSimpleLocomotion) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableNPCSimpleLocomotion");
static_assert(offsetof(X6GameUserSettings_GetEnableNPCSimpleLocomotion, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableNPCSimpleLocomotion::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableObjectPoolPreCreate
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableObjectPoolPreCreate final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableObjectPoolPreCreate) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableObjectPoolPreCreate");
static_assert(sizeof(X6GameUserSettings_GetEnableObjectPoolPreCreate) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableObjectPoolPreCreate");
static_assert(offsetof(X6GameUserSettings_GetEnableObjectPoolPreCreate, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableObjectPoolPreCreate::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableRewardPreload
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableRewardPreload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableRewardPreload) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableRewardPreload");
static_assert(sizeof(X6GameUserSettings_GetEnableRewardPreload) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableRewardPreload");
static_assert(offsetof(X6GameUserSettings_GetEnableRewardPreload, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableRewardPreload::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableSkipUpdateAnimation
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableSkipUpdateAnimation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableSkipUpdateAnimation) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableSkipUpdateAnimation");
static_assert(sizeof(X6GameUserSettings_GetEnableSkipUpdateAnimation) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableSkipUpdateAnimation");
static_assert(offsetof(X6GameUserSettings_GetEnableSkipUpdateAnimation, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableSkipUpdateAnimation::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetEnableSoundPreload
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetEnableSoundPreload final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetEnableSoundPreload) == 0x000001, "Wrong alignment on X6GameUserSettings_GetEnableSoundPreload");
static_assert(sizeof(X6GameUserSettings_GetEnableSoundPreload) == 0x000001, "Wrong size on X6GameUserSettings_GetEnableSoundPreload");
static_assert(offsetof(X6GameUserSettings_GetEnableSoundPreload, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetEnableSoundPreload::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetLightedPlayerMaxCount
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetLightedPlayerMaxCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetLightedPlayerMaxCount) == 0x000004, "Wrong alignment on X6GameUserSettings_GetLightedPlayerMaxCount");
static_assert(sizeof(X6GameUserSettings_GetLightedPlayerMaxCount) == 0x000004, "Wrong size on X6GameUserSettings_GetLightedPlayerMaxCount");
static_assert(offsetof(X6GameUserSettings_GetLightedPlayerMaxCount, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetLightedPlayerMaxCount::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetMaxRefreshRate
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetMaxRefreshRate final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetMaxRefreshRate) == 0x000004, "Wrong alignment on X6GameUserSettings_GetMaxRefreshRate");
static_assert(sizeof(X6GameUserSettings_GetMaxRefreshRate) == 0x000004, "Wrong size on X6GameUserSettings_GetMaxRefreshRate");
static_assert(offsetof(X6GameUserSettings_GetMaxRefreshRate, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetMaxRefreshRate::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetObjectPoolMemoryThreshold
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetObjectPoolMemoryThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetObjectPoolMemoryThreshold) == 0x000004, "Wrong alignment on X6GameUserSettings_GetObjectPoolMemoryThreshold");
static_assert(sizeof(X6GameUserSettings_GetObjectPoolMemoryThreshold) == 0x000004, "Wrong size on X6GameUserSettings_GetObjectPoolMemoryThreshold");
static_assert(offsetof(X6GameUserSettings_GetObjectPoolMemoryThreshold, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetObjectPoolMemoryThreshold::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetPreLoadPoolMemoryThresholdScalar
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar) == 0x000004, "Wrong alignment on X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar");
static_assert(sizeof(X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar) == 0x000004, "Wrong size on X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar");
static_assert(offsetof(X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetPreLoadPoolMemoryThresholdScalar::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetResolutionQualityForScreenSize
// 0x0010 (0x0010 - 0x0000)
struct X6GameUserSettings_GetResolutionQualityForScreenSize final
{
public:
	float                                         Width;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFullScreen;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetResolutionQualityForScreenSize) == 0x000004, "Wrong alignment on X6GameUserSettings_GetResolutionQualityForScreenSize");
static_assert(sizeof(X6GameUserSettings_GetResolutionQualityForScreenSize) == 0x000010, "Wrong size on X6GameUserSettings_GetResolutionQualityForScreenSize");
static_assert(offsetof(X6GameUserSettings_GetResolutionQualityForScreenSize, Width) == 0x000000, "Member 'X6GameUserSettings_GetResolutionQualityForScreenSize::Width' has a wrong offset!");
static_assert(offsetof(X6GameUserSettings_GetResolutionQualityForScreenSize, Height) == 0x000004, "Member 'X6GameUserSettings_GetResolutionQualityForScreenSize::Height' has a wrong offset!");
static_assert(offsetof(X6GameUserSettings_GetResolutionQualityForScreenSize, bUseFullScreen) == 0x000008, "Member 'X6GameUserSettings_GetResolutionQualityForScreenSize::bUseFullScreen' has a wrong offset!");
static_assert(offsetof(X6GameUserSettings_GetResolutionQualityForScreenSize, ReturnValue) == 0x00000C, "Member 'X6GameUserSettings_GetResolutionQualityForScreenSize::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetResolutionQualityRate
// 0x0008 (0x0008 - 0x0000)
struct X6GameUserSettings_GetResolutionQualityRate final
{
public:
	EGUSAntiAliasingMethod                        AntiAliasingMethod_0;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetResolutionQualityRate) == 0x000004, "Wrong alignment on X6GameUserSettings_GetResolutionQualityRate");
static_assert(sizeof(X6GameUserSettings_GetResolutionQualityRate) == 0x000008, "Wrong size on X6GameUserSettings_GetResolutionQualityRate");
static_assert(offsetof(X6GameUserSettings_GetResolutionQualityRate, AntiAliasingMethod_0) == 0x000000, "Member 'X6GameUserSettings_GetResolutionQualityRate::AntiAliasingMethod_0' has a wrong offset!");
static_assert(offsetof(X6GameUserSettings_GetResolutionQualityRate, ReturnValue) == 0x000004, "Member 'X6GameUserSettings_GetResolutionQualityRate::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetSpawnDistance
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetSpawnDistance final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetSpawnDistance) == 0x000004, "Wrong alignment on X6GameUserSettings_GetSpawnDistance");
static_assert(sizeof(X6GameUserSettings_GetSpawnDistance) == 0x000004, "Wrong size on X6GameUserSettings_GetSpawnDistance");
static_assert(offsetof(X6GameUserSettings_GetSpawnDistance, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetSpawnDistance::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetT2NPCSpawnRate
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetT2NPCSpawnRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetT2NPCSpawnRate) == 0x000004, "Wrong alignment on X6GameUserSettings_GetT2NPCSpawnRate");
static_assert(sizeof(X6GameUserSettings_GetT2NPCSpawnRate) == 0x000004, "Wrong size on X6GameUserSettings_GetT2NPCSpawnRate");
static_assert(offsetof(X6GameUserSettings_GetT2NPCSpawnRate, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetT2NPCSpawnRate::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetTotalPhysicalGB
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetTotalPhysicalGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetTotalPhysicalGB) == 0x000004, "Wrong alignment on X6GameUserSettings_GetTotalPhysicalGB");
static_assert(sizeof(X6GameUserSettings_GetTotalPhysicalGB) == 0x000004, "Wrong size on X6GameUserSettings_GetTotalPhysicalGB");
static_assert(offsetof(X6GameUserSettings_GetTotalPhysicalGB, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetTotalPhysicalGB::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetUIResolution
// 0x0008 (0x0008 - 0x0000)
struct X6GameUserSettings_GetUIResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetUIResolution) == 0x000004, "Wrong alignment on X6GameUserSettings_GetUIResolution");
static_assert(sizeof(X6GameUserSettings_GetUIResolution) == 0x000008, "Wrong size on X6GameUserSettings_GetUIResolution");
static_assert(offsetof(X6GameUserSettings_GetUIResolution, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetUIResolution::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetX6DisplayGamma
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetX6DisplayGamma final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetX6DisplayGamma) == 0x000004, "Wrong alignment on X6GameUserSettings_GetX6DisplayGamma");
static_assert(sizeof(X6GameUserSettings_GetX6DisplayGamma) == 0x000004, "Wrong size on X6GameUserSettings_GetX6DisplayGamma");
static_assert(offsetof(X6GameUserSettings_GetX6DisplayGamma, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetX6DisplayGamma::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetX6RecommendQuality
// 0x0044 (0x0044 - 0x0000)
struct X6GameUserSettings_GetX6RecommendQuality final
{
public:
	struct FRecommendQualityLevels                ReturnValue;                                       // 0x0000(0x0044)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetX6RecommendQuality) == 0x000004, "Wrong alignment on X6GameUserSettings_GetX6RecommendQuality");
static_assert(sizeof(X6GameUserSettings_GetX6RecommendQuality) == 0x000044, "Wrong size on X6GameUserSettings_GetX6RecommendQuality");
static_assert(offsetof(X6GameUserSettings_GetX6RecommendQuality, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetX6RecommendQuality::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetAmbientOcclusionEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetAmbientOcclusionEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetAmbientOcclusionEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_SetAmbientOcclusionEnabled");
static_assert(sizeof(X6GameUserSettings_SetAmbientOcclusionEnabled) == 0x000001, "Wrong size on X6GameUserSettings_SetAmbientOcclusionEnabled");
static_assert(offsetof(X6GameUserSettings_SetAmbientOcclusionEnabled, bEnable) == 0x000000, "Member 'X6GameUserSettings_SetAmbientOcclusionEnabled::bEnable' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetAntiAliasingMethod
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetAntiAliasingMethod final
{
public:
	EGUSAntiAliasingMethod                        Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetAntiAliasingMethod) == 0x000001, "Wrong alignment on X6GameUserSettings_SetAntiAliasingMethod");
static_assert(sizeof(X6GameUserSettings_SetAntiAliasingMethod) == 0x000001, "Wrong size on X6GameUserSettings_SetAntiAliasingMethod");
static_assert(offsetof(X6GameUserSettings_SetAntiAliasingMethod, Value) == 0x000000, "Member 'X6GameUserSettings_SetAntiAliasingMethod::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetBloomEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetBloomEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetBloomEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_SetBloomEnabled");
static_assert(sizeof(X6GameUserSettings_SetBloomEnabled) == 0x000001, "Wrong size on X6GameUserSettings_SetBloomEnabled");
static_assert(offsetof(X6GameUserSettings_SetBloomEnabled, bEnable) == 0x000000, "Member 'X6GameUserSettings_SetBloomEnabled::bEnable' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetCustomUpScaleRate
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetCustomUpScaleRate final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetCustomUpScaleRate) == 0x000004, "Wrong alignment on X6GameUserSettings_SetCustomUpScaleRate");
static_assert(sizeof(X6GameUserSettings_SetCustomUpScaleRate) == 0x000004, "Wrong size on X6GameUserSettings_SetCustomUpScaleRate");
static_assert(offsetof(X6GameUserSettings_SetCustomUpScaleRate, InValue) == 0x000000, "Member 'X6GameUserSettings_SetCustomUpScaleRate::InValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetDefaultFrameRateFromIni
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetDefaultFrameRateFromIni final
{
public:
	int32                                         DeviceLevel;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetDefaultFrameRateFromIni) == 0x000004, "Wrong alignment on X6GameUserSettings_SetDefaultFrameRateFromIni");
static_assert(sizeof(X6GameUserSettings_SetDefaultFrameRateFromIni) == 0x000004, "Wrong size on X6GameUserSettings_SetDefaultFrameRateFromIni");
static_assert(offsetof(X6GameUserSettings_SetDefaultFrameRateFromIni, DeviceLevel) == 0x000000, "Member 'X6GameUserSettings_SetDefaultFrameRateFromIni::DeviceLevel' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetGlobalIlluminationMethod
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetGlobalIlluminationMethod final
{
public:
	EGlobalIlluminationMethod                     Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetGlobalIlluminationMethod) == 0x000001, "Wrong alignment on X6GameUserSettings_SetGlobalIlluminationMethod");
static_assert(sizeof(X6GameUserSettings_SetGlobalIlluminationMethod) == 0x000001, "Wrong size on X6GameUserSettings_SetGlobalIlluminationMethod");
static_assert(offsetof(X6GameUserSettings_SetGlobalIlluminationMethod, Value) == 0x000000, "Member 'X6GameUserSettings_SetGlobalIlluminationMethod::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetGlobalIlluminationMethodCVar
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetGlobalIlluminationMethodCVar final
{
public:
	EGlobalIlluminationMethod                     Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetGlobalIlluminationMethodCVar) == 0x000001, "Wrong alignment on X6GameUserSettings_SetGlobalIlluminationMethodCVar");
static_assert(sizeof(X6GameUserSettings_SetGlobalIlluminationMethodCVar) == 0x000001, "Wrong size on X6GameUserSettings_SetGlobalIlluminationMethodCVar");
static_assert(offsetof(X6GameUserSettings_SetGlobalIlluminationMethodCVar, Value) == 0x000000, "Member 'X6GameUserSettings_SetGlobalIlluminationMethodCVar::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetLastCPUBenchmarkResult
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetLastCPUBenchmarkResult final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetLastCPUBenchmarkResult) == 0x000004, "Wrong alignment on X6GameUserSettings_SetLastCPUBenchmarkResult");
static_assert(sizeof(X6GameUserSettings_SetLastCPUBenchmarkResult) == 0x000004, "Wrong size on X6GameUserSettings_SetLastCPUBenchmarkResult");
static_assert(offsetof(X6GameUserSettings_SetLastCPUBenchmarkResult, Val) == 0x000000, "Member 'X6GameUserSettings_SetLastCPUBenchmarkResult::Val' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetLastGPUBenchmarkResult
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetLastGPUBenchmarkResult final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetLastGPUBenchmarkResult) == 0x000004, "Wrong alignment on X6GameUserSettings_SetLastGPUBenchmarkResult");
static_assert(sizeof(X6GameUserSettings_SetLastGPUBenchmarkResult) == 0x000004, "Wrong size on X6GameUserSettings_SetLastGPUBenchmarkResult");
static_assert(offsetof(X6GameUserSettings_SetLastGPUBenchmarkResult, Val) == 0x000000, "Member 'X6GameUserSettings_SetLastGPUBenchmarkResult::Val' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetMobileContentScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetMobileContentScaleFactor final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetMobileContentScaleFactor) == 0x000004, "Wrong alignment on X6GameUserSettings_SetMobileContentScaleFactor");
static_assert(sizeof(X6GameUserSettings_SetMobileContentScaleFactor) == 0x000004, "Wrong size on X6GameUserSettings_SetMobileContentScaleFactor");
static_assert(offsetof(X6GameUserSettings_SetMobileContentScaleFactor, Value) == 0x000000, "Member 'X6GameUserSettings_SetMobileContentScaleFactor::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetMotionBlurEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetMotionBlurEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetMotionBlurEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_SetMotionBlurEnabled");
static_assert(sizeof(X6GameUserSettings_SetMotionBlurEnabled) == 0x000001, "Wrong size on X6GameUserSettings_SetMotionBlurEnabled");
static_assert(offsetof(X6GameUserSettings_SetMotionBlurEnabled, bEnable) == 0x000000, "Member 'X6GameUserSettings_SetMotionBlurEnabled::bEnable' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetRayTracingAmbientOcclusionEnable
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetRayTracingAmbientOcclusionEnable final
{
public:
	bool                                          IsEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetRayTracingAmbientOcclusionEnable) == 0x000001, "Wrong alignment on X6GameUserSettings_SetRayTracingAmbientOcclusionEnable");
static_assert(sizeof(X6GameUserSettings_SetRayTracingAmbientOcclusionEnable) == 0x000001, "Wrong size on X6GameUserSettings_SetRayTracingAmbientOcclusionEnable");
static_assert(offsetof(X6GameUserSettings_SetRayTracingAmbientOcclusionEnable, IsEnable) == 0x000000, "Member 'X6GameUserSettings_SetRayTracingAmbientOcclusionEnable::IsEnable' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetRayTracingEnableInGame
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetRayTracingEnableInGame final
{
public:
	bool                                          IsEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetRayTracingEnableInGame) == 0x000001, "Wrong alignment on X6GameUserSettings_SetRayTracingEnableInGame");
static_assert(sizeof(X6GameUserSettings_SetRayTracingEnableInGame) == 0x000001, "Wrong size on X6GameUserSettings_SetRayTracingEnableInGame");
static_assert(offsetof(X6GameUserSettings_SetRayTracingEnableInGame, IsEnable) == 0x000000, "Member 'X6GameUserSettings_SetRayTracingEnableInGame::IsEnable' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetRayTracingReflectionEnable
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetRayTracingReflectionEnable final
{
public:
	bool                                          IsEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetRayTracingReflectionEnable) == 0x000001, "Wrong alignment on X6GameUserSettings_SetRayTracingReflectionEnable");
static_assert(sizeof(X6GameUserSettings_SetRayTracingReflectionEnable) == 0x000001, "Wrong size on X6GameUserSettings_SetRayTracingReflectionEnable");
static_assert(offsetof(X6GameUserSettings_SetRayTracingReflectionEnable, IsEnable) == 0x000000, "Member 'X6GameUserSettings_SetRayTracingReflectionEnable::IsEnable' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetSceneDetailMode
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetSceneDetailMode final
{
public:
	ESceneDetailMode                              Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetSceneDetailMode) == 0x000001, "Wrong alignment on X6GameUserSettings_SetSceneDetailMode");
static_assert(sizeof(X6GameUserSettings_SetSceneDetailMode) == 0x000001, "Wrong size on X6GameUserSettings_SetSceneDetailMode");
static_assert(offsetof(X6GameUserSettings_SetSceneDetailMode, Value) == 0x000000, "Member 'X6GameUserSettings_SetSceneDetailMode::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetSceneDetailModeCVar
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetSceneDetailModeCVar final
{
public:
	ESceneDetailMode                              Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetSceneDetailModeCVar) == 0x000001, "Wrong alignment on X6GameUserSettings_SetSceneDetailModeCVar");
static_assert(sizeof(X6GameUserSettings_SetSceneDetailModeCVar) == 0x000001, "Wrong size on X6GameUserSettings_SetSceneDetailModeCVar");
static_assert(offsetof(X6GameUserSettings_SetSceneDetailModeCVar, Value) == 0x000000, "Member 'X6GameUserSettings_SetSceneDetailModeCVar::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetSecondaryUpscaleCVar
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetSecondaryUpscaleCVar final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetSecondaryUpscaleCVar) == 0x000004, "Wrong alignment on X6GameUserSettings_SetSecondaryUpscaleCVar");
static_assert(sizeof(X6GameUserSettings_SetSecondaryUpscaleCVar) == 0x000004, "Wrong size on X6GameUserSettings_SetSecondaryUpscaleCVar");
static_assert(offsetof(X6GameUserSettings_SetSecondaryUpscaleCVar, Value) == 0x000000, "Member 'X6GameUserSettings_SetSecondaryUpscaleCVar::Value' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetUIResolution
// 0x0008 (0x0008 - 0x0000)
struct X6GameUserSettings_SetUIResolution final
{
public:
	struct FIntPoint                              Resolution;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetUIResolution) == 0x000004, "Wrong alignment on X6GameUserSettings_SetUIResolution");
static_assert(sizeof(X6GameUserSettings_SetUIResolution) == 0x000008, "Wrong size on X6GameUserSettings_SetUIResolution");
static_assert(offsetof(X6GameUserSettings_SetUIResolution, Resolution) == 0x000000, "Member 'X6GameUserSettings_SetUIResolution::Resolution' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetUpScaleMode
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_SetUpScaleMode final
{
public:
	EUpScaleMode                                  InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetUpScaleMode) == 0x000001, "Wrong alignment on X6GameUserSettings_SetUpScaleMode");
static_assert(sizeof(X6GameUserSettings_SetUpScaleMode) == 0x000001, "Wrong size on X6GameUserSettings_SetUpScaleMode");
static_assert(offsetof(X6GameUserSettings_SetUpScaleMode, InMode) == 0x000000, "Member 'X6GameUserSettings_SetUpScaleMode::InMode' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetX6DisplayGamma
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetX6DisplayGamma final
{
public:
	float                                         NewGamma;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetX6DisplayGamma) == 0x000004, "Wrong alignment on X6GameUserSettings_SetX6DisplayGamma");
static_assert(sizeof(X6GameUserSettings_SetX6DisplayGamma) == 0x000004, "Wrong size on X6GameUserSettings_SetX6DisplayGamma");
static_assert(offsetof(X6GameUserSettings_SetX6DisplayGamma, NewGamma) == 0x000000, "Member 'X6GameUserSettings_SetX6DisplayGamma::NewGamma' has a wrong offset!");

// Function X6Game.X6GameUserSettings.SetX6SaveDataVersion
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_SetX6SaveDataVersion final
{
public:
	int32                                         InVersion;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_SetX6SaveDataVersion) == 0x000004, "Wrong alignment on X6GameUserSettings_SetX6SaveDataVersion");
static_assert(sizeof(X6GameUserSettings_SetX6SaveDataVersion) == 0x000004, "Wrong size on X6GameUserSettings_SetX6SaveDataVersion");
static_assert(offsetof(X6GameUserSettings_SetX6SaveDataVersion, InVersion) == 0x000000, "Member 'X6GameUserSettings_SetX6SaveDataVersion::InVersion' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetAntiAliasingMethod
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetAntiAliasingMethod final
{
public:
	EGUSAntiAliasingMethod                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetAntiAliasingMethod) == 0x000001, "Wrong alignment on X6GameUserSettings_GetAntiAliasingMethod");
static_assert(sizeof(X6GameUserSettings_GetAntiAliasingMethod) == 0x000001, "Wrong size on X6GameUserSettings_GetAntiAliasingMethod");
static_assert(offsetof(X6GameUserSettings_GetAntiAliasingMethod, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetAntiAliasingMethod::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetDesiredScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct X6GameUserSettings_GetDesiredScreenResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetDesiredScreenResolution) == 0x000004, "Wrong alignment on X6GameUserSettings_GetDesiredScreenResolution");
static_assert(sizeof(X6GameUserSettings_GetDesiredScreenResolution) == 0x000008, "Wrong size on X6GameUserSettings_GetDesiredScreenResolution");
static_assert(offsetof(X6GameUserSettings_GetDesiredScreenResolution, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetDesiredScreenResolution::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetGlobalIlluminationMethod
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetGlobalIlluminationMethod final
{
public:
	EGlobalIlluminationMethod                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetGlobalIlluminationMethod) == 0x000001, "Wrong alignment on X6GameUserSettings_GetGlobalIlluminationMethod");
static_assert(sizeof(X6GameUserSettings_GetGlobalIlluminationMethod) == 0x000001, "Wrong size on X6GameUserSettings_GetGlobalIlluminationMethod");
static_assert(offsetof(X6GameUserSettings_GetGlobalIlluminationMethod, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetGlobalIlluminationMethod::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetMobileContentScaleFactorValue
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetMobileContentScaleFactorValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetMobileContentScaleFactorValue) == 0x000004, "Wrong alignment on X6GameUserSettings_GetMobileContentScaleFactorValue");
static_assert(sizeof(X6GameUserSettings_GetMobileContentScaleFactorValue) == 0x000004, "Wrong size on X6GameUserSettings_GetMobileContentScaleFactorValue");
static_assert(offsetof(X6GameUserSettings_GetMobileContentScaleFactorValue, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetMobileContentScaleFactorValue::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetSceneDetailMode
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetSceneDetailMode final
{
public:
	ESceneDetailMode                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetSceneDetailMode) == 0x000001, "Wrong alignment on X6GameUserSettings_GetSceneDetailMode");
static_assert(sizeof(X6GameUserSettings_GetSceneDetailMode) == 0x000001, "Wrong size on X6GameUserSettings_GetSceneDetailMode");
static_assert(offsetof(X6GameUserSettings_GetSceneDetailMode, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetSceneDetailMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetUpScaleMode
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_GetUpScaleMode final
{
public:
	EUpScaleMode                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetUpScaleMode) == 0x000001, "Wrong alignment on X6GameUserSettings_GetUpScaleMode");
static_assert(sizeof(X6GameUserSettings_GetUpScaleMode) == 0x000001, "Wrong size on X6GameUserSettings_GetUpScaleMode");
static_assert(offsetof(X6GameUserSettings_GetUpScaleMode, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetUpScaleMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.GetX6SaveDataVersion
// 0x0004 (0x0004 - 0x0000)
struct X6GameUserSettings_GetX6SaveDataVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_GetX6SaveDataVersion) == 0x000004, "Wrong alignment on X6GameUserSettings_GetX6SaveDataVersion");
static_assert(sizeof(X6GameUserSettings_GetX6SaveDataVersion) == 0x000004, "Wrong size on X6GameUserSettings_GetX6SaveDataVersion");
static_assert(offsetof(X6GameUserSettings_GetX6SaveDataVersion, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_GetX6SaveDataVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.IsAmbientOcclusionEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_IsAmbientOcclusionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_IsAmbientOcclusionEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_IsAmbientOcclusionEnabled");
static_assert(sizeof(X6GameUserSettings_IsAmbientOcclusionEnabled) == 0x000001, "Wrong size on X6GameUserSettings_IsAmbientOcclusionEnabled");
static_assert(offsetof(X6GameUserSettings_IsAmbientOcclusionEnabled, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_IsAmbientOcclusionEnabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.IsBloomEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_IsBloomEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_IsBloomEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_IsBloomEnabled");
static_assert(sizeof(X6GameUserSettings_IsBloomEnabled) == 0x000001, "Wrong size on X6GameUserSettings_IsBloomEnabled");
static_assert(offsetof(X6GameUserSettings_IsBloomEnabled, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_IsBloomEnabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.IsMotionBlurEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_IsMotionBlurEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_IsMotionBlurEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_IsMotionBlurEnabled");
static_assert(sizeof(X6GameUserSettings_IsMotionBlurEnabled) == 0x000001, "Wrong size on X6GameUserSettings_IsMotionBlurEnabled");
static_assert(offsetof(X6GameUserSettings_IsMotionBlurEnabled, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_IsMotionBlurEnabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.IsRayTracingAmbientOcclusionEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled");
static_assert(sizeof(X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled) == 0x000001, "Wrong size on X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled");
static_assert(offsetof(X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_IsRayTracingAmbientOcclusionEnabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.IsRayTracingEnableInGame
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_IsRayTracingEnableInGame final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_IsRayTracingEnableInGame) == 0x000001, "Wrong alignment on X6GameUserSettings_IsRayTracingEnableInGame");
static_assert(sizeof(X6GameUserSettings_IsRayTracingEnableInGame) == 0x000001, "Wrong size on X6GameUserSettings_IsRayTracingEnableInGame");
static_assert(offsetof(X6GameUserSettings_IsRayTracingEnableInGame, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_IsRayTracingEnableInGame::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameUserSettings.IsRayTracingReflectionsEnabled
// 0x0001 (0x0001 - 0x0000)
struct X6GameUserSettings_IsRayTracingReflectionsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameUserSettings_IsRayTracingReflectionsEnabled) == 0x000001, "Wrong alignment on X6GameUserSettings_IsRayTracingReflectionsEnabled");
static_assert(sizeof(X6GameUserSettings_IsRayTracingReflectionsEnabled) == 0x000001, "Wrong size on X6GameUserSettings_IsRayTracingReflectionsEnabled");
static_assert(offsetof(X6GameUserSettings_IsRayTracingReflectionsEnabled, ReturnValue) == 0x000000, "Member 'X6GameUserSettings_IsRayTracingReflectionsEnabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.AddSituationType
// 0x0001 (0x0001 - 0x0000)
struct X6GeneralAnimationDataComponent_AddSituationType final
{
public:
	ECharacterSituationType                       NewSituationType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_AddSituationType) == 0x000001, "Wrong alignment on X6GeneralAnimationDataComponent_AddSituationType");
static_assert(sizeof(X6GeneralAnimationDataComponent_AddSituationType) == 0x000001, "Wrong size on X6GeneralAnimationDataComponent_AddSituationType");
static_assert(offsetof(X6GeneralAnimationDataComponent_AddSituationType, NewSituationType) == 0x000000, "Member 'X6GeneralAnimationDataComponent_AddSituationType::NewSituationType' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.InitializeLocomotionDataContainer
// 0x0010 (0x0010 - 0x0000)
struct X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer final
{
public:
	TSubclassOf<class ULocomotionDataContainerBase> LocomotionDataContainerClass;                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocomotionDataContainerBase*           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer) == 0x000008, "Wrong alignment on X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer");
static_assert(sizeof(X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer) == 0x000010, "Wrong size on X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer");
static_assert(offsetof(X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer, LocomotionDataContainerClass) == 0x000000, "Member 'X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer::LocomotionDataContainerClass' has a wrong offset!");
static_assert(offsetof(X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer, ReturnValue) == 0x000008, "Member 'X6GeneralAnimationDataComponent_InitializeLocomotionDataContainer::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.RemoveSituationType
// 0x0001 (0x0001 - 0x0000)
struct X6GeneralAnimationDataComponent_RemoveSituationType final
{
public:
	ECharacterSituationType                       NewSituationType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_RemoveSituationType) == 0x000001, "Wrong alignment on X6GeneralAnimationDataComponent_RemoveSituationType");
static_assert(sizeof(X6GeneralAnimationDataComponent_RemoveSituationType) == 0x000001, "Wrong size on X6GeneralAnimationDataComponent_RemoveSituationType");
static_assert(offsetof(X6GeneralAnimationDataComponent_RemoveSituationType, NewSituationType) == 0x000000, "Member 'X6GeneralAnimationDataComponent_RemoveSituationType::NewSituationType' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.SetCurrentWaterDepth
// 0x0004 (0x0004 - 0x0000)
struct X6GeneralAnimationDataComponent_SetCurrentWaterDepth final
{
public:
	float                                         NewWaterDepth;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_SetCurrentWaterDepth) == 0x000004, "Wrong alignment on X6GeneralAnimationDataComponent_SetCurrentWaterDepth");
static_assert(sizeof(X6GeneralAnimationDataComponent_SetCurrentWaterDepth) == 0x000004, "Wrong size on X6GeneralAnimationDataComponent_SetCurrentWaterDepth");
static_assert(offsetof(X6GeneralAnimationDataComponent_SetCurrentWaterDepth, NewWaterDepth) == 0x000000, "Member 'X6GeneralAnimationDataComponent_SetCurrentWaterDepth::NewWaterDepth' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.SetDamiaoInFollowFloat
// 0x0001 (0x0001 - 0x0000)
struct X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat final
{
public:
	bool                                          FollowFloat;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat) == 0x000001, "Wrong alignment on X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat");
static_assert(sizeof(X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat) == 0x000001, "Wrong size on X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat");
static_assert(offsetof(X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat, FollowFloat) == 0x000000, "Member 'X6GeneralAnimationDataComponent_SetDamiaoInFollowFloat::FollowFloat' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.SetDamiaoTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct X6GeneralAnimationDataComponent_SetDamiaoTargetLocation final
{
public:
	struct FVector                                TargetLoc;                                         // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_SetDamiaoTargetLocation) == 0x000008, "Wrong alignment on X6GeneralAnimationDataComponent_SetDamiaoTargetLocation");
static_assert(sizeof(X6GeneralAnimationDataComponent_SetDamiaoTargetLocation) == 0x000018, "Wrong size on X6GeneralAnimationDataComponent_SetDamiaoTargetLocation");
static_assert(offsetof(X6GeneralAnimationDataComponent_SetDamiaoTargetLocation, TargetLoc) == 0x000000, "Member 'X6GeneralAnimationDataComponent_SetDamiaoTargetLocation::TargetLoc' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.SetEnableSlopeCalculate
// 0x0001 (0x0001 - 0x0000)
struct X6GeneralAnimationDataComponent_SetEnableSlopeCalculate final
{
public:
	bool                                          bNewEnable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_SetEnableSlopeCalculate) == 0x000001, "Wrong alignment on X6GeneralAnimationDataComponent_SetEnableSlopeCalculate");
static_assert(sizeof(X6GeneralAnimationDataComponent_SetEnableSlopeCalculate) == 0x000001, "Wrong size on X6GeneralAnimationDataComponent_SetEnableSlopeCalculate");
static_assert(offsetof(X6GeneralAnimationDataComponent_SetEnableSlopeCalculate, bNewEnable) == 0x000000, "Member 'X6GeneralAnimationDataComponent_SetEnableSlopeCalculate::bNewEnable' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.SetLocomotionRequestObject
// 0x0008 (0x0008 - 0x0000)
struct X6GeneralAnimationDataComponent_SetLocomotionRequestObject final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_SetLocomotionRequestObject) == 0x000008, "Wrong alignment on X6GeneralAnimationDataComponent_SetLocomotionRequestObject");
static_assert(sizeof(X6GeneralAnimationDataComponent_SetLocomotionRequestObject) == 0x000008, "Wrong size on X6GeneralAnimationDataComponent_SetLocomotionRequestObject");
static_assert(offsetof(X6GeneralAnimationDataComponent_SetLocomotionRequestObject, InObject) == 0x000000, "Member 'X6GeneralAnimationDataComponent_SetLocomotionRequestObject::InObject' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.TurnInPlaceByAngle
// 0x0028 (0x0028 - 0x0000)
struct X6GeneralAnimationDataComponent_TurnInPlaceByAngle final
{
public:
	float                                         TurnAngle;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnComplete;                                        // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterrupt;                                       // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GeneralAnimationDataComponent_TurnInPlaceByAngle) == 0x000004, "Wrong alignment on X6GeneralAnimationDataComponent_TurnInPlaceByAngle");
static_assert(sizeof(X6GeneralAnimationDataComponent_TurnInPlaceByAngle) == 0x000028, "Wrong size on X6GeneralAnimationDataComponent_TurnInPlaceByAngle");
static_assert(offsetof(X6GeneralAnimationDataComponent_TurnInPlaceByAngle, TurnAngle) == 0x000000, "Member 'X6GeneralAnimationDataComponent_TurnInPlaceByAngle::TurnAngle' has a wrong offset!");
static_assert(offsetof(X6GeneralAnimationDataComponent_TurnInPlaceByAngle, OnComplete) == 0x000004, "Member 'X6GeneralAnimationDataComponent_TurnInPlaceByAngle::OnComplete' has a wrong offset!");
static_assert(offsetof(X6GeneralAnimationDataComponent_TurnInPlaceByAngle, OnInterrupt) == 0x000014, "Member 'X6GeneralAnimationDataComponent_TurnInPlaceByAngle::OnInterrupt' has a wrong offset!");
static_assert(offsetof(X6GeneralAnimationDataComponent_TurnInPlaceByAngle, ReturnValue) == 0x000024, "Member 'X6GeneralAnimationDataComponent_TurnInPlaceByAngle::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.GetCurrentWaterDepth
// 0x0004 (0x0004 - 0x0000)
struct X6GeneralAnimationDataComponent_GetCurrentWaterDepth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_GetCurrentWaterDepth) == 0x000004, "Wrong alignment on X6GeneralAnimationDataComponent_GetCurrentWaterDepth");
static_assert(sizeof(X6GeneralAnimationDataComponent_GetCurrentWaterDepth) == 0x000004, "Wrong size on X6GeneralAnimationDataComponent_GetCurrentWaterDepth");
static_assert(offsetof(X6GeneralAnimationDataComponent_GetCurrentWaterDepth, ReturnValue) == 0x000000, "Member 'X6GeneralAnimationDataComponent_GetCurrentWaterDepth::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.GetForwardSlopeAngle
// 0x0004 (0x0004 - 0x0000)
struct X6GeneralAnimationDataComponent_GetForwardSlopeAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_GetForwardSlopeAngle) == 0x000004, "Wrong alignment on X6GeneralAnimationDataComponent_GetForwardSlopeAngle");
static_assert(sizeof(X6GeneralAnimationDataComponent_GetForwardSlopeAngle) == 0x000004, "Wrong size on X6GeneralAnimationDataComponent_GetForwardSlopeAngle");
static_assert(offsetof(X6GeneralAnimationDataComponent_GetForwardSlopeAngle, ReturnValue) == 0x000000, "Member 'X6GeneralAnimationDataComponent_GetForwardSlopeAngle::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.GetLocomotionCanEverTurnInPlace
// 0x0001 (0x0001 - 0x0000)
struct X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace) == 0x000001, "Wrong alignment on X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace");
static_assert(sizeof(X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace) == 0x000001, "Wrong size on X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace");
static_assert(offsetof(X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace, ReturnValue) == 0x000000, "Member 'X6GeneralAnimationDataComponent_GetLocomotionCanEverTurnInPlace::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.GetRegularMovementBaseVelocity
// 0x0018 (0x0018 - 0x0000)
struct X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity) == 0x000008, "Wrong alignment on X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity");
static_assert(sizeof(X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity) == 0x000018, "Wrong size on X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity");
static_assert(offsetof(X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity, ReturnValue) == 0x000000, "Member 'X6GeneralAnimationDataComponent_GetRegularMovementBaseVelocity::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.GetRightSlopeAngle
// 0x0004 (0x0004 - 0x0000)
struct X6GeneralAnimationDataComponent_GetRightSlopeAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_GetRightSlopeAngle) == 0x000004, "Wrong alignment on X6GeneralAnimationDataComponent_GetRightSlopeAngle");
static_assert(sizeof(X6GeneralAnimationDataComponent_GetRightSlopeAngle) == 0x000004, "Wrong size on X6GeneralAnimationDataComponent_GetRightSlopeAngle");
static_assert(offsetof(X6GeneralAnimationDataComponent_GetRightSlopeAngle, ReturnValue) == 0x000000, "Member 'X6GeneralAnimationDataComponent_GetRightSlopeAngle::ReturnValue' has a wrong offset!");

// Function X6Game.X6GeneralAnimationDataComponent.HasSituationType
// 0x0002 (0x0002 - 0x0000)
struct X6GeneralAnimationDataComponent_HasSituationType final
{
public:
	ECharacterSituationType                       NewSituationType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GeneralAnimationDataComponent_HasSituationType) == 0x000001, "Wrong alignment on X6GeneralAnimationDataComponent_HasSituationType");
static_assert(sizeof(X6GeneralAnimationDataComponent_HasSituationType) == 0x000002, "Wrong size on X6GeneralAnimationDataComponent_HasSituationType");
static_assert(offsetof(X6GeneralAnimationDataComponent_HasSituationType, NewSituationType) == 0x000000, "Member 'X6GeneralAnimationDataComponent_HasSituationType::NewSituationType' has a wrong offset!");
static_assert(offsetof(X6GeneralAnimationDataComponent_HasSituationType, ReturnValue) == 0x000001, "Member 'X6GeneralAnimationDataComponent_HasSituationType::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.GetGroundFlyHeight
// 0x0004 (0x0004 - 0x0000)
struct X6GroundFlyMovementComponent_GetGroundFlyHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_GetGroundFlyHeight) == 0x000004, "Wrong alignment on X6GroundFlyMovementComponent_GetGroundFlyHeight");
static_assert(sizeof(X6GroundFlyMovementComponent_GetGroundFlyHeight) == 0x000004, "Wrong size on X6GroundFlyMovementComponent_GetGroundFlyHeight");
static_assert(offsetof(X6GroundFlyMovementComponent_GetGroundFlyHeight, ReturnValue) == 0x000000, "Member 'X6GroundFlyMovementComponent_GetGroundFlyHeight::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.GetMovementArriveMode
// 0x0001 (0x0001 - 0x0000)
struct X6GroundFlyMovementComponent_GetMovementArriveMode final
{
public:
	EGroundFlyMovementMode                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_GetMovementArriveMode) == 0x000001, "Wrong alignment on X6GroundFlyMovementComponent_GetMovementArriveMode");
static_assert(sizeof(X6GroundFlyMovementComponent_GetMovementArriveMode) == 0x000001, "Wrong size on X6GroundFlyMovementComponent_GetMovementArriveMode");
static_assert(offsetof(X6GroundFlyMovementComponent_GetMovementArriveMode, ReturnValue) == 0x000000, "Member 'X6GroundFlyMovementComponent_GetMovementArriveMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.GetMovementMode
// 0x0001 (0x0001 - 0x0000)
struct X6GroundFlyMovementComponent_GetMovementMode final
{
public:
	EGroundFlyMovementMode                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_GetMovementMode) == 0x000001, "Wrong alignment on X6GroundFlyMovementComponent_GetMovementMode");
static_assert(sizeof(X6GroundFlyMovementComponent_GetMovementMode) == 0x000001, "Wrong size on X6GroundFlyMovementComponent_GetMovementMode");
static_assert(offsetof(X6GroundFlyMovementComponent_GetMovementMode, ReturnValue) == 0x000000, "Member 'X6GroundFlyMovementComponent_GetMovementMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.GetTargetModeGroundFlyHeight
// 0x0008 (0x0008 - 0x0000)
struct X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight final
{
public:
	EGroundFlyMovementMode                        TargetMode;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight) == 0x000004, "Wrong alignment on X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight");
static_assert(sizeof(X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight) == 0x000008, "Wrong size on X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight");
static_assert(offsetof(X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight, TargetMode) == 0x000000, "Member 'X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight::TargetMode' has a wrong offset!");
static_assert(offsetof(X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight, ReturnValue) == 0x000004, "Member 'X6GroundFlyMovementComponent_GetTargetModeGroundFlyHeight::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.InstantChangeHeight
// 0x0001 (0x0001 - 0x0000)
struct X6GroundFlyMovementComponent_InstantChangeHeight final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_InstantChangeHeight) == 0x000001, "Wrong alignment on X6GroundFlyMovementComponent_InstantChangeHeight");
static_assert(sizeof(X6GroundFlyMovementComponent_InstantChangeHeight) == 0x000001, "Wrong size on X6GroundFlyMovementComponent_InstantChangeHeight");
static_assert(offsetof(X6GroundFlyMovementComponent_InstantChangeHeight, ReturnValue) == 0x000000, "Member 'X6GroundFlyMovementComponent_InstantChangeHeight::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.MapGroundFlyMode2MoveMode
// 0x0002 (0x0002 - 0x0000)
struct X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode final
{
public:
	EGroundFlyMovementMode                        TargetMode;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode) == 0x000001, "Wrong alignment on X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode");
static_assert(sizeof(X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode) == 0x000002, "Wrong size on X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode");
static_assert(offsetof(X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode, TargetMode) == 0x000000, "Member 'X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode::TargetMode' has a wrong offset!");
static_assert(offsetof(X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode, ReturnValue) == 0x000001, "Member 'X6GroundFlyMovementComponent_MapGroundFlyMode2MoveMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.SetGroundFlyDefaultMovementMode
// 0x0002 (0x0002 - 0x0000)
struct X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode final
{
public:
	EGroundFlyMovementMode                        TargetMoveMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroundFlyMovementMode                        TargetArriveMode;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode) == 0x000001, "Wrong alignment on X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode");
static_assert(sizeof(X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode) == 0x000002, "Wrong size on X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode");
static_assert(offsetof(X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode, TargetMoveMode) == 0x000000, "Member 'X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode::TargetMoveMode' has a wrong offset!");
static_assert(offsetof(X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode, TargetArriveMode) == 0x000001, "Member 'X6GroundFlyMovementComponent_SetGroundFlyDefaultMovementMode::TargetArriveMode' has a wrong offset!");

// Function X6Game.X6GroundFlyMovementComponent.SetGroundFlyMovementMode
// 0x0028 (0x0028 - 0x0000)
struct X6GroundFlyMovementComponent_SetGroundFlyMovementMode final
{
public:
	struct FGroundFlyMovementSettings             Settings;                                          // 0x0000(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GroundFlyMovementComponent_SetGroundFlyMovementMode) == 0x000008, "Wrong alignment on X6GroundFlyMovementComponent_SetGroundFlyMovementMode");
static_assert(sizeof(X6GroundFlyMovementComponent_SetGroundFlyMovementMode) == 0x000028, "Wrong size on X6GroundFlyMovementComponent_SetGroundFlyMovementMode");
static_assert(offsetof(X6GroundFlyMovementComponent_SetGroundFlyMovementMode, Settings) == 0x000000, "Member 'X6GroundFlyMovementComponent_SetGroundFlyMovementMode::Settings' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.GetCPUBenchMark
// 0x0018 (0x0018 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark final
{
public:
	class FString                                 InBrandInfo;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark) == 0x000018, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark, InBrandInfo) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark::InBrandInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark, ReturnValue) == 0x000010, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetCPUBenchMark::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.GetCPUBrand
// 0x0010 (0x0010 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand) == 0x000010, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand, ReturnValue) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetCPUBrand::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.GetCPUInfo
// 0x0010 (0x0010 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo) == 0x000010, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo, ReturnValue) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetCPUInfo::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.GetCPUVendor
// 0x0010 (0x0010 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor) == 0x000010, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor, ReturnValue) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetCPUVendor::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.GetGPUBenchMark
// 0x0018 (0x0018 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark final
{
public:
	class FString                                 InBrandInfo;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark) == 0x000018, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark, InBrandInfo) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark::InBrandInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark, ReturnValue) == 0x000010, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetGPUBenchMark::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.GetGPUBrand
// 0x0010 (0x0010 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand) == 0x000010, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand, ReturnValue) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_GetGPUBrand::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.IsCPUReachedSuggestedVersion
// 0x0018 (0x0018 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion final
{
public:
	class FString                                 InBrandInfo;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion) == 0x000018, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion, InBrandInfo) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion::InBrandInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion, ReturnValue) == 0x000010, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedSuggestedVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.IsCPUReachedTargetVersion
// 0x0028 (0x0028 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion final
{
public:
	class FString                                 InBrandInfo;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetInfo;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion) == 0x000028, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion, InBrandInfo) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion::InBrandInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion, TargetInfo) == 0x000010, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion::TargetInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion, ReturnValue) == 0x000020, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsCPUReachedTargetVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.IsGPUReachedSuggestedVersion
// 0x0018 (0x0018 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion final
{
public:
	class FString                                 InBrandInfo;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion) == 0x000018, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion, InBrandInfo) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion::InBrandInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion, ReturnValue) == 0x000010, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedSuggestedVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6HardWareBenchmarkBlueprintFunctions.IsGPUReachedTargetVersion
// 0x0028 (0x0028 - 0x0000)
struct X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion final
{
public:
	class FString                                 InBrandInfo;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetInfo;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion) == 0x000008, "Wrong alignment on X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion");
static_assert(sizeof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion) == 0x000028, "Wrong size on X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion, InBrandInfo) == 0x000000, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion::InBrandInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion, TargetInfo) == 0x000010, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion::TargetInfo' has a wrong offset!");
static_assert(offsetof(X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion, ReturnValue) == 0x000020, "Member 'X6HardWareBenchmarkBlueprintFunctions_IsGPUReachedTargetVersion::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetAllTextMaterialInstanceDynamic
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic final
{
public:
	TArray<class UMaterialInstanceDynamic*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic");
static_assert(sizeof(X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic) == 0x000010, "Wrong size on X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic");
static_assert(offsetof(X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic, ReturnValue) == 0x000000, "Member 'X6HeadInfoComponent_GetAllTextMaterialInstanceDynamic::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetIconMaterialInstanceDynamic
// 0x0008 (0x0008 - 0x0000)
struct X6HeadInfoComponent_GetIconMaterialInstanceDynamic final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetIconMaterialInstanceDynamic) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetIconMaterialInstanceDynamic");
static_assert(sizeof(X6HeadInfoComponent_GetIconMaterialInstanceDynamic) == 0x000008, "Wrong size on X6HeadInfoComponent_GetIconMaterialInstanceDynamic");
static_assert(offsetof(X6HeadInfoComponent_GetIconMaterialInstanceDynamic, ReturnValue) == 0x000000, "Member 'X6HeadInfoComponent_GetIconMaterialInstanceDynamic::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetIconSize
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_GetIconSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetIconSize) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetIconSize");
static_assert(sizeof(X6HeadInfoComponent_GetIconSize) == 0x000010, "Wrong size on X6HeadInfoComponent_GetIconSize");
static_assert(offsetof(X6HeadInfoComponent_GetIconSize, ReturnValue) == 0x000000, "Member 'X6HeadInfoComponent_GetIconSize::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetInteractiveIconMaterialInstanceDynamic
// 0x0008 (0x0008 - 0x0000)
struct X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic");
static_assert(sizeof(X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic) == 0x000008, "Wrong size on X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic");
static_assert(offsetof(X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic, ReturnValue) == 0x000000, "Member 'X6HeadInfoComponent_GetInteractiveIconMaterialInstanceDynamic::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetInteractiveIconSize
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_GetInteractiveIconSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetInteractiveIconSize) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetInteractiveIconSize");
static_assert(sizeof(X6HeadInfoComponent_GetInteractiveIconSize) == 0x000010, "Wrong size on X6HeadInfoComponent_GetInteractiveIconSize");
static_assert(offsetof(X6HeadInfoComponent_GetInteractiveIconSize, ReturnValue) == 0x000000, "Member 'X6HeadInfoComponent_GetInteractiveIconSize::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetTextMaterialInstanceDynamic
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_GetTextMaterialInstanceDynamic final
{
public:
	int32                                         PageIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetTextMaterialInstanceDynamic) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetTextMaterialInstanceDynamic");
static_assert(sizeof(X6HeadInfoComponent_GetTextMaterialInstanceDynamic) == 0x000010, "Wrong size on X6HeadInfoComponent_GetTextMaterialInstanceDynamic");
static_assert(offsetof(X6HeadInfoComponent_GetTextMaterialInstanceDynamic, PageIndex) == 0x000000, "Member 'X6HeadInfoComponent_GetTextMaterialInstanceDynamic::PageIndex' has a wrong offset!");
static_assert(offsetof(X6HeadInfoComponent_GetTextMaterialInstanceDynamic, ReturnValue) == 0x000008, "Member 'X6HeadInfoComponent_GetTextMaterialInstanceDynamic::ReturnValue' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetFont
// 0x0008 (0x0008 - 0x0000)
struct X6HeadInfoComponent_SetFont final
{
public:
	class UFont*                                  InFont;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetFont) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetFont");
static_assert(sizeof(X6HeadInfoComponent_SetFont) == 0x000008, "Wrong size on X6HeadInfoComponent_SetFont");
static_assert(offsetof(X6HeadInfoComponent_SetFont, InFont) == 0x000000, "Member 'X6HeadInfoComponent_SetFont::InFont' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetIconMaterial
// 0x0008 (0x0008 - 0x0000)
struct X6HeadInfoComponent_SetIconMaterial final
{
public:
	class UMaterialInterface*                     InIconMaterial;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetIconMaterial) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetIconMaterial");
static_assert(sizeof(X6HeadInfoComponent_SetIconMaterial) == 0x000008, "Wrong size on X6HeadInfoComponent_SetIconMaterial");
static_assert(offsetof(X6HeadInfoComponent_SetIconMaterial, InIconMaterial) == 0x000000, "Member 'X6HeadInfoComponent_SetIconMaterial::InIconMaterial' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetIconSize
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_SetIconSize final
{
public:
	struct FVector2D                              InIconSize;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetIconSize) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetIconSize");
static_assert(sizeof(X6HeadInfoComponent_SetIconSize) == 0x000010, "Wrong size on X6HeadInfoComponent_SetIconSize");
static_assert(offsetof(X6HeadInfoComponent_SetIconSize, InIconSize) == 0x000000, "Member 'X6HeadInfoComponent_SetIconSize::InIconSize' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetIconVisible
// 0x0001 (0x0001 - 0x0000)
struct X6HeadInfoComponent_SetIconVisible final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetIconVisible) == 0x000001, "Wrong alignment on X6HeadInfoComponent_SetIconVisible");
static_assert(sizeof(X6HeadInfoComponent_SetIconVisible) == 0x000001, "Wrong size on X6HeadInfoComponent_SetIconVisible");
static_assert(offsetof(X6HeadInfoComponent_SetIconVisible, Visible) == 0x000000, "Member 'X6HeadInfoComponent_SetIconVisible::Visible' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetInteractiveIconMaterial
// 0x0008 (0x0008 - 0x0000)
struct X6HeadInfoComponent_SetInteractiveIconMaterial final
{
public:
	class UMaterialInterface*                     InInteractiveIconMaterial;                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetInteractiveIconMaterial) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetInteractiveIconMaterial");
static_assert(sizeof(X6HeadInfoComponent_SetInteractiveIconMaterial) == 0x000008, "Wrong size on X6HeadInfoComponent_SetInteractiveIconMaterial");
static_assert(offsetof(X6HeadInfoComponent_SetInteractiveIconMaterial, InInteractiveIconMaterial) == 0x000000, "Member 'X6HeadInfoComponent_SetInteractiveIconMaterial::InInteractiveIconMaterial' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetInteractiveIconSize
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_SetInteractiveIconSize final
{
public:
	struct FVector2D                              InInteractiveIconSize;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetInteractiveIconSize) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetInteractiveIconSize");
static_assert(sizeof(X6HeadInfoComponent_SetInteractiveIconSize) == 0x000010, "Wrong size on X6HeadInfoComponent_SetInteractiveIconSize");
static_assert(offsetof(X6HeadInfoComponent_SetInteractiveIconSize, InInteractiveIconSize) == 0x000000, "Member 'X6HeadInfoComponent_SetInteractiveIconSize::InInteractiveIconSize' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetInteractiveIconVisible
// 0x0001 (0x0001 - 0x0000)
struct X6HeadInfoComponent_SetInteractiveIconVisible final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetInteractiveIconVisible) == 0x000001, "Wrong alignment on X6HeadInfoComponent_SetInteractiveIconVisible");
static_assert(sizeof(X6HeadInfoComponent_SetInteractiveIconVisible) == 0x000001, "Wrong size on X6HeadInfoComponent_SetInteractiveIconVisible");
static_assert(offsetof(X6HeadInfoComponent_SetInteractiveIconVisible, Visible) == 0x000000, "Member 'X6HeadInfoComponent_SetInteractiveIconVisible::Visible' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetText
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_SetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetText) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetText");
static_assert(sizeof(X6HeadInfoComponent_SetText) == 0x000010, "Wrong size on X6HeadInfoComponent_SetText");
static_assert(offsetof(X6HeadInfoComponent_SetText, InText) == 0x000000, "Member 'X6HeadInfoComponent_SetText::InText' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetTextMaterial
// 0x0008 (0x0008 - 0x0000)
struct X6HeadInfoComponent_SetTextMaterial final
{
public:
	class UMaterialInterface*                     InTextMaterial;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetTextMaterial) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetTextMaterial");
static_assert(sizeof(X6HeadInfoComponent_SetTextMaterial) == 0x000008, "Wrong size on X6HeadInfoComponent_SetTextMaterial");
static_assert(offsetof(X6HeadInfoComponent_SetTextMaterial, InTextMaterial) == 0x000000, "Member 'X6HeadInfoComponent_SetTextMaterial::InTextMaterial' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetTextScale
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_SetTextScale final
{
public:
	struct FVector2D                              InTextScale;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetTextScale) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetTextScale");
static_assert(sizeof(X6HeadInfoComponent_SetTextScale) == 0x000010, "Wrong size on X6HeadInfoComponent_SetTextScale");
static_assert(offsetof(X6HeadInfoComponent_SetTextScale, InTextScale) == 0x000000, "Member 'X6HeadInfoComponent_SetTextScale::InTextScale' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.SetTimerDelegate
// 0x0018 (0x0018 - 0x0000)
struct X6HeadInfoComponent_SetTimerDelegate final
{
public:
	class UCurveFloat*                            CurveFloat;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Time, float Value, bool bFinished)> Delegate;                               // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_SetTimerDelegate) == 0x000008, "Wrong alignment on X6HeadInfoComponent_SetTimerDelegate");
static_assert(sizeof(X6HeadInfoComponent_SetTimerDelegate) == 0x000018, "Wrong size on X6HeadInfoComponent_SetTimerDelegate");
static_assert(offsetof(X6HeadInfoComponent_SetTimerDelegate, CurveFloat) == 0x000000, "Member 'X6HeadInfoComponent_SetTimerDelegate::CurveFloat' has a wrong offset!");
static_assert(offsetof(X6HeadInfoComponent_SetTimerDelegate, Delegate) == 0x000008, "Member 'X6HeadInfoComponent_SetTimerDelegate::Delegate' has a wrong offset!");

// Function X6Game.X6HeadInfoComponent.GetTextSize
// 0x0010 (0x0010 - 0x0000)
struct X6HeadInfoComponent_GetTextSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HeadInfoComponent_GetTextSize) == 0x000008, "Wrong alignment on X6HeadInfoComponent_GetTextSize");
static_assert(sizeof(X6HeadInfoComponent_GetTextSize) == 0x000010, "Wrong size on X6HeadInfoComponent_GetTextSize");
static_assert(offsetof(X6HeadInfoComponent_GetTextSize, ReturnValue) == 0x000000, "Member 'X6HeadInfoComponent_GetTextSize::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.AddStaticMeshesToHISM
// 0x0040 (0x0040 - 0x0000)
struct X6HISMManagerSubSystem_AddStaticMeshesToHISM final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Transforms;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             CustomMaterials;                                   // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UHierarchicalInstancedStaticMeshComponent> InstanceClass;                      // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_AddStaticMeshesToHISM) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_AddStaticMeshesToHISM");
static_assert(sizeof(X6HISMManagerSubSystem_AddStaticMeshesToHISM) == 0x000040, "Wrong size on X6HISMManagerSubSystem_AddStaticMeshesToHISM");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshesToHISM, StaticMesh) == 0x000000, "Member 'X6HISMManagerSubSystem_AddStaticMeshesToHISM::StaticMesh' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshesToHISM, Transforms) == 0x000008, "Member 'X6HISMManagerSubSystem_AddStaticMeshesToHISM::Transforms' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshesToHISM, CustomMaterials) == 0x000018, "Member 'X6HISMManagerSubSystem_AddStaticMeshesToHISM::CustomMaterials' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshesToHISM, InstanceClass) == 0x000028, "Member 'X6HISMManagerSubSystem_AddStaticMeshesToHISM::InstanceClass' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshesToHISM, ReturnValue) == 0x000030, "Member 'X6HISMManagerSubSystem_AddStaticMeshesToHISM::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.AddStaticMeshtoHISM
// 0x0090 (0x0090 - 0x0000)
struct X6HISMManagerSubSystem_AddStaticMeshtoHISM final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHierarchicalInstancedStaticMeshComponent> InstanceClass;                      // 0x0070(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ReturnValue;                                       // 0x0078(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HISMManagerSubSystem_AddStaticMeshtoHISM) == 0x000010, "Wrong alignment on X6HISMManagerSubSystem_AddStaticMeshtoHISM");
static_assert(sizeof(X6HISMManagerSubSystem_AddStaticMeshtoHISM) == 0x000090, "Wrong size on X6HISMManagerSubSystem_AddStaticMeshtoHISM");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshtoHISM, StaticMesh) == 0x000000, "Member 'X6HISMManagerSubSystem_AddStaticMeshtoHISM::StaticMesh' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshtoHISM, Transform) == 0x000010, "Member 'X6HISMManagerSubSystem_AddStaticMeshtoHISM::Transform' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshtoHISM, InstanceClass) == 0x000070, "Member 'X6HISMManagerSubSystem_AddStaticMeshtoHISM::InstanceClass' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshtoHISM, ReturnValue) == 0x000078, "Member 'X6HISMManagerSubSystem_AddStaticMeshtoHISM::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.AddStaticMeshToHISMV2
// 0x00A0 (0x00A0 - 0x0000)
struct X6HISMManagerSubSystem_AddStaticMeshToHISMV2 final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             CustomMaterials;                                   // 0x0070(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UHierarchicalInstancedStaticMeshComponent> InstanceClass;                      // 0x0080(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ReturnValue;                                       // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2) == 0x000010, "Wrong alignment on X6HISMManagerSubSystem_AddStaticMeshToHISMV2");
static_assert(sizeof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2) == 0x0000A0, "Wrong size on X6HISMManagerSubSystem_AddStaticMeshToHISMV2");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2, StaticMesh) == 0x000000, "Member 'X6HISMManagerSubSystem_AddStaticMeshToHISMV2::StaticMesh' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2, Transform) == 0x000010, "Member 'X6HISMManagerSubSystem_AddStaticMeshToHISMV2::Transform' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2, CustomMaterials) == 0x000070, "Member 'X6HISMManagerSubSystem_AddStaticMeshToHISMV2::CustomMaterials' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2, InstanceClass) == 0x000080, "Member 'X6HISMManagerSubSystem_AddStaticMeshToHISMV2::InstanceClass' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_AddStaticMeshToHISMV2, ReturnValue) == 0x000088, "Member 'X6HISMManagerSubSystem_AddStaticMeshToHISMV2::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.DestroyHISMByGuids
// 0x0010 (0x0010 - 0x0000)
struct X6HISMManagerSubSystem_DestroyHISMByGuids final
{
public:
	TArray<struct FGuid>                          InstanceGuids;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_DestroyHISMByGuids) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_DestroyHISMByGuids");
static_assert(sizeof(X6HISMManagerSubSystem_DestroyHISMByGuids) == 0x000010, "Wrong size on X6HISMManagerSubSystem_DestroyHISMByGuids");
static_assert(offsetof(X6HISMManagerSubSystem_DestroyHISMByGuids, InstanceGuids) == 0x000000, "Member 'X6HISMManagerSubSystem_DestroyHISMByGuids::InstanceGuids' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.GetHISMComponentByGuid
// 0x0018 (0x0018 - 0x0000)
struct X6HISMManagerSubSystem_GetHISMComponentByGuid final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* ReturnValue;                                    // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_GetHISMComponentByGuid) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_GetHISMComponentByGuid");
static_assert(sizeof(X6HISMManagerSubSystem_GetHISMComponentByGuid) == 0x000018, "Wrong size on X6HISMManagerSubSystem_GetHISMComponentByGuid");
static_assert(offsetof(X6HISMManagerSubSystem_GetHISMComponentByGuid, Guid) == 0x000000, "Member 'X6HISMManagerSubSystem_GetHISMComponentByGuid::Guid' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_GetHISMComponentByGuid, ReturnValue) == 0x000010, "Member 'X6HISMManagerSubSystem_GetHISMComponentByGuid::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.GetHISMKeyByGuid
// 0x0020 (0x0020 - 0x0000)
struct X6HISMManagerSubSystem_GetHISMKeyByGuid final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_GetHISMKeyByGuid) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_GetHISMKeyByGuid");
static_assert(sizeof(X6HISMManagerSubSystem_GetHISMKeyByGuid) == 0x000020, "Wrong size on X6HISMManagerSubSystem_GetHISMKeyByGuid");
static_assert(offsetof(X6HISMManagerSubSystem_GetHISMKeyByGuid, Guid) == 0x000000, "Member 'X6HISMManagerSubSystem_GetHISMKeyByGuid::Guid' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_GetHISMKeyByGuid, ReturnValue) == 0x000010, "Member 'X6HISMManagerSubSystem_GetHISMKeyByGuid::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.GetMaxDistanceLimit
// 0x0004 (0x0004 - 0x0000)
struct X6HISMManagerSubSystem_GetMaxDistanceLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_GetMaxDistanceLimit) == 0x000004, "Wrong alignment on X6HISMManagerSubSystem_GetMaxDistanceLimit");
static_assert(sizeof(X6HISMManagerSubSystem_GetMaxDistanceLimit) == 0x000004, "Wrong size on X6HISMManagerSubSystem_GetMaxDistanceLimit");
static_assert(offsetof(X6HISMManagerSubSystem_GetMaxDistanceLimit, ReturnValue) == 0x000000, "Member 'X6HISMManagerSubSystem_GetMaxDistanceLimit::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.RemoveInstanceByGuid
// 0x0018 (0x0018 - 0x0000)
struct X6HISMManagerSubSystem_RemoveInstanceByGuid final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  InstanceGuid;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_RemoveInstanceByGuid) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_RemoveInstanceByGuid");
static_assert(sizeof(X6HISMManagerSubSystem_RemoveInstanceByGuid) == 0x000018, "Wrong size on X6HISMManagerSubSystem_RemoveInstanceByGuid");
static_assert(offsetof(X6HISMManagerSubSystem_RemoveInstanceByGuid, StaticMesh) == 0x000000, "Member 'X6HISMManagerSubSystem_RemoveInstanceByGuid::StaticMesh' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_RemoveInstanceByGuid, InstanceGuid) == 0x000008, "Member 'X6HISMManagerSubSystem_RemoveInstanceByGuid::InstanceGuid' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.RemoveInstancesByGuid
// 0x0010 (0x0010 - 0x0000)
struct X6HISMManagerSubSystem_RemoveInstancesByGuid final
{
public:
	TArray<struct FGuid>                          InstanceGuids;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_RemoveInstancesByGuid) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_RemoveInstancesByGuid");
static_assert(sizeof(X6HISMManagerSubSystem_RemoveInstancesByGuid) == 0x000010, "Wrong size on X6HISMManagerSubSystem_RemoveInstancesByGuid");
static_assert(offsetof(X6HISMManagerSubSystem_RemoveInstancesByGuid, InstanceGuids) == 0x000000, "Member 'X6HISMManagerSubSystem_RemoveInstancesByGuid::InstanceGuids' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.RemoveStaticMeshFromHISM
// 0x0010 (0x0010 - 0x0000)
struct X6HISMManagerSubSystem_RemoveStaticMeshFromHISM final
{
public:
	class FString                                 HISMKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_RemoveStaticMeshFromHISM) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_RemoveStaticMeshFromHISM");
static_assert(sizeof(X6HISMManagerSubSystem_RemoveStaticMeshFromHISM) == 0x000010, "Wrong size on X6HISMManagerSubSystem_RemoveStaticMeshFromHISM");
static_assert(offsetof(X6HISMManagerSubSystem_RemoveStaticMeshFromHISM, HISMKey) == 0x000000, "Member 'X6HISMManagerSubSystem_RemoveStaticMeshFromHISM::HISMKey' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.ReplaceInstanceMaterial
// 0x0030 (0x0030 - 0x0000)
struct X6HISMManagerSubSystem_ReplaceInstanceMaterial final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             NewMaterials;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGuid                                  ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_ReplaceInstanceMaterial) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_ReplaceInstanceMaterial");
static_assert(sizeof(X6HISMManagerSubSystem_ReplaceInstanceMaterial) == 0x000030, "Wrong size on X6HISMManagerSubSystem_ReplaceInstanceMaterial");
static_assert(offsetof(X6HISMManagerSubSystem_ReplaceInstanceMaterial, Guid) == 0x000000, "Member 'X6HISMManagerSubSystem_ReplaceInstanceMaterial::Guid' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_ReplaceInstanceMaterial, NewMaterials) == 0x000010, "Member 'X6HISMManagerSubSystem_ReplaceInstanceMaterial::NewMaterials' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_ReplaceInstanceMaterial, ReturnValue) == 0x000020, "Member 'X6HISMManagerSubSystem_ReplaceInstanceMaterial::ReturnValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.SetHISMCollisionEnabled
// 0x0018 (0x0018 - 0x0000)
struct X6HISMManagerSubSystem_SetHISMCollisionEnabled final
{
public:
	class FString                                 HISMKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             NewType;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HISMManagerSubSystem_SetHISMCollisionEnabled) == 0x000008, "Wrong alignment on X6HISMManagerSubSystem_SetHISMCollisionEnabled");
static_assert(sizeof(X6HISMManagerSubSystem_SetHISMCollisionEnabled) == 0x000018, "Wrong size on X6HISMManagerSubSystem_SetHISMCollisionEnabled");
static_assert(offsetof(X6HISMManagerSubSystem_SetHISMCollisionEnabled, HISMKey) == 0x000000, "Member 'X6HISMManagerSubSystem_SetHISMCollisionEnabled::HISMKey' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_SetHISMCollisionEnabled, NewType) == 0x000010, "Member 'X6HISMManagerSubSystem_SetHISMCollisionEnabled::NewType' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.SetInstanceCustomDataValue
// 0x001C (0x001C - 0x0000)
struct X6HISMManagerSubSystem_SetInstanceCustomDataValue final
{
public:
	struct FGuid                                  InstanceId;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomDataIndex;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomDataValue;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkRenderStateDirty;                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HISMManagerSubSystem_SetInstanceCustomDataValue) == 0x000004, "Wrong alignment on X6HISMManagerSubSystem_SetInstanceCustomDataValue");
static_assert(sizeof(X6HISMManagerSubSystem_SetInstanceCustomDataValue) == 0x00001C, "Wrong size on X6HISMManagerSubSystem_SetInstanceCustomDataValue");
static_assert(offsetof(X6HISMManagerSubSystem_SetInstanceCustomDataValue, InstanceId) == 0x000000, "Member 'X6HISMManagerSubSystem_SetInstanceCustomDataValue::InstanceId' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_SetInstanceCustomDataValue, CustomDataIndex) == 0x000010, "Member 'X6HISMManagerSubSystem_SetInstanceCustomDataValue::CustomDataIndex' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_SetInstanceCustomDataValue, CustomDataValue) == 0x000014, "Member 'X6HISMManagerSubSystem_SetInstanceCustomDataValue::CustomDataValue' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_SetInstanceCustomDataValue, bMarkRenderStateDirty) == 0x000018, "Member 'X6HISMManagerSubSystem_SetInstanceCustomDataValue::bMarkRenderStateDirty' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.SetMaxDistanceLimit
// 0x0004 (0x0004 - 0x0000)
struct X6HISMManagerSubSystem_SetMaxDistanceLimit final
{
public:
	float                                         limitValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HISMManagerSubSystem_SetMaxDistanceLimit) == 0x000004, "Wrong alignment on X6HISMManagerSubSystem_SetMaxDistanceLimit");
static_assert(sizeof(X6HISMManagerSubSystem_SetMaxDistanceLimit) == 0x000004, "Wrong size on X6HISMManagerSubSystem_SetMaxDistanceLimit");
static_assert(offsetof(X6HISMManagerSubSystem_SetMaxDistanceLimit, limitValue) == 0x000000, "Member 'X6HISMManagerSubSystem_SetMaxDistanceLimit::limitValue' has a wrong offset!");

// Function X6Game.X6HISMManagerSubSystem.UpdateInstanceTransform
// 0x0090 (0x0090 - 0x0000)
struct X6HISMManagerSubSystem_UpdateInstanceTransform final
{
public:
	struct FGuid                                  InstanceGuid;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             NewTransform;                                      // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkRenderStateDirty;                             // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ReturnValue;                                       // 0x0074(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HISMManagerSubSystem_UpdateInstanceTransform) == 0x000010, "Wrong alignment on X6HISMManagerSubSystem_UpdateInstanceTransform");
static_assert(sizeof(X6HISMManagerSubSystem_UpdateInstanceTransform) == 0x000090, "Wrong size on X6HISMManagerSubSystem_UpdateInstanceTransform");
static_assert(offsetof(X6HISMManagerSubSystem_UpdateInstanceTransform, InstanceGuid) == 0x000000, "Member 'X6HISMManagerSubSystem_UpdateInstanceTransform::InstanceGuid' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_UpdateInstanceTransform, NewTransform) == 0x000010, "Member 'X6HISMManagerSubSystem_UpdateInstanceTransform::NewTransform' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_UpdateInstanceTransform, bMarkRenderStateDirty) == 0x000070, "Member 'X6HISMManagerSubSystem_UpdateInstanceTransform::bMarkRenderStateDirty' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_UpdateInstanceTransform, bTeleport) == 0x000071, "Member 'X6HISMManagerSubSystem_UpdateInstanceTransform::bTeleport' has a wrong offset!");
static_assert(offsetof(X6HISMManagerSubSystem_UpdateInstanceTransform, ReturnValue) == 0x000074, "Member 'X6HISMManagerSubSystem_UpdateInstanceTransform::ReturnValue' has a wrong offset!");

// Function X6Game.X6HyperLinkTextBlockDecorator.OnLinkClick
// 0x0050 (0x0050 - 0x0000)
struct X6HyperLinkTextBlockDecorator_OnLinkClick final
{
public:
	TMap<class FString, class FString>            Data;                                              // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HyperLinkTextBlockDecorator_OnLinkClick) == 0x000008, "Wrong alignment on X6HyperLinkTextBlockDecorator_OnLinkClick");
static_assert(sizeof(X6HyperLinkTextBlockDecorator_OnLinkClick) == 0x000050, "Wrong size on X6HyperLinkTextBlockDecorator_OnLinkClick");
static_assert(offsetof(X6HyperLinkTextBlockDecorator_OnLinkClick, Data) == 0x000000, "Member 'X6HyperLinkTextBlockDecorator_OnLinkClick::Data' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindAnalogInputEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindAnalogInputEvent final
{
public:
	TDelegate<void(const struct FAnalogInputEvent& AnalogInputEvent)> InOnAnalogInput;               // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindAnalogInputEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindAnalogInputEvent");
static_assert(sizeof(X6InputProcessorHelper_BindAnalogInputEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindAnalogInputEvent");
static_assert(offsetof(X6InputProcessorHelper_BindAnalogInputEvent, InOnAnalogInput) == 0x000000, "Member 'X6InputProcessorHelper_BindAnalogInputEvent::InOnAnalogInput' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindAnalogInputEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindAnalogInputEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindGestureEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindGestureEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnGesture;                             // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindGestureEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindGestureEvent");
static_assert(sizeof(X6InputProcessorHelper_BindGestureEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindGestureEvent");
static_assert(offsetof(X6InputProcessorHelper_BindGestureEvent, InOnGesture) == 0x000000, "Member 'X6InputProcessorHelper_BindGestureEvent::InOnGesture' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindGestureEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindGestureEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindInputDeviceEvent
// 0x0010 (0x0010 - 0x0000)
struct X6InputProcessorHelper_BindInputDeviceEvent final
{
public:
	TDelegate<void(EX6InputDeviceKeyType InputDeviceKeyType)> InOnInputDevice;                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindInputDeviceEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindInputDeviceEvent");
static_assert(sizeof(X6InputProcessorHelper_BindInputDeviceEvent) == 0x000010, "Wrong size on X6InputProcessorHelper_BindInputDeviceEvent");
static_assert(offsetof(X6InputProcessorHelper_BindInputDeviceEvent, InOnInputDevice) == 0x000000, "Member 'X6InputProcessorHelper_BindInputDeviceEvent::InOnInputDevice' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindKeyDownEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindKeyDownEvent final
{
public:
	TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyDown;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindKeyDownEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindKeyDownEvent");
static_assert(sizeof(X6InputProcessorHelper_BindKeyDownEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindKeyDownEvent");
static_assert(offsetof(X6InputProcessorHelper_BindKeyDownEvent, InOnKeyDown) == 0x000000, "Member 'X6InputProcessorHelper_BindKeyDownEvent::InOnKeyDown' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindKeyDownEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindKeyDownEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindKeyUpEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindKeyUpEvent final
{
public:
	TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyUp;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindKeyUpEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindKeyUpEvent");
static_assert(sizeof(X6InputProcessorHelper_BindKeyUpEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindKeyUpEvent");
static_assert(offsetof(X6InputProcessorHelper_BindKeyUpEvent, InOnKeyUp) == 0x000000, "Member 'X6InputProcessorHelper_BindKeyUpEvent::InOnKeyUp' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindKeyUpEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindKeyUpEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindMotionDetectedEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindMotionDetectedEvent final
{
public:
	TDelegate<void(const struct FMotionEvent& MotionEvent)> InOnMotionDetected;                      // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindMotionDetectedEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindMotionDetectedEvent");
static_assert(sizeof(X6InputProcessorHelper_BindMotionDetectedEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindMotionDetectedEvent");
static_assert(offsetof(X6InputProcessorHelper_BindMotionDetectedEvent, InOnMotionDetected) == 0x000000, "Member 'X6InputProcessorHelper_BindMotionDetectedEvent::InOnMotionDetected' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindMotionDetectedEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindMotionDetectedEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindMouseButtonDoubleClickEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindMouseButtonDoubleClickEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDoubleClick;              // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindMouseButtonDoubleClickEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindMouseButtonDoubleClickEvent");
static_assert(sizeof(X6InputProcessorHelper_BindMouseButtonDoubleClickEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindMouseButtonDoubleClickEvent");
static_assert(offsetof(X6InputProcessorHelper_BindMouseButtonDoubleClickEvent, InOnMouseButtonDoubleClick) == 0x000000, "Member 'X6InputProcessorHelper_BindMouseButtonDoubleClickEvent::InOnMouseButtonDoubleClick' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindMouseButtonDoubleClickEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindMouseButtonDoubleClickEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindMouseButtonDownEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindMouseButtonDownEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDown;                     // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindMouseButtonDownEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindMouseButtonDownEvent");
static_assert(sizeof(X6InputProcessorHelper_BindMouseButtonDownEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindMouseButtonDownEvent");
static_assert(offsetof(X6InputProcessorHelper_BindMouseButtonDownEvent, InOnMouseButtonDown) == 0x000000, "Member 'X6InputProcessorHelper_BindMouseButtonDownEvent::InOnMouseButtonDown' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindMouseButtonDownEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindMouseButtonDownEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindMouseButtonUpEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindMouseButtonUpEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonUp;                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindMouseButtonUpEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindMouseButtonUpEvent");
static_assert(sizeof(X6InputProcessorHelper_BindMouseButtonUpEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindMouseButtonUpEvent");
static_assert(offsetof(X6InputProcessorHelper_BindMouseButtonUpEvent, InOnMouseButtonUp) == 0x000000, "Member 'X6InputProcessorHelper_BindMouseButtonUpEvent::InOnMouseButtonUp' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindMouseButtonUpEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindMouseButtonUpEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindMouseMoveEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindMouseMoveEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseMove;                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindMouseMoveEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindMouseMoveEvent");
static_assert(sizeof(X6InputProcessorHelper_BindMouseMoveEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindMouseMoveEvent");
static_assert(offsetof(X6InputProcessorHelper_BindMouseMoveEvent, InOnMouseMove) == 0x000000, "Member 'X6InputProcessorHelper_BindMouseMoveEvent::InOnMouseMove' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindMouseMoveEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindMouseMoveEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.BindMouseWheelEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_BindMouseWheelEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseWheel;                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_BindMouseWheelEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_BindMouseWheelEvent");
static_assert(sizeof(X6InputProcessorHelper_BindMouseWheelEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_BindMouseWheelEvent");
static_assert(offsetof(X6InputProcessorHelper_BindMouseWheelEvent, InOnMouseWheel) == 0x000000, "Member 'X6InputProcessorHelper_BindMouseWheelEvent::InOnMouseWheel' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_BindMouseWheelEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_BindMouseWheelEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.GetCurInputDeviceKeyType
// 0x0001 (0x0001 - 0x0000)
struct X6InputProcessorHelper_GetCurInputDeviceKeyType final
{
public:
	EX6InputDeviceKeyType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_GetCurInputDeviceKeyType) == 0x000001, "Wrong alignment on X6InputProcessorHelper_GetCurInputDeviceKeyType");
static_assert(sizeof(X6InputProcessorHelper_GetCurInputDeviceKeyType) == 0x000001, "Wrong size on X6InputProcessorHelper_GetCurInputDeviceKeyType");
static_assert(offsetof(X6InputProcessorHelper_GetCurInputDeviceKeyType, ReturnValue) == 0x000000, "Member 'X6InputProcessorHelper_GetCurInputDeviceKeyType::ReturnValue' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.GetMouseResponseDisabled
// 0x0001 (0x0001 - 0x0000)
struct X6InputProcessorHelper_GetMouseResponseDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_GetMouseResponseDisabled) == 0x000001, "Wrong alignment on X6InputProcessorHelper_GetMouseResponseDisabled");
static_assert(sizeof(X6InputProcessorHelper_GetMouseResponseDisabled) == 0x000001, "Wrong size on X6InputProcessorHelper_GetMouseResponseDisabled");
static_assert(offsetof(X6InputProcessorHelper_GetMouseResponseDisabled, ReturnValue) == 0x000000, "Member 'X6InputProcessorHelper_GetMouseResponseDisabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.SetInputDeviceIgnoreValue
// 0x0004 (0x0004 - 0x0000)
struct X6InputProcessorHelper_SetInputDeviceIgnoreValue final
{
public:
	float                                         InInputDeviceIgnoreValue;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_SetInputDeviceIgnoreValue) == 0x000004, "Wrong alignment on X6InputProcessorHelper_SetInputDeviceIgnoreValue");
static_assert(sizeof(X6InputProcessorHelper_SetInputDeviceIgnoreValue) == 0x000004, "Wrong size on X6InputProcessorHelper_SetInputDeviceIgnoreValue");
static_assert(offsetof(X6InputProcessorHelper_SetInputDeviceIgnoreValue, InInputDeviceIgnoreValue) == 0x000000, "Member 'X6InputProcessorHelper_SetInputDeviceIgnoreValue::InInputDeviceIgnoreValue' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.SetMouseResponseDisabled
// 0x0002 (0x0002 - 0x0000)
struct X6InputProcessorHelper_SetMouseResponseDisabled final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_SetMouseResponseDisabled) == 0x000001, "Wrong alignment on X6InputProcessorHelper_SetMouseResponseDisabled");
static_assert(sizeof(X6InputProcessorHelper_SetMouseResponseDisabled) == 0x000002, "Wrong size on X6InputProcessorHelper_SetMouseResponseDisabled");
static_assert(offsetof(X6InputProcessorHelper_SetMouseResponseDisabled, bDisable) == 0x000000, "Member 'X6InputProcessorHelper_SetMouseResponseDisabled::bDisable' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_SetMouseResponseDisabled, ReturnValue) == 0x000001, "Member 'X6InputProcessorHelper_SetMouseResponseDisabled::ReturnValue' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindAnalogInputEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindAnalogInputEvent final
{
public:
	TDelegate<void(const struct FAnalogInputEvent& AnalogInputEvent)> InOnAnalogInput;               // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindAnalogInputEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindAnalogInputEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindAnalogInputEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindAnalogInputEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindAnalogInputEvent, InOnAnalogInput) == 0x000000, "Member 'X6InputProcessorHelper_UnbindAnalogInputEvent::InOnAnalogInput' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindAnalogInputEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindAnalogInputEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindGestureEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindGestureEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnGesture;                             // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindGestureEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindGestureEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindGestureEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindGestureEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindGestureEvent, InOnGesture) == 0x000000, "Member 'X6InputProcessorHelper_UnbindGestureEvent::InOnGesture' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindGestureEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindGestureEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindInputDeviceEvent
// 0x0010 (0x0010 - 0x0000)
struct X6InputProcessorHelper_UnbindInputDeviceEvent final
{
public:
	TDelegate<void(EX6InputDeviceKeyType InputDeviceKeyType)> InOnInputDevice;                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindInputDeviceEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindInputDeviceEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindInputDeviceEvent) == 0x000010, "Wrong size on X6InputProcessorHelper_UnbindInputDeviceEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindInputDeviceEvent, InOnInputDevice) == 0x000000, "Member 'X6InputProcessorHelper_UnbindInputDeviceEvent::InOnInputDevice' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindKeyDownEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindKeyDownEvent final
{
public:
	TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyDown;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindKeyDownEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindKeyDownEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindKeyDownEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindKeyDownEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindKeyDownEvent, InOnKeyDown) == 0x000000, "Member 'X6InputProcessorHelper_UnbindKeyDownEvent::InOnKeyDown' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindKeyDownEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindKeyDownEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindKeyUpEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindKeyUpEvent final
{
public:
	TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyUp;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindKeyUpEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindKeyUpEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindKeyUpEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindKeyUpEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindKeyUpEvent, InOnKeyUp) == 0x000000, "Member 'X6InputProcessorHelper_UnbindKeyUpEvent::InOnKeyUp' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindKeyUpEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindKeyUpEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindMotionDetectedEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindMotionDetectedEvent final
{
public:
	TDelegate<void(const struct FMotionEvent& MotionEvent)> InOnMotionDetected;                      // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindMotionDetectedEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindMotionDetectedEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindMotionDetectedEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindMotionDetectedEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindMotionDetectedEvent, InOnMotionDetected) == 0x000000, "Member 'X6InputProcessorHelper_UnbindMotionDetectedEvent::InOnMotionDetected' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindMotionDetectedEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindMotionDetectedEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindMouseButtonDoubleClickEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDoubleClick;              // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent, InOnMouseButtonDoubleClick) == 0x000000, "Member 'X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent::InOnMouseButtonDoubleClick' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindMouseButtonDoubleClickEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindMouseButtonDownEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindMouseButtonDownEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDown;                     // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindMouseButtonDownEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindMouseButtonDownEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindMouseButtonDownEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindMouseButtonDownEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseButtonDownEvent, InOnMouseButtonDown) == 0x000000, "Member 'X6InputProcessorHelper_UnbindMouseButtonDownEvent::InOnMouseButtonDown' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseButtonDownEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindMouseButtonDownEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindMouseButtonUpEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindMouseButtonUpEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonUp;                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindMouseButtonUpEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindMouseButtonUpEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindMouseButtonUpEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindMouseButtonUpEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseButtonUpEvent, InOnMouseButtonUp) == 0x000000, "Member 'X6InputProcessorHelper_UnbindMouseButtonUpEvent::InOnMouseButtonUp' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseButtonUpEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindMouseButtonUpEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindMouseMoveEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindMouseMoveEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseMove;                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindMouseMoveEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindMouseMoveEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindMouseMoveEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindMouseMoveEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseMoveEvent, InOnMouseMove) == 0x000000, "Member 'X6InputProcessorHelper_UnbindMouseMoveEvent::InOnMouseMove' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseMoveEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindMouseMoveEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputProcessorHelper.UnbindMouseWheelEvent
// 0x0014 (0x0014 - 0x0000)
struct X6InputProcessorHelper_UnbindMouseWheelEvent final
{
public:
	TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseWheel;                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputProcessorHelper_UnbindMouseWheelEvent) == 0x000004, "Wrong alignment on X6InputProcessorHelper_UnbindMouseWheelEvent");
static_assert(sizeof(X6InputProcessorHelper_UnbindMouseWheelEvent) == 0x000014, "Wrong size on X6InputProcessorHelper_UnbindMouseWheelEvent");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseWheelEvent, InOnMouseWheel) == 0x000000, "Member 'X6InputProcessorHelper_UnbindMouseWheelEvent::InOnMouseWheel' has a wrong offset!");
static_assert(offsetof(X6InputProcessorHelper_UnbindMouseWheelEvent, InPriority) == 0x000010, "Member 'X6InputProcessorHelper_UnbindMouseWheelEvent::InPriority' has a wrong offset!");

// Function X6Game.X6InputTouchDelegateBinding.HandleInputTouch_0
// 0x0020 (0x0020 - 0x0000)
struct X6InputTouchDelegateBinding_HandleInputTouch_0 final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputTouchDelegateBinding_HandleInputTouch_0) == 0x000008, "Wrong alignment on X6InputTouchDelegateBinding_HandleInputTouch_0");
static_assert(sizeof(X6InputTouchDelegateBinding_HandleInputTouch_0) == 0x000020, "Wrong size on X6InputTouchDelegateBinding_HandleInputTouch_0");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_0, FingerIndex) == 0x000000, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_0::FingerIndex' has a wrong offset!");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_0, Location) == 0x000008, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_0::Location' has a wrong offset!");

// Function X6Game.X6InputTouchDelegateBinding.HandleInputTouch_1
// 0x0020 (0x0020 - 0x0000)
struct X6InputTouchDelegateBinding_HandleInputTouch_1 final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputTouchDelegateBinding_HandleInputTouch_1) == 0x000008, "Wrong alignment on X6InputTouchDelegateBinding_HandleInputTouch_1");
static_assert(sizeof(X6InputTouchDelegateBinding_HandleInputTouch_1) == 0x000020, "Wrong size on X6InputTouchDelegateBinding_HandleInputTouch_1");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_1, FingerIndex) == 0x000000, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_1::FingerIndex' has a wrong offset!");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_1, Location) == 0x000008, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_1::Location' has a wrong offset!");

// Function X6Game.X6InputTouchDelegateBinding.HandleInputTouch_2
// 0x0020 (0x0020 - 0x0000)
struct X6InputTouchDelegateBinding_HandleInputTouch_2 final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputTouchDelegateBinding_HandleInputTouch_2) == 0x000008, "Wrong alignment on X6InputTouchDelegateBinding_HandleInputTouch_2");
static_assert(sizeof(X6InputTouchDelegateBinding_HandleInputTouch_2) == 0x000020, "Wrong size on X6InputTouchDelegateBinding_HandleInputTouch_2");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_2, FingerIndex) == 0x000000, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_2::FingerIndex' has a wrong offset!");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_2, Location) == 0x000008, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_2::Location' has a wrong offset!");

// Function X6Game.X6InputTouchDelegateBinding.HandleInputTouch_3
// 0x0020 (0x0020 - 0x0000)
struct X6InputTouchDelegateBinding_HandleInputTouch_3 final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InputTouchDelegateBinding_HandleInputTouch_3) == 0x000008, "Wrong alignment on X6InputTouchDelegateBinding_HandleInputTouch_3");
static_assert(sizeof(X6InputTouchDelegateBinding_HandleInputTouch_3) == 0x000020, "Wrong size on X6InputTouchDelegateBinding_HandleInputTouch_3");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_3, FingerIndex) == 0x000000, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_3::FingerIndex' has a wrong offset!");
static_assert(offsetof(X6InputTouchDelegateBinding_HandleInputTouch_3, Location) == 0x000008, "Member 'X6InputTouchDelegateBinding_HandleInputTouch_3::Location' has a wrong offset!");

// Function X6Game.X6InteractiveActorComponent.BakeArrowsToSlot
// 0x0008 (0x0008 - 0x0000)
struct X6InteractiveActorComponent_BakeArrowsToSlot final
{
public:
	TSubclassOf<class UObject>                    ObjectClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InteractiveActorComponent_BakeArrowsToSlot) == 0x000008, "Wrong alignment on X6InteractiveActorComponent_BakeArrowsToSlot");
static_assert(sizeof(X6InteractiveActorComponent_BakeArrowsToSlot) == 0x000008, "Wrong size on X6InteractiveActorComponent_BakeArrowsToSlot");
static_assert(offsetof(X6InteractiveActorComponent_BakeArrowsToSlot, ObjectClass) == 0x000000, "Member 'X6InteractiveActorComponent_BakeArrowsToSlot::ObjectClass' has a wrong offset!");

// Function X6Game.X6InteractiveActorComponent.GetChatBubbleSlot
// 0x0030 (0x0030 - 0x0000)
struct X6InteractiveActorComponent_GetChatBubbleSlot final
{
public:
	struct FChatBubbleSlotDefinition              ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InteractiveActorComponent_GetChatBubbleSlot) == 0x000008, "Wrong alignment on X6InteractiveActorComponent_GetChatBubbleSlot");
static_assert(sizeof(X6InteractiveActorComponent_GetChatBubbleSlot) == 0x000030, "Wrong size on X6InteractiveActorComponent_GetChatBubbleSlot");
static_assert(offsetof(X6InteractiveActorComponent_GetChatBubbleSlot, ReturnValue) == 0x000000, "Member 'X6InteractiveActorComponent_GetChatBubbleSlot::ReturnValue' has a wrong offset!");

// Function X6Game.X6InteractiveActorComponent.GetNearestSlotIndex
// 0x0020 (0x0020 - 0x0000)
struct X6InteractiveActorComponent_GetNearestSlotIndex final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6InteractiveActorComponent_GetNearestSlotIndex) == 0x000008, "Wrong alignment on X6InteractiveActorComponent_GetNearestSlotIndex");
static_assert(sizeof(X6InteractiveActorComponent_GetNearestSlotIndex) == 0x000020, "Wrong size on X6InteractiveActorComponent_GetNearestSlotIndex");
static_assert(offsetof(X6InteractiveActorComponent_GetNearestSlotIndex, TargetLocation) == 0x000000, "Member 'X6InteractiveActorComponent_GetNearestSlotIndex::TargetLocation' has a wrong offset!");
static_assert(offsetof(X6InteractiveActorComponent_GetNearestSlotIndex, ReturnValue) == 0x000018, "Member 'X6InteractiveActorComponent_GetNearestSlotIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6InteractiveActorComponent.GetSlotTransform
// 0x0070 (0x0070 - 0x0000)
struct X6InteractiveActorComponent_GetSlotTransform final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6InteractiveActorComponent_GetSlotTransform) == 0x000010, "Wrong alignment on X6InteractiveActorComponent_GetSlotTransform");
static_assert(sizeof(X6InteractiveActorComponent_GetSlotTransform) == 0x000070, "Wrong size on X6InteractiveActorComponent_GetSlotTransform");
static_assert(offsetof(X6InteractiveActorComponent_GetSlotTransform, SlotIndex) == 0x000000, "Member 'X6InteractiveActorComponent_GetSlotTransform::SlotIndex' has a wrong offset!");
static_assert(offsetof(X6InteractiveActorComponent_GetSlotTransform, ReturnValue) == 0x000010, "Member 'X6InteractiveActorComponent_GetSlotTransform::ReturnValue' has a wrong offset!");

// Function X6Game.X6LevelSequencePreLoadObjectInterface.StartLoad
// 0x0020 (0x0020 - 0x0000)
struct X6LevelSequencePreLoadObjectInterface_StartLoad final
{
public:
	class FString                                 LevelSequenceName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLoadProperty>                  LoadProperties;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6LevelSequencePreLoadObjectInterface_StartLoad) == 0x000008, "Wrong alignment on X6LevelSequencePreLoadObjectInterface_StartLoad");
static_assert(sizeof(X6LevelSequencePreLoadObjectInterface_StartLoad) == 0x000020, "Wrong size on X6LevelSequencePreLoadObjectInterface_StartLoad");
static_assert(offsetof(X6LevelSequencePreLoadObjectInterface_StartLoad, LevelSequenceName) == 0x000000, "Member 'X6LevelSequencePreLoadObjectInterface_StartLoad::LevelSequenceName' has a wrong offset!");
static_assert(offsetof(X6LevelSequencePreLoadObjectInterface_StartLoad, LoadProperties) == 0x000010, "Member 'X6LevelSequencePreLoadObjectInterface_StartLoad::LoadProperties' has a wrong offset!");

// Function X6Game.X6LevelSequencePreLoadSectionInterface.StartLoad
// 0x0010 (0x0010 - 0x0000)
struct X6LevelSequencePreLoadSectionInterface_StartLoad final
{
public:
	class FString                                 LevelSequenceName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6LevelSequencePreLoadSectionInterface_StartLoad) == 0x000008, "Wrong alignment on X6LevelSequencePreLoadSectionInterface_StartLoad");
static_assert(sizeof(X6LevelSequencePreLoadSectionInterface_StartLoad) == 0x000010, "Wrong size on X6LevelSequencePreLoadSectionInterface_StartLoad");
static_assert(offsetof(X6LevelSequencePreLoadSectionInterface_StartLoad, LevelSequenceName) == 0x000000, "Member 'X6LevelSequencePreLoadSectionInterface_StartLoad::LevelSequenceName' has a wrong offset!");

// Function X6Game.X6UserObjectListEntry.OnListItemObjectSetViaIndex
// 0x0004 (0x0004 - 0x0000)
struct X6UserObjectListEntry_OnListItemObjectSetViaIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6UserObjectListEntry_OnListItemObjectSetViaIndex) == 0x000004, "Wrong alignment on X6UserObjectListEntry_OnListItemObjectSetViaIndex");
static_assert(sizeof(X6UserObjectListEntry_OnListItemObjectSetViaIndex) == 0x000004, "Wrong size on X6UserObjectListEntry_OnListItemObjectSetViaIndex");
static_assert(offsetof(X6UserObjectListEntry_OnListItemObjectSetViaIndex, Index_0) == 0x000000, "Member 'X6UserObjectListEntry_OnListItemObjectSetViaIndex::Index_0' has a wrong offset!");

// Function X6Game.X6UserObjectListEntry.OnListItemValueChangedViaIndex
// 0x0004 (0x0004 - 0x0000)
struct X6UserObjectListEntry_OnListItemValueChangedViaIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6UserObjectListEntry_OnListItemValueChangedViaIndex) == 0x000004, "Wrong alignment on X6UserObjectListEntry_OnListItemValueChangedViaIndex");
static_assert(sizeof(X6UserObjectListEntry_OnListItemValueChangedViaIndex) == 0x000004, "Wrong size on X6UserObjectListEntry_OnListItemValueChangedViaIndex");
static_assert(offsetof(X6UserObjectListEntry_OnListItemValueChangedViaIndex, Index_0) == 0x000000, "Member 'X6UserObjectListEntry_OnListItemValueChangedViaIndex::Index_0' has a wrong offset!");

// Function X6Game.X6ListView.BP_NavigateToItemIndex
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_BP_NavigateToItemIndex final
{
public:
	int32                                         ItemIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_BP_NavigateToItemIndex) == 0x000004, "Wrong alignment on X6ListView_BP_NavigateToItemIndex");
static_assert(sizeof(X6ListView_BP_NavigateToItemIndex) == 0x000004, "Wrong size on X6ListView_BP_NavigateToItemIndex");
static_assert(offsetof(X6ListView_BP_NavigateToItemIndex, ItemIndex) == 0x000000, "Member 'X6ListView_BP_NavigateToItemIndex::ItemIndex' has a wrong offset!");

// Function X6Game.X6ListView.BP_OnListItemValueChanged
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_BP_OnListItemValueChanged final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_BP_OnListItemValueChanged) == 0x000004, "Wrong alignment on X6ListView_BP_OnListItemValueChanged");
static_assert(sizeof(X6ListView_BP_OnListItemValueChanged) == 0x000004, "Wrong size on X6ListView_BP_OnListItemValueChanged");
static_assert(offsetof(X6ListView_BP_OnListItemValueChanged, Index_0) == 0x000000, "Member 'X6ListView_BP_OnListItemValueChanged::Index_0' has a wrong offset!");

// Function X6Game.X6ListView.BP_ScrollItemIndexIntoView
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_BP_ScrollItemIndexIntoView final
{
public:
	int32                                         ItemIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_BP_ScrollItemIndexIntoView) == 0x000004, "Wrong alignment on X6ListView_BP_ScrollItemIndexIntoView");
static_assert(sizeof(X6ListView_BP_ScrollItemIndexIntoView) == 0x000004, "Wrong size on X6ListView_BP_ScrollItemIndexIntoView");
static_assert(offsetof(X6ListView_BP_ScrollItemIndexIntoView, ItemIndex) == 0x000000, "Member 'X6ListView_BP_ScrollItemIndexIntoView::ItemIndex' has a wrong offset!");

// Function X6Game.X6ListView.BP_SetItemSelectionByIndex
// 0x0008 (0x0008 - 0x0000)
struct X6ListView_BP_SetItemSelectionByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ListView_BP_SetItemSelectionByIndex) == 0x000004, "Wrong alignment on X6ListView_BP_SetItemSelectionByIndex");
static_assert(sizeof(X6ListView_BP_SetItemSelectionByIndex) == 0x000008, "Wrong size on X6ListView_BP_SetItemSelectionByIndex");
static_assert(offsetof(X6ListView_BP_SetItemSelectionByIndex, Index_0) == 0x000000, "Member 'X6ListView_BP_SetItemSelectionByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6ListView_BP_SetItemSelectionByIndex, bSelected) == 0x000004, "Member 'X6ListView_BP_SetItemSelectionByIndex::bSelected' has a wrong offset!");

// Function X6Game.X6ListView.BP_SetListItemCount
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_BP_SetListItemCount final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_BP_SetListItemCount) == 0x000004, "Wrong alignment on X6ListView_BP_SetListItemCount");
static_assert(sizeof(X6ListView_BP_SetListItemCount) == 0x000004, "Wrong size on X6ListView_BP_SetListItemCount");
static_assert(offsetof(X6ListView_BP_SetListItemCount, Count) == 0x000000, "Member 'X6ListView_BP_SetListItemCount::Count' has a wrong offset!");

// Function X6Game.X6ListView.BP_SetSelectedItemByIndex
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_BP_SetSelectedItemByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_BP_SetSelectedItemByIndex) == 0x000004, "Wrong alignment on X6ListView_BP_SetSelectedItemByIndex");
static_assert(sizeof(X6ListView_BP_SetSelectedItemByIndex) == 0x000004, "Wrong size on X6ListView_BP_SetSelectedItemByIndex");
static_assert(offsetof(X6ListView_BP_SetSelectedItemByIndex, Index_0) == 0x000000, "Member 'X6ListView_BP_SetSelectedItemByIndex::Index_0' has a wrong offset!");

// Function X6Game.X6ListView.RemoveItemByIndex
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_RemoveItemByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_RemoveItemByIndex) == 0x000004, "Wrong alignment on X6ListView_RemoveItemByIndex");
static_assert(sizeof(X6ListView_RemoveItemByIndex) == 0x000004, "Wrong size on X6ListView_RemoveItemByIndex");
static_assert(offsetof(X6ListView_RemoveItemByIndex, Index_0) == 0x000000, "Member 'X6ListView_RemoveItemByIndex::Index_0' has a wrong offset!");

// Function X6Game.X6ListView.SetOverriddenItemLength
// 0x0010 (0x0010 - 0x0000)
struct X6ListView_SetOverriddenItemLength final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Value;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_SetOverriddenItemLength) == 0x000008, "Wrong alignment on X6ListView_SetOverriddenItemLength");
static_assert(sizeof(X6ListView_SetOverriddenItemLength) == 0x000010, "Wrong size on X6ListView_SetOverriddenItemLength");
static_assert(offsetof(X6ListView_SetOverriddenItemLength, Index_0) == 0x000000, "Member 'X6ListView_SetOverriddenItemLength::Index_0' has a wrong offset!");
static_assert(offsetof(X6ListView_SetOverriddenItemLength, Value) == 0x000008, "Member 'X6ListView_SetOverriddenItemLength::Value' has a wrong offset!");

// Function X6Game.X6ListView.SetOverriddenItemLengthByArray
// 0x0018 (0x0018 - 0x0000)
struct X6ListView_SetOverriddenItemLengthByArray final
{
public:
	TArray<float>                                 ItemsLength;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bClearOldData;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ListView_SetOverriddenItemLengthByArray) == 0x000008, "Wrong alignment on X6ListView_SetOverriddenItemLengthByArray");
static_assert(sizeof(X6ListView_SetOverriddenItemLengthByArray) == 0x000018, "Wrong size on X6ListView_SetOverriddenItemLengthByArray");
static_assert(offsetof(X6ListView_SetOverriddenItemLengthByArray, ItemsLength) == 0x000000, "Member 'X6ListView_SetOverriddenItemLengthByArray::ItemsLength' has a wrong offset!");
static_assert(offsetof(X6ListView_SetOverriddenItemLengthByArray, bClearOldData) == 0x000010, "Member 'X6ListView_SetOverriddenItemLengthByArray::bClearOldData' has a wrong offset!");

// Function X6Game.X6ListView.SetOverriddenTotalLength
// 0x0008 (0x0008 - 0x0000)
struct X6ListView_SetOverriddenTotalLength final
{
public:
	double                                        TotalLength;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_SetOverriddenTotalLength) == 0x000008, "Wrong alignment on X6ListView_SetOverriddenTotalLength");
static_assert(sizeof(X6ListView_SetOverriddenTotalLength) == 0x000008, "Wrong size on X6ListView_SetOverriddenTotalLength");
static_assert(offsetof(X6ListView_SetOverriddenTotalLength, TotalLength) == 0x000000, "Member 'X6ListView_SetOverriddenTotalLength::TotalLength' has a wrong offset!");

// Function X6Game.X6ListView.SetScrollBarAlwaysVisible
// 0x0001 (0x0001 - 0x0000)
struct X6ListView_SetScrollBarAlwaysVisible final
{
public:
	bool                                          bAlwaysShowScrollbar;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_SetScrollBarAlwaysVisible) == 0x000001, "Wrong alignment on X6ListView_SetScrollBarAlwaysVisible");
static_assert(sizeof(X6ListView_SetScrollBarAlwaysVisible) == 0x000001, "Wrong size on X6ListView_SetScrollBarAlwaysVisible");
static_assert(offsetof(X6ListView_SetScrollBarAlwaysVisible, bAlwaysShowScrollbar) == 0x000000, "Member 'X6ListView_SetScrollBarAlwaysVisible::bAlwaysShowScrollbar' has a wrong offset!");

// Function X6Game.X6ListView.SetScrollBarTrackAlwaysVisible
// 0x0001 (0x0001 - 0x0000)
struct X6ListView_SetScrollBarTrackAlwaysVisible final
{
public:
	bool                                          bAlwaysShowScrollbarTrack;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_SetScrollBarTrackAlwaysVisible) == 0x000001, "Wrong alignment on X6ListView_SetScrollBarTrackAlwaysVisible");
static_assert(sizeof(X6ListView_SetScrollBarTrackAlwaysVisible) == 0x000001, "Wrong size on X6ListView_SetScrollBarTrackAlwaysVisible");
static_assert(offsetof(X6ListView_SetScrollBarTrackAlwaysVisible, bAlwaysShowScrollbarTrack) == 0x000000, "Member 'X6ListView_SetScrollBarTrackAlwaysVisible::bAlwaysShowScrollbarTrack' has a wrong offset!");

// Function X6Game.X6ListView.SetScrollSizeNotBaseOnNumLines
// 0x0001 (0x0001 - 0x0000)
struct X6ListView_SetScrollSizeNotBaseOnNumLines final
{
public:
	bool                                          bNotBaseOnNumLines;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_SetScrollSizeNotBaseOnNumLines) == 0x000001, "Wrong alignment on X6ListView_SetScrollSizeNotBaseOnNumLines");
static_assert(sizeof(X6ListView_SetScrollSizeNotBaseOnNumLines) == 0x000001, "Wrong size on X6ListView_SetScrollSizeNotBaseOnNumLines");
static_assert(offsetof(X6ListView_SetScrollSizeNotBaseOnNumLines, bNotBaseOnNumLines) == 0x000000, "Member 'X6ListView_SetScrollSizeNotBaseOnNumLines::bNotBaseOnNumLines' has a wrong offset!");

// Function X6Game.X6ListView.BP_GetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_BP_GetSelectedIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_BP_GetSelectedIndex) == 0x000004, "Wrong alignment on X6ListView_BP_GetSelectedIndex");
static_assert(sizeof(X6ListView_BP_GetSelectedIndex) == 0x000004, "Wrong size on X6ListView_BP_GetSelectedIndex");
static_assert(offsetof(X6ListView_BP_GetSelectedIndex, ReturnValue) == 0x000000, "Member 'X6ListView_BP_GetSelectedIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6ListView.BP_GetSelectedItemsViaIndex
// 0x0018 (0x0018 - 0x0000)
struct X6ListView_BP_GetSelectedItemsViaIndex final
{
public:
	TArray<int32>                                 Items;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ListView_BP_GetSelectedItemsViaIndex) == 0x000008, "Wrong alignment on X6ListView_BP_GetSelectedItemsViaIndex");
static_assert(sizeof(X6ListView_BP_GetSelectedItemsViaIndex) == 0x000018, "Wrong size on X6ListView_BP_GetSelectedItemsViaIndex");
static_assert(offsetof(X6ListView_BP_GetSelectedItemsViaIndex, Items) == 0x000000, "Member 'X6ListView_BP_GetSelectedItemsViaIndex::Items' has a wrong offset!");
static_assert(offsetof(X6ListView_BP_GetSelectedItemsViaIndex, ReturnValue) == 0x000010, "Member 'X6ListView_BP_GetSelectedItemsViaIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6ListView.BP_IsItemVisibleByIndex
// 0x0008 (0x0008 - 0x0000)
struct X6ListView_BP_IsItemVisibleByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ListView_BP_IsItemVisibleByIndex) == 0x000004, "Wrong alignment on X6ListView_BP_IsItemVisibleByIndex");
static_assert(sizeof(X6ListView_BP_IsItemVisibleByIndex) == 0x000008, "Wrong size on X6ListView_BP_IsItemVisibleByIndex");
static_assert(offsetof(X6ListView_BP_IsItemVisibleByIndex, Index_0) == 0x000000, "Member 'X6ListView_BP_IsItemVisibleByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6ListView_BP_IsItemVisibleByIndex, ReturnValue) == 0x000004, "Member 'X6ListView_BP_IsItemVisibleByIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6ListView.GetScrollDistance
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_GetScrollDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_GetScrollDistance) == 0x000004, "Wrong alignment on X6ListView_GetScrollDistance");
static_assert(sizeof(X6ListView_GetScrollDistance) == 0x000004, "Wrong size on X6ListView_GetScrollDistance");
static_assert(offsetof(X6ListView_GetScrollDistance, ReturnValue) == 0x000000, "Member 'X6ListView_GetScrollDistance::ReturnValue' has a wrong offset!");

// Function X6Game.X6ListView.GetScrollDistanceRemaining
// 0x0004 (0x0004 - 0x0000)
struct X6ListView_GetScrollDistanceRemaining final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ListView_GetScrollDistanceRemaining) == 0x000004, "Wrong alignment on X6ListView_GetScrollDistanceRemaining");
static_assert(sizeof(X6ListView_GetScrollDistanceRemaining) == 0x000004, "Wrong size on X6ListView_GetScrollDistanceRemaining");
static_assert(offsetof(X6ListView_GetScrollDistanceRemaining, ReturnValue) == 0x000000, "Member 'X6ListView_GetScrollDistanceRemaining::ReturnValue' has a wrong offset!");

// Function X6Game.X6LocalizationSettings.GetX6LocalizationSettings
// 0x0008 (0x0008 - 0x0000)
struct X6LocalizationSettings_GetX6LocalizationSettings final
{
public:
	const class UX6LocalizationSettings*          ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6LocalizationSettings_GetX6LocalizationSettings) == 0x000008, "Wrong alignment on X6LocalizationSettings_GetX6LocalizationSettings");
static_assert(sizeof(X6LocalizationSettings_GetX6LocalizationSettings) == 0x000008, "Wrong size on X6LocalizationSettings_GetX6LocalizationSettings");
static_assert(offsetof(X6LocalizationSettings_GetX6LocalizationSettings, ReturnValue) == 0x000000, "Member 'X6LocalizationSettings_GetX6LocalizationSettings::ReturnValue' has a wrong offset!");

// Function X6Game.X6MapHudBase.NT_OnPostMoveContentPosition
// 0x0010 (0x0010 - 0x0000)
struct X6MapHudBase_NT_OnPostMoveContentPosition final
{
public:
	struct FVector2D                              Pos;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MapHudBase_NT_OnPostMoveContentPosition) == 0x000008, "Wrong alignment on X6MapHudBase_NT_OnPostMoveContentPosition");
static_assert(sizeof(X6MapHudBase_NT_OnPostMoveContentPosition) == 0x000010, "Wrong size on X6MapHudBase_NT_OnPostMoveContentPosition");
static_assert(offsetof(X6MapHudBase_NT_OnPostMoveContentPosition, Pos) == 0x000000, "Member 'X6MapHudBase_NT_OnPostMoveContentPosition::Pos' has a wrong offset!");

// Function X6Game.X6MapHudBase.NT_SetMoveContentPosition
// 0x0010 (0x0010 - 0x0000)
struct X6MapHudBase_NT_SetMoveContentPosition final
{
public:
	struct FVector2D                              Pos;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MapHudBase_NT_SetMoveContentPosition) == 0x000008, "Wrong alignment on X6MapHudBase_NT_SetMoveContentPosition");
static_assert(sizeof(X6MapHudBase_NT_SetMoveContentPosition) == 0x000010, "Wrong size on X6MapHudBase_NT_SetMoveContentPosition");
static_assert(offsetof(X6MapHudBase_NT_SetMoveContentPosition, Pos) == 0x000000, "Member 'X6MapHudBase_NT_SetMoveContentPosition::Pos' has a wrong offset!");

// Function X6Game.X6MapHudBase.NT_UpdateMapRootConstraintInfo
// 0x0038 (0x0038 - 0x0000)
struct X6MapHudBase_NT_UpdateMapRootConstraintInfo final
{
public:
	struct FGeometry                              Geometry;                                          // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MapHudBase_NT_UpdateMapRootConstraintInfo) == 0x000004, "Wrong alignment on X6MapHudBase_NT_UpdateMapRootConstraintInfo");
static_assert(sizeof(X6MapHudBase_NT_UpdateMapRootConstraintInfo) == 0x000038, "Wrong size on X6MapHudBase_NT_UpdateMapRootConstraintInfo");
static_assert(offsetof(X6MapHudBase_NT_UpdateMapRootConstraintInfo, Geometry) == 0x000000, "Member 'X6MapHudBase_NT_UpdateMapRootConstraintInfo::Geometry' has a wrong offset!");

// Function X6Game.X6MapHudBase.NT_ConstraintMoveRootPos
// 0x0020 (0x0020 - 0x0000)
struct X6MapHudBase_NT_ConstraintMoveRootPos final
{
public:
	struct FVector2D                              originPos;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MapHudBase_NT_ConstraintMoveRootPos) == 0x000008, "Wrong alignment on X6MapHudBase_NT_ConstraintMoveRootPos");
static_assert(sizeof(X6MapHudBase_NT_ConstraintMoveRootPos) == 0x000020, "Wrong size on X6MapHudBase_NT_ConstraintMoveRootPos");
static_assert(offsetof(X6MapHudBase_NT_ConstraintMoveRootPos, originPos) == 0x000000, "Member 'X6MapHudBase_NT_ConstraintMoveRootPos::originPos' has a wrong offset!");
static_assert(offsetof(X6MapHudBase_NT_ConstraintMoveRootPos, ReturnValue) == 0x000010, "Member 'X6MapHudBase_NT_ConstraintMoveRootPos::ReturnValue' has a wrong offset!");

// Function X6Game.X6MapHudBase.NT_ConvertMapPosToWindowPos
// 0x0020 (0x0020 - 0x0000)
struct X6MapHudBase_NT_ConvertMapPosToWindowPos final
{
public:
	struct FVector2D                              mapPos;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MapHudBase_NT_ConvertMapPosToWindowPos) == 0x000008, "Wrong alignment on X6MapHudBase_NT_ConvertMapPosToWindowPos");
static_assert(sizeof(X6MapHudBase_NT_ConvertMapPosToWindowPos) == 0x000020, "Wrong size on X6MapHudBase_NT_ConvertMapPosToWindowPos");
static_assert(offsetof(X6MapHudBase_NT_ConvertMapPosToWindowPos, mapPos) == 0x000000, "Member 'X6MapHudBase_NT_ConvertMapPosToWindowPos::mapPos' has a wrong offset!");
static_assert(offsetof(X6MapHudBase_NT_ConvertMapPosToWindowPos, ReturnValue) == 0x000010, "Member 'X6MapHudBase_NT_ConvertMapPosToWindowPos::ReturnValue' has a wrong offset!");

// Function X6Game.X6MapHudBase.NT_ConvertWindowPosToMapPos
// 0x0020 (0x0020 - 0x0000)
struct X6MapHudBase_NT_ConvertWindowPosToMapPos final
{
public:
	struct FVector2D                              windowPos;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MapHudBase_NT_ConvertWindowPosToMapPos) == 0x000008, "Wrong alignment on X6MapHudBase_NT_ConvertWindowPosToMapPos");
static_assert(sizeof(X6MapHudBase_NT_ConvertWindowPosToMapPos) == 0x000020, "Wrong size on X6MapHudBase_NT_ConvertWindowPosToMapPos");
static_assert(offsetof(X6MapHudBase_NT_ConvertWindowPosToMapPos, windowPos) == 0x000000, "Member 'X6MapHudBase_NT_ConvertWindowPosToMapPos::windowPos' has a wrong offset!");
static_assert(offsetof(X6MapHudBase_NT_ConvertWindowPosToMapPos, ReturnValue) == 0x000010, "Member 'X6MapHudBase_NT_ConvertWindowPosToMapPos::ReturnValue' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.GetPlayerShadowDecalProcessor
// 0x0008 (0x0008 - 0x0000)
struct X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor final
{
public:
	class UPlayerShadowDecalProcessor*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor) == 0x000008, "Wrong alignment on X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor");
static_assert(sizeof(X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor) == 0x000008, "Wrong size on X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor");
static_assert(offsetof(X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor, ReturnValue) == 0x000000, "Member 'X6ModularFeaturesContainerComp_GetPlayerShadowDecalProcessor::ReturnValue' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.K2_GetCurTargetShadowGroundDistance
// 0x0004 (0x0004 - 0x0000)
struct X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance) == 0x000004, "Wrong alignment on X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance");
static_assert(sizeof(X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance) == 0x000004, "Wrong size on X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance, ReturnValue) == 0x000000, "Member 'X6ModularFeaturesContainerComp_K2_GetCurTargetShadowGroundDistance::ReturnValue' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.K2_InitConfigInformation
// 0x0030 (0x0030 - 0x0000)
struct X6ModularFeaturesContainerComp_K2_InitConfigInformation final
{
public:
	float                                         MaxTraceDownHeight;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeight;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShadowDecalSize;                                   // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereTraceRadius;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve_ShadowDecalDistanceMappedToScale2D;          // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ModularFeaturesContainerComp_K2_InitConfigInformation) == 0x000008, "Wrong alignment on X6ModularFeaturesContainerComp_K2_InitConfigInformation");
static_assert(sizeof(X6ModularFeaturesContainerComp_K2_InitConfigInformation) == 0x000030, "Wrong size on X6ModularFeaturesContainerComp_K2_InitConfigInformation");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitConfigInformation, MaxTraceDownHeight) == 0x000000, "Member 'X6ModularFeaturesContainerComp_K2_InitConfigInformation::MaxTraceDownHeight' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitConfigInformation, MaxJumpHeight) == 0x000004, "Member 'X6ModularFeaturesContainerComp_K2_InitConfigInformation::MaxJumpHeight' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitConfigInformation, ShadowDecalSize) == 0x000008, "Member 'X6ModularFeaturesContainerComp_K2_InitConfigInformation::ShadowDecalSize' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitConfigInformation, SphereTraceRadius) == 0x000020, "Member 'X6ModularFeaturesContainerComp_K2_InitConfigInformation::SphereTraceRadius' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitConfigInformation, Curve_ShadowDecalDistanceMappedToScale2D) == 0x000028, "Member 'X6ModularFeaturesContainerComp_K2_InitConfigInformation::Curve_ShadowDecalDistanceMappedToScale2D' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.K2_InitShadowDynamicMIParam
// 0x0018 (0x0018 - 0x0000)
struct X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam final
{
public:
	class FName                                   OpacityParamName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlurWeightParamName;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScaleParamName;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam) == 0x000004, "Wrong alignment on X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam");
static_assert(sizeof(X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam) == 0x000018, "Wrong size on X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam, OpacityParamName) == 0x000000, "Member 'X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam::OpacityParamName' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam, BlurWeightParamName) == 0x000008, "Member 'X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam::BlurWeightParamName' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam, ScaleParamName) == 0x000010, "Member 'X6ModularFeaturesContainerComp_K2_InitShadowDynamicMIParam::ScaleParamName' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.K2_UpdateDecalMaterialInstanceParam
// 0x0018 (0x0018 - 0x0000)
struct X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ShadowDynamicMI;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam) == 0x000008, "Wrong alignment on X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam");
static_assert(sizeof(X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam) == 0x000018, "Wrong size on X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam, DeltaSeconds) == 0x000000, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam, OwnerCharacter) == 0x000008, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam, ShadowDynamicMI) == 0x000010, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDecalMaterialInstanceParam::ShadowDynamicMI' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.K2_UpdateDrawPlayerShadowDecal
// 0x0030 (0x0030 - 0x0000)
struct X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ShadowOnWaterPlaneMeshComp;                        // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal) == 0x000008, "Wrong alignment on X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal");
static_assert(sizeof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal) == 0x000030, "Wrong size on X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal, DeltaSeconds) == 0x000000, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal, OwnerCharacter) == 0x000008, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal, SkeletalMeshComponent) == 0x000010, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal, DecalComponent) == 0x000018, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal::DecalComponent' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal, ShadowOnWaterPlaneMeshComp) == 0x000020, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal::ShadowOnWaterPlaneMeshComp' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal, ReturnValue) == 0x000028, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal::ReturnValue' has a wrong offset!");

// Function X6Game.X6ModularFeaturesContainerComp.K2_UpdateDrawPlayerShadowDecal_Mobile
// 0x0030 (0x0030 - 0x0000)
struct X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CubeMeshComponent;                                 // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ShadowOnWaterPlaneMeshComp;                        // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile) == 0x000008, "Wrong alignment on X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile");
static_assert(sizeof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile) == 0x000030, "Wrong size on X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile, DeltaSeconds) == 0x000000, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile, OwnerCharacter) == 0x000008, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile, SkeletalMeshComponent) == 0x000010, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile, CubeMeshComponent) == 0x000018, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile::CubeMeshComponent' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile, ShadowOnWaterPlaneMeshComp) == 0x000020, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile::ShadowOnWaterPlaneMeshComp' has a wrong offset!");
static_assert(offsetof(X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile, ReturnValue) == 0x000028, "Member 'X6ModularFeaturesContainerComp_K2_UpdateDrawPlayerShadowDecal_Mobile::ReturnValue' has a wrong offset!");

// Function X6Game.X6MonsterAnimInstance.PostOwnerBeginPlay
// 0x0008 (0x0008 - 0x0000)
struct X6MonsterAnimInstance_PostOwnerBeginPlay final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MonsterAnimInstance_PostOwnerBeginPlay) == 0x000008, "Wrong alignment on X6MonsterAnimInstance_PostOwnerBeginPlay");
static_assert(sizeof(X6MonsterAnimInstance_PostOwnerBeginPlay) == 0x000008, "Wrong size on X6MonsterAnimInstance_PostOwnerBeginPlay");
static_assert(offsetof(X6MonsterAnimInstance_PostOwnerBeginPlay, OwnerActor) == 0x000000, "Member 'X6MonsterAnimInstance_PostOwnerBeginPlay::OwnerActor' has a wrong offset!");

// Function X6Game.X6MultiLineEditableText.SetTextWithCursorStay
// 0x0010 (0x0010 - 0x0000)
struct X6MultiLineEditableText_SetTextWithCursorStay final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiLineEditableText_SetTextWithCursorStay) == 0x000008, "Wrong alignment on X6MultiLineEditableText_SetTextWithCursorStay");
static_assert(sizeof(X6MultiLineEditableText_SetTextWithCursorStay) == 0x000010, "Wrong size on X6MultiLineEditableText_SetTextWithCursorStay");
static_assert(offsetof(X6MultiLineEditableText_SetTextWithCursorStay, InText) == 0x000000, "Member 'X6MultiLineEditableText_SetTextWithCursorStay::InText' has a wrong offset!");

// Function X6Game.X6MultiLineEditableText.IsComposing
// 0x0001 (0x0001 - 0x0000)
struct X6MultiLineEditableText_IsComposing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6MultiLineEditableText_IsComposing) == 0x000001, "Wrong alignment on X6MultiLineEditableText_IsComposing");
static_assert(sizeof(X6MultiLineEditableText_IsComposing) == 0x000001, "Wrong size on X6MultiLineEditableText_IsComposing");
static_assert(offsetof(X6MultiLineEditableText_IsComposing, ReturnValue) == 0x000000, "Member 'X6MultiLineEditableText_IsComposing::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationRegionComponent.UpdateRegionBounds
// 0x0030 (0x0030 - 0x0000)
struct X6NavigationRegionComponent_UpdateRegionBounds final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationRegionComponent_UpdateRegionBounds) == 0x000008, "Wrong alignment on X6NavigationRegionComponent_UpdateRegionBounds");
static_assert(sizeof(X6NavigationRegionComponent_UpdateRegionBounds) == 0x000030, "Wrong size on X6NavigationRegionComponent_UpdateRegionBounds");
static_assert(offsetof(X6NavigationRegionComponent_UpdateRegionBounds, Center) == 0x000000, "Member 'X6NavigationRegionComponent_UpdateRegionBounds::Center' has a wrong offset!");
static_assert(offsetof(X6NavigationRegionComponent_UpdateRegionBounds, Extent) == 0x000018, "Member 'X6NavigationRegionComponent_UpdateRegionBounds::Extent' has a wrong offset!");

// Function X6Game.X6NavigationRegionComponent.UpdateRegionFlag
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationRegionComponent_UpdateRegionFlag final
{
public:
	int32                                         InRegionFlag;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationRegionComponent_UpdateRegionFlag) == 0x000004, "Wrong alignment on X6NavigationRegionComponent_UpdateRegionFlag");
static_assert(sizeof(X6NavigationRegionComponent_UpdateRegionFlag) == 0x000004, "Wrong size on X6NavigationRegionComponent_UpdateRegionFlag");
static_assert(offsetof(X6NavigationRegionComponent_UpdateRegionFlag, InRegionFlag) == 0x000000, "Member 'X6NavigationRegionComponent_UpdateRegionFlag::InRegionFlag' has a wrong offset!");

// Function X6Game.X6NavigationRegionComponent.UpdateRegionPassableState
// 0x0001 (0x0001 - 0x0000)
struct X6NavigationRegionComponent_UpdateRegionPassableState final
{
public:
	bool                                          bPassable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationRegionComponent_UpdateRegionPassableState) == 0x000001, "Wrong alignment on X6NavigationRegionComponent_UpdateRegionPassableState");
static_assert(sizeof(X6NavigationRegionComponent_UpdateRegionPassableState) == 0x000001, "Wrong size on X6NavigationRegionComponent_UpdateRegionPassableState");
static_assert(offsetof(X6NavigationRegionComponent_UpdateRegionPassableState, bPassable) == 0x000000, "Member 'X6NavigationRegionComponent_UpdateRegionPassableState::bPassable' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.AddPathPoint
// 0x0018 (0x0018 - 0x0000)
struct X6NavigationPathPoints_AddPathPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_AddPathPoint) == 0x000008, "Wrong alignment on X6NavigationPathPoints_AddPathPoint");
static_assert(sizeof(X6NavigationPathPoints_AddPathPoint) == 0x000018, "Wrong size on X6NavigationPathPoints_AddPathPoint");
static_assert(offsetof(X6NavigationPathPoints_AddPathPoint, Location) == 0x000000, "Member 'X6NavigationPathPoints_AddPathPoint::Location' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.InsertPathPoint
// 0x0020 (0x0020 - 0x0000)
struct X6NavigationPathPoints_InsertPathPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationPathPoints_InsertPathPoint) == 0x000008, "Wrong alignment on X6NavigationPathPoints_InsertPathPoint");
static_assert(sizeof(X6NavigationPathPoints_InsertPathPoint) == 0x000020, "Wrong size on X6NavigationPathPoints_InsertPathPoint");
static_assert(offsetof(X6NavigationPathPoints_InsertPathPoint, Location) == 0x000000, "Member 'X6NavigationPathPoints_InsertPathPoint::Location' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_InsertPathPoint, Index_0) == 0x000018, "Member 'X6NavigationPathPoints_InsertPathPoint::Index_0' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.RemoveAgentPassedPoints
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationPathPoints_RemoveAgentPassedPoints final
{
public:
	const class AAIController*                    Controller;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_RemoveAgentPassedPoints) == 0x000008, "Wrong alignment on X6NavigationPathPoints_RemoveAgentPassedPoints");
static_assert(sizeof(X6NavigationPathPoints_RemoveAgentPassedPoints) == 0x000008, "Wrong size on X6NavigationPathPoints_RemoveAgentPassedPoints");
static_assert(offsetof(X6NavigationPathPoints_RemoveAgentPassedPoints, Controller) == 0x000000, "Member 'X6NavigationPathPoints_RemoveAgentPassedPoints::Controller' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.RemovePassedPoints
// 0x0018 (0x0018 - 0x0000)
struct X6NavigationPathPoints_RemovePassedPoints final
{
public:
	struct FVector                                CurrentLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_RemovePassedPoints) == 0x000008, "Wrong alignment on X6NavigationPathPoints_RemovePassedPoints");
static_assert(sizeof(X6NavigationPathPoints_RemovePassedPoints) == 0x000018, "Wrong size on X6NavigationPathPoints_RemovePassedPoints");
static_assert(offsetof(X6NavigationPathPoints_RemovePassedPoints, CurrentLocation) == 0x000000, "Member 'X6NavigationPathPoints_RemovePassedPoints::CurrentLocation' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.RemovePathPoint
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationPathPoints_RemovePathPoint final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_RemovePathPoint) == 0x000004, "Wrong alignment on X6NavigationPathPoints_RemovePathPoint");
static_assert(sizeof(X6NavigationPathPoints_RemovePathPoint) == 0x000004, "Wrong size on X6NavigationPathPoints_RemovePathPoint");
static_assert(offsetof(X6NavigationPathPoints_RemovePathPoint, Index_0) == 0x000000, "Member 'X6NavigationPathPoints_RemovePathPoint::Index_0' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.ResetPathPointsHeight
// 0x0004 (0x0004 - 0x0000)
struct X6NavigationPathPoints_ResetPathPointsHeight final
{
public:
	float                                         NewHeight;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_ResetPathPointsHeight) == 0x000004, "Wrong alignment on X6NavigationPathPoints_ResetPathPointsHeight");
static_assert(sizeof(X6NavigationPathPoints_ResetPathPointsHeight) == 0x000004, "Wrong size on X6NavigationPathPoints_ResetPathPointsHeight");
static_assert(offsetof(X6NavigationPathPoints_ResetPathPointsHeight, NewHeight) == 0x000000, "Member 'X6NavigationPathPoints_ResetPathPointsHeight::NewHeight' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.DrawDebugPath
// 0x0064 (0x0064 - 0x0000)
struct X6NavigationPathPoints_DrawDebugPath final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NormalPathColor;                                   // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RoadPathColor;                                     // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RoadTransactionColor;                              // 0x0024(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RoadNodeColor;                                     // 0x0034(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StartSegmentColor;                                 // 0x0044(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EndSegmentColor;                                   // 0x0054(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_DrawDebugPath) == 0x000004, "Wrong alignment on X6NavigationPathPoints_DrawDebugPath");
static_assert(sizeof(X6NavigationPathPoints_DrawDebugPath) == 0x000064, "Wrong size on X6NavigationPathPoints_DrawDebugPath");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, Duration) == 0x000000, "Member 'X6NavigationPathPoints_DrawDebugPath::Duration' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, NormalPathColor) == 0x000004, "Member 'X6NavigationPathPoints_DrawDebugPath::NormalPathColor' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, RoadPathColor) == 0x000014, "Member 'X6NavigationPathPoints_DrawDebugPath::RoadPathColor' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, RoadTransactionColor) == 0x000024, "Member 'X6NavigationPathPoints_DrawDebugPath::RoadTransactionColor' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, RoadNodeColor) == 0x000034, "Member 'X6NavigationPathPoints_DrawDebugPath::RoadNodeColor' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, StartSegmentColor) == 0x000044, "Member 'X6NavigationPathPoints_DrawDebugPath::StartSegmentColor' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_DrawDebugPath, EndSegmentColor) == 0x000054, "Member 'X6NavigationPathPoints_DrawDebugPath::EndSegmentColor' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.IsGeneratedRoadPoint
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationPathPoints_IsGeneratedRoadPoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationPathPoints_IsGeneratedRoadPoint) == 0x000004, "Wrong alignment on X6NavigationPathPoints_IsGeneratedRoadPoint");
static_assert(sizeof(X6NavigationPathPoints_IsGeneratedRoadPoint) == 0x000008, "Wrong size on X6NavigationPathPoints_IsGeneratedRoadPoint");
static_assert(offsetof(X6NavigationPathPoints_IsGeneratedRoadPoint, PointIndex) == 0x000000, "Member 'X6NavigationPathPoints_IsGeneratedRoadPoint::PointIndex' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_IsGeneratedRoadPoint, ReturnValue) == 0x000004, "Member 'X6NavigationPathPoints_IsGeneratedRoadPoint::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.IsNavLink
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationPathPoints_IsNavLink final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationPathPoints_IsNavLink) == 0x000004, "Wrong alignment on X6NavigationPathPoints_IsNavLink");
static_assert(sizeof(X6NavigationPathPoints_IsNavLink) == 0x000008, "Wrong size on X6NavigationPathPoints_IsNavLink");
static_assert(offsetof(X6NavigationPathPoints_IsNavLink, PointIndex) == 0x000000, "Member 'X6NavigationPathPoints_IsNavLink::PointIndex' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_IsNavLink, ReturnValue) == 0x000004, "Member 'X6NavigationPathPoints_IsNavLink::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.IsRoadPoint
// 0x0008 (0x0008 - 0x0000)
struct X6NavigationPathPoints_IsRoadPoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NavigationPathPoints_IsRoadPoint) == 0x000004, "Wrong alignment on X6NavigationPathPoints_IsRoadPoint");
static_assert(sizeof(X6NavigationPathPoints_IsRoadPoint) == 0x000008, "Wrong size on X6NavigationPathPoints_IsRoadPoint");
static_assert(offsetof(X6NavigationPathPoints_IsRoadPoint, PointIndex) == 0x000000, "Member 'X6NavigationPathPoints_IsRoadPoint::PointIndex' has a wrong offset!");
static_assert(offsetof(X6NavigationPathPoints_IsRoadPoint, ReturnValue) == 0x000004, "Member 'X6NavigationPathPoints_IsRoadPoint::ReturnValue' has a wrong offset!");

// Function X6Game.X6NavigationPathPoints.IsValidPath
// 0x0001 (0x0001 - 0x0000)
struct X6NavigationPathPoints_IsValidPath final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NavigationPathPoints_IsValidPath) == 0x000001, "Wrong alignment on X6NavigationPathPoints_IsValidPath");
static_assert(sizeof(X6NavigationPathPoints_IsValidPath) == 0x000001, "Wrong size on X6NavigationPathPoints_IsValidPath");
static_assert(offsetof(X6NavigationPathPoints_IsValidPath, ReturnValue) == 0x000000, "Member 'X6NavigationPathPoints_IsValidPath::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiCPPTickHelperComponent.CalculateCurFloorAngleV2
// 0x0008 (0x0008 - 0x0000)
struct X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2 final
{
public:
	bool                                          bForceUpdate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2) == 0x000004, "Wrong alignment on X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2");
static_assert(sizeof(X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2) == 0x000008, "Wrong size on X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2, bForceUpdate) == 0x000000, "Member 'X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2::bForceUpdate' has a wrong offset!");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2, ReturnValue) == 0x000004, "Member 'X6NikkiCPPTickHelperComponent_CalculateCurFloorAngleV2::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiCPPTickHelperComponent.GeneratedFeetIKFeatureTargetV2
// 0x00A0 (0x00A0 - 0x0000)
struct X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2 final
{
public:
	struct FFootIKFeatureTargetDataV2             OutFootIKFeatureTarget;                            // 0x0000(0x00A0)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2) == 0x000008, "Wrong alignment on X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2");
static_assert(sizeof(X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2) == 0x0000A0, "Wrong size on X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2, OutFootIKFeatureTarget) == 0x000000, "Member 'X6NikkiCPPTickHelperComponent_GeneratedFeetIKFeatureTargetV2::OutFootIKFeatureTarget' has a wrong offset!");

// Function X6Game.X6NikkiCPPTickHelperComponent.IsLandedGroundWithDeltaInAir
// 0x00F8 (0x00F8 - 0x0000)
struct X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir final
{
public:
	struct FHitResult                             ReturnValue;                                       // 0x0000(0x00F8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir) == 0x000008, "Wrong alignment on X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir");
static_assert(sizeof(X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir) == 0x0000F8, "Wrong size on X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir, ReturnValue) == 0x000000, "Member 'X6NikkiCPPTickHelperComponent_IsLandedGroundWithDeltaInAir::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiCPPTickHelperComponent.ResetIKOffsets
// 0x0060 (0x0060 - 0x0000)
struct X6NikkiCPPTickHelperComponent_ResetIKOffsets final
{
public:
	struct FVector                                FootOffsetLLocation;                               // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootOffsetRLocation;                               // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootOffsetLRotation;                               // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FootOffsetRRotation;                               // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiCPPTickHelperComponent_ResetIKOffsets) == 0x000008, "Wrong alignment on X6NikkiCPPTickHelperComponent_ResetIKOffsets");
static_assert(sizeof(X6NikkiCPPTickHelperComponent_ResetIKOffsets) == 0x000060, "Wrong size on X6NikkiCPPTickHelperComponent_ResetIKOffsets");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_ResetIKOffsets, FootOffsetLLocation) == 0x000000, "Member 'X6NikkiCPPTickHelperComponent_ResetIKOffsets::FootOffsetLLocation' has a wrong offset!");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_ResetIKOffsets, FootOffsetRLocation) == 0x000018, "Member 'X6NikkiCPPTickHelperComponent_ResetIKOffsets::FootOffsetRLocation' has a wrong offset!");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_ResetIKOffsets, FootOffsetLRotation) == 0x000030, "Member 'X6NikkiCPPTickHelperComponent_ResetIKOffsets::FootOffsetLRotation' has a wrong offset!");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_ResetIKOffsets, FootOffsetRRotation) == 0x000048, "Member 'X6NikkiCPPTickHelperComponent_ResetIKOffsets::FootOffsetRRotation' has a wrong offset!");

// Function X6Game.X6NikkiCPPTickHelperComponent.ResetPelvisIKOffsets
// 0x0020 (0x0020 - 0x0000)
struct X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets final
{
public:
	float                                         PelvisAlpha;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PelvisOffset;                                      // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets) == 0x000008, "Wrong alignment on X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets");
static_assert(sizeof(X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets) == 0x000020, "Wrong size on X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets, PelvisAlpha) == 0x000000, "Member 'X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets::PelvisAlpha' has a wrong offset!");
static_assert(offsetof(X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets, PelvisOffset) == 0x000008, "Member 'X6NikkiCPPTickHelperComponent_ResetPelvisIKOffsets::PelvisOffset' has a wrong offset!");

// Function X6Game.X6NikkiMainAnimInstance.GetCurFootIKFeatureTargetData
// 0x00A0 (0x00A0 - 0x0000)
struct X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData final
{
public:
	struct FFootIKFeatureTargetDataV2             ReturnValue;                                       // 0x0000(0x00A0)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData) == 0x000008, "Wrong alignment on X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData");
static_assert(sizeof(X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData) == 0x0000A0, "Wrong size on X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData");
static_assert(offsetof(X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData, ReturnValue) == 0x000000, "Member 'X6NikkiMainAnimInstance_GetCurFootIKFeatureTargetData::ReturnValue' has a wrong offset!");

// Function X6Game.X6NikkiMainAnimInstance.PrepareInitializationData
// 0x0001 (0x0001 - 0x0000)
struct X6NikkiMainAnimInstance_PrepareInitializationData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NikkiMainAnimInstance_PrepareInitializationData) == 0x000001, "Wrong alignment on X6NikkiMainAnimInstance_PrepareInitializationData");
static_assert(sizeof(X6NikkiMainAnimInstance_PrepareInitializationData) == 0x000001, "Wrong size on X6NikkiMainAnimInstance_PrepareInitializationData");
static_assert(offsetof(X6NikkiMainAnimInstance_PrepareInitializationData, ReturnValue) == 0x000000, "Member 'X6NikkiMainAnimInstance_PrepareInitializationData::ReturnValue' has a wrong offset!");

// Function X6Game.X6NpcDataProcessor.InitFaceMaterialCurvesCheckParam
// 0x0020 (0x0020 - 0x0000)
struct X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam final
{
public:
	TArray<class FName>                           FaceMaterialCurvesArray;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         EnabledAngle;                                      // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCMainMeshTag;                                    // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam) == 0x000008, "Wrong alignment on X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam");
static_assert(sizeof(X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam) == 0x000020, "Wrong size on X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam");
static_assert(offsetof(X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam, FaceMaterialCurvesArray) == 0x000000, "Member 'X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam::FaceMaterialCurvesArray' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam, EnabledAngle) == 0x000010, "Member 'X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam::EnabledAngle' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam, NPCMainMeshTag) == 0x000014, "Member 'X6NpcDataProcessor_InitFaceMaterialCurvesCheckParam::NPCMainMeshTag' has a wrong offset!");

// Function X6Game.X6NpcDataProcessor.RegisterActorShouldCheckMaterialCurve
// 0x0010 (0x0010 - 0x0000)
struct X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve final
{
public:
	class AActor*                                 ActorShouldCheckMaterialCurve;                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve) == 0x000008, "Wrong alignment on X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve");
static_assert(sizeof(X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve) == 0x000010, "Wrong size on X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve");
static_assert(offsetof(X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve, ActorShouldCheckMaterialCurve) == 0x000000, "Member 'X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve::ActorShouldCheckMaterialCurve' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve, ReturnValue) == 0x000008, "Member 'X6NpcDataProcessor_RegisterActorShouldCheckMaterialCurve::ReturnValue' has a wrong offset!");

// Function X6Game.X6NpcDataProcessor.RegisterT2StaticNpcActors
// 0x0028 (0x0028 - 0x0000)
struct X6NpcDataProcessor_RegisterT2StaticNpcActors final
{
public:
	int64                                         SpawnerID;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GroupActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FT2NpcRadiusHalfHeightStruct>   T2NpcActors;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NpcDataProcessor_RegisterT2StaticNpcActors) == 0x000008, "Wrong alignment on X6NpcDataProcessor_RegisterT2StaticNpcActors");
static_assert(sizeof(X6NpcDataProcessor_RegisterT2StaticNpcActors) == 0x000028, "Wrong size on X6NpcDataProcessor_RegisterT2StaticNpcActors");
static_assert(offsetof(X6NpcDataProcessor_RegisterT2StaticNpcActors, SpawnerID) == 0x000000, "Member 'X6NpcDataProcessor_RegisterT2StaticNpcActors::SpawnerID' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_RegisterT2StaticNpcActors, GroupActor) == 0x000008, "Member 'X6NpcDataProcessor_RegisterT2StaticNpcActors::GroupActor' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_RegisterT2StaticNpcActors, T2NpcActors) == 0x000010, "Member 'X6NpcDataProcessor_RegisterT2StaticNpcActors::T2NpcActors' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_RegisterT2StaticNpcActors, ReturnValue) == 0x000020, "Member 'X6NpcDataProcessor_RegisterT2StaticNpcActors::ReturnValue' has a wrong offset!");

// Function X6Game.X6NpcDataProcessor.SetNpcMainMeshTag
// 0x0008 (0x0008 - 0x0000)
struct X6NpcDataProcessor_SetNpcMainMeshTag final
{
public:
	class FName                                   NPCMainMeshTag;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6NpcDataProcessor_SetNpcMainMeshTag) == 0x000004, "Wrong alignment on X6NpcDataProcessor_SetNpcMainMeshTag");
static_assert(sizeof(X6NpcDataProcessor_SetNpcMainMeshTag) == 0x000008, "Wrong size on X6NpcDataProcessor_SetNpcMainMeshTag");
static_assert(offsetof(X6NpcDataProcessor_SetNpcMainMeshTag, NPCMainMeshTag) == 0x000000, "Member 'X6NpcDataProcessor_SetNpcMainMeshTag::NPCMainMeshTag' has a wrong offset!");

// Function X6Game.X6NpcDataProcessor.UnregisterActorShouldCheckMaterialCurve
// 0x0010 (0x0010 - 0x0000)
struct X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve final
{
public:
	class AActor*                                 ActorShouldCheckMaterialCurve;                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve) == 0x000008, "Wrong alignment on X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve");
static_assert(sizeof(X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve) == 0x000010, "Wrong size on X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve");
static_assert(offsetof(X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve, ActorShouldCheckMaterialCurve) == 0x000000, "Member 'X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve::ActorShouldCheckMaterialCurve' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve, ReturnValue) == 0x000008, "Member 'X6NpcDataProcessor_UnregisterActorShouldCheckMaterialCurve::ReturnValue' has a wrong offset!");

// Function X6Game.X6NpcDataProcessor.UnregisterT2StaticNpcActors
// 0x0010 (0x0010 - 0x0000)
struct X6NpcDataProcessor_UnregisterT2StaticNpcActors final
{
public:
	int64                                         SpawnerID;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6NpcDataProcessor_UnregisterT2StaticNpcActors) == 0x000008, "Wrong alignment on X6NpcDataProcessor_UnregisterT2StaticNpcActors");
static_assert(sizeof(X6NpcDataProcessor_UnregisterT2StaticNpcActors) == 0x000010, "Wrong size on X6NpcDataProcessor_UnregisterT2StaticNpcActors");
static_assert(offsetof(X6NpcDataProcessor_UnregisterT2StaticNpcActors, SpawnerID) == 0x000000, "Member 'X6NpcDataProcessor_UnregisterT2StaticNpcActors::SpawnerID' has a wrong offset!");
static_assert(offsetof(X6NpcDataProcessor_UnregisterT2StaticNpcActors, ReturnValue) == 0x000008, "Member 'X6NpcDataProcessor_UnregisterT2StaticNpcActors::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.AddOctreeElement
// 0x00C0 (0x00C0 - 0x0000)
struct X6ObjectOctree_AddOctreeElement final
{
public:
	struct FX6OctreeElement                       inNewOctreeElement;                                // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_AddOctreeElement) == 0x000010, "Wrong alignment on X6ObjectOctree_AddOctreeElement");
static_assert(sizeof(X6ObjectOctree_AddOctreeElement) == 0x0000C0, "Wrong size on X6ObjectOctree_AddOctreeElement");
static_assert(offsetof(X6ObjectOctree_AddOctreeElement, inNewOctreeElement) == 0x000000, "Member 'X6ObjectOctree_AddOctreeElement::inNewOctreeElement' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_AddOctreeElement, ReturnValue) == 0x0000B0, "Member 'X6ObjectOctree_AddOctreeElement::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.AddOctreeElementByActor
// 0x0010 (0x0010 - 0x0000)
struct X6ObjectOctree_AddOctreeElementByActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_AddOctreeElementByActor) == 0x000008, "Wrong alignment on X6ObjectOctree_AddOctreeElementByActor");
static_assert(sizeof(X6ObjectOctree_AddOctreeElementByActor) == 0x000010, "Wrong size on X6ObjectOctree_AddOctreeElementByActor");
static_assert(offsetof(X6ObjectOctree_AddOctreeElementByActor, Actor) == 0x000000, "Member 'X6ObjectOctree_AddOctreeElementByActor::Actor' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_AddOctreeElementByActor, ReturnValue) == 0x000008, "Member 'X6ObjectOctree_AddOctreeElementByActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.GetActorsWithinBounds
// 0x0048 (0x0048 - 0x0000)
struct X6ObjectOctree_GetActorsWithinBounds final
{
public:
	struct FBoxSphereBounds                       BoundsQuery;                                       // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutResult;                                         // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectOctree_GetActorsWithinBounds) == 0x000008, "Wrong alignment on X6ObjectOctree_GetActorsWithinBounds");
static_assert(sizeof(X6ObjectOctree_GetActorsWithinBounds) == 0x000048, "Wrong size on X6ObjectOctree_GetActorsWithinBounds");
static_assert(offsetof(X6ObjectOctree_GetActorsWithinBounds, BoundsQuery) == 0x000000, "Member 'X6ObjectOctree_GetActorsWithinBounds::BoundsQuery' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetActorsWithinBounds, OutResult) == 0x000038, "Member 'X6ObjectOctree_GetActorsWithinBounds::OutResult' has a wrong offset!");

// Function X6Game.X6ObjectOctree.GetElementsWithinBounds
// 0x0048 (0x0048 - 0x0000)
struct X6ObjectOctree_GetElementsWithinBounds final
{
public:
	struct FBoxSphereBounds                       BoundsQuery;                                       // 0x0000(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FX6OctreeElement>               OutResult;                                         // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectOctree_GetElementsWithinBounds) == 0x000008, "Wrong alignment on X6ObjectOctree_GetElementsWithinBounds");
static_assert(sizeof(X6ObjectOctree_GetElementsWithinBounds) == 0x000048, "Wrong size on X6ObjectOctree_GetElementsWithinBounds");
static_assert(offsetof(X6ObjectOctree_GetElementsWithinBounds, BoundsQuery) == 0x000000, "Member 'X6ObjectOctree_GetElementsWithinBounds::BoundsQuery' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetElementsWithinBounds, OutResult) == 0x000038, "Member 'X6ObjectOctree_GetElementsWithinBounds::OutResult' has a wrong offset!");

// Function X6Game.X6ObjectOctree.GetOctreeBoundsByActor
// 0x0048 (0x0048 - 0x0000)
struct X6ObjectOctree_GetOctreeBoundsByActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       OutBounds;                                         // 0x0008(0x0038)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_GetOctreeBoundsByActor) == 0x000008, "Wrong alignment on X6ObjectOctree_GetOctreeBoundsByActor");
static_assert(sizeof(X6ObjectOctree_GetOctreeBoundsByActor) == 0x000048, "Wrong size on X6ObjectOctree_GetOctreeBoundsByActor");
static_assert(offsetof(X6ObjectOctree_GetOctreeBoundsByActor, Actor) == 0x000000, "Member 'X6ObjectOctree_GetOctreeBoundsByActor::Actor' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetOctreeBoundsByActor, OutBounds) == 0x000008, "Member 'X6ObjectOctree_GetOctreeBoundsByActor::OutBounds' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetOctreeBoundsByActor, ReturnValue) == 0x000040, "Member 'X6ObjectOctree_GetOctreeBoundsByActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.GetOctreeIdByActor
// 0x0018 (0x0018 - 0x0000)
struct X6ObjectOctree_GetOctreeIdByActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutNodeIndex;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutElemenetIndex;                                  // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_GetOctreeIdByActor) == 0x000008, "Wrong alignment on X6ObjectOctree_GetOctreeIdByActor");
static_assert(sizeof(X6ObjectOctree_GetOctreeIdByActor) == 0x000018, "Wrong size on X6ObjectOctree_GetOctreeIdByActor");
static_assert(offsetof(X6ObjectOctree_GetOctreeIdByActor, Actor) == 0x000000, "Member 'X6ObjectOctree_GetOctreeIdByActor::Actor' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetOctreeIdByActor, OutNodeIndex) == 0x000008, "Member 'X6ObjectOctree_GetOctreeIdByActor::OutNodeIndex' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetOctreeIdByActor, OutElemenetIndex) == 0x00000C, "Member 'X6ObjectOctree_GetOctreeIdByActor::OutElemenetIndex' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_GetOctreeIdByActor, ReturnValue) == 0x000010, "Member 'X6ObjectOctree_GetOctreeIdByActor::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.InitOctree
// 0x0030 (0x0030 - 0x0000)
struct X6ObjectOctree_InitOctree final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_InitOctree) == 0x000008, "Wrong alignment on X6ObjectOctree_InitOctree");
static_assert(sizeof(X6ObjectOctree_InitOctree) == 0x000030, "Wrong size on X6ObjectOctree_InitOctree");
static_assert(offsetof(X6ObjectOctree_InitOctree, Origin) == 0x000000, "Member 'X6ObjectOctree_InitOctree::Origin' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_InitOctree, Radius) == 0x000018, "Member 'X6ObjectOctree_InitOctree::Radius' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_InitOctree, Class_0) == 0x000020, "Member 'X6ObjectOctree_InitOctree::Class_0' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_InitOctree, ReturnValue) == 0x000028, "Member 'X6ObjectOctree_InitOctree::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.IsReady
// 0x0001 (0x0001 - 0x0000)
struct X6ObjectOctree_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectOctree_IsReady) == 0x000001, "Wrong alignment on X6ObjectOctree_IsReady");
static_assert(sizeof(X6ObjectOctree_IsReady) == 0x000001, "Wrong size on X6ObjectOctree_IsReady");
static_assert(offsetof(X6ObjectOctree_IsReady, ReturnValue) == 0x000000, "Member 'X6ObjectOctree_IsReady::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.ObserveMovableObjects
// 0x0018 (0x0018 - 0x0000)
struct X6ObjectOctree_ObserveMovableObjects final
{
public:
	TArray<class AActor*>                         MoveableActos;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_ObserveMovableObjects) == 0x000008, "Wrong alignment on X6ObjectOctree_ObserveMovableObjects");
static_assert(sizeof(X6ObjectOctree_ObserveMovableObjects) == 0x000018, "Wrong size on X6ObjectOctree_ObserveMovableObjects");
static_assert(offsetof(X6ObjectOctree_ObserveMovableObjects, MoveableActos) == 0x000000, "Member 'X6ObjectOctree_ObserveMovableObjects::MoveableActos' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_ObserveMovableObjects, ReturnValue) == 0x000010, "Member 'X6ObjectOctree_ObserveMovableObjects::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.PostActorEndPlay
// 0x0010 (0x0010 - 0x0000)
struct X6ObjectOctree_PostActorEndPlay final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_PostActorEndPlay) == 0x000008, "Wrong alignment on X6ObjectOctree_PostActorEndPlay");
static_assert(sizeof(X6ObjectOctree_PostActorEndPlay) == 0x000010, "Wrong size on X6ObjectOctree_PostActorEndPlay");
static_assert(offsetof(X6ObjectOctree_PostActorEndPlay, Actor) == 0x000000, "Member 'X6ObjectOctree_PostActorEndPlay::Actor' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_PostActorEndPlay, EndPlayReason) == 0x000008, "Member 'X6ObjectOctree_PostActorEndPlay::EndPlayReason' has a wrong offset!");

// Function X6Game.X6ObjectOctree.RemoveObservedMovableObjects
// 0x0018 (0x0018 - 0x0000)
struct X6ObjectOctree_RemoveObservedMovableObjects final
{
public:
	TArray<class AActor*>                         MoveableActos;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectOctree_RemoveObservedMovableObjects) == 0x000008, "Wrong alignment on X6ObjectOctree_RemoveObservedMovableObjects");
static_assert(sizeof(X6ObjectOctree_RemoveObservedMovableObjects) == 0x000018, "Wrong size on X6ObjectOctree_RemoveObservedMovableObjects");
static_assert(offsetof(X6ObjectOctree_RemoveObservedMovableObjects, MoveableActos) == 0x000000, "Member 'X6ObjectOctree_RemoveObservedMovableObjects::MoveableActos' has a wrong offset!");
static_assert(offsetof(X6ObjectOctree_RemoveObservedMovableObjects, ReturnValue) == 0x000010, "Member 'X6ObjectOctree_RemoveObservedMovableObjects::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectOctree.RemoveOctreeElement
// 0x00B0 (0x00B0 - 0x0000)
struct X6ObjectOctree_RemoveOctreeElement final
{
public:
	struct FX6OctreeElement                       inNewOctreeElement;                                // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectOctree_RemoveOctreeElement) == 0x000010, "Wrong alignment on X6ObjectOctree_RemoveOctreeElement");
static_assert(sizeof(X6ObjectOctree_RemoveOctreeElement) == 0x0000B0, "Wrong size on X6ObjectOctree_RemoveOctreeElement");
static_assert(offsetof(X6ObjectOctree_RemoveOctreeElement, inNewOctreeElement) == 0x000000, "Member 'X6ObjectOctree_RemoveOctreeElement::inNewOctreeElement' has a wrong offset!");

// Function X6Game.X6ObjectOctree.RemoveOctreeElementByActor
// 0x0008 (0x0008 - 0x0000)
struct X6ObjectOctree_RemoveOctreeElementByActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectOctree_RemoveOctreeElementByActor) == 0x000008, "Wrong alignment on X6ObjectOctree_RemoveOctreeElementByActor");
static_assert(sizeof(X6ObjectOctree_RemoveOctreeElementByActor) == 0x000008, "Wrong size on X6ObjectOctree_RemoveOctreeElementByActor");
static_assert(offsetof(X6ObjectOctree_RemoveOctreeElementByActor, Actor) == 0x000000, "Member 'X6ObjectOctree_RemoveOctreeElementByActor::Actor' has a wrong offset!");

// Function X6Game.X6ObjectOctree.SetEnableDebugDraw
// 0x0001 (0x0001 - 0x0000)
struct X6ObjectOctree_SetEnableDebugDraw final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectOctree_SetEnableDebugDraw) == 0x000001, "Wrong alignment on X6ObjectOctree_SetEnableDebugDraw");
static_assert(sizeof(X6ObjectOctree_SetEnableDebugDraw) == 0x000001, "Wrong size on X6ObjectOctree_SetEnableDebugDraw");
static_assert(offsetof(X6ObjectOctree_SetEnableDebugDraw, bEnable) == 0x000000, "Member 'X6ObjectOctree_SetEnableDebugDraw::bEnable' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.CleanUpPools
// 0x0001 (0x0001 - 0x0000)
struct X6ObjectPoolSubSystem_CleanUpPools final
{
public:
	bool                                          bTryCleanMoreObjects;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectPoolSubSystem_CleanUpPools) == 0x000001, "Wrong alignment on X6ObjectPoolSubSystem_CleanUpPools");
static_assert(sizeof(X6ObjectPoolSubSystem_CleanUpPools) == 0x000001, "Wrong size on X6ObjectPoolSubSystem_CleanUpPools");
static_assert(offsetof(X6ObjectPoolSubSystem_CleanUpPools, bTryCleanMoreObjects) == 0x000000, "Member 'X6ObjectPoolSubSystem_CleanUpPools::bTryCleanMoreObjects' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.CreatePoolByClass
// 0x0008 (0x0008 - 0x0000)
struct X6ObjectPoolSubSystem_CreatePoolByClass final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectPoolSubSystem_CreatePoolByClass) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_CreatePoolByClass");
static_assert(sizeof(X6ObjectPoolSubSystem_CreatePoolByClass) == 0x000008, "Wrong size on X6ObjectPoolSubSystem_CreatePoolByClass");
static_assert(offsetof(X6ObjectPoolSubSystem_CreatePoolByClass, InClass) == 0x000000, "Member 'X6ObjectPoolSubSystem_CreatePoolByClass::InClass' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.DestroyPoolByClass
// 0x0008 (0x0008 - 0x0000)
struct X6ObjectPoolSubSystem_DestroyPoolByClass final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectPoolSubSystem_DestroyPoolByClass) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_DestroyPoolByClass");
static_assert(sizeof(X6ObjectPoolSubSystem_DestroyPoolByClass) == 0x000008, "Wrong size on X6ObjectPoolSubSystem_DestroyPoolByClass");
static_assert(offsetof(X6ObjectPoolSubSystem_DestroyPoolByClass, InClass) == 0x000000, "Member 'X6ObjectPoolSubSystem_DestroyPoolByClass::InClass' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.GetFreeByPoolTag
// 0x0008 (0x0008 - 0x0000)
struct X6ObjectPoolSubSystem_GetFreeByPoolTag final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectPoolSubSystem_GetFreeByPoolTag) == 0x000004, "Wrong alignment on X6ObjectPoolSubSystem_GetFreeByPoolTag");
static_assert(sizeof(X6ObjectPoolSubSystem_GetFreeByPoolTag) == 0x000008, "Wrong size on X6ObjectPoolSubSystem_GetFreeByPoolTag");
static_assert(offsetof(X6ObjectPoolSubSystem_GetFreeByPoolTag, ReturnValue) == 0x000000, "Member 'X6ObjectPoolSubSystem_GetFreeByPoolTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.GetObjectByClass
// 0x0028 (0x0028 - 0x0000)
struct X6ObjectPoolSubSystem_GetObjectByClass final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Outer_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectPoolSubSystem_GetObjectByClass) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_GetObjectByClass");
static_assert(sizeof(X6ObjectPoolSubSystem_GetObjectByClass) == 0x000028, "Wrong size on X6ObjectPoolSubSystem_GetObjectByClass");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClass, InClass) == 0x000000, "Member 'X6ObjectPoolSubSystem_GetObjectByClass::InClass' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClass, Outer_0) == 0x000008, "Member 'X6ObjectPoolSubSystem_GetObjectByClass::Outer_0' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClass, ObjectName) == 0x000010, "Member 'X6ObjectPoolSubSystem_GetObjectByClass::ObjectName' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClass, ReturnValue) == 0x000020, "Member 'X6ObjectPoolSubSystem_GetObjectByClass::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.GetObjectByClassEvenIfNoPool
// 0x0028 (0x0028 - 0x0000)
struct X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Outer_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool");
static_assert(sizeof(X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool) == 0x000028, "Wrong size on X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool, InClass) == 0x000000, "Member 'X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool::InClass' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool, Outer_0) == 0x000008, "Member 'X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool::Outer_0' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool, ObjectName) == 0x000010, "Member 'X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool::ObjectName' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool, ReturnValue) == 0x000020, "Member 'X6ObjectPoolSubSystem_GetObjectByClassEvenIfNoPool::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.HasPoolOfClass
// 0x0010 (0x0010 - 0x0000)
struct X6ObjectPoolSubSystem_HasPoolOfClass final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectPoolSubSystem_HasPoolOfClass) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_HasPoolOfClass");
static_assert(sizeof(X6ObjectPoolSubSystem_HasPoolOfClass) == 0x000010, "Wrong size on X6ObjectPoolSubSystem_HasPoolOfClass");
static_assert(offsetof(X6ObjectPoolSubSystem_HasPoolOfClass, InClass) == 0x000000, "Member 'X6ObjectPoolSubSystem_HasPoolOfClass::InClass' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_HasPoolOfClass, ReturnValue) == 0x000008, "Member 'X6ObjectPoolSubSystem_HasPoolOfClass::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.IsPooledObject
// 0x0010 (0x0010 - 0x0000)
struct X6ObjectPoolSubSystem_IsPooledObject final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectPoolSubSystem_IsPooledObject) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_IsPooledObject");
static_assert(sizeof(X6ObjectPoolSubSystem_IsPooledObject) == 0x000010, "Wrong size on X6ObjectPoolSubSystem_IsPooledObject");
static_assert(offsetof(X6ObjectPoolSubSystem_IsPooledObject, InObject) == 0x000000, "Member 'X6ObjectPoolSubSystem_IsPooledObject::InObject' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_IsPooledObject, ReturnValue) == 0x000008, "Member 'X6ObjectPoolSubSystem_IsPooledObject::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.IsVaildForUse
// 0x0010 (0x0010 - 0x0000)
struct X6ObjectPoolSubSystem_IsVaildForUse final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectPoolSubSystem_IsVaildForUse) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_IsVaildForUse");
static_assert(sizeof(X6ObjectPoolSubSystem_IsVaildForUse) == 0x000010, "Wrong size on X6ObjectPoolSubSystem_IsVaildForUse");
static_assert(offsetof(X6ObjectPoolSubSystem_IsVaildForUse, InObject) == 0x000000, "Member 'X6ObjectPoolSubSystem_IsVaildForUse::InObject' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_IsVaildForUse, ReturnValue) == 0x000008, "Member 'X6ObjectPoolSubSystem_IsVaildForUse::ReturnValue' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.PreCreateObjects
// 0x0010 (0x0010 - 0x0000)
struct X6ObjectPoolSubSystem_PreCreateObjects final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreCreateNum;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectPoolSubSystem_PreCreateObjects) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_PreCreateObjects");
static_assert(sizeof(X6ObjectPoolSubSystem_PreCreateObjects) == 0x000010, "Wrong size on X6ObjectPoolSubSystem_PreCreateObjects");
static_assert(offsetof(X6ObjectPoolSubSystem_PreCreateObjects, InClass) == 0x000000, "Member 'X6ObjectPoolSubSystem_PreCreateObjects::InClass' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_PreCreateObjects, PreCreateNum) == 0x000008, "Member 'X6ObjectPoolSubSystem_PreCreateObjects::PreCreateNum' has a wrong offset!");

// Function X6Game.X6ObjectPoolSubSystem.RecycleObject
// 0x0020 (0x0020 - 0x0000)
struct X6ObjectPoolSubSystem_RecycleObject final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ModifiedProperties;                                // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ObjectPoolSubSystem_RecycleObject) == 0x000008, "Wrong alignment on X6ObjectPoolSubSystem_RecycleObject");
static_assert(sizeof(X6ObjectPoolSubSystem_RecycleObject) == 0x000020, "Wrong size on X6ObjectPoolSubSystem_RecycleObject");
static_assert(offsetof(X6ObjectPoolSubSystem_RecycleObject, InObject) == 0x000000, "Member 'X6ObjectPoolSubSystem_RecycleObject::InObject' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_RecycleObject, ModifiedProperties) == 0x000008, "Member 'X6ObjectPoolSubSystem_RecycleObject::ModifiedProperties' has a wrong offset!");
static_assert(offsetof(X6ObjectPoolSubSystem_RecycleObject, ReturnValue) == 0x000018, "Member 'X6ObjectPoolSubSystem_RecycleObject::ReturnValue' has a wrong offset!");

// Function X6Game.X6PackageSettings.GetX6PackageSettings
// 0x0008 (0x0008 - 0x0000)
struct X6PackageSettings_GetX6PackageSettings final
{
public:
	const class UX6PackageSettings*               ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6PackageSettings_GetX6PackageSettings) == 0x000008, "Wrong alignment on X6PackageSettings_GetX6PackageSettings");
static_assert(sizeof(X6PackageSettings_GetX6PackageSettings) == 0x000008, "Wrong size on X6PackageSettings_GetX6PackageSettings");
static_assert(offsetof(X6PackageSettings_GetX6PackageSettings, ReturnValue) == 0x000000, "Member 'X6PackageSettings_GetX6PackageSettings::ReturnValue' has a wrong offset!");

// Function X6Game.X6ReceiveSkillBaseComponent.SetIsAlwaysChargeOutLineEffect
// 0x0001 (0x0001 - 0x0000)
struct X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect final
{
public:
	bool                                          IsAlwaysChargeOutLineEffect;                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect) == 0x000001, "Wrong alignment on X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect");
static_assert(sizeof(X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect) == 0x000001, "Wrong size on X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect");
static_assert(offsetof(X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect, IsAlwaysChargeOutLineEffect) == 0x000000, "Member 'X6ReceiveSkillBaseComponent_SetIsAlwaysChargeOutLineEffect::IsAlwaysChargeOutLineEffect' has a wrong offset!");

// Function X6Game.X6ReceiveSkillBaseComponent.SetIsBulletAttachment
// 0x0001 (0x0001 - 0x0000)
struct X6ReceiveSkillBaseComponent_SetIsBulletAttachment final
{
public:
	bool                                          IsBulletAttachment;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ReceiveSkillBaseComponent_SetIsBulletAttachment) == 0x000001, "Wrong alignment on X6ReceiveSkillBaseComponent_SetIsBulletAttachment");
static_assert(sizeof(X6ReceiveSkillBaseComponent_SetIsBulletAttachment) == 0x000001, "Wrong size on X6ReceiveSkillBaseComponent_SetIsBulletAttachment");
static_assert(offsetof(X6ReceiveSkillBaseComponent_SetIsBulletAttachment, IsBulletAttachment) == 0x000000, "Member 'X6ReceiveSkillBaseComponent_SetIsBulletAttachment::IsBulletAttachment' has a wrong offset!");

// Function X6Game.X6ReceiveSkillBaseComponent.SetIsBulletDestroyWhenNotSimulation
// 0x0001 (0x0001 - 0x0000)
struct X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation final
{
public:
	bool                                          IsBulletDestroyWhenNotSimulation;                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation) == 0x000001, "Wrong alignment on X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation");
static_assert(sizeof(X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation) == 0x000001, "Wrong size on X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation");
static_assert(offsetof(X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation, IsBulletDestroyWhenNotSimulation) == 0x000000, "Member 'X6ReceiveSkillBaseComponent_SetIsBulletDestroyWhenNotSimulation::IsBulletDestroyWhenNotSimulation' has a wrong offset!");

// Function X6Game.X6ReceiveSkillBaseComponent.SetIsBulletPenetrateWhenSimulation
// 0x0001 (0x0001 - 0x0000)
struct X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation final
{
public:
	bool                                          IsBulletPenetrateWhenSimulation;                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation) == 0x000001, "Wrong alignment on X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation");
static_assert(sizeof(X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation) == 0x000001, "Wrong size on X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation");
static_assert(offsetof(X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation, IsBulletPenetrateWhenSimulation) == 0x000000, "Member 'X6ReceiveSkillBaseComponent_SetIsBulletPenetrateWhenSimulation::IsBulletPenetrateWhenSimulation' has a wrong offset!");

// Function X6Game.X6ReceiveSkillBaseComponent.SetIsChargeOutLineEffect
// 0x0001 (0x0001 - 0x0000)
struct X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect final
{
public:
	bool                                          IsChargeOutLineEffect;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect) == 0x000001, "Wrong alignment on X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect");
static_assert(sizeof(X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect) == 0x000001, "Wrong size on X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect");
static_assert(offsetof(X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect, IsChargeOutLineEffect) == 0x000000, "Member 'X6ReceiveSkillBaseComponent_SetIsChargeOutLineEffect::IsChargeOutLineEffect' has a wrong offset!");

// Function X6Game.X6RichTextBlockNetImageDecorator.OnResDownloaded
// 0x0020 (0x0020 - 0x0000)
struct X6RichTextBlockNetImageDecorator_OnResDownloaded final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResponseCode;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestID;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentDownloadFileName;                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RichTextBlockNetImageDecorator_OnResDownloaded) == 0x000008, "Wrong alignment on X6RichTextBlockNetImageDecorator_OnResDownloaded");
static_assert(sizeof(X6RichTextBlockNetImageDecorator_OnResDownloaded) == 0x000020, "Wrong size on X6RichTextBlockNetImageDecorator_OnResDownloaded");
static_assert(offsetof(X6RichTextBlockNetImageDecorator_OnResDownloaded, bSuccess) == 0x000000, "Member 'X6RichTextBlockNetImageDecorator_OnResDownloaded::bSuccess' has a wrong offset!");
static_assert(offsetof(X6RichTextBlockNetImageDecorator_OnResDownloaded, ResponseCode) == 0x000004, "Member 'X6RichTextBlockNetImageDecorator_OnResDownloaded::ResponseCode' has a wrong offset!");
static_assert(offsetof(X6RichTextBlockNetImageDecorator_OnResDownloaded, Size) == 0x000008, "Member 'X6RichTextBlockNetImageDecorator_OnResDownloaded::Size' has a wrong offset!");
static_assert(offsetof(X6RichTextBlockNetImageDecorator_OnResDownloaded, RequestID) == 0x00000C, "Member 'X6RichTextBlockNetImageDecorator_OnResDownloaded::RequestID' has a wrong offset!");
static_assert(offsetof(X6RichTextBlockNetImageDecorator_OnResDownloaded, CurrentDownloadFileName) == 0x000010, "Member 'X6RichTextBlockNetImageDecorator_OnResDownloaded::CurrentDownloadFileName' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.Blueprint_PostUpdateRegularMovementBehavior
// 0x0004 (0x0004 - 0x0000)
struct X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior) == 0x000004, "Wrong alignment on X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior");
static_assert(sizeof(X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior) == 0x000004, "Wrong size on X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior");
static_assert(offsetof(X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior, DeltaSeconds) == 0x000000, "Member 'X6RMWalkingComponent_Blueprint_PostUpdateRegularMovementBehavior::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.Blueprint_PreUpdateRegularMovementBehavior
// 0x0004 (0x0004 - 0x0000)
struct X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior) == 0x000004, "Wrong alignment on X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior");
static_assert(sizeof(X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior) == 0x000004, "Wrong size on X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior");
static_assert(offsetof(X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior, DeltaSeconds) == 0x000000, "Member 'X6RMWalkingComponent_Blueprint_PreUpdateRegularMovementBehavior::DeltaSeconds' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.ChangeDesiredGait
// 0x0002 (0x0002 - 0x0000)
struct X6RMWalkingComponent_ChangeDesiredGait final
{
public:
	ERegularLocomotionType                        NewGait;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceChangeOperationInput;                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_ChangeDesiredGait) == 0x000001, "Wrong alignment on X6RMWalkingComponent_ChangeDesiredGait");
static_assert(sizeof(X6RMWalkingComponent_ChangeDesiredGait) == 0x000002, "Wrong size on X6RMWalkingComponent_ChangeDesiredGait");
static_assert(offsetof(X6RMWalkingComponent_ChangeDesiredGait, NewGait) == 0x000000, "Member 'X6RMWalkingComponent_ChangeDesiredGait::NewGait' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_ChangeDesiredGait, bForceChangeOperationInput) == 0x000001, "Member 'X6RMWalkingComponent_ChangeDesiredGait::bForceChangeOperationInput' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.GetConfigMaxSpeedByCurAllowedGait
// 0x0004 (0x0004 - 0x0000)
struct X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait) == 0x000004, "Wrong alignment on X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait");
static_assert(sizeof(X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait) == 0x000004, "Wrong size on X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait");
static_assert(offsetof(X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait, ReturnValue) == 0x000000, "Member 'X6RMWalkingComponent_GetConfigMaxSpeedByCurAllowedGait::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.GetConfigMaxSpeedData
// 0x000C (0x000C - 0x0000)
struct X6RMWalkingComponent_GetConfigMaxSpeedData final
{
public:
	float                                         MaxSpeed_Walk;                                     // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed_Run;                                      // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed_Sprint;                                   // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_GetConfigMaxSpeedData) == 0x000004, "Wrong alignment on X6RMWalkingComponent_GetConfigMaxSpeedData");
static_assert(sizeof(X6RMWalkingComponent_GetConfigMaxSpeedData) == 0x00000C, "Wrong size on X6RMWalkingComponent_GetConfigMaxSpeedData");
static_assert(offsetof(X6RMWalkingComponent_GetConfigMaxSpeedData, MaxSpeed_Walk) == 0x000000, "Member 'X6RMWalkingComponent_GetConfigMaxSpeedData::MaxSpeed_Walk' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_GetConfigMaxSpeedData, MaxSpeed_Run) == 0x000004, "Member 'X6RMWalkingComponent_GetConfigMaxSpeedData::MaxSpeed_Run' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_GetConfigMaxSpeedData, MaxSpeed_Sprint) == 0x000008, "Member 'X6RMWalkingComponent_GetConfigMaxSpeedData::MaxSpeed_Sprint' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.GetCurConfigMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6RMWalkingComponent_GetCurConfigMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_GetCurConfigMaxSpeed) == 0x000004, "Wrong alignment on X6RMWalkingComponent_GetCurConfigMaxSpeed");
static_assert(sizeof(X6RMWalkingComponent_GetCurConfigMaxSpeed) == 0x000004, "Wrong size on X6RMWalkingComponent_GetCurConfigMaxSpeed");
static_assert(offsetof(X6RMWalkingComponent_GetCurConfigMaxSpeed, ReturnValue) == 0x000000, "Member 'X6RMWalkingComponent_GetCurConfigMaxSpeed::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.GetCurLocomotionTypeBySpeed
// 0x0008 (0x0008 - 0x0000)
struct X6RMWalkingComponent_GetCurLocomotionTypeBySpeed final
{
public:
	float                                         Speed2D;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6RMWalkingComponent_GetCurLocomotionTypeBySpeed) == 0x000004, "Wrong alignment on X6RMWalkingComponent_GetCurLocomotionTypeBySpeed");
static_assert(sizeof(X6RMWalkingComponent_GetCurLocomotionTypeBySpeed) == 0x000008, "Wrong size on X6RMWalkingComponent_GetCurLocomotionTypeBySpeed");
static_assert(offsetof(X6RMWalkingComponent_GetCurLocomotionTypeBySpeed, Speed2D) == 0x000000, "Member 'X6RMWalkingComponent_GetCurLocomotionTypeBySpeed::Speed2D' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_GetCurLocomotionTypeBySpeed, ReturnValue) == 0x000004, "Member 'X6RMWalkingComponent_GetCurLocomotionTypeBySpeed::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.GetCurRMBaseLogicProcessor
// 0x0008 (0x0008 - 0x0000)
struct X6RMWalkingComponent_GetCurRMBaseLogicProcessor final
{
public:
	class URMBaseLogicProcessor*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_GetCurRMBaseLogicProcessor) == 0x000008, "Wrong alignment on X6RMWalkingComponent_GetCurRMBaseLogicProcessor");
static_assert(sizeof(X6RMWalkingComponent_GetCurRMBaseLogicProcessor) == 0x000008, "Wrong size on X6RMWalkingComponent_GetCurRMBaseLogicProcessor");
static_assert(offsetof(X6RMWalkingComponent_GetCurRMBaseLogicProcessor, ReturnValue) == 0x000000, "Member 'X6RMWalkingComponent_GetCurRMBaseLogicProcessor::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.InitRMBaseLogicProcessor
// 0x0008 (0x0008 - 0x0000)
struct X6RMWalkingComponent_InitRMBaseLogicProcessor final
{
public:
	class URMBaseLogicProcessor*                  RMBaseLogicProcessor;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_InitRMBaseLogicProcessor) == 0x000008, "Wrong alignment on X6RMWalkingComponent_InitRMBaseLogicProcessor");
static_assert(sizeof(X6RMWalkingComponent_InitRMBaseLogicProcessor) == 0x000008, "Wrong size on X6RMWalkingComponent_InitRMBaseLogicProcessor");
static_assert(offsetof(X6RMWalkingComponent_InitRMBaseLogicProcessor, RMBaseLogicProcessor) == 0x000000, "Member 'X6RMWalkingComponent_InitRMBaseLogicProcessor::RMBaseLogicProcessor' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.IsValidReplicatedMovingDirection
// 0x0001 (0x0001 - 0x0000)
struct X6RMWalkingComponent_IsValidReplicatedMovingDirection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_IsValidReplicatedMovingDirection) == 0x000001, "Wrong alignment on X6RMWalkingComponent_IsValidReplicatedMovingDirection");
static_assert(sizeof(X6RMWalkingComponent_IsValidReplicatedMovingDirection) == 0x000001, "Wrong size on X6RMWalkingComponent_IsValidReplicatedMovingDirection");
static_assert(offsetof(X6RMWalkingComponent_IsValidReplicatedMovingDirection, ReturnValue) == 0x000000, "Member 'X6RMWalkingComponent_IsValidReplicatedMovingDirection::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.NotifyBeforeMovementPropertyChanged
// 0x0018 (0x0018 - 0x0000)
struct X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged final
{
public:
	float                                         MaxWalkSpeed;                                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedCrouched;                              // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAnalogWalkSpeed;                                // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged) == 0x000004, "Wrong alignment on X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged");
static_assert(sizeof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged) == 0x000018, "Wrong size on X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged");
static_assert(offsetof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged, MaxWalkSpeed) == 0x000000, "Member 'X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged, MaxWalkSpeedCrouched) == 0x000004, "Member 'X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged::MaxWalkSpeedCrouched' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged, MinAnalogWalkSpeed) == 0x000008, "Member 'X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged::MinAnalogWalkSpeed' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged, MaxAcceleration) == 0x00000C, "Member 'X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged, BrakingDecelerationWalking) == 0x000010, "Member 'X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged, GroundFriction) == 0x000014, "Member 'X6RMWalkingComponent_NotifyBeforeMovementPropertyChanged::GroundFriction' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.NotifyCurActualGaitChanged
// 0x0002 (0x0002 - 0x0000)
struct X6RMWalkingComponent_NotifyCurActualGaitChanged final
{
public:
	ERegularLocomotionType                        NewGait;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentGait;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_NotifyCurActualGaitChanged) == 0x000001, "Wrong alignment on X6RMWalkingComponent_NotifyCurActualGaitChanged");
static_assert(sizeof(X6RMWalkingComponent_NotifyCurActualGaitChanged) == 0x000002, "Wrong size on X6RMWalkingComponent_NotifyCurActualGaitChanged");
static_assert(offsetof(X6RMWalkingComponent_NotifyCurActualGaitChanged, NewGait) == 0x000000, "Member 'X6RMWalkingComponent_NotifyCurActualGaitChanged::NewGait' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyCurActualGaitChanged, CurrentGait) == 0x000001, "Member 'X6RMWalkingComponent_NotifyCurActualGaitChanged::CurrentGait' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.NotifyCurAllowedGaitChanged
// 0x0002 (0x0002 - 0x0000)
struct X6RMWalkingComponent_NotifyCurAllowedGaitChanged final
{
public:
	ERegularLocomotionType                        NewGait;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentGait;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_NotifyCurAllowedGaitChanged) == 0x000001, "Wrong alignment on X6RMWalkingComponent_NotifyCurAllowedGaitChanged");
static_assert(sizeof(X6RMWalkingComponent_NotifyCurAllowedGaitChanged) == 0x000002, "Wrong size on X6RMWalkingComponent_NotifyCurAllowedGaitChanged");
static_assert(offsetof(X6RMWalkingComponent_NotifyCurAllowedGaitChanged, NewGait) == 0x000000, "Member 'X6RMWalkingComponent_NotifyCurAllowedGaitChanged::NewGait' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyCurAllowedGaitChanged, CurrentGait) == 0x000001, "Member 'X6RMWalkingComponent_NotifyCurAllowedGaitChanged::CurrentGait' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.NotifyCurReplicatedAllowedGaitChanged
// 0x0002 (0x0002 - 0x0000)
struct X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged final
{
public:
	ERegularLocomotionType                        NewGait;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentGait;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged) == 0x000001, "Wrong alignment on X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged");
static_assert(sizeof(X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged) == 0x000002, "Wrong size on X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged");
static_assert(offsetof(X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged, NewGait) == 0x000000, "Member 'X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged::NewGait' has a wrong offset!");
static_assert(offsetof(X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged, CurrentGait) == 0x000001, "Member 'X6RMWalkingComponent_NotifyCurReplicatedAllowedGaitChanged::CurrentGait' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.OnMovementBlockedBy
// 0x00F8 (0x00F8 - 0x0000)
struct X6RMWalkingComponent_OnMovementBlockedBy final
{
public:
	struct FHitResult                             Impact;                                            // 0x0000(0x00F8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_OnMovementBlockedBy) == 0x000008, "Wrong alignment on X6RMWalkingComponent_OnMovementBlockedBy");
static_assert(sizeof(X6RMWalkingComponent_OnMovementBlockedBy) == 0x0000F8, "Wrong size on X6RMWalkingComponent_OnMovementBlockedBy");
static_assert(offsetof(X6RMWalkingComponent_OnMovementBlockedBy, Impact) == 0x000000, "Member 'X6RMWalkingComponent_OnMovementBlockedBy::Impact' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.ShouldUpdateRegularMovementBehaviorTree
// 0x0001 (0x0001 - 0x0000)
struct X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree) == 0x000001, "Wrong alignment on X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree");
static_assert(sizeof(X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree) == 0x000001, "Wrong size on X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree");
static_assert(offsetof(X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree, ReturnValue) == 0x000000, "Member 'X6RMWalkingComponent_ShouldUpdateRegularMovementBehaviorTree::ReturnValue' has a wrong offset!");

// Function X6Game.X6RMWalkingComponent.UpdateDynamicMovmentSettings
// 0x0001 (0x0001 - 0x0000)
struct X6RMWalkingComponent_UpdateDynamicMovmentSettings final
{
public:
	bool                                          bForceUpdate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6RMWalkingComponent_UpdateDynamicMovmentSettings) == 0x000001, "Wrong alignment on X6RMWalkingComponent_UpdateDynamicMovmentSettings");
static_assert(sizeof(X6RMWalkingComponent_UpdateDynamicMovmentSettings) == 0x000001, "Wrong size on X6RMWalkingComponent_UpdateDynamicMovmentSettings");
static_assert(offsetof(X6RMWalkingComponent_UpdateDynamicMovmentSettings, bForceUpdate) == 0x000000, "Member 'X6RMWalkingComponent_UpdateDynamicMovmentSettings::bForceUpdate' has a wrong offset!");

// Function X6Game.X6SoftRefWidget.GetContentWidget
// 0x0008 (0x0008 - 0x0000)
struct X6SoftRefWidget_GetContentWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SoftRefWidget_GetContentWidget) == 0x000008, "Wrong alignment on X6SoftRefWidget_GetContentWidget");
static_assert(sizeof(X6SoftRefWidget_GetContentWidget) == 0x000008, "Wrong size on X6SoftRefWidget_GetContentWidget");
static_assert(offsetof(X6SoftRefWidget_GetContentWidget, ReturnValue) == 0x000000, "Member 'X6SoftRefWidget_GetContentWidget::ReturnValue' has a wrong offset!");

// Function X6Game.X6SoftRefWidget.LoadContentWidget
// 0x0002 (0x0002 - 0x0000)
struct X6SoftRefWidget_LoadContentWidget final
{
public:
	bool                                          bSyncLoad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedRecreate;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SoftRefWidget_LoadContentWidget) == 0x000001, "Wrong alignment on X6SoftRefWidget_LoadContentWidget");
static_assert(sizeof(X6SoftRefWidget_LoadContentWidget) == 0x000002, "Wrong size on X6SoftRefWidget_LoadContentWidget");
static_assert(offsetof(X6SoftRefWidget_LoadContentWidget, bSyncLoad) == 0x000000, "Member 'X6SoftRefWidget_LoadContentWidget::bSyncLoad' has a wrong offset!");
static_assert(offsetof(X6SoftRefWidget_LoadContentWidget, bNeedRecreate) == 0x000001, "Member 'X6SoftRefWidget_LoadContentWidget::bNeedRecreate' has a wrong offset!");

// Function X6Game.X6SoftRefWidget.OnLoaded
// 0x0018 (0x0018 - 0x0000)
struct X6SoftRefWidget_OnLoaded final
{
public:
	int32                                         AsyncId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        InLoadedObjects;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SoftRefWidget_OnLoaded) == 0x000008, "Wrong alignment on X6SoftRefWidget_OnLoaded");
static_assert(sizeof(X6SoftRefWidget_OnLoaded) == 0x000018, "Wrong size on X6SoftRefWidget_OnLoaded");
static_assert(offsetof(X6SoftRefWidget_OnLoaded, AsyncId) == 0x000000, "Member 'X6SoftRefWidget_OnLoaded::AsyncId' has a wrong offset!");
static_assert(offsetof(X6SoftRefWidget_OnLoaded, InLoadedObjects) == 0x000008, "Member 'X6SoftRefWidget_OnLoaded::InLoadedObjects' has a wrong offset!");

// Function X6Game.X6SteamFunctionLibrary.UpdateAchievements
// 0x0060 (0x0060 - 0x0000)
struct X6SteamFunctionLibrary_UpdateAchievements final
{
public:
	TMap<class FString, int32>                    InAchievements;                                    // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ChannelString;                                     // 0x0050(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SteamFunctionLibrary_UpdateAchievements) == 0x000008, "Wrong alignment on X6SteamFunctionLibrary_UpdateAchievements");
static_assert(sizeof(X6SteamFunctionLibrary_UpdateAchievements) == 0x000060, "Wrong size on X6SteamFunctionLibrary_UpdateAchievements");
static_assert(offsetof(X6SteamFunctionLibrary_UpdateAchievements, InAchievements) == 0x000000, "Member 'X6SteamFunctionLibrary_UpdateAchievements::InAchievements' has a wrong offset!");
static_assert(offsetof(X6SteamFunctionLibrary_UpdateAchievements, ChannelString) == 0x000050, "Member 'X6SteamFunctionLibrary_UpdateAchievements::ChannelString' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.CallPreivewFunction
// 0x0018 (0x0018 - 0x0000)
struct X6SuitDisplayComponent_CallPreivewFunction final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InFunctionName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InParams;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SuitDisplayComponent_CallPreivewFunction) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_CallPreivewFunction");
static_assert(sizeof(X6SuitDisplayComponent_CallPreivewFunction) == 0x000018, "Wrong size on X6SuitDisplayComponent_CallPreivewFunction");
static_assert(offsetof(X6SuitDisplayComponent_CallPreivewFunction, InActor) == 0x000000, "Member 'X6SuitDisplayComponent_CallPreivewFunction::InActor' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_CallPreivewFunction, InFunctionName) == 0x000008, "Member 'X6SuitDisplayComponent_CallPreivewFunction::InFunctionName' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_CallPreivewFunction, InParams) == 0x000010, "Member 'X6SuitDisplayComponent_CallPreivewFunction::InParams' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.SetPreviewProperty
// 0x0018 (0x0018 - 0x0000)
struct X6SuitDisplayComponent_SetPreviewProperty final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InPropertyName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPropertyValue;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SuitDisplayComponent_SetPreviewProperty) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_SetPreviewProperty");
static_assert(sizeof(X6SuitDisplayComponent_SetPreviewProperty) == 0x000018, "Wrong size on X6SuitDisplayComponent_SetPreviewProperty");
static_assert(offsetof(X6SuitDisplayComponent_SetPreviewProperty, InActor) == 0x000000, "Member 'X6SuitDisplayComponent_SetPreviewProperty::InActor' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_SetPreviewProperty, InPropertyName) == 0x000008, "Member 'X6SuitDisplayComponent_SetPreviewProperty::InPropertyName' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_SetPreviewProperty, InPropertyValue) == 0x000010, "Member 'X6SuitDisplayComponent_SetPreviewProperty::InPropertyValue' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.AsyncCallBPFunction
// 0x0018 (0x0018 - 0x0000)
struct X6SuitDisplayComponent_AsyncCallBPFunction final
{
public:
	class FName                                   FunctionName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  MeshArr;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SuitDisplayComponent_AsyncCallBPFunction) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_AsyncCallBPFunction");
static_assert(sizeof(X6SuitDisplayComponent_AsyncCallBPFunction) == 0x000018, "Wrong size on X6SuitDisplayComponent_AsyncCallBPFunction");
static_assert(offsetof(X6SuitDisplayComponent_AsyncCallBPFunction, FunctionName) == 0x000000, "Member 'X6SuitDisplayComponent_AsyncCallBPFunction::FunctionName' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_AsyncCallBPFunction, MeshArr) == 0x000008, "Member 'X6SuitDisplayComponent_AsyncCallBPFunction::MeshArr' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.AsyncNewObject
// 0x0010 (0x0010 - 0x0000)
struct X6SuitDisplayComponent_AsyncNewObject final
{
public:
	TSubclassOf<class UObject>                    InObjectClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SuitDisplayComponent_AsyncNewObject) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_AsyncNewObject");
static_assert(sizeof(X6SuitDisplayComponent_AsyncNewObject) == 0x000010, "Wrong size on X6SuitDisplayComponent_AsyncNewObject");
static_assert(offsetof(X6SuitDisplayComponent_AsyncNewObject, InObjectClass) == 0x000000, "Member 'X6SuitDisplayComponent_AsyncNewObject::InObjectClass' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_AsyncNewObject, ReturnValue) == 0x000008, "Member 'X6SuitDisplayComponent_AsyncNewObject::ReturnValue' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.NotifyCppClothID2ClothPath
// 0x0050 (0x0050 - 0x0000)
struct X6SuitDisplayComponent_NotifyCppClothID2ClothPath final
{
public:
	TMap<int64, class FString>                    ClothPair;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SuitDisplayComponent_NotifyCppClothID2ClothPath) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_NotifyCppClothID2ClothPath");
static_assert(sizeof(X6SuitDisplayComponent_NotifyCppClothID2ClothPath) == 0x000050, "Wrong size on X6SuitDisplayComponent_NotifyCppClothID2ClothPath");
static_assert(offsetof(X6SuitDisplayComponent_NotifyCppClothID2ClothPath, ClothPair) == 0x000000, "Member 'X6SuitDisplayComponent_NotifyCppClothID2ClothPath::ClothPair' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.OnAsyncCallFinished
// 0x0008 (0x0008 - 0x0000)
struct X6SuitDisplayComponent_OnAsyncCallFinished final
{
public:
	class UObject*                                AsyncResult;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SuitDisplayComponent_OnAsyncCallFinished) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_OnAsyncCallFinished");
static_assert(sizeof(X6SuitDisplayComponent_OnAsyncCallFinished) == 0x000008, "Wrong size on X6SuitDisplayComponent_OnAsyncCallFinished");
static_assert(offsetof(X6SuitDisplayComponent_OnAsyncCallFinished, AsyncResult) == 0x000000, "Member 'X6SuitDisplayComponent_OnAsyncCallFinished::AsyncResult' has a wrong offset!");

// Function X6Game.X6SuitDisplayComponent.RenameComponent
// 0x0018 (0x0018 - 0x0000)
struct X6SuitDisplayComponent_RenameComponent final
{
public:
	class UActorComponent*                        InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InNewName;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SuitDisplayComponent_RenameComponent) == 0x000008, "Wrong alignment on X6SuitDisplayComponent_RenameComponent");
static_assert(sizeof(X6SuitDisplayComponent_RenameComponent) == 0x000018, "Wrong size on X6SuitDisplayComponent_RenameComponent");
static_assert(offsetof(X6SuitDisplayComponent_RenameComponent, InComponent) == 0x000000, "Member 'X6SuitDisplayComponent_RenameComponent::InComponent' has a wrong offset!");
static_assert(offsetof(X6SuitDisplayComponent_RenameComponent, InNewName) == 0x000008, "Member 'X6SuitDisplayComponent_RenameComponent::InNewName' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_AOE.BP_GetTargetingResultDataByIndex
// 0x0108 (0x0108 - 0x0000)
struct X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTargetingDefaultResultData            ResultData;                                        // 0x0008(0x0100)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex");
static_assert(sizeof(X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex) == 0x000108, "Wrong size on X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex");
static_assert(offsetof(X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex, Index_0) == 0x000004, "Member 'X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex, ResultData) == 0x000008, "Member 'X6TargetingSelectionTask_AOE_BP_GetTargetingResultDataByIndex::ResultData' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_AOE.GetOffsetRotationInEditor
// 0x0030 (0x0030 - 0x0000)
struct X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor) == 0x000010, "Wrong alignment on X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor");
static_assert(sizeof(X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor) == 0x000030, "Wrong size on X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor, Actor) == 0x000000, "Member 'X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor::Actor' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor, ReturnValue) == 0x000010, "Member 'X6TargetingSelectionTask_AOE_GetOffsetRotationInEditor::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_AOE.GetSourceLocation
// 0x0020 (0x0020 - 0x0000)
struct X6TargetingSelectionTask_AOE_GetSourceLocation final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_AOE_GetSourceLocation) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_AOE_GetSourceLocation");
static_assert(sizeof(X6TargetingSelectionTask_AOE_GetSourceLocation) == 0x000020, "Wrong size on X6TargetingSelectionTask_AOE_GetSourceLocation");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetSourceLocation, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_AOE_GetSourceLocation::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetSourceLocation, ReturnValue) == 0x000008, "Member 'X6TargetingSelectionTask_AOE_GetSourceLocation::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_AOE.GetSourceOffset
// 0x0020 (0x0020 - 0x0000)
struct X6TargetingSelectionTask_AOE_GetSourceOffset final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_AOE_GetSourceOffset) == 0x000008, "Wrong alignment on X6TargetingSelectionTask_AOE_GetSourceOffset");
static_assert(sizeof(X6TargetingSelectionTask_AOE_GetSourceOffset) == 0x000020, "Wrong size on X6TargetingSelectionTask_AOE_GetSourceOffset");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetSourceOffset, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_AOE_GetSourceOffset::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetSourceOffset, ReturnValue) == 0x000008, "Member 'X6TargetingSelectionTask_AOE_GetSourceOffset::ReturnValue' has a wrong offset!");

// Function X6Game.X6TargetingSelectionTask_AOE.GetSourceRotation
// 0x0030 (0x0030 - 0x0000)
struct X6TargetingSelectionTask_AOE_GetSourceRotation final
{
public:
	struct FTargetingRequestHandle                TargetingHandle;                                   // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TargetingSelectionTask_AOE_GetSourceRotation) == 0x000010, "Wrong alignment on X6TargetingSelectionTask_AOE_GetSourceRotation");
static_assert(sizeof(X6TargetingSelectionTask_AOE_GetSourceRotation) == 0x000030, "Wrong size on X6TargetingSelectionTask_AOE_GetSourceRotation");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetSourceRotation, TargetingHandle) == 0x000000, "Member 'X6TargetingSelectionTask_AOE_GetSourceRotation::TargetingHandle' has a wrong offset!");
static_assert(offsetof(X6TargetingSelectionTask_AOE_GetSourceRotation, ReturnValue) == 0x000010, "Member 'X6TargetingSelectionTask_AOE_GetSourceRotation::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.ChangeActivityAvailability
// 0x0028 (0x0028 - 0x0000)
struct X6TRCBlueprintLibrary_ChangeActivityAvailability final
{
public:
	TArray<class FString>                         AvailableIDs;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         UnavailableIDs;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TRCBlueprintLibrary_ChangeActivityAvailability) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_ChangeActivityAvailability");
static_assert(sizeof(X6TRCBlueprintLibrary_ChangeActivityAvailability) == 0x000028, "Wrong size on X6TRCBlueprintLibrary_ChangeActivityAvailability");
static_assert(offsetof(X6TRCBlueprintLibrary_ChangeActivityAvailability, AvailableIDs) == 0x000000, "Member 'X6TRCBlueprintLibrary_ChangeActivityAvailability::AvailableIDs' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_ChangeActivityAvailability, UnavailableIDs) == 0x000010, "Member 'X6TRCBlueprintLibrary_ChangeActivityAvailability::UnavailableIDs' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_ChangeActivityAvailability, ReturnValue) == 0x000020, "Member 'X6TRCBlueprintLibrary_ChangeActivityAvailability::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.CheckPSPremium
// 0x0001 (0x0001 - 0x0000)
struct X6TRCBlueprintLibrary_CheckPSPremium final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_CheckPSPremium) == 0x000001, "Wrong alignment on X6TRCBlueprintLibrary_CheckPSPremium");
static_assert(sizeof(X6TRCBlueprintLibrary_CheckPSPremium) == 0x000001, "Wrong size on X6TRCBlueprintLibrary_CheckPSPremium");
static_assert(offsetof(X6TRCBlueprintLibrary_CheckPSPremium, ReturnValue) == 0x000000, "Member 'X6TRCBlueprintLibrary_CheckPSPremium::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.CheckPSPremiumAsync
// 0x0010 (0x0010 - 0x0000)
struct X6TRCBlueprintLibrary_CheckPSPremiumAsync final
{
public:
	TDelegate<void(bool Result)>                  Callback;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_CheckPSPremiumAsync) == 0x000004, "Wrong alignment on X6TRCBlueprintLibrary_CheckPSPremiumAsync");
static_assert(sizeof(X6TRCBlueprintLibrary_CheckPSPremiumAsync) == 0x000010, "Wrong size on X6TRCBlueprintLibrary_CheckPSPremiumAsync");
static_assert(offsetof(X6TRCBlueprintLibrary_CheckPSPremiumAsync, Callback) == 0x000000, "Member 'X6TRCBlueprintLibrary_CheckPSPremiumAsync::Callback' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.EndActivity
// 0x0018 (0x0018 - 0x0000)
struct X6TRCBlueprintLibrary_EndActivity final
{
public:
	class FString                                 activityID;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TRCBlueprintLibrary_EndActivity) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_EndActivity");
static_assert(sizeof(X6TRCBlueprintLibrary_EndActivity) == 0x000018, "Wrong size on X6TRCBlueprintLibrary_EndActivity");
static_assert(offsetof(X6TRCBlueprintLibrary_EndActivity, activityID) == 0x000000, "Member 'X6TRCBlueprintLibrary_EndActivity::activityID' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_EndActivity, ReturnValue) == 0x000010, "Member 'X6TRCBlueprintLibrary_EndActivity::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.ExportToAlbum
// 0x0028 (0x0028 - 0x0000)
struct X6TRCBlueprintLibrary_ExportToAlbum final
{
public:
	class FString                                 FromPath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TRCBlueprintLibrary_ExportToAlbum) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_ExportToAlbum");
static_assert(sizeof(X6TRCBlueprintLibrary_ExportToAlbum) == 0x000028, "Wrong size on X6TRCBlueprintLibrary_ExportToAlbum");
static_assert(offsetof(X6TRCBlueprintLibrary_ExportToAlbum, FromPath) == 0x000000, "Member 'X6TRCBlueprintLibrary_ExportToAlbum::FromPath' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_ExportToAlbum, Filename) == 0x000010, "Member 'X6TRCBlueprintLibrary_ExportToAlbum::Filename' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_ExportToAlbum, ReturnValue) == 0x000020, "Member 'X6TRCBlueprintLibrary_ExportToAlbum::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.IsPremiumFeatureNotifying
// 0x0001 (0x0001 - 0x0000)
struct X6TRCBlueprintLibrary_IsPremiumFeatureNotifying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_IsPremiumFeatureNotifying) == 0x000001, "Wrong alignment on X6TRCBlueprintLibrary_IsPremiumFeatureNotifying");
static_assert(sizeof(X6TRCBlueprintLibrary_IsPremiumFeatureNotifying) == 0x000001, "Wrong size on X6TRCBlueprintLibrary_IsPremiumFeatureNotifying");
static_assert(offsetof(X6TRCBlueprintLibrary_IsPremiumFeatureNotifying, ReturnValue) == 0x000000, "Member 'X6TRCBlueprintLibrary_IsPremiumFeatureNotifying::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.LaunchURLForPredeterminedContent
// 0x0010 (0x0010 - 0x0000)
struct X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent");
static_assert(sizeof(X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent) == 0x000010, "Wrong size on X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent");
static_assert(offsetof(X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent, URL) == 0x000000, "Member 'X6TRCBlueprintLibrary_LaunchURLForPredeterminedContent::URL' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.RequestTRCWebApi
// 0x0050 (0x0050 - 0x0000)
struct X6TRCBlueprintLibrary_RequestTRCWebApi final
{
public:
	class FString                                 ApiGroup;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ApiPath;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 httpMethod;                                        // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JsonContent;                                       // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 ResponceCode, const class FString& Content, float NextRequestTime)> Callback; // 0x0040(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_RequestTRCWebApi) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_RequestTRCWebApi");
static_assert(sizeof(X6TRCBlueprintLibrary_RequestTRCWebApi) == 0x000050, "Wrong size on X6TRCBlueprintLibrary_RequestTRCWebApi");
static_assert(offsetof(X6TRCBlueprintLibrary_RequestTRCWebApi, ApiGroup) == 0x000000, "Member 'X6TRCBlueprintLibrary_RequestTRCWebApi::ApiGroup' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_RequestTRCWebApi, ApiPath) == 0x000010, "Member 'X6TRCBlueprintLibrary_RequestTRCWebApi::ApiPath' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_RequestTRCWebApi, httpMethod) == 0x000020, "Member 'X6TRCBlueprintLibrary_RequestTRCWebApi::httpMethod' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_RequestTRCWebApi, JsonContent) == 0x000030, "Member 'X6TRCBlueprintLibrary_RequestTRCWebApi::JsonContent' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_RequestTRCWebApi, Callback) == 0x000040, "Member 'X6TRCBlueprintLibrary_RequestTRCWebApi::Callback' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.ResetActivity
// 0x0018 (0x0018 - 0x0000)
struct X6TRCBlueprintLibrary_ResetActivity final
{
public:
	class FString                                 activityID;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TRCBlueprintLibrary_ResetActivity) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_ResetActivity");
static_assert(sizeof(X6TRCBlueprintLibrary_ResetActivity) == 0x000018, "Wrong size on X6TRCBlueprintLibrary_ResetActivity");
static_assert(offsetof(X6TRCBlueprintLibrary_ResetActivity, activityID) == 0x000000, "Member 'X6TRCBlueprintLibrary_ResetActivity::activityID' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_ResetActivity, ReturnValue) == 0x000010, "Member 'X6TRCBlueprintLibrary_ResetActivity::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.ShowCommerceDialog
// 0x0001 (0x0001 - 0x0000)
struct X6TRCBlueprintLibrary_ShowCommerceDialog final
{
public:
	EX6CommerceType                               CommerceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_ShowCommerceDialog) == 0x000001, "Wrong alignment on X6TRCBlueprintLibrary_ShowCommerceDialog");
static_assert(sizeof(X6TRCBlueprintLibrary_ShowCommerceDialog) == 0x000001, "Wrong size on X6TRCBlueprintLibrary_ShowCommerceDialog");
static_assert(offsetof(X6TRCBlueprintLibrary_ShowCommerceDialog, CommerceType) == 0x000000, "Member 'X6TRCBlueprintLibrary_ShowCommerceDialog::CommerceType' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.ShowSystemMsgDialog
// 0x0001 (0x0001 - 0x0000)
struct X6TRCBlueprintLibrary_ShowSystemMsgDialog final
{
public:
	EX6SystemMsgType                              MsgType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_ShowSystemMsgDialog) == 0x000001, "Wrong alignment on X6TRCBlueprintLibrary_ShowSystemMsgDialog");
static_assert(sizeof(X6TRCBlueprintLibrary_ShowSystemMsgDialog) == 0x000001, "Wrong size on X6TRCBlueprintLibrary_ShowSystemMsgDialog");
static_assert(offsetof(X6TRCBlueprintLibrary_ShowSystemMsgDialog, MsgType) == 0x000000, "Member 'X6TRCBlueprintLibrary_ShowSystemMsgDialog::MsgType' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.StartActivity
// 0x0018 (0x0018 - 0x0000)
struct X6TRCBlueprintLibrary_StartActivity final
{
public:
	class FString                                 activityID;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TRCBlueprintLibrary_StartActivity) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_StartActivity");
static_assert(sizeof(X6TRCBlueprintLibrary_StartActivity) == 0x000018, "Wrong size on X6TRCBlueprintLibrary_StartActivity");
static_assert(offsetof(X6TRCBlueprintLibrary_StartActivity, activityID) == 0x000000, "Member 'X6TRCBlueprintLibrary_StartActivity::activityID' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_StartActivity, ReturnValue) == 0x000010, "Member 'X6TRCBlueprintLibrary_StartActivity::ReturnValue' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.StartPSNotifyPremiumFeature
// 0x0004 (0x0004 - 0x0000)
struct X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature final
{
public:
	float                                         TimeInterval;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature) == 0x000004, "Wrong alignment on X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature");
static_assert(sizeof(X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature) == 0x000004, "Wrong size on X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature");
static_assert(offsetof(X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature, TimeInterval) == 0x000000, "Member 'X6TRCBlueprintLibrary_StartPSNotifyPremiumFeature::TimeInterval' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.UpdateAchievements
// 0x0050 (0x0050 - 0x0000)
struct X6TRCBlueprintLibrary_UpdateAchievements final
{
public:
	TMap<int32, int32>                            Achievements;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6TRCBlueprintLibrary_UpdateAchievements) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_UpdateAchievements");
static_assert(sizeof(X6TRCBlueprintLibrary_UpdateAchievements) == 0x000050, "Wrong size on X6TRCBlueprintLibrary_UpdateAchievements");
static_assert(offsetof(X6TRCBlueprintLibrary_UpdateAchievements, Achievements) == 0x000000, "Member 'X6TRCBlueprintLibrary_UpdateAchievements::Achievements' has a wrong offset!");

// Function X6Game.X6TRCBlueprintLibrary.X6GetDiskFreeSpace
// 0x0018 (0x0018 - 0x0000)
struct X6TRCBlueprintLibrary_X6GetDiskFreeSpace final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6TRCBlueprintLibrary_X6GetDiskFreeSpace) == 0x000008, "Wrong alignment on X6TRCBlueprintLibrary_X6GetDiskFreeSpace");
static_assert(sizeof(X6TRCBlueprintLibrary_X6GetDiskFreeSpace) == 0x000018, "Wrong size on X6TRCBlueprintLibrary_X6GetDiskFreeSpace");
static_assert(offsetof(X6TRCBlueprintLibrary_X6GetDiskFreeSpace, InPath) == 0x000000, "Member 'X6TRCBlueprintLibrary_X6GetDiskFreeSpace::InPath' has a wrong offset!");
static_assert(offsetof(X6TRCBlueprintLibrary_X6GetDiskFreeSpace, ReturnValue) == 0x000010, "Member 'X6TRCBlueprintLibrary_X6GetDiskFreeSpace::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.GetPointToLeave
// 0x0010 (0x0010 - 0x0000)
struct X6WaterBuoyancyManagerComponent_GetPointToLeave final
{
public:
	struct FSimulateWaterFlowKeyPoint             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_GetPointToLeave) == 0x000008, "Wrong alignment on X6WaterBuoyancyManagerComponent_GetPointToLeave");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_GetPointToLeave) == 0x000010, "Wrong size on X6WaterBuoyancyManagerComponent_GetPointToLeave");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_GetPointToLeave, ReturnValue) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_GetPointToLeave::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.GetTargetPointToToward
// 0x0010 (0x0010 - 0x0000)
struct X6WaterBuoyancyManagerComponent_GetTargetPointToToward final
{
public:
	struct FSimulateWaterFlowKeyPoint             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_GetTargetPointToToward) == 0x000008, "Wrong alignment on X6WaterBuoyancyManagerComponent_GetTargetPointToToward");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_GetTargetPointToToward) == 0x000010, "Wrong size on X6WaterBuoyancyManagerComponent_GetTargetPointToToward");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_GetTargetPointToToward, ReturnValue) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_GetTargetPointToToward::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.GetWaterCurrentDensity
// 0x0004 (0x0004 - 0x0000)
struct X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity) == 0x000004, "Wrong size on X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity, ReturnValue) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_GetWaterCurrentDensity::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.GetWaterSurfaceHeightInWorldCoordinate
// 0x0004 (0x0004 - 0x0000)
struct X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate) == 0x000004, "Wrong size on X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate, ReturnValue) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_GetWaterSurfaceHeightInWorldCoordinate::ReturnValue' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.OnUpdateWaterSurfaceHeight
// 0x0004 (0x0004 - 0x0000)
struct X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight) == 0x000004, "Wrong size on X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight, DeltaTime) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_OnUpdateWaterSurfaceHeight::DeltaTime' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.OnWaterActorBeginOverlaped
// 0x0010 (0x0010 - 0x0000)
struct X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped) == 0x000008, "Wrong alignment on X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped) == 0x000010, "Wrong size on X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped, OverlappedActor) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped::OverlappedActor' has a wrong offset!");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped, OtherActor) == 0x000008, "Member 'X6WaterBuoyancyManagerComponent_OnWaterActorBeginOverlaped::OtherActor' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.OnWaterActorEndOverlaped
// 0x0010 (0x0010 - 0x0000)
struct X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped) == 0x000008, "Wrong alignment on X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped) == 0x000010, "Wrong size on X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped, OverlappedActor) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped::OverlappedActor' has a wrong offset!");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped, OtherActor) == 0x000008, "Member 'X6WaterBuoyancyManagerComponent_OnWaterActorEndOverlaped::OtherActor' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.UpdateWaterDensity
// 0x0004 (0x0004 - 0x0000)
struct X6WaterBuoyancyManagerComponent_UpdateWaterDensity final
{
public:
	float                                         NewDensity;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_UpdateWaterDensity) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_UpdateWaterDensity");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_UpdateWaterDensity) == 0x000004, "Wrong size on X6WaterBuoyancyManagerComponent_UpdateWaterDensity");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterDensity, NewDensity) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterDensity::NewDensity' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.UpdateWaterIceState
// 0x0001 (0x0001 - 0x0000)
struct X6WaterBuoyancyManagerComponent_UpdateWaterIceState final
{
public:
	bool                                          ToIceOrExit;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_UpdateWaterIceState) == 0x000001, "Wrong alignment on X6WaterBuoyancyManagerComponent_UpdateWaterIceState");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_UpdateWaterIceState) == 0x000001, "Wrong size on X6WaterBuoyancyManagerComponent_UpdateWaterIceState");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterIceState, ToIceOrExit) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterIceState::ToIceOrExit' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.UpdateWaterSurfaceHeight
// 0x0004 (0x0004 - 0x0000)
struct X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight final
{
public:
	float                                         HeightOfffsetToUpdate;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight) == 0x000004, "Wrong size on X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight, HeightOfffsetToUpdate) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeight::HeightOfffsetToUpdate' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.UpdateWaterSurfaceHeightInTime
// 0x0008 (0x0008 - 0x0000)
struct X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime final
{
public:
	float                                         TimeDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalHeightToUpdate;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime) == 0x000008, "Wrong size on X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime, TimeDuration) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime::TimeDuration' has a wrong offset!");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime, TotalHeightToUpdate) == 0x000004, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightInTime::TotalHeightToUpdate' has a wrong offset!");

// Function X6Game.X6WaterBuoyancyManagerComponent.UpdateWaterSurfaceHeightWithSpeed
// 0x0008 (0x0008 - 0x0000)
struct X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed final
{
public:
	float                                         UpdateHeightSpeed;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalHeightToUpdate;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed) == 0x000004, "Wrong alignment on X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed");
static_assert(sizeof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed) == 0x000008, "Wrong size on X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed, UpdateHeightSpeed) == 0x000000, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed::UpdateHeightSpeed' has a wrong offset!");
static_assert(offsetof(X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed, TotalHeightToUpdate) == 0x000004, "Member 'X6WaterBuoyancyManagerComponent_UpdateWaterSurfaceHeightWithSpeed::TotalHeightToUpdate' has a wrong offset!");

// Function X6Game.X6WorldCarriageMovementComponent.SetMoveSpeed
// 0x0004 (0x0004 - 0x0000)
struct X6WorldCarriageMovementComponent_SetMoveSpeed final
{
public:
	float                                         InMoveSpeed;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WorldCarriageMovementComponent_SetMoveSpeed) == 0x000004, "Wrong alignment on X6WorldCarriageMovementComponent_SetMoveSpeed");
static_assert(sizeof(X6WorldCarriageMovementComponent_SetMoveSpeed) == 0x000004, "Wrong size on X6WorldCarriageMovementComponent_SetMoveSpeed");
static_assert(offsetof(X6WorldCarriageMovementComponent_SetMoveSpeed, InMoveSpeed) == 0x000000, "Member 'X6WorldCarriageMovementComponent_SetMoveSpeed::InMoveSpeed' has a wrong offset!");

// Function X6Game.X6WorldCarriageMovementComponent.SetTargetSplinePath
// 0x0008 (0x0008 - 0x0000)
struct X6WorldCarriageMovementComponent_SetTargetSplinePath final
{
public:
	const class USplineComponent*                 InTargetSplinePathComponent;                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6WorldCarriageMovementComponent_SetTargetSplinePath) == 0x000008, "Wrong alignment on X6WorldCarriageMovementComponent_SetTargetSplinePath");
static_assert(sizeof(X6WorldCarriageMovementComponent_SetTargetSplinePath) == 0x000008, "Wrong size on X6WorldCarriageMovementComponent_SetTargetSplinePath");
static_assert(offsetof(X6WorldCarriageMovementComponent_SetTargetSplinePath, InTargetSplinePathComponent) == 0x000000, "Member 'X6WorldCarriageMovementComponent_SetTargetSplinePath::InTargetSplinePathComponent' has a wrong offset!");

// Function X6Game.X6AbilityTask_ApplyRootMotionJumpForce.X6ApplyRootMotionJumpForce
// 0x0078 (0x0078 - 0x0000)
struct X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation_0;                                        // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance_0;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height_0;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration_0;                                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLandedTriggerTime_0;                        // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishOnLanded_0;                                 // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 VelocityOnFinishMode;                              // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SetVelocityOnFinish;                               // 0x0040(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampVelocityOnFinish;                             // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve_0;                                 // 0x0060(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeMappingCurve_0;                                // 0x0068(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6AbilityTask_ApplyRootMotionJumpForce* ReturnValue;                                      // 0x0070(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce) == 0x000008, "Wrong alignment on X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce");
static_assert(sizeof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce) == 0x000078, "Wrong size on X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, OwningAbility) == 0x000000, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::OwningAbility' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, TaskInstanceName) == 0x000008, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, Rotation_0) == 0x000010, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::Rotation_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, Distance_0) == 0x000028, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::Distance_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, Height_0) == 0x00002C, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::Height_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, Duration_0) == 0x000030, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::Duration_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, MinimumLandedTriggerTime_0) == 0x000034, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::MinimumLandedTriggerTime_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, bFinishOnLanded_0) == 0x000038, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::bFinishOnLanded_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, VelocityOnFinishMode) == 0x000039, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::VelocityOnFinishMode' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, SetVelocityOnFinish) == 0x000040, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::SetVelocityOnFinish' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, ClampVelocityOnFinish) == 0x000058, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::ClampVelocityOnFinish' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, PathOffsetCurve_0) == 0x000060, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::PathOffsetCurve_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, TimeMappingCurve_0) == 0x000068, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::TimeMappingCurve_0' has a wrong offset!");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce, ReturnValue) == 0x000070, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_X6ApplyRootMotionJumpForce::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilityTask_ApplyRootMotionJumpForce.OnLandedCallback
// 0x00F8 (0x00F8 - 0x0000)
struct X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback) == 0x000008, "Wrong alignment on X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback");
static_assert(sizeof(X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback) == 0x0000F8, "Wrong size on X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback");
static_assert(offsetof(X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback, Hit) == 0x000000, "Member 'X6AbilityTask_ApplyRootMotionJumpForce_OnLandedCallback::Hit' has a wrong offset!");

// Function X6Game.X6GameplayAbility.ChangeActivationGroup
// 0x0002 (0x0002 - 0x0000)
struct X6GameplayAbility_ChangeActivationGroup final
{
public:
	EX6AbilityActivationGroup                     NewGroup;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameplayAbility_ChangeActivationGroup) == 0x000001, "Wrong alignment on X6GameplayAbility_ChangeActivationGroup");
static_assert(sizeof(X6GameplayAbility_ChangeActivationGroup) == 0x000002, "Wrong size on X6GameplayAbility_ChangeActivationGroup");
static_assert(offsetof(X6GameplayAbility_ChangeActivationGroup, NewGroup) == 0x000000, "Member 'X6GameplayAbility_ChangeActivationGroup::NewGroup' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_ChangeActivationGroup, ReturnValue) == 0x000001, "Member 'X6GameplayAbility_ChangeActivationGroup::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.MontageDisableRootMotion
// 0x0001 (0x0001 - 0x0000)
struct X6GameplayAbility_MontageDisableRootMotion final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameplayAbility_MontageDisableRootMotion) == 0x000001, "Wrong alignment on X6GameplayAbility_MontageDisableRootMotion");
static_assert(sizeof(X6GameplayAbility_MontageDisableRootMotion) == 0x000001, "Wrong size on X6GameplayAbility_MontageDisableRootMotion");
static_assert(offsetof(X6GameplayAbility_MontageDisableRootMotion, bDisable) == 0x000000, "Member 'X6GameplayAbility_MontageDisableRootMotion::bDisable' has a wrong offset!");

// Function X6Game.X6GameplayAbility.SendGameplayEventWithRet
// 0x00C0 (0x00C0 - 0x0000)
struct X6GameplayAbility_SendGameplayEventWithRet final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x00B8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GameplayAbility_SendGameplayEventWithRet) == 0x000008, "Wrong alignment on X6GameplayAbility_SendGameplayEventWithRet");
static_assert(sizeof(X6GameplayAbility_SendGameplayEventWithRet) == 0x0000C0, "Wrong size on X6GameplayAbility_SendGameplayEventWithRet");
static_assert(offsetof(X6GameplayAbility_SendGameplayEventWithRet, EventTag) == 0x000000, "Member 'X6GameplayAbility_SendGameplayEventWithRet::EventTag' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_SendGameplayEventWithRet, Payload) == 0x000008, "Member 'X6GameplayAbility_SendGameplayEventWithRet::Payload' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_SendGameplayEventWithRet, ReturnValue) == 0x0000B8, "Member 'X6GameplayAbility_SendGameplayEventWithRet::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.CanChangeActivationGroup
// 0x0002 (0x0002 - 0x0000)
struct X6GameplayAbility_CanChangeActivationGroup final
{
public:
	EX6AbilityActivationGroup                     NewGroup;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameplayAbility_CanChangeActivationGroup) == 0x000001, "Wrong alignment on X6GameplayAbility_CanChangeActivationGroup");
static_assert(sizeof(X6GameplayAbility_CanChangeActivationGroup) == 0x000002, "Wrong size on X6GameplayAbility_CanChangeActivationGroup");
static_assert(offsetof(X6GameplayAbility_CanChangeActivationGroup, NewGroup) == 0x000000, "Member 'X6GameplayAbility_CanChangeActivationGroup::NewGroup' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_CanChangeActivationGroup, ReturnValue) == 0x000001, "Member 'X6GameplayAbility_CanChangeActivationGroup::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.GetX6AbilitySystemComponentFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo final
{
public:
	class UX6AbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo) == 0x000008, "Wrong alignment on X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo");
static_assert(sizeof(X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo) == 0x000008, "Wrong size on X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo");
static_assert(offsetof(X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo, ReturnValue) == 0x000000, "Member 'X6GameplayAbility_GetX6AbilitySystemComponentFromActorInfo::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.HasAnyTag
// 0x0028 (0x0028 - 0x0000)
struct X6GameplayAbility_HasAnyTag final
{
public:
	struct FGameplayTagContainer                  ContainerToCheck;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GameplayAbility_HasAnyTag) == 0x000008, "Wrong alignment on X6GameplayAbility_HasAnyTag");
static_assert(sizeof(X6GameplayAbility_HasAnyTag) == 0x000028, "Wrong size on X6GameplayAbility_HasAnyTag");
static_assert(offsetof(X6GameplayAbility_HasAnyTag, ContainerToCheck) == 0x000000, "Member 'X6GameplayAbility_HasAnyTag::ContainerToCheck' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_HasAnyTag, ReturnValue) == 0x000020, "Member 'X6GameplayAbility_HasAnyTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.HasTag
// 0x000C (0x000C - 0x0000)
struct X6GameplayAbility_HasTag final
{
public:
	struct FGameplayTag                           TagToCheck;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GameplayAbility_HasTag) == 0x000004, "Wrong alignment on X6GameplayAbility_HasTag");
static_assert(sizeof(X6GameplayAbility_HasTag) == 0x00000C, "Wrong size on X6GameplayAbility_HasTag");
static_assert(offsetof(X6GameplayAbility_HasTag, TagToCheck) == 0x000000, "Member 'X6GameplayAbility_HasTag::TagToCheck' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_HasTag, ReturnValue) == 0x000008, "Member 'X6GameplayAbility_HasTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.K2_CanActivateAbilityEx
// 0x0050 (0x0050 - 0x0000)
struct X6GameplayAbility_K2_CanActivateAbilityEx final
{
public:
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0000(0x0048)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0048(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GameplayAbility_K2_CanActivateAbilityEx) == 0x000008, "Wrong alignment on X6GameplayAbility_K2_CanActivateAbilityEx");
static_assert(sizeof(X6GameplayAbility_K2_CanActivateAbilityEx) == 0x000050, "Wrong size on X6GameplayAbility_K2_CanActivateAbilityEx");
static_assert(offsetof(X6GameplayAbility_K2_CanActivateAbilityEx, ActorInfo) == 0x000000, "Member 'X6GameplayAbility_K2_CanActivateAbilityEx::ActorInfo' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_K2_CanActivateAbilityEx, Handle) == 0x000048, "Member 'X6GameplayAbility_K2_CanActivateAbilityEx::Handle' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_K2_CanActivateAbilityEx, ReturnValue) == 0x00004C, "Member 'X6GameplayAbility_K2_CanActivateAbilityEx::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.K2_OnCheckCooldown
// 0x0010 (0x0010 - 0x0000)
struct X6GameplayAbility_K2_OnCheckCooldown final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GameplayAbility_K2_OnCheckCooldown) == 0x000008, "Wrong alignment on X6GameplayAbility_K2_OnCheckCooldown");
static_assert(sizeof(X6GameplayAbility_K2_OnCheckCooldown) == 0x000010, "Wrong size on X6GameplayAbility_K2_OnCheckCooldown");
static_assert(offsetof(X6GameplayAbility_K2_OnCheckCooldown, OwnerActor) == 0x000000, "Member 'X6GameplayAbility_K2_OnCheckCooldown::OwnerActor' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_K2_OnCheckCooldown, ReturnValue) == 0x000008, "Member 'X6GameplayAbility_K2_OnCheckCooldown::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.K2_OnCheckCost
// 0x0010 (0x0010 - 0x0000)
struct X6GameplayAbility_K2_OnCheckCost final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6GameplayAbility_K2_OnCheckCost) == 0x000008, "Wrong alignment on X6GameplayAbility_K2_OnCheckCost");
static_assert(sizeof(X6GameplayAbility_K2_OnCheckCost) == 0x000010, "Wrong size on X6GameplayAbility_K2_OnCheckCost");
static_assert(offsetof(X6GameplayAbility_K2_OnCheckCost, OwnerActor) == 0x000000, "Member 'X6GameplayAbility_K2_OnCheckCost::OwnerActor' has a wrong offset!");
static_assert(offsetof(X6GameplayAbility_K2_OnCheckCost, ReturnValue) == 0x000008, "Member 'X6GameplayAbility_K2_OnCheckCost::ReturnValue' has a wrong offset!");

// Function X6Game.X6GameplayAbility.ScriptOnAbilityFailedToActivate
// 0x0020 (0x0020 - 0x0000)
struct X6GameplayAbility_ScriptOnAbilityFailedToActivate final
{
public:
	struct FGameplayTagContainer                  FailedReason;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6GameplayAbility_ScriptOnAbilityFailedToActivate) == 0x000008, "Wrong alignment on X6GameplayAbility_ScriptOnAbilityFailedToActivate");
static_assert(sizeof(X6GameplayAbility_ScriptOnAbilityFailedToActivate) == 0x000020, "Wrong size on X6GameplayAbility_ScriptOnAbilityFailedToActivate");
static_assert(offsetof(X6GameplayAbility_ScriptOnAbilityFailedToActivate, FailedReason) == 0x000000, "Member 'X6GameplayAbility_ScriptOnAbilityFailedToActivate::FailedReason' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.AbilityInputTagPressed
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_AbilityInputTagPressed final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_AbilityInputTagPressed) == 0x000004, "Wrong alignment on X6AbilitySystemComponent_AbilityInputTagPressed");
static_assert(sizeof(X6AbilitySystemComponent_AbilityInputTagPressed) == 0x000008, "Wrong size on X6AbilitySystemComponent_AbilityInputTagPressed");
static_assert(offsetof(X6AbilitySystemComponent_AbilityInputTagPressed, InputTag) == 0x000000, "Member 'X6AbilitySystemComponent_AbilityInputTagPressed::InputTag' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.AbilityInputTagReleased
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_AbilityInputTagReleased final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_AbilityInputTagReleased) == 0x000004, "Wrong alignment on X6AbilitySystemComponent_AbilityInputTagReleased");
static_assert(sizeof(X6AbilitySystemComponent_AbilityInputTagReleased) == 0x000008, "Wrong size on X6AbilitySystemComponent_AbilityInputTagReleased");
static_assert(offsetof(X6AbilitySystemComponent_AbilityInputTagReleased, InputTag) == 0x000000, "Member 'X6AbilitySystemComponent_AbilityInputTagReleased::InputTag' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.AddGenericTarget
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_AddGenericTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_AddGenericTarget) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_AddGenericTarget");
static_assert(sizeof(X6AbilitySystemComponent_AddGenericTarget) == 0x000008, "Wrong size on X6AbilitySystemComponent_AddGenericTarget");
static_assert(offsetof(X6AbilitySystemComponent_AddGenericTarget, Target) == 0x000000, "Member 'X6AbilitySystemComponent_AddGenericTarget::Target' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.AddGenericTargetHitResult
// 0x00F8 (0x00F8 - 0x0000)
struct X6AbilitySystemComponent_AddGenericTargetHitResult final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_AddGenericTargetHitResult) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_AddGenericTargetHitResult");
static_assert(sizeof(X6AbilitySystemComponent_AddGenericTargetHitResult) == 0x0000F8, "Wrong size on X6AbilitySystemComponent_AddGenericTargetHitResult");
static_assert(offsetof(X6AbilitySystemComponent_AddGenericTargetHitResult, HitResult) == 0x000000, "Member 'X6AbilitySystemComponent_AddGenericTargetHitResult::HitResult' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.ClientNotifyAbilityFailed
// 0x0028 (0x0028 - 0x0000)
struct X6AbilitySystemComponent_ClientNotifyAbilityFailed final
{
public:
	const class UGameplayAbility*                 Ability;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FailureReason;                                     // 0x0008(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_ClientNotifyAbilityFailed) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_ClientNotifyAbilityFailed");
static_assert(sizeof(X6AbilitySystemComponent_ClientNotifyAbilityFailed) == 0x000028, "Wrong size on X6AbilitySystemComponent_ClientNotifyAbilityFailed");
static_assert(offsetof(X6AbilitySystemComponent_ClientNotifyAbilityFailed, Ability) == 0x000000, "Member 'X6AbilitySystemComponent_ClientNotifyAbilityFailed::Ability' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_ClientNotifyAbilityFailed, FailureReason) == 0x000008, "Member 'X6AbilitySystemComponent_ClientNotifyAbilityFailed::FailureReason' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.CurrentMontageDisableRootMotion
// 0x0001 (0x0001 - 0x0000)
struct X6AbilitySystemComponent_CurrentMontageDisableRootMotion final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_CurrentMontageDisableRootMotion) == 0x000001, "Wrong alignment on X6AbilitySystemComponent_CurrentMontageDisableRootMotion");
static_assert(sizeof(X6AbilitySystemComponent_CurrentMontageDisableRootMotion) == 0x000001, "Wrong size on X6AbilitySystemComponent_CurrentMontageDisableRootMotion");
static_assert(offsetof(X6AbilitySystemComponent_CurrentMontageDisableRootMotion, bDisable) == 0x000000, "Member 'X6AbilitySystemComponent_CurrentMontageDisableRootMotion::bDisable' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.EnableComboInputCache
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemComponent_EnableComboInputCache final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UComboInputData*>                InComboInputDataList;                              // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_EnableComboInputCache) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_EnableComboInputCache");
static_assert(sizeof(X6AbilitySystemComponent_EnableComboInputCache) == 0x000018, "Wrong size on X6AbilitySystemComponent_EnableComboInputCache");
static_assert(offsetof(X6AbilitySystemComponent_EnableComboInputCache, bEnable) == 0x000000, "Member 'X6AbilitySystemComponent_EnableComboInputCache::bEnable' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_EnableComboInputCache, InComboInputDataList) == 0x000008, "Member 'X6AbilitySystemComponent_EnableComboInputCache::InComboInputDataList' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.GetGenericTargetActorByIndex
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_GetGenericTargetActorByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_GetGenericTargetActorByIndex) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_GetGenericTargetActorByIndex");
static_assert(sizeof(X6AbilitySystemComponent_GetGenericTargetActorByIndex) == 0x000010, "Wrong size on X6AbilitySystemComponent_GetGenericTargetActorByIndex");
static_assert(offsetof(X6AbilitySystemComponent_GetGenericTargetActorByIndex, Index_0) == 0x000000, "Member 'X6AbilitySystemComponent_GetGenericTargetActorByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_GetGenericTargetActorByIndex, ReturnValue) == 0x000008, "Member 'X6AbilitySystemComponent_GetGenericTargetActorByIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.GetGenericTargetComponentByIndex
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_GetGenericTargetComponentByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_GetGenericTargetComponentByIndex) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_GetGenericTargetComponentByIndex");
static_assert(sizeof(X6AbilitySystemComponent_GetGenericTargetComponentByIndex) == 0x000010, "Wrong size on X6AbilitySystemComponent_GetGenericTargetComponentByIndex");
static_assert(offsetof(X6AbilitySystemComponent_GetGenericTargetComponentByIndex, Index_0) == 0x000000, "Member 'X6AbilitySystemComponent_GetGenericTargetComponentByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_GetGenericTargetComponentByIndex, ReturnValue) == 0x000008, "Member 'X6AbilitySystemComponent_GetGenericTargetComponentByIndex::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_CancelAbilitesByTag
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_K2_CancelAbilitesByTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_K2_CancelAbilitesByTag) == 0x000004, "Wrong alignment on X6AbilitySystemComponent_K2_CancelAbilitesByTag");
static_assert(sizeof(X6AbilitySystemComponent_K2_CancelAbilitesByTag) == 0x000008, "Wrong size on X6AbilitySystemComponent_K2_CancelAbilitesByTag");
static_assert(offsetof(X6AbilitySystemComponent_K2_CancelAbilitesByTag, Tag) == 0x000000, "Member 'X6AbilitySystemComponent_K2_CancelAbilitesByTag::Tag' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_ClearAbilitiesFromClass
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_K2_ClearAbilitiesFromClass final
{
public:
	TSubclassOf<class UX6GameplayAbility>         InAbilityClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearOnlyOnce;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_K2_ClearAbilitiesFromClass) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_K2_ClearAbilitiesFromClass");
static_assert(sizeof(X6AbilitySystemComponent_K2_ClearAbilitiesFromClass) == 0x000010, "Wrong size on X6AbilitySystemComponent_K2_ClearAbilitiesFromClass");
static_assert(offsetof(X6AbilitySystemComponent_K2_ClearAbilitiesFromClass, InAbilityClass) == 0x000000, "Member 'X6AbilitySystemComponent_K2_ClearAbilitiesFromClass::InAbilityClass' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_ClearAbilitiesFromClass, bClearOnlyOnce) == 0x000008, "Member 'X6AbilitySystemComponent_K2_ClearAbilitiesFromClass::bClearOnlyOnce' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_GetAnimatingAbility
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_K2_GetAnimatingAbility final
{
public:
	class UGameplayAbility*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_K2_GetAnimatingAbility) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_K2_GetAnimatingAbility");
static_assert(sizeof(X6AbilitySystemComponent_K2_GetAnimatingAbility) == 0x000008, "Wrong size on X6AbilitySystemComponent_K2_GetAnimatingAbility");
static_assert(offsetof(X6AbilitySystemComponent_K2_GetAnimatingAbility, ReturnValue) == 0x000000, "Member 'X6AbilitySystemComponent_K2_GetAnimatingAbility::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_GiveAbilityWithInputTag
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemComponent_K2_GiveAbilityWithInputTag final
{
public:
	TSubclassOf<class UX6GameplayAbility>         InAbilityClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_K2_GiveAbilityWithInputTag) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_K2_GiveAbilityWithInputTag");
static_assert(sizeof(X6AbilitySystemComponent_K2_GiveAbilityWithInputTag) == 0x000018, "Wrong size on X6AbilitySystemComponent_K2_GiveAbilityWithInputTag");
static_assert(offsetof(X6AbilitySystemComponent_K2_GiveAbilityWithInputTag, InAbilityClass) == 0x000000, "Member 'X6AbilitySystemComponent_K2_GiveAbilityWithInputTag::InAbilityClass' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_GiveAbilityWithInputTag, InputTag) == 0x000008, "Member 'X6AbilitySystemComponent_K2_GiveAbilityWithInputTag::InputTag' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_GiveAbilityWithInputTag, ReturnValue) == 0x000010, "Member 'X6AbilitySystemComponent_K2_GiveAbilityWithInputTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_ReceiveEndPlay
// 0x0001 (0x0001 - 0x0000)
struct X6AbilitySystemComponent_K2_ReceiveEndPlay final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_K2_ReceiveEndPlay) == 0x000001, "Wrong alignment on X6AbilitySystemComponent_K2_ReceiveEndPlay");
static_assert(sizeof(X6AbilitySystemComponent_K2_ReceiveEndPlay) == 0x000001, "Wrong size on X6AbilitySystemComponent_K2_ReceiveEndPlay");
static_assert(offsetof(X6AbilitySystemComponent_K2_ReceiveEndPlay, EndPlayReason) == 0x000000, "Member 'X6AbilitySystemComponent_K2_ReceiveEndPlay::EndPlayReason' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_SetSkillEndBlock
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_K2_SetSkillEndBlock final
{
public:
	int32                                         GroupID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlock;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_K2_SetSkillEndBlock) == 0x000004, "Wrong alignment on X6AbilitySystemComponent_K2_SetSkillEndBlock");
static_assert(sizeof(X6AbilitySystemComponent_K2_SetSkillEndBlock) == 0x000008, "Wrong size on X6AbilitySystemComponent_K2_SetSkillEndBlock");
static_assert(offsetof(X6AbilitySystemComponent_K2_SetSkillEndBlock, GroupID) == 0x000000, "Member 'X6AbilitySystemComponent_K2_SetSkillEndBlock::GroupID' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_SetSkillEndBlock, bShouldBlock) == 0x000004, "Member 'X6AbilitySystemComponent_K2_SetSkillEndBlock::bShouldBlock' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_SpawnBullet
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemComponent_K2_SpawnBullet final
{
public:
	class UPrimaryDataAsset*                      TriggerData;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsModifyHitDirection;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_K2_SpawnBullet) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_K2_SpawnBullet");
static_assert(sizeof(X6AbilitySystemComponent_K2_SpawnBullet) == 0x000018, "Wrong size on X6AbilitySystemComponent_K2_SpawnBullet");
static_assert(offsetof(X6AbilitySystemComponent_K2_SpawnBullet, TriggerData) == 0x000000, "Member 'X6AbilitySystemComponent_K2_SpawnBullet::TriggerData' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_SpawnBullet, IsModifyHitDirection) == 0x000008, "Member 'X6AbilitySystemComponent_K2_SpawnBullet::IsModifyHitDirection' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_SpawnBullet, TargetActor) == 0x000010, "Member 'X6AbilitySystemComponent_K2_SpawnBullet::TargetActor' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.OnPlayedMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_OnPlayedMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_OnPlayedMontageEnded) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_OnPlayedMontageEnded");
static_assert(sizeof(X6AbilitySystemComponent_OnPlayedMontageEnded) == 0x000010, "Wrong size on X6AbilitySystemComponent_OnPlayedMontageEnded");
static_assert(offsetof(X6AbilitySystemComponent_OnPlayedMontageEnded, Montage) == 0x000000, "Member 'X6AbilitySystemComponent_OnPlayedMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_OnPlayedMontageEnded, bInterrupted) == 0x000008, "Member 'X6AbilitySystemComponent_OnPlayedMontageEnded::bInterrupted' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.RemoveGenericTarget
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_RemoveGenericTarget final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_RemoveGenericTarget) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_RemoveGenericTarget");
static_assert(sizeof(X6AbilitySystemComponent_RemoveGenericTarget) == 0x000008, "Wrong size on X6AbilitySystemComponent_RemoveGenericTarget");
static_assert(offsetof(X6AbilitySystemComponent_RemoveGenericTarget, Target) == 0x000000, "Member 'X6AbilitySystemComponent_RemoveGenericTarget::Target' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.SetTagRelationshipMapping
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_SetTagRelationshipMapping final
{
public:
	class UX6AbilityTagRelationshipMapping*       NewMapping;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_SetTagRelationshipMapping) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_SetTagRelationshipMapping");
static_assert(sizeof(X6AbilitySystemComponent_SetTagRelationshipMapping) == 0x000008, "Wrong size on X6AbilitySystemComponent_SetTagRelationshipMapping");
static_assert(offsetof(X6AbilitySystemComponent_SetTagRelationshipMapping, NewMapping) == 0x000000, "Member 'X6AbilitySystemComponent_SetTagRelationshipMapping::NewMapping' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.UpdateNextComboInputList
// 0x0018 (0x0018 - 0x0000)
struct X6AbilitySystemComponent_UpdateNextComboInputList final
{
public:
	TArray<class UComboInputData*>                InComboInputDataList;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ActivationDuration;                                // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_UpdateNextComboInputList) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_UpdateNextComboInputList");
static_assert(sizeof(X6AbilitySystemComponent_UpdateNextComboInputList) == 0x000018, "Wrong size on X6AbilitySystemComponent_UpdateNextComboInputList");
static_assert(offsetof(X6AbilitySystemComponent_UpdateNextComboInputList, InComboInputDataList) == 0x000000, "Member 'X6AbilitySystemComponent_UpdateNextComboInputList::InComboInputDataList' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_UpdateNextComboInputList, ActivationDuration) == 0x000010, "Member 'X6AbilitySystemComponent_UpdateNextComboInputList::ActivationDuration' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.X6HasActivatableAbilityClass
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_X6HasActivatableAbilityClass final
{
public:
	TSubclassOf<class UGameplayAbility>           InAbilityToActivate;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_X6HasActivatableAbilityClass) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_X6HasActivatableAbilityClass");
static_assert(sizeof(X6AbilitySystemComponent_X6HasActivatableAbilityClass) == 0x000010, "Wrong size on X6AbilitySystemComponent_X6HasActivatableAbilityClass");
static_assert(offsetof(X6AbilitySystemComponent_X6HasActivatableAbilityClass, InAbilityToActivate) == 0x000000, "Member 'X6AbilitySystemComponent_X6HasActivatableAbilityClass::InAbilityToActivate' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_X6HasActivatableAbilityClass, ReturnValue) == 0x000008, "Member 'X6AbilitySystemComponent_X6HasActivatableAbilityClass::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.X6HasActivatableTriggeredAbility
// 0x000C (0x000C - 0x0000)
struct X6AbilitySystemComponent_X6HasActivatableTriggeredAbility final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_X6HasActivatableTriggeredAbility) == 0x000004, "Wrong alignment on X6AbilitySystemComponent_X6HasActivatableTriggeredAbility");
static_assert(sizeof(X6AbilitySystemComponent_X6HasActivatableTriggeredAbility) == 0x00000C, "Wrong size on X6AbilitySystemComponent_X6HasActivatableTriggeredAbility");
static_assert(offsetof(X6AbilitySystemComponent_X6HasActivatableTriggeredAbility, Tag) == 0x000000, "Member 'X6AbilitySystemComponent_X6HasActivatableTriggeredAbility::Tag' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_X6HasActivatableTriggeredAbility, ReturnValue) == 0x000008, "Member 'X6AbilitySystemComponent_X6HasActivatableTriggeredAbility::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.GetGenericTargetActors
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_GetGenericTargetActors final
{
public:
	TArray<class AActor*>                         OutTargetActors;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_GetGenericTargetActors) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_GetGenericTargetActors");
static_assert(sizeof(X6AbilitySystemComponent_GetGenericTargetActors) == 0x000010, "Wrong size on X6AbilitySystemComponent_GetGenericTargetActors");
static_assert(offsetof(X6AbilitySystemComponent_GetGenericTargetActors, OutTargetActors) == 0x000000, "Member 'X6AbilitySystemComponent_GetGenericTargetActors::OutTargetActors' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.GetGenericTargetComponents
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_GetGenericTargetComponents final
{
public:
	TArray<class USceneComponent*>                OutTargetComponents;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_GetGenericTargetComponents) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_GetGenericTargetComponents");
static_assert(sizeof(X6AbilitySystemComponent_GetGenericTargetComponents) == 0x000010, "Wrong size on X6AbilitySystemComponent_GetGenericTargetComponents");
static_assert(offsetof(X6AbilitySystemComponent_GetGenericTargetComponents, OutTargetComponents) == 0x000000, "Member 'X6AbilitySystemComponent_GetGenericTargetComponents::OutTargetComponents' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_GetActiveAbilityByTag
// 0x0010 (0x0010 - 0x0000)
struct X6AbilitySystemComponent_K2_GetActiveAbilityByTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AbilitySystemComponent_K2_GetActiveAbilityByTag) == 0x000008, "Wrong alignment on X6AbilitySystemComponent_K2_GetActiveAbilityByTag");
static_assert(sizeof(X6AbilitySystemComponent_K2_GetActiveAbilityByTag) == 0x000010, "Wrong size on X6AbilitySystemComponent_K2_GetActiveAbilityByTag");
static_assert(offsetof(X6AbilitySystemComponent_K2_GetActiveAbilityByTag, Tag) == 0x000000, "Member 'X6AbilitySystemComponent_K2_GetActiveAbilityByTag::Tag' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_GetActiveAbilityByTag, ReturnValue) == 0x000008, "Member 'X6AbilitySystemComponent_K2_GetActiveAbilityByTag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AbilitySystemComponent.K2_GetSkillEndFlag
// 0x0008 (0x0008 - 0x0000)
struct X6AbilitySystemComponent_K2_GetSkillEndFlag final
{
public:
	int32                                         GroupID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6AbilitySystemComponent_K2_GetSkillEndFlag) == 0x000004, "Wrong alignment on X6AbilitySystemComponent_K2_GetSkillEndFlag");
static_assert(sizeof(X6AbilitySystemComponent_K2_GetSkillEndFlag) == 0x000008, "Wrong size on X6AbilitySystemComponent_K2_GetSkillEndFlag");
static_assert(offsetof(X6AbilitySystemComponent_K2_GetSkillEndFlag, GroupID) == 0x000000, "Member 'X6AbilitySystemComponent_K2_GetSkillEndFlag::GroupID' has a wrong offset!");
static_assert(offsetof(X6AbilitySystemComponent_K2_GetSkillEndFlag, ReturnValue) == 0x000004, "Member 'X6AbilitySystemComponent_K2_GetSkillEndFlag::ReturnValue' has a wrong offset!");

// Function X6Game.X6AnimNotify_PlayNiagaraEffect.GetSpawnedEffect
// 0x0008 (0x0008 - 0x0000)
struct X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect final
{
public:
	class UFXSystemComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect) == 0x000008, "Wrong alignment on X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect");
static_assert(sizeof(X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect) == 0x000008, "Wrong size on X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect");
static_assert(offsetof(X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect, ReturnValue) == 0x000000, "Member 'X6AnimNotify_PlayNiagaraEffect_GetSpawnedEffect::ReturnValue' has a wrong offset!");

// Function X6Game.CombatCollisionInterface.GetCombatFilterPriority
// 0x0004 (0x0004 - 0x0000)
struct CombatCollisionInterface_GetCombatFilterPriority final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CombatCollisionInterface_GetCombatFilterPriority) == 0x000004, "Wrong alignment on CombatCollisionInterface_GetCombatFilterPriority");
static_assert(sizeof(CombatCollisionInterface_GetCombatFilterPriority) == 0x000004, "Wrong size on CombatCollisionInterface_GetCombatFilterPriority");
static_assert(offsetof(CombatCollisionInterface_GetCombatFilterPriority, ReturnValue) == 0x000000, "Member 'CombatCollisionInterface_GetCombatFilterPriority::ReturnValue' has a wrong offset!");

// Function X6Game.CombatCollisionInterface.IsCombatBulletFilter
// 0x0001 (0x0001 - 0x0000)
struct CombatCollisionInterface_IsCombatBulletFilter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CombatCollisionInterface_IsCombatBulletFilter) == 0x000001, "Wrong alignment on CombatCollisionInterface_IsCombatBulletFilter");
static_assert(sizeof(CombatCollisionInterface_IsCombatBulletFilter) == 0x000001, "Wrong size on CombatCollisionInterface_IsCombatBulletFilter");
static_assert(offsetof(CombatCollisionInterface_IsCombatBulletFilter, ReturnValue) == 0x000000, "Member 'CombatCollisionInterface_IsCombatBulletFilter::ReturnValue' has a wrong offset!");

// Function X6Game.CombatCollisionInterface.IsCombatHitCollision
// 0x0001 (0x0001 - 0x0000)
struct CombatCollisionInterface_IsCombatHitCollision final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CombatCollisionInterface_IsCombatHitCollision) == 0x000001, "Wrong alignment on CombatCollisionInterface_IsCombatHitCollision");
static_assert(sizeof(CombatCollisionInterface_IsCombatHitCollision) == 0x000001, "Wrong size on CombatCollisionInterface_IsCombatHitCollision");
static_assert(offsetof(CombatCollisionInterface_IsCombatHitCollision, ReturnValue) == 0x000000, "Member 'CombatCollisionInterface_IsCombatHitCollision::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.AddItem
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_AddItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_AddItem) == 0x000008, "Wrong alignment on X6ArcListView_AddItem");
static_assert(sizeof(X6ArcListView_AddItem) == 0x000008, "Wrong size on X6ArcListView_AddItem");
static_assert(offsetof(X6ArcListView_AddItem, Item) == 0x000000, "Member 'X6ArcListView_AddItem::Item' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_NavigateToItem
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_BP_NavigateToItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_NavigateToItem) == 0x000008, "Wrong alignment on X6ArcListView_BP_NavigateToItem");
static_assert(sizeof(X6ArcListView_BP_NavigateToItem) == 0x000008, "Wrong size on X6ArcListView_BP_NavigateToItem");
static_assert(offsetof(X6ArcListView_BP_NavigateToItem, Item) == 0x000000, "Member 'X6ArcListView_BP_NavigateToItem::Item' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_NavigateToWidget
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_BP_NavigateToWidget final
{
public:
	class UUserWidget*                            EntryWidget;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_NavigateToWidget) == 0x000008, "Wrong alignment on X6ArcListView_BP_NavigateToWidget");
static_assert(sizeof(X6ArcListView_BP_NavigateToWidget) == 0x000008, "Wrong size on X6ArcListView_BP_NavigateToWidget");
static_assert(offsetof(X6ArcListView_BP_NavigateToWidget, EntryWidget) == 0x000000, "Member 'X6ArcListView_BP_NavigateToWidget::EntryWidget' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_ScrollItemIntoView
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_BP_ScrollItemIntoView final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_ScrollItemIntoView) == 0x000008, "Wrong alignment on X6ArcListView_BP_ScrollItemIntoView");
static_assert(sizeof(X6ArcListView_BP_ScrollItemIntoView) == 0x000008, "Wrong size on X6ArcListView_BP_ScrollItemIntoView");
static_assert(offsetof(X6ArcListView_BP_ScrollItemIntoView, Item) == 0x000000, "Member 'X6ArcListView_BP_ScrollItemIntoView::Item' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_SetItemSelection
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_BP_SetItemSelection final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ArcListView_BP_SetItemSelection) == 0x000008, "Wrong alignment on X6ArcListView_BP_SetItemSelection");
static_assert(sizeof(X6ArcListView_BP_SetItemSelection) == 0x000010, "Wrong size on X6ArcListView_BP_SetItemSelection");
static_assert(offsetof(X6ArcListView_BP_SetItemSelection, Item) == 0x000000, "Member 'X6ArcListView_BP_SetItemSelection::Item' has a wrong offset!");
static_assert(offsetof(X6ArcListView_BP_SetItemSelection, bSelected) == 0x000008, "Member 'X6ArcListView_BP_SetItemSelection::bSelected' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_SetListItems
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_BP_SetListItems final
{
public:
	TArray<class UObject*>                        InListItems;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_SetListItems) == 0x000008, "Wrong alignment on X6ArcListView_BP_SetListItems");
static_assert(sizeof(X6ArcListView_BP_SetListItems) == 0x000010, "Wrong size on X6ArcListView_BP_SetListItems");
static_assert(offsetof(X6ArcListView_BP_SetListItems, InListItems) == 0x000000, "Member 'X6ArcListView_BP_SetListItems::InListItems' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_SetSelectedItem
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_BP_SetSelectedItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_SetSelectedItem) == 0x000008, "Wrong alignment on X6ArcListView_BP_SetSelectedItem");
static_assert(sizeof(X6ArcListView_BP_SetSelectedItem) == 0x000008, "Wrong size on X6ArcListView_BP_SetSelectedItem");
static_assert(offsetof(X6ArcListView_BP_SetSelectedItem, Item) == 0x000000, "Member 'X6ArcListView_BP_SetSelectedItem::Item' has a wrong offset!");

// Function X6Game.X6ArcListView.NavigateToIndex
// 0x0004 (0x0004 - 0x0000)
struct X6ArcListView_NavigateToIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_NavigateToIndex) == 0x000004, "Wrong alignment on X6ArcListView_NavigateToIndex");
static_assert(sizeof(X6ArcListView_NavigateToIndex) == 0x000004, "Wrong size on X6ArcListView_NavigateToIndex");
static_assert(offsetof(X6ArcListView_NavigateToIndex, Index_0) == 0x000000, "Member 'X6ArcListView_NavigateToIndex::Index_0' has a wrong offset!");

// Function X6Game.X6ArcListView.OnListItemEndPlayed
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_OnListItemEndPlayed final
{
public:
	class AActor*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ArcListView_OnListItemEndPlayed) == 0x000008, "Wrong alignment on X6ArcListView_OnListItemEndPlayed");
static_assert(sizeof(X6ArcListView_OnListItemEndPlayed) == 0x000010, "Wrong size on X6ArcListView_OnListItemEndPlayed");
static_assert(offsetof(X6ArcListView_OnListItemEndPlayed, Item) == 0x000000, "Member 'X6ArcListView_OnListItemEndPlayed::Item' has a wrong offset!");
static_assert(offsetof(X6ArcListView_OnListItemEndPlayed, EndPlayReason) == 0x000008, "Member 'X6ArcListView_OnListItemEndPlayed::EndPlayReason' has a wrong offset!");

// Function X6Game.X6ArcListView.OnListItemOuterEndPlayed
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_OnListItemOuterEndPlayed final
{
public:
	class AActor*                                 ItemOuter;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ArcListView_OnListItemOuterEndPlayed) == 0x000008, "Wrong alignment on X6ArcListView_OnListItemOuterEndPlayed");
static_assert(sizeof(X6ArcListView_OnListItemOuterEndPlayed) == 0x000010, "Wrong size on X6ArcListView_OnListItemOuterEndPlayed");
static_assert(offsetof(X6ArcListView_OnListItemOuterEndPlayed, ItemOuter) == 0x000000, "Member 'X6ArcListView_OnListItemOuterEndPlayed::ItemOuter' has a wrong offset!");
static_assert(offsetof(X6ArcListView_OnListItemOuterEndPlayed, EndPlayReason) == 0x000008, "Member 'X6ArcListView_OnListItemOuterEndPlayed::EndPlayReason' has a wrong offset!");

// Function X6Game.X6ArcListView.RemoveItem
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_RemoveItem final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_RemoveItem) == 0x000008, "Wrong alignment on X6ArcListView_RemoveItem");
static_assert(sizeof(X6ArcListView_RemoveItem) == 0x000008, "Wrong size on X6ArcListView_RemoveItem");
static_assert(offsetof(X6ArcListView_RemoveItem, Item) == 0x000000, "Member 'X6ArcListView_RemoveItem::Item' has a wrong offset!");

// Function X6Game.X6ArcListView.ScrollIndexIntoView
// 0x0004 (0x0004 - 0x0000)
struct X6ArcListView_ScrollIndexIntoView final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_ScrollIndexIntoView) == 0x000004, "Wrong alignment on X6ArcListView_ScrollIndexIntoView");
static_assert(sizeof(X6ArcListView_ScrollIndexIntoView) == 0x000004, "Wrong size on X6ArcListView_ScrollIndexIntoView");
static_assert(offsetof(X6ArcListView_ScrollIndexIntoView, Index_0) == 0x000000, "Member 'X6ArcListView_ScrollIndexIntoView::Index_0' has a wrong offset!");

// Function X6Game.X6ArcListView.SetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct X6ArcListView_SetSelectedIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_SetSelectedIndex) == 0x000004, "Wrong alignment on X6ArcListView_SetSelectedIndex");
static_assert(sizeof(X6ArcListView_SetSelectedIndex) == 0x000004, "Wrong size on X6ArcListView_SetSelectedIndex");
static_assert(offsetof(X6ArcListView_SetSelectedIndex, Index_0) == 0x000000, "Member 'X6ArcListView_SetSelectedIndex::Index_0' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_CanScrollWithLoop
// 0x0001 (0x0001 - 0x0000)
struct X6ArcListView_BP_CanScrollWithLoop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_CanScrollWithLoop) == 0x000001, "Wrong alignment on X6ArcListView_BP_CanScrollWithLoop");
static_assert(sizeof(X6ArcListView_BP_CanScrollWithLoop) == 0x000001, "Wrong size on X6ArcListView_BP_CanScrollWithLoop");
static_assert(offsetof(X6ArcListView_BP_CanScrollWithLoop, ReturnValue) == 0x000000, "Member 'X6ArcListView_BP_CanScrollWithLoop::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_GetNumItemsSelected
// 0x0004 (0x0004 - 0x0000)
struct X6ArcListView_BP_GetNumItemsSelected final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_GetNumItemsSelected) == 0x000004, "Wrong alignment on X6ArcListView_BP_GetNumItemsSelected");
static_assert(sizeof(X6ArcListView_BP_GetNumItemsSelected) == 0x000004, "Wrong size on X6ArcListView_BP_GetNumItemsSelected");
static_assert(offsetof(X6ArcListView_BP_GetNumItemsSelected, ReturnValue) == 0x000000, "Member 'X6ArcListView_BP_GetNumItemsSelected::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_GetSelectedItem
// 0x0008 (0x0008 - 0x0000)
struct X6ArcListView_BP_GetSelectedItem final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_BP_GetSelectedItem) == 0x000008, "Wrong alignment on X6ArcListView_BP_GetSelectedItem");
static_assert(sizeof(X6ArcListView_BP_GetSelectedItem) == 0x000008, "Wrong size on X6ArcListView_BP_GetSelectedItem");
static_assert(offsetof(X6ArcListView_BP_GetSelectedItem, ReturnValue) == 0x000000, "Member 'X6ArcListView_BP_GetSelectedItem::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_GetSelectedItems
// 0x0018 (0x0018 - 0x0000)
struct X6ArcListView_BP_GetSelectedItems final
{
public:
	TArray<class UObject*>                        Items;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ArcListView_BP_GetSelectedItems) == 0x000008, "Wrong alignment on X6ArcListView_BP_GetSelectedItems");
static_assert(sizeof(X6ArcListView_BP_GetSelectedItems) == 0x000018, "Wrong size on X6ArcListView_BP_GetSelectedItems");
static_assert(offsetof(X6ArcListView_BP_GetSelectedItems, Items) == 0x000000, "Member 'X6ArcListView_BP_GetSelectedItems::Items' has a wrong offset!");
static_assert(offsetof(X6ArcListView_BP_GetSelectedItems, ReturnValue) == 0x000010, "Member 'X6ArcListView_BP_GetSelectedItems::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.BP_IsItemVisible
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_BP_IsItemVisible final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ArcListView_BP_IsItemVisible) == 0x000008, "Wrong alignment on X6ArcListView_BP_IsItemVisible");
static_assert(sizeof(X6ArcListView_BP_IsItemVisible) == 0x000010, "Wrong size on X6ArcListView_BP_IsItemVisible");
static_assert(offsetof(X6ArcListView_BP_IsItemVisible, Item) == 0x000000, "Member 'X6ArcListView_BP_IsItemVisible::Item' has a wrong offset!");
static_assert(offsetof(X6ArcListView_BP_IsItemVisible, ReturnValue) == 0x000008, "Member 'X6ArcListView_BP_IsItemVisible::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.GetIndexForItem
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_GetIndexForItem final
{
public:
	const class UObject*                          Item;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6ArcListView_GetIndexForItem) == 0x000008, "Wrong alignment on X6ArcListView_GetIndexForItem");
static_assert(sizeof(X6ArcListView_GetIndexForItem) == 0x000010, "Wrong size on X6ArcListView_GetIndexForItem");
static_assert(offsetof(X6ArcListView_GetIndexForItem, Item) == 0x000000, "Member 'X6ArcListView_GetIndexForItem::Item' has a wrong offset!");
static_assert(offsetof(X6ArcListView_GetIndexForItem, ReturnValue) == 0x000008, "Member 'X6ArcListView_GetIndexForItem::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.GetItemAt
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_GetItemAt final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_GetItemAt) == 0x000008, "Wrong alignment on X6ArcListView_GetItemAt");
static_assert(sizeof(X6ArcListView_GetItemAt) == 0x000010, "Wrong size on X6ArcListView_GetItemAt");
static_assert(offsetof(X6ArcListView_GetItemAt, Index_0) == 0x000000, "Member 'X6ArcListView_GetItemAt::Index_0' has a wrong offset!");
static_assert(offsetof(X6ArcListView_GetItemAt, ReturnValue) == 0x000008, "Member 'X6ArcListView_GetItemAt::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.GetListItems
// 0x0010 (0x0010 - 0x0000)
struct X6ArcListView_GetListItems final
{
public:
	TArray<class UObject*>                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_GetListItems) == 0x000008, "Wrong alignment on X6ArcListView_GetListItems");
static_assert(sizeof(X6ArcListView_GetListItems) == 0x000010, "Wrong size on X6ArcListView_GetListItems");
static_assert(offsetof(X6ArcListView_GetListItems, ReturnValue) == 0x000000, "Member 'X6ArcListView_GetListItems::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.GetNumItems
// 0x0004 (0x0004 - 0x0000)
struct X6ArcListView_GetNumItems final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_GetNumItems) == 0x000004, "Wrong alignment on X6ArcListView_GetNumItems");
static_assert(sizeof(X6ArcListView_GetNumItems) == 0x000004, "Wrong size on X6ArcListView_GetNumItems");
static_assert(offsetof(X6ArcListView_GetNumItems, ReturnValue) == 0x000000, "Member 'X6ArcListView_GetNumItems::ReturnValue' has a wrong offset!");

// Function X6Game.X6ArcListView.IsRefreshPending
// 0x0001 (0x0001 - 0x0000)
struct X6ArcListView_IsRefreshPending final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6ArcListView_IsRefreshPending) == 0x000001, "Wrong alignment on X6ArcListView_IsRefreshPending");
static_assert(sizeof(X6ArcListView_IsRefreshPending) == 0x000001, "Wrong size on X6ArcListView_IsRefreshPending");
static_assert(offsetof(X6ArcListView_IsRefreshPending, ReturnValue) == 0x000000, "Member 'X6ArcListView_IsRefreshPending::ReturnValue' has a wrong offset!");

// Function X6Game.X6HitThroughImage.GetDynamicMaterial
// 0x0008 (0x0008 - 0x0000)
struct X6HitThroughImage_GetDynamicMaterial final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_GetDynamicMaterial) == 0x000008, "Wrong alignment on X6HitThroughImage_GetDynamicMaterial");
static_assert(sizeof(X6HitThroughImage_GetDynamicMaterial) == 0x000008, "Wrong size on X6HitThroughImage_GetDynamicMaterial");
static_assert(offsetof(X6HitThroughImage_GetDynamicMaterial, ReturnValue) == 0x000000, "Member 'X6HitThroughImage_GetDynamicMaterial::ReturnValue' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrush
// 0x00D0 (0x00D0 - 0x0000)
struct X6HitThroughImage_SetBrush final
{
public:
	struct FSlateBrush                            InBrush;                                           // 0x0000(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetBrush) == 0x000010, "Wrong alignment on X6HitThroughImage_SetBrush");
static_assert(sizeof(X6HitThroughImage_SetBrush) == 0x0000D0, "Wrong size on X6HitThroughImage_SetBrush");
static_assert(offsetof(X6HitThroughImage_SetBrush, InBrush) == 0x000000, "Member 'X6HitThroughImage_SetBrush::InBrush' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromAsset
// 0x0008 (0x0008 - 0x0000)
struct X6HitThroughImage_SetBrushFromAsset final
{
public:
	class USlateBrushAsset*                       Asset;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetBrushFromAsset) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromAsset");
static_assert(sizeof(X6HitThroughImage_SetBrushFromAsset) == 0x000008, "Wrong size on X6HitThroughImage_SetBrushFromAsset");
static_assert(offsetof(X6HitThroughImage_SetBrushFromAsset, Asset) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromAsset::Asset' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromAtlasInterface
// 0x0018 (0x0018 - 0x0000)
struct X6HitThroughImage_SetBrushFromAtlasInterface final
{
public:
	TScriptInterface<class ISlateTextureAtlasInterface> AtlasRegion;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HitThroughImage_SetBrushFromAtlasInterface) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromAtlasInterface");
static_assert(sizeof(X6HitThroughImage_SetBrushFromAtlasInterface) == 0x000018, "Wrong size on X6HitThroughImage_SetBrushFromAtlasInterface");
static_assert(offsetof(X6HitThroughImage_SetBrushFromAtlasInterface, AtlasRegion) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromAtlasInterface::AtlasRegion' has a wrong offset!");
static_assert(offsetof(X6HitThroughImage_SetBrushFromAtlasInterface, bMatchSize) == 0x000010, "Member 'X6HitThroughImage_SetBrushFromAtlasInterface::bMatchSize' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromMaterial
// 0x0008 (0x0008 - 0x0000)
struct X6HitThroughImage_SetBrushFromMaterial final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetBrushFromMaterial) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromMaterial");
static_assert(sizeof(X6HitThroughImage_SetBrushFromMaterial) == 0x000008, "Wrong size on X6HitThroughImage_SetBrushFromMaterial");
static_assert(offsetof(X6HitThroughImage_SetBrushFromMaterial, Material) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromMaterial::Material' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromSoftMaterial
// 0x0028 (0x0028 - 0x0000)
struct X6HitThroughImage_SetBrushFromSoftMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      SoftMaterial;                                      // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetBrushFromSoftMaterial) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromSoftMaterial");
static_assert(sizeof(X6HitThroughImage_SetBrushFromSoftMaterial) == 0x000028, "Wrong size on X6HitThroughImage_SetBrushFromSoftMaterial");
static_assert(offsetof(X6HitThroughImage_SetBrushFromSoftMaterial, SoftMaterial) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromSoftMaterial::SoftMaterial' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromSoftTexture
// 0x0030 (0x0030 - 0x0000)
struct X6HitThroughImage_SetBrushFromSoftTexture final
{
public:
	TSoftObjectPtr<class UTexture2D>              SoftTexture;                                       // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HitThroughImage_SetBrushFromSoftTexture) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromSoftTexture");
static_assert(sizeof(X6HitThroughImage_SetBrushFromSoftTexture) == 0x000030, "Wrong size on X6HitThroughImage_SetBrushFromSoftTexture");
static_assert(offsetof(X6HitThroughImage_SetBrushFromSoftTexture, SoftTexture) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromSoftTexture::SoftTexture' has a wrong offset!");
static_assert(offsetof(X6HitThroughImage_SetBrushFromSoftTexture, bMatchSize) == 0x000028, "Member 'X6HitThroughImage_SetBrushFromSoftTexture::bMatchSize' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromTexture
// 0x0010 (0x0010 - 0x0000)
struct X6HitThroughImage_SetBrushFromTexture final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HitThroughImage_SetBrushFromTexture) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromTexture");
static_assert(sizeof(X6HitThroughImage_SetBrushFromTexture) == 0x000010, "Wrong size on X6HitThroughImage_SetBrushFromTexture");
static_assert(offsetof(X6HitThroughImage_SetBrushFromTexture, Texture) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromTexture::Texture' has a wrong offset!");
static_assert(offsetof(X6HitThroughImage_SetBrushFromTexture, bMatchSize) == 0x000008, "Member 'X6HitThroughImage_SetBrushFromTexture::bMatchSize' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushFromTextureDynamic
// 0x0010 (0x0010 - 0x0000)
struct X6HitThroughImage_SetBrushFromTextureDynamic final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchSize;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6HitThroughImage_SetBrushFromTextureDynamic) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushFromTextureDynamic");
static_assert(sizeof(X6HitThroughImage_SetBrushFromTextureDynamic) == 0x000010, "Wrong size on X6HitThroughImage_SetBrushFromTextureDynamic");
static_assert(offsetof(X6HitThroughImage_SetBrushFromTextureDynamic, Texture) == 0x000000, "Member 'X6HitThroughImage_SetBrushFromTextureDynamic::Texture' has a wrong offset!");
static_assert(offsetof(X6HitThroughImage_SetBrushFromTextureDynamic, bMatchSize) == 0x000008, "Member 'X6HitThroughImage_SetBrushFromTextureDynamic::bMatchSize' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushResourceObject
// 0x0008 (0x0008 - 0x0000)
struct X6HitThroughImage_SetBrushResourceObject final
{
public:
	class UObject*                                ResourceObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetBrushResourceObject) == 0x000008, "Wrong alignment on X6HitThroughImage_SetBrushResourceObject");
static_assert(sizeof(X6HitThroughImage_SetBrushResourceObject) == 0x000008, "Wrong size on X6HitThroughImage_SetBrushResourceObject");
static_assert(offsetof(X6HitThroughImage_SetBrushResourceObject, ResourceObject) == 0x000000, "Member 'X6HitThroughImage_SetBrushResourceObject::ResourceObject' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetBrushTintColor
// 0x0014 (0x0014 - 0x0000)
struct X6HitThroughImage_SetBrushTintColor final
{
public:
	struct FSlateColor                            TintColor;                                         // 0x0000(0x0014)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetBrushTintColor) == 0x000004, "Wrong alignment on X6HitThroughImage_SetBrushTintColor");
static_assert(sizeof(X6HitThroughImage_SetBrushTintColor) == 0x000014, "Wrong size on X6HitThroughImage_SetBrushTintColor");
static_assert(offsetof(X6HitThroughImage_SetBrushTintColor, TintColor) == 0x000000, "Member 'X6HitThroughImage_SetBrushTintColor::TintColor' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetColorAndOpacity
// 0x0010 (0x0010 - 0x0000)
struct X6HitThroughImage_SetColorAndOpacity final
{
public:
	struct FLinearColor                           InColorAndOpacity;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetColorAndOpacity) == 0x000004, "Wrong alignment on X6HitThroughImage_SetColorAndOpacity");
static_assert(sizeof(X6HitThroughImage_SetColorAndOpacity) == 0x000010, "Wrong size on X6HitThroughImage_SetColorAndOpacity");
static_assert(offsetof(X6HitThroughImage_SetColorAndOpacity, InColorAndOpacity) == 0x000000, "Member 'X6HitThroughImage_SetColorAndOpacity::InColorAndOpacity' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetDesiredSizeOverride
// 0x0010 (0x0010 - 0x0000)
struct X6HitThroughImage_SetDesiredSizeOverride final
{
public:
	struct FVector2D                              DesiredSize;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetDesiredSizeOverride) == 0x000008, "Wrong alignment on X6HitThroughImage_SetDesiredSizeOverride");
static_assert(sizeof(X6HitThroughImage_SetDesiredSizeOverride) == 0x000010, "Wrong size on X6HitThroughImage_SetDesiredSizeOverride");
static_assert(offsetof(X6HitThroughImage_SetDesiredSizeOverride, DesiredSize) == 0x000000, "Member 'X6HitThroughImage_SetDesiredSizeOverride::DesiredSize' has a wrong offset!");

// Function X6Game.X6HitThroughImage.SetOpacity
// 0x0004 (0x0004 - 0x0000)
struct X6HitThroughImage_SetOpacity final
{
public:
	float                                         InOpacity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6HitThroughImage_SetOpacity) == 0x000004, "Wrong alignment on X6HitThroughImage_SetOpacity");
static_assert(sizeof(X6HitThroughImage_SetOpacity) == 0x000004, "Wrong size on X6HitThroughImage_SetOpacity");
static_assert(offsetof(X6HitThroughImage_SetOpacity, InOpacity) == 0x000000, "Member 'X6HitThroughImage_SetOpacity::InOpacity' has a wrong offset!");

// Function X6Game.X6SoloLevelSubsystem.BindSoloLevelPausedEvent
// 0x0010 (0x0010 - 0x0000)
struct X6SoloLevelSubsystem_BindSoloLevelPausedEvent final
{
public:
	TDelegate<void(bool bPaused)>                 PausedDelegate;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X6SoloLevelSubsystem_BindSoloLevelPausedEvent) == 0x000004, "Wrong alignment on X6SoloLevelSubsystem_BindSoloLevelPausedEvent");
static_assert(sizeof(X6SoloLevelSubsystem_BindSoloLevelPausedEvent) == 0x000010, "Wrong size on X6SoloLevelSubsystem_BindSoloLevelPausedEvent");
static_assert(offsetof(X6SoloLevelSubsystem_BindSoloLevelPausedEvent, PausedDelegate) == 0x000000, "Member 'X6SoloLevelSubsystem_BindSoloLevelPausedEvent::PausedDelegate' has a wrong offset!");

// Function X6Game.X6SoloLevelSubsystem.IsInSoloLevelPausedMode
// 0x0010 (0x0010 - 0x0000)
struct X6SoloLevelSubsystem_IsInSoloLevelPausedMode final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SoloLevelSubsystem_IsInSoloLevelPausedMode) == 0x000008, "Wrong alignment on X6SoloLevelSubsystem_IsInSoloLevelPausedMode");
static_assert(sizeof(X6SoloLevelSubsystem_IsInSoloLevelPausedMode) == 0x000010, "Wrong size on X6SoloLevelSubsystem_IsInSoloLevelPausedMode");
static_assert(offsetof(X6SoloLevelSubsystem_IsInSoloLevelPausedMode, InWorldContextObject) == 0x000000, "Member 'X6SoloLevelSubsystem_IsInSoloLevelPausedMode::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6SoloLevelSubsystem_IsInSoloLevelPausedMode, ReturnValue) == 0x000008, "Member 'X6SoloLevelSubsystem_IsInSoloLevelPausedMode::ReturnValue' has a wrong offset!");

// Function X6Game.X6SoloLevelSubsystem.SetDefaultSoloLevelPaused
// 0x0010 (0x0010 - 0x0000)
struct X6SoloLevelSubsystem_SetDefaultSoloLevelPaused final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SoloLevelSubsystem_SetDefaultSoloLevelPaused) == 0x000008, "Wrong alignment on X6SoloLevelSubsystem_SetDefaultSoloLevelPaused");
static_assert(sizeof(X6SoloLevelSubsystem_SetDefaultSoloLevelPaused) == 0x000010, "Wrong size on X6SoloLevelSubsystem_SetDefaultSoloLevelPaused");
static_assert(offsetof(X6SoloLevelSubsystem_SetDefaultSoloLevelPaused, InWorldContextObject) == 0x000000, "Member 'X6SoloLevelSubsystem_SetDefaultSoloLevelPaused::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6SoloLevelSubsystem_SetDefaultSoloLevelPaused, bPaused) == 0x000008, "Member 'X6SoloLevelSubsystem_SetDefaultSoloLevelPaused::bPaused' has a wrong offset!");

// Function X6Game.X6SoloLevelSubsystem.SetSoloLevelPauseEnabled
// 0x0010 (0x0010 - 0x0000)
struct X6SoloLevelSubsystem_SetSoloLevelPauseEnabled final
{
public:
	class UObject*                                InWorldContextObject;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X6SoloLevelSubsystem_SetSoloLevelPauseEnabled) == 0x000008, "Wrong alignment on X6SoloLevelSubsystem_SetSoloLevelPauseEnabled");
static_assert(sizeof(X6SoloLevelSubsystem_SetSoloLevelPauseEnabled) == 0x000010, "Wrong size on X6SoloLevelSubsystem_SetSoloLevelPauseEnabled");
static_assert(offsetof(X6SoloLevelSubsystem_SetSoloLevelPauseEnabled, InWorldContextObject) == 0x000000, "Member 'X6SoloLevelSubsystem_SetSoloLevelPauseEnabled::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(X6SoloLevelSubsystem_SetSoloLevelPauseEnabled, bEnabled) == 0x000008, "Member 'X6SoloLevelSubsystem_SetSoloLevelPauseEnabled::bEnabled' has a wrong offset!");

}

