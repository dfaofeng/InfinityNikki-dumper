#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PaperStreamingRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum PaperStreamingRuntime.EPaperMeshPass
// NumValues: 0x0025
enum class EPaperMeshPass : uint8
{
	DepthPass                                = 0,
	SecondStageDepthPass                     = 1,
	BasePass                                 = 2,
	AnisotropyPass                           = 3,
	SkyPass                                  = 4,
	SingleLayerWaterPass                     = 5,
	SingleLayerWaterDepthPrepass             = 6,
	CSMShadowDepth                           = 7,
	VSMShadowDepth                           = 8,
	Distortion                               = 9,
	Velocity                                 = 10,
	TranslucentVelocity                      = 11,
	TranslucencyStandard                     = 12,
	TranslucencyStandardModulate             = 13,
	TranslucencyAfterDOF                     = 14,
	TranslucencyAfterDOFModulate             = 15,
	TranslucencyAfterMotionBlur              = 16,
	TranslucencyAll                          = 17,
	LightmapDensity                          = 18,
	DebugViewMode                            = 19,
	CustomDepth                              = 20,
	MobileBasePassCSM                        = 21,
	VirtualTexture                           = 22,
	LumenCardCapture                         = 23,
	LumenCardNanite                          = 24,
	LumenTranslucencyRadianceCacheMark       = 25,
	LumenFrontLayerTranslucencyGBuffer       = 26,
	DitheredLODFadingOutMaskPass             = 27,
	NaniteMeshPass                           = 28,
	MeshDecal                                = 29,
	WaterInfoTextureDepthPass                = 30,
	WaterInfoTexturePass                     = 31,
	TranslucencyOIT                          = 32,
	TranslucentVelocityOIT                   = 33,
	Num                                      = 34,
	NumBits                                  = 6,
	EPaperMeshPass_MAX                       = 35,
};

// Enum PaperStreamingRuntime.EPaperSubpassHint
// NumValues: 0x0006
enum class EPaperSubpassHint : uint8
{
	None                                     = 0,
	DepthReadSubpass                         = 1,
	DeferredShadingSubpass                   = 2,
	CustomResolveSubpass                     = 3,
	OITShadingSubpass                        = 4,
	EPaperSubpassHint_MAX                    = 5,
};

// ScriptStruct PaperStreamingRuntime.LevelAndPos
// 0x0028 (0x0028 - 0x0000)
struct FLevelAndPos final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PosName;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelAndPos) == 0x000008, "Wrong alignment on FLevelAndPos");
static_assert(sizeof(FLevelAndPos) == 0x000028, "Wrong size on FLevelAndPos");
static_assert(offsetof(FLevelAndPos, Pos) == 0x000000, "Member 'FLevelAndPos::Pos' has a wrong offset!");
static_assert(offsetof(FLevelAndPos, PosName) == 0x000018, "Member 'FLevelAndPos::PosName' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.LLMMemroyCollection
// 0x0050 (0x0050 - 0x0000)
struct FLLMMemroyCollection final
{
public:
	TMap<class FString, int64>                    allMemory;                                         // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLMMemroyCollection) == 0x000008, "Wrong alignment on FLLMMemroyCollection");
static_assert(sizeof(FLLMMemroyCollection) == 0x000050, "Wrong size on FLLMMemroyCollection");
static_assert(offsetof(FLLMMemroyCollection, allMemory) == 0x000000, "Member 'FLLMMemroyCollection::allMemory' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.MemoryWorldTypeGroup
// 0x0060 (0x0060 - 0x0000)
struct FMemoryWorldTypeGroup final
{
public:
	struct FLLMMemroyCollection                   MemoryCollection;                                  // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 RecordWordType;                                    // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMemoryWorldTypeGroup) == 0x000008, "Wrong alignment on FMemoryWorldTypeGroup");
static_assert(sizeof(FMemoryWorldTypeGroup) == 0x000060, "Wrong size on FMemoryWorldTypeGroup");
static_assert(offsetof(FMemoryWorldTypeGroup, MemoryCollection) == 0x000000, "Member 'FMemoryWorldTypeGroup::MemoryCollection' has a wrong offset!");
static_assert(offsetof(FMemoryWorldTypeGroup, RecordWordType) == 0x000050, "Member 'FMemoryWorldTypeGroup::RecordWordType' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.MemoryWorldPlaceGroup
// 0x00D0 (0x00D0 - 0x0000)
struct FMemoryWorldPlaceGroup final
{
public:
	TArray<struct FMemoryWorldTypeGroup>          MemoryWorldTypeGroupArray;                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DateTime;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurPos;                                            // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PosName;                                           // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Project;                                           // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildDesc;                                         // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x58];                                      // 0x0078(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMemoryWorldPlaceGroup) == 0x000008, "Wrong alignment on FMemoryWorldPlaceGroup");
static_assert(sizeof(FMemoryWorldPlaceGroup) == 0x0000D0, "Wrong size on FMemoryWorldPlaceGroup");
static_assert(offsetof(FMemoryWorldPlaceGroup, MemoryWorldTypeGroupArray) == 0x000000, "Member 'FMemoryWorldPlaceGroup::MemoryWorldTypeGroupArray' has a wrong offset!");
static_assert(offsetof(FMemoryWorldPlaceGroup, DateTime) == 0x000010, "Member 'FMemoryWorldPlaceGroup::DateTime' has a wrong offset!");
static_assert(offsetof(FMemoryWorldPlaceGroup, Platform) == 0x000020, "Member 'FMemoryWorldPlaceGroup::Platform' has a wrong offset!");
static_assert(offsetof(FMemoryWorldPlaceGroup, CurPos) == 0x000030, "Member 'FMemoryWorldPlaceGroup::CurPos' has a wrong offset!");
static_assert(offsetof(FMemoryWorldPlaceGroup, PosName) == 0x000048, "Member 'FMemoryWorldPlaceGroup::PosName' has a wrong offset!");
static_assert(offsetof(FMemoryWorldPlaceGroup, Project) == 0x000058, "Member 'FMemoryWorldPlaceGroup::Project' has a wrong offset!");
static_assert(offsetof(FMemoryWorldPlaceGroup, BuildDesc) == 0x000068, "Member 'FMemoryWorldPlaceGroup::BuildDesc' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.PaperGraphicsPipelineRenderTargetsInfoSettings
// 0x00A0 (0x00A0 - 0x0000)
struct FPaperGraphicsPipelineRenderTargetsInfoSettings final
{
public:
	TMap<class FString, uint64>                   PCSettings;                                        // 0x0000(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FString, uint64>                   MobileSettings;                                    // 0x0050(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPaperGraphicsPipelineRenderTargetsInfoSettings) == 0x000008, "Wrong alignment on FPaperGraphicsPipelineRenderTargetsInfoSettings");
static_assert(sizeof(FPaperGraphicsPipelineRenderTargetsInfoSettings) == 0x0000A0, "Wrong size on FPaperGraphicsPipelineRenderTargetsInfoSettings");
static_assert(offsetof(FPaperGraphicsPipelineRenderTargetsInfoSettings, PCSettings) == 0x000000, "Member 'FPaperGraphicsPipelineRenderTargetsInfoSettings::PCSettings' has a wrong offset!");
static_assert(offsetof(FPaperGraphicsPipelineRenderTargetsInfoSettings, MobileSettings) == 0x000050, "Member 'FPaperGraphicsPipelineRenderTargetsInfoSettings::MobileSettings' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.LoadMapParams
// 0x0058 (0x0058 - 0x0000)
struct FLoadMapParams final
{
public:
	class FString                                 MapPath;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StreamingSourceTag;                                // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         VisibleLevelPaths;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 WorldTag;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadMapParams) == 0x000008, "Wrong alignment on FLoadMapParams");
static_assert(sizeof(FLoadMapParams) == 0x000058, "Wrong size on FLoadMapParams");
static_assert(offsetof(FLoadMapParams, MapPath) == 0x000000, "Member 'FLoadMapParams::MapPath' has a wrong offset!");
static_assert(offsetof(FLoadMapParams, StreamingSourceTag) == 0x000010, "Member 'FLoadMapParams::StreamingSourceTag' has a wrong offset!");
static_assert(offsetof(FLoadMapParams, Location) == 0x000020, "Member 'FLoadMapParams::Location' has a wrong offset!");
static_assert(offsetof(FLoadMapParams, VisibleLevelPaths) == 0x000038, "Member 'FLoadMapParams::VisibleLevelPaths' has a wrong offset!");
static_assert(offsetof(FLoadMapParams, WorldTag) == 0x000048, "Member 'FLoadMapParams::WorldTag' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.MapLoadCache
// 0x00D0 (0x00D0 - 0x0000)
struct FMapLoadCache final
{
public:
	float                                         TimeStamp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingProgress;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadedLevelNum;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ToLoadLevelNum;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPath;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentMapPath;                                    // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ToLoadLevels;                                      // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoadedLevels;                                      // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         InSubLevels;                                       // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLoadMapParams>                 LoadMapParams;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastFreezeIn;                                      // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastFreezeOut;                                     // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWorldPartitionRuntimeCell*>     ToLoadWPCells;                                     // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnablePlayerControllerSource;                      // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperPartition*                        PaperPartition;                                    // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorldTag;                                          // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapLoadCache) == 0x000008, "Wrong alignment on FMapLoadCache");
static_assert(sizeof(FMapLoadCache) == 0x0000D0, "Wrong size on FMapLoadCache");
static_assert(offsetof(FMapLoadCache, TimeStamp) == 0x000000, "Member 'FMapLoadCache::TimeStamp' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, LoadingProgress) == 0x000004, "Member 'FMapLoadCache::LoadingProgress' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, LoadedLevelNum) == 0x000008, "Member 'FMapLoadCache::LoadedLevelNum' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, ToLoadLevelNum) == 0x00000C, "Member 'FMapLoadCache::ToLoadLevelNum' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, InLocation) == 0x000010, "Member 'FMapLoadCache::InLocation' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, MapPath) == 0x000028, "Member 'FMapLoadCache::MapPath' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, CurrentMapPath) == 0x000038, "Member 'FMapLoadCache::CurrentMapPath' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, ToLoadLevels) == 0x000048, "Member 'FMapLoadCache::ToLoadLevels' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, LoadedLevels) == 0x000058, "Member 'FMapLoadCache::LoadedLevels' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, InSubLevels) == 0x000068, "Member 'FMapLoadCache::InSubLevels' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, LoadMapParams) == 0x000078, "Member 'FMapLoadCache::LoadMapParams' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, World) == 0x000088, "Member 'FMapLoadCache::World' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, LastFreezeIn) == 0x000090, "Member 'FMapLoadCache::LastFreezeIn' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, LastFreezeOut) == 0x000091, "Member 'FMapLoadCache::LastFreezeOut' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, ToLoadWPCells) == 0x000098, "Member 'FMapLoadCache::ToLoadWPCells' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, EnablePlayerControllerSource) == 0x0000A8, "Member 'FMapLoadCache::EnablePlayerControllerSource' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, PaperPartition) == 0x0000B0, "Member 'FMapLoadCache::PaperPartition' has a wrong offset!");
static_assert(offsetof(FMapLoadCache, WorldTag) == 0x0000C0, "Member 'FMapLoadCache::WorldTag' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.MapLoadCacheV2
// 0x0078 (0x0078 - 0x0000)
struct FMapLoadCacheV2 final
{
public:
	float                                         LoadingProgress;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadedLevelNum;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ToLoadLevelNum;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ToLoadLevels;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoadedLevels;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLoadMapParams>                 LoadMapParams;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastFreezeIn;                                      // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastFreezeOut;                                     // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstLoadMapPath;                                  // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapLoadCacheV2) == 0x000008, "Wrong alignment on FMapLoadCacheV2");
static_assert(sizeof(FMapLoadCacheV2) == 0x000078, "Wrong size on FMapLoadCacheV2");
static_assert(offsetof(FMapLoadCacheV2, LoadingProgress) == 0x000000, "Member 'FMapLoadCacheV2::LoadingProgress' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, LoadedLevelNum) == 0x000004, "Member 'FMapLoadCacheV2::LoadedLevelNum' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, ToLoadLevelNum) == 0x000008, "Member 'FMapLoadCacheV2::ToLoadLevelNum' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, ToLoadLevels) == 0x000010, "Member 'FMapLoadCacheV2::ToLoadLevels' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, LoadedLevels) == 0x000020, "Member 'FMapLoadCacheV2::LoadedLevels' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, LoadMapParams) == 0x000030, "Member 'FMapLoadCacheV2::LoadMapParams' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, World) == 0x000040, "Member 'FMapLoadCacheV2::World' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, LastFreezeIn) == 0x000048, "Member 'FMapLoadCacheV2::LastFreezeIn' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, LastFreezeOut) == 0x000049, "Member 'FMapLoadCacheV2::LastFreezeOut' has a wrong offset!");
static_assert(offsetof(FMapLoadCacheV2, FirstLoadMapPath) == 0x000050, "Member 'FMapLoadCacheV2::FirstLoadMapPath' has a wrong offset!");

// ScriptStruct PaperStreamingRuntime.AsyncLoadCache
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAsyncLoadCache final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAsyncLoadCache) == 0x000008, "Wrong alignment on FAsyncLoadCache");
static_assert(sizeof(FAsyncLoadCache) == 0x000010, "Wrong size on FAsyncLoadCache");

// ScriptStruct PaperStreamingRuntime.LoadRangeInfo
// 0x0038 (0x0038 - 0x0000)
struct FLoadRangeInfo final
{
public:
	struct FBox2D                                 StreamingRange;                                    // 0x0000(0x0028)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBox2D>                         LoadingRanges;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadRangeInfo) == 0x000008, "Wrong alignment on FLoadRangeInfo");
static_assert(sizeof(FLoadRangeInfo) == 0x000038, "Wrong size on FLoadRangeInfo");
static_assert(offsetof(FLoadRangeInfo, StreamingRange) == 0x000000, "Member 'FLoadRangeInfo::StreamingRange' has a wrong offset!");
static_assert(offsetof(FLoadRangeInfo, LoadingRanges) == 0x000028, "Member 'FLoadRangeInfo::LoadingRanges' has a wrong offset!");

}

