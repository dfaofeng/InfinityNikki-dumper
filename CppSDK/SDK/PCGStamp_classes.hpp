#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PCGStamp

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class PCGStamp.PCGActorWithSceneOutlinerParent
// 0x0000 (0x03A8 - 0x03A8)
class APCGActorWithSceneOutlinerParent final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGActorWithSceneOutlinerParent">();
	}
	static class APCGActorWithSceneOutlinerParent* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCGActorWithSceneOutlinerParent>();
	}
};
static_assert(alignof(APCGActorWithSceneOutlinerParent) == 0x000008, "Wrong alignment on APCGActorWithSceneOutlinerParent");
static_assert(sizeof(APCGActorWithSceneOutlinerParent) == 0x0003A8, "Wrong size on APCGActorWithSceneOutlinerParent");

// Class PCGStamp.PCGBaseStampActor
// 0x0000 (0x03A8 - 0x03A8)
class APCGBaseStampActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGBaseStampActor">();
	}
	static class APCGBaseStampActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCGBaseStampActor>();
	}
};
static_assert(alignof(APCGBaseStampActor) == 0x000008, "Wrong alignment on APCGBaseStampActor");
static_assert(sizeof(APCGBaseStampActor) == 0x0003A8, "Wrong size on APCGBaseStampActor");

// Class PCGStamp.PCGStampBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPCGStampBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddInstancedComponent(class UActorComponent* Component);
	static void AddProceduralMesh(class UProceduralMeshComponent* proceduraMesh, const TArray<struct FVector2D>& polygonPoints, float Height, float BaseHeight, bool bEnableCollision);
	static void AddToBrush(class ABrush* Brush, const TArray<struct FVector2D>& polygonPoints, float Height, float BaseHeight);
	static class UProceduralMeshComponent* BuildProceduralMeshFromSpline(class USplineComponent* Spline, const float BuildMeshStep, const struct FVector2D& OffsetRange);
	static bool CheckInside(const struct FVector& V, const struct FVector& v0, const struct FVector& v1, const struct FVector& v2);
	static bool CheckInside2D(const struct FVector2D& Point, const struct FVector2D& A, const struct FVector2D& B, const struct FVector2D& C);
	static void EditorSelectorActorsTo(const TArray<class AActor*>& InActors);
	static void EditorSelectorActorTo(class AActor* InActor);
	static void EditorSelectorComponentTo(class UActorComponent* InComponent);
	static bool GetMeshTransfromFrom2DPoint(class UStaticMesh* mesh, const TArray<struct FVector2D>& polygonPoints, struct FTransform* OutTransform, EAxis FrontDirect, bool bBack);
	static float GetNextPositionAlongSpline(class USplineComponent* Spline, const TArray<struct FVector2D>& CheckPolygon, float LastDistance, const TArray<struct FVector>& NewSizes, TArray<struct FVector2D>* OutPosition, int32* OutIdx, const float Step, const float OutDistance, class UProceduralMeshComponent* proceduralMesh);
	static float GetSplineArea(class USplineComponent* Spline, TArray<struct FVector2D>* InsideCells, const struct FVector2D& StartPoint, const struct FVector2D& CellSize, float CurveStep);
	static void SelectSplineAreaObjects(class USplineComponent* Spline, const TArray<class FString>& FilterKeys, float MinSize, float CurveStep);
	static void SetBuildingProceduralMesh(class UProceduralMeshComponent* proceduraMesh, const TArray<struct FVector2D>& polygonPoints, float Height, float BaseHeight, bool bEnableCollision);
	static class AActor* SpawnActorFromAsset(class UObject* WorldContextObject, const struct FTransform& Transform, class UObject* PrefabAsset);
	static class UProceduralMeshComponent* SplineToProceduralMesh(class USplineComponent* Spline, const float BuildMeshStep);
	static class UProceduralMeshComponent* SplineToProceduralMeshWithHeight(class UProceduralMeshComponent* proceduraMesh, class USplineComponent* Spline, const float BuildMeshStep, const float Height);
	static TArray<struct FBox2D> TryGetSubBoxes(const struct FVector2D& BaseSize, const TArray<struct FVector2D>& SubSize, float MaxDisFromEdge, float MinDisFromOthers, int32 MaxSubCount, int32 MaxTryTimes, bool bCanRotateSubSize);
	static void TryReArrangeTransform(TArray<struct FTransform>& InOutArray, float Dis, const struct FBox2D& Range);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGStampBlueprintLibrary">();
	}
	static class UPCGStampBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGStampBlueprintLibrary>();
	}
};
static_assert(alignof(UPCGStampBlueprintLibrary) == 0x000008, "Wrong alignment on UPCGStampBlueprintLibrary");
static_assert(sizeof(UPCGStampBlueprintLibrary) == 0x000028, "Wrong size on UPCGStampBlueprintLibrary");

}

