#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UIPF

#include "Basic.hpp"

#include "UIPF_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class UIPF.UIPFActor
// 0x0170 (0x0518 - 0x03A8)
class AUIPFActor final : public AActor
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DynamicInstance;                                   // 0x03B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicInstanceStatic;                             // 0x03B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BlockingCollisionOverideSMComp;                    // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* MyISM;                                          // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SM;                                                // 0x03D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkelMesh;                                          // 0x03E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x100];                                    // 0x03E8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIPFManager>            UIPFManagerect;                                    // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x28];                                     // 0x04F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayPhysEnabled();
	void Init(bool bFromManual);
	void SkeletonSleep(class UPrimitiveComponent* Comp, class FName bone);
	void TrySleep();
	void UpdateTransition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFActor">();
	}
	static class AUIPFActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPFActor>();
	}
};
static_assert(alignof(AUIPFActor) == 0x000008, "Wrong alignment on AUIPFActor");
static_assert(sizeof(AUIPFActor) == 0x000518, "Wrong size on AUIPFActor");
static_assert(offsetof(AUIPFActor, DynamicInstance) == 0x0003B0, "Member 'AUIPFActor::DynamicInstance' has a wrong offset!");
static_assert(offsetof(AUIPFActor, DynamicInstanceStatic) == 0x0003B8, "Member 'AUIPFActor::DynamicInstanceStatic' has a wrong offset!");
static_assert(offsetof(AUIPFActor, SkeletalMeshComp) == 0x0003C0, "Member 'AUIPFActor::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(AUIPFActor, BlockingCollisionOverideSMComp) == 0x0003C8, "Member 'AUIPFActor::BlockingCollisionOverideSMComp' has a wrong offset!");
static_assert(offsetof(AUIPFActor, MyISM) == 0x0003D0, "Member 'AUIPFActor::MyISM' has a wrong offset!");
static_assert(offsetof(AUIPFActor, SM) == 0x0003D8, "Member 'AUIPFActor::SM' has a wrong offset!");
static_assert(offsetof(AUIPFActor, SkelMesh) == 0x0003E0, "Member 'AUIPFActor::SkelMesh' has a wrong offset!");
static_assert(offsetof(AUIPFActor, UIPFManagerect) == 0x0004E8, "Member 'AUIPFActor::UIPFManagerect' has a wrong offset!");

// Class UIPF.UIPFImpulse
// 0x0030 (0x03D8 - 0x03A8)
class AUIPFImpulse final : public AActor
{
public:
	uint8                                         Pad_3A8[0x20];                                     // 0x03A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIPFManager>            UIPFManagerect;                                    // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereComp;                                        // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeImpulse(float ImpulseRadius, bool UsingTruePhys, bool UsingShaderInt, float ImpulseStrength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFImpulse">();
	}
	static class AUIPFImpulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPFImpulse>();
	}
};
static_assert(alignof(AUIPFImpulse) == 0x000008, "Wrong alignment on AUIPFImpulse");
static_assert(sizeof(AUIPFImpulse) == 0x0003D8, "Wrong size on AUIPFImpulse");
static_assert(offsetof(AUIPFImpulse, UIPFManagerect) == 0x0003C8, "Member 'AUIPFImpulse::UIPFManagerect' has a wrong offset!");
static_assert(offsetof(AUIPFImpulse, SphereComp) == 0x0003D0, "Member 'AUIPFImpulse::SphereComp' has a wrong offset!");

// Class UIPF.IPFTypes
// 0x0000 (0x0100 - 0x0100)
class UIPFTypes final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IPFTypes">();
	}
	static class UIPFTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIPFTypes>();
	}
};
static_assert(alignof(UIPFTypes) == 0x000008, "Wrong alignment on UIPFTypes");
static_assert(sizeof(UIPFTypes) == 0x000100, "Wrong size on UIPFTypes");

// Class UIPF.UIPFInteractor
// 0x00C0 (0x02F0 - 0x0230)
class UUIPFInteractor : public USceneComponent
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EUIPFManagerType                              UsingUIPFManagerType;                              // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitTickRate;                                    // 0x0251(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x2];                                      // 0x0252(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickRate;                                          // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysFoliageSwapTickRate;                           // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractWithGrass;                                // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fGrassInteractionDiameter;                         // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityDeadZone;                                  // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWriteInfoToMPC;                                   // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWriteInfoToSecondSlotMPC;                         // 0x026D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractiveType                              InteractiveType;                                   // 0x026E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F[0x1];                                      // 0x026F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomIntensity;                                   // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingRadius;                                        // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawVelDirection;                                 // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideInteractorActivationDistance;             // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x2];                                      // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractorActivationDistance;                      // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       FoliageDeactivationVolume;                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             UIPFDT;                                            // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x2C];                                     // 0x02B0(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIPFManager>            UIPFManagerect;                                    // 0x02DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0xC];                                      // 0x02E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCustomLocation();
	struct FVector4 GetCustomVelocity();
	class AUIPFManager* GetUIPFManagerToRegister();
	void ManuallyActivateFoliage(bool WithImpulse, float ImpulseStrength, const struct FHitResult& Hit);
	void OnDeactivationEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void PhysCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFInteractor">();
	}
	static class UUIPFInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPFInteractor>();
	}
};
static_assert(alignof(UUIPFInteractor) == 0x000010, "Wrong alignment on UUIPFInteractor");
static_assert(sizeof(UUIPFInteractor) == 0x0002F0, "Wrong size on UUIPFInteractor");
static_assert(offsetof(UUIPFInteractor, UsingUIPFManagerType) == 0x000250, "Member 'UUIPFInteractor::UsingUIPFManagerType' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bLimitTickRate) == 0x000251, "Member 'UUIPFInteractor::bLimitTickRate' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, TickRate) == 0x000254, "Member 'UUIPFInteractor::TickRate' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, PhysFoliageSwapTickRate) == 0x000258, "Member 'UUIPFInteractor::PhysFoliageSwapTickRate' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bInteractWithGrass) == 0x00025C, "Member 'UUIPFInteractor::bInteractWithGrass' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, fGrassInteractionDiameter) == 0x000260, "Member 'UUIPFInteractor::fGrassInteractionDiameter' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, VelocityDeadZone) == 0x000264, "Member 'UUIPFInteractor::VelocityDeadZone' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, MaxVelocity) == 0x000268, "Member 'UUIPFInteractor::MaxVelocity' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bWriteInfoToMPC) == 0x00026C, "Member 'UUIPFInteractor::bWriteInfoToMPC' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bWriteInfoToSecondSlotMPC) == 0x00026D, "Member 'UUIPFInteractor::bWriteInfoToSecondSlotMPC' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, InteractiveType) == 0x00026E, "Member 'UUIPFInteractor::InteractiveType' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, CustomIntensity) == 0x000270, "Member 'UUIPFInteractor::CustomIntensity' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, RingRadius) == 0x000274, "Member 'UUIPFInteractor::RingRadius' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bDrawVelDirection) == 0x000278, "Member 'UUIPFInteractor::bDrawVelDirection' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, bOverrideInteractorActivationDistance) == 0x000279, "Member 'UUIPFInteractor::bOverrideInteractorActivationDistance' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, InteractorActivationDistance) == 0x00027C, "Member 'UUIPFInteractor::InteractorActivationDistance' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, FoliageDeactivationVolume) == 0x000290, "Member 'UUIPFInteractor::FoliageDeactivationVolume' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, UIPFDT) == 0x0002A8, "Member 'UUIPFInteractor::UIPFDT' has a wrong offset!");
static_assert(offsetof(UUIPFInteractor, UIPFManagerect) == 0x0002DC, "Member 'UUIPFInteractor::UIPFManagerect' has a wrong offset!");

// Class UIPF.UIPFManager
// 0x0250 (0x05F8 - 0x03A8)
class AUIPFManager : public AActor
{
public:
	uint8                                         Pad_3A8[0x12];                                     // 0x03A8(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseShaderInteraction;                              // 0x03BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysics;                                    // 0x03BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntSwitch;                                // 0x03BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntPS4;                                   // 0x03BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntXbox;                                  // 0x03BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntIOS;                                   // 0x03BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShaderIntAndroid;                               // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsSwitch;                              // 0x03C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsPS4;                                 // 0x03C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsXbox;                                // 0x03C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsIOS;                                 // 0x03C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTruePhysicsAndroid;                             // 0x03C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivateOnImpulse;                                 // 0x03C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFXOutputLayout;                                // 0x03C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractive;                                    // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitTickRate;                                    // 0x03C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CA[0x2];                                      // 0x03CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickRate;                                          // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPhysActivationRadius;                        // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPhysDeactivationRadius;                      // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxManualActivationDistance;                       // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultInteractorActivationDistance;               // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FoliageDataTable;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIPFManagerType                              UIPFType;                                          // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MPC_UIPF_IN_WEATHER;                               // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MPC_UIPF;                                          // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUIPFActor>                 UIPFActorClass;                                    // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 UIPFVelocityPosRT0;                                // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 UIPFVelocityPosRT1;                                // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRegisterdInteractorCount;                       // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayTime;                                         // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayTimeSlow;                                     // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTraceChannel;                             // 0x0424(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             FoliageTraceChannel;                               // 0x0425(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_426[0x10A];                                    // 0x0426(0x010A)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 rtvel;                                             // 0x0530(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 ImpulseRt[0x2];                                    // 0x0538(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x18];                                     // 0x0548(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 rtpos;                                             // 0x0560(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 rtobj;                                             // 0x0568(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ForceSplatMat;                                     // 0x0570(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x18];                                     // 0x0578(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               AccumulatorInst;                                   // 0x0590(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ManualSplatInst;                                   // 0x0598(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               VelocitySplatInst;                                 // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvas*                                Canvas;                                            // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Size;                                              // 0x05B0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDrawToRenderTargetContext             Context;                                           // 0x05C0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCanvas*                                CanvasInteract;                                    // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SizeInteract;                                      // 0x05D8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDrawToRenderTargetContext             ContextInteract;                                   // 0x05E8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static void SetGlobalUIPFInteractive(class UObject* WorldContextObject, bool InValue);

	void DrawUIPFMaterialtoRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material);
	void FoliageForceAtLocation(class UObject* Interactor, float fStrength, float fSizePercent, const struct FVector& HitLocation, const struct FVector& HitDirection, bool bIsImpulse, float TypeIndex, float RingRadius, bool bDrawVelDirection);
	void ForceAppliedAtLocation(const struct FVector& Loc, float Strength);
	void ImpulseAtLocation(const struct FVector& Location, float ImpulseDiameter, float ImpulseStrength);
	void InitializeRenderTargetsOnLoaded();
	void UpdateInteractorLocation(int32 InteractorID, const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPFManager">();
	}
	static class AUIPFManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPFManager>();
	}
};
static_assert(alignof(AUIPFManager) == 0x000008, "Wrong alignment on AUIPFManager");
static_assert(sizeof(AUIPFManager) == 0x0005F8, "Wrong size on AUIPFManager");
static_assert(offsetof(AUIPFManager, UseShaderInteraction) == 0x0003BA, "Member 'AUIPFManager::UseShaderInteraction' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysics) == 0x0003BB, "Member 'AUIPFManager::UseTruePhysics' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntSwitch) == 0x0003BC, "Member 'AUIPFManager::UseShaderIntSwitch' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntPS4) == 0x0003BD, "Member 'AUIPFManager::UseShaderIntPS4' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntXbox) == 0x0003BE, "Member 'AUIPFManager::UseShaderIntXbox' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntIOS) == 0x0003BF, "Member 'AUIPFManager::UseShaderIntIOS' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseShaderIntAndroid) == 0x0003C0, "Member 'AUIPFManager::UseShaderIntAndroid' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsSwitch) == 0x0003C1, "Member 'AUIPFManager::UseTruePhysicsSwitch' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsPS4) == 0x0003C2, "Member 'AUIPFManager::UseTruePhysicsPS4' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsXbox) == 0x0003C3, "Member 'AUIPFManager::UseTruePhysicsXbox' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsIOS) == 0x0003C4, "Member 'AUIPFManager::UseTruePhysicsIOS' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UseTruePhysicsAndroid) == 0x0003C5, "Member 'AUIPFManager::UseTruePhysicsAndroid' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ActivateOnImpulse) == 0x0003C6, "Member 'AUIPFManager::ActivateOnImpulse' has a wrong offset!");
static_assert(offsetof(AUIPFManager, bUseFXOutputLayout) == 0x0003C7, "Member 'AUIPFManager::bUseFXOutputLayout' has a wrong offset!");
static_assert(offsetof(AUIPFManager, bIsInteractive) == 0x0003C8, "Member 'AUIPFManager::bIsInteractive' has a wrong offset!");
static_assert(offsetof(AUIPFManager, bLimitTickRate) == 0x0003C9, "Member 'AUIPFManager::bLimitTickRate' has a wrong offset!");
static_assert(offsetof(AUIPFManager, TickRate) == 0x0003CC, "Member 'AUIPFManager::TickRate' has a wrong offset!");
static_assert(offsetof(AUIPFManager, PlayerPhysActivationRadius) == 0x0003D0, "Member 'AUIPFManager::PlayerPhysActivationRadius' has a wrong offset!");
static_assert(offsetof(AUIPFManager, PlayerPhysDeactivationRadius) == 0x0003D4, "Member 'AUIPFManager::PlayerPhysDeactivationRadius' has a wrong offset!");
static_assert(offsetof(AUIPFManager, MaxManualActivationDistance) == 0x0003D8, "Member 'AUIPFManager::MaxManualActivationDistance' has a wrong offset!");
static_assert(offsetof(AUIPFManager, DefaultInteractorActivationDistance) == 0x0003DC, "Member 'AUIPFManager::DefaultInteractorActivationDistance' has a wrong offset!");
static_assert(offsetof(AUIPFManager, FoliageDataTable) == 0x0003E0, "Member 'AUIPFManager::FoliageDataTable' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UIPFType) == 0x0003E8, "Member 'AUIPFManager::UIPFType' has a wrong offset!");
static_assert(offsetof(AUIPFManager, MPC_UIPF_IN_WEATHER) == 0x0003F0, "Member 'AUIPFManager::MPC_UIPF_IN_WEATHER' has a wrong offset!");
static_assert(offsetof(AUIPFManager, MPC_UIPF) == 0x0003F8, "Member 'AUIPFManager::MPC_UIPF' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UIPFActorClass) == 0x000400, "Member 'AUIPFManager::UIPFActorClass' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UIPFVelocityPosRT0) == 0x000408, "Member 'AUIPFManager::UIPFVelocityPosRT0' has a wrong offset!");
static_assert(offsetof(AUIPFManager, UIPFVelocityPosRT1) == 0x000410, "Member 'AUIPFManager::UIPFVelocityPosRT1' has a wrong offset!");
static_assert(offsetof(AUIPFManager, MaxRegisterdInteractorCount) == 0x000418, "Member 'AUIPFManager::MaxRegisterdInteractorCount' has a wrong offset!");
static_assert(offsetof(AUIPFManager, DecayTime) == 0x00041C, "Member 'AUIPFManager::DecayTime' has a wrong offset!");
static_assert(offsetof(AUIPFManager, DecayTimeSlow) == 0x000420, "Member 'AUIPFManager::DecayTimeSlow' has a wrong offset!");
static_assert(offsetof(AUIPFManager, bOverrideTraceChannel) == 0x000424, "Member 'AUIPFManager::bOverrideTraceChannel' has a wrong offset!");
static_assert(offsetof(AUIPFManager, FoliageTraceChannel) == 0x000425, "Member 'AUIPFManager::FoliageTraceChannel' has a wrong offset!");
static_assert(offsetof(AUIPFManager, rtvel) == 0x000530, "Member 'AUIPFManager::rtvel' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ImpulseRt) == 0x000538, "Member 'AUIPFManager::ImpulseRt' has a wrong offset!");
static_assert(offsetof(AUIPFManager, rtpos) == 0x000560, "Member 'AUIPFManager::rtpos' has a wrong offset!");
static_assert(offsetof(AUIPFManager, rtobj) == 0x000568, "Member 'AUIPFManager::rtobj' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ForceSplatMat) == 0x000570, "Member 'AUIPFManager::ForceSplatMat' has a wrong offset!");
static_assert(offsetof(AUIPFManager, AccumulatorInst) == 0x000590, "Member 'AUIPFManager::AccumulatorInst' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ManualSplatInst) == 0x000598, "Member 'AUIPFManager::ManualSplatInst' has a wrong offset!");
static_assert(offsetof(AUIPFManager, VelocitySplatInst) == 0x0005A0, "Member 'AUIPFManager::VelocitySplatInst' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Canvas) == 0x0005A8, "Member 'AUIPFManager::Canvas' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Size) == 0x0005B0, "Member 'AUIPFManager::Size' has a wrong offset!");
static_assert(offsetof(AUIPFManager, Context) == 0x0005C0, "Member 'AUIPFManager::Context' has a wrong offset!");
static_assert(offsetof(AUIPFManager, CanvasInteract) == 0x0005D0, "Member 'AUIPFManager::CanvasInteract' has a wrong offset!");
static_assert(offsetof(AUIPFManager, SizeInteract) == 0x0005D8, "Member 'AUIPFManager::SizeInteract' has a wrong offset!");
static_assert(offsetof(AUIPFManager, ContextInteract) == 0x0005E8, "Member 'AUIPFManager::ContextInteract' has a wrong offset!");

}

