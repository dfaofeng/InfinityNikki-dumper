#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PCGStamp

#include "Basic.hpp"

#include "PCGStamp_classes.hpp"
#include "PCGStamp_parameters.hpp"


namespace SDK
{

// Function PCGStamp.PCGStampBlueprintLibrary.AddInstancedComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPCGStampBlueprintLibrary::AddInstancedComponent(class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "AddInstancedComponent");

	Params::PCGStampBlueprintLibrary_AddInstancedComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.AddProceduralMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UProceduralMeshComponent*         proceduraMesh                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         polygonPoints                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::AddProceduralMesh(class UProceduralMeshComponent* proceduraMesh, const TArray<struct FVector2D>& polygonPoints, float Height, float BaseHeight, bool bEnableCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "AddProceduralMesh");

	Params::PCGStampBlueprintLibrary_AddProceduralMesh Parms{};

	Parms.proceduraMesh = proceduraMesh;
	Parms.polygonPoints = std::move(polygonPoints);
	Parms.Height = Height;
	Parms.BaseHeight = BaseHeight;
	Parms.bEnableCollision = bEnableCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.AddToBrush
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ABrush*                           Brush                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         polygonPoints                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::AddToBrush(class ABrush* Brush, const TArray<struct FVector2D>& polygonPoints, float Height, float BaseHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "AddToBrush");

	Params::PCGStampBlueprintLibrary_AddToBrush Parms{};

	Parms.Brush = Brush;
	Parms.polygonPoints = std::move(polygonPoints);
	Parms.Height = Height;
	Parms.BaseHeight = BaseHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.BuildProceduralMeshFromSpline
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             BuildMeshStep                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 OffsetRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProceduralMeshComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProceduralMeshComponent* UPCGStampBlueprintLibrary::BuildProceduralMeshFromSpline(class USplineComponent* Spline, const float BuildMeshStep, const struct FVector2D& OffsetRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "BuildProceduralMeshFromSpline");

	Params::PCGStampBlueprintLibrary_BuildProceduralMeshFromSpline Parms{};

	Parms.Spline = Spline;
	Parms.BuildMeshStep = BuildMeshStep;
	Parms.OffsetRange = std::move(OffsetRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.CheckInside
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   V                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   v0                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   v1                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   v2                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPCGStampBlueprintLibrary::CheckInside(const struct FVector& V, const struct FVector& v0, const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "CheckInside");

	Params::PCGStampBlueprintLibrary_CheckInside Parms{};

	Parms.V = std::move(V);
	Parms.v0 = std::move(v0);
	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.CheckInside2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Point                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 C                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPCGStampBlueprintLibrary::CheckInside2D(const struct FVector2D& Point, const struct FVector2D& A, const struct FVector2D& B, const struct FVector2D& C)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "CheckInside2D");

	Params::PCGStampBlueprintLibrary_CheckInside2D Parms{};

	Parms.Point = std::move(Point);
	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.C = std::move(C);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.EditorSelectorActorsTo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::EditorSelectorActorsTo(const TArray<class AActor*>& InActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "EditorSelectorActorsTo");

	Params::PCGStampBlueprintLibrary_EditorSelectorActorsTo Parms{};

	Parms.InActors = std::move(InActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.EditorSelectorActorTo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::EditorSelectorActorTo(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "EditorSelectorActorTo");

	Params::PCGStampBlueprintLibrary_EditorSelectorActorTo Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.EditorSelectorComponentTo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::EditorSelectorComponentTo(class UActorComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "EditorSelectorComponentTo");

	Params::PCGStampBlueprintLibrary_EditorSelectorComponentTo Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.GetMeshTransfromFrom2DPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      mesh                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         polygonPoints                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxis                                   FrontDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPCGStampBlueprintLibrary::GetMeshTransfromFrom2DPoint(class UStaticMesh* mesh, const TArray<struct FVector2D>& polygonPoints, struct FTransform* OutTransform, EAxis FrontDirect, bool bBack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "GetMeshTransfromFrom2DPoint");

	Params::PCGStampBlueprintLibrary_GetMeshTransfromFrom2DPoint Parms{};

	Parms.mesh = mesh;
	Parms.polygonPoints = std::move(polygonPoints);
	Parms.FrontDirect = FrontDirect;
	Parms.bBack = bBack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.GetNextPositionAlongSpline
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         CheckPolygon                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   LastDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           NewSizes                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>*               OutPosition                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32*                                  OutIdx                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Step                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OutDistance                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProceduralMeshComponent*         proceduralMesh                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPCGStampBlueprintLibrary::GetNextPositionAlongSpline(class USplineComponent* Spline, const TArray<struct FVector2D>& CheckPolygon, float LastDistance, const TArray<struct FVector>& NewSizes, TArray<struct FVector2D>* OutPosition, int32* OutIdx, const float Step, const float OutDistance, class UProceduralMeshComponent* proceduralMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "GetNextPositionAlongSpline");

	Params::PCGStampBlueprintLibrary_GetNextPositionAlongSpline Parms{};

	Parms.Spline = Spline;
	Parms.CheckPolygon = std::move(CheckPolygon);
	Parms.LastDistance = LastDistance;
	Parms.NewSizes = std::move(NewSizes);
	Parms.Step = Step;
	Parms.OutDistance = OutDistance;
	Parms.proceduralMesh = proceduralMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutIdx != nullptr)
		*OutIdx = Parms.OutIdx;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.GetSplineArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>*               InsideCells                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 StartPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 CellSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurveStep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPCGStampBlueprintLibrary::GetSplineArea(class USplineComponent* Spline, TArray<struct FVector2D>* InsideCells, const struct FVector2D& StartPoint, const struct FVector2D& CellSize, float CurveStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "GetSplineArea");

	Params::PCGStampBlueprintLibrary_GetSplineArea Parms{};

	Parms.Spline = Spline;
	Parms.StartPoint = std::move(StartPoint);
	Parms.CellSize = std::move(CellSize);
	Parms.CurveStep = CurveStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InsideCells != nullptr)
		*InsideCells = std::move(Parms.InsideCells);

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.SelectSplineAreaObjects
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            FilterKeys                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MinSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurveStep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::SelectSplineAreaObjects(class USplineComponent* Spline, const TArray<class FString>& FilterKeys, float MinSize, float CurveStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "SelectSplineAreaObjects");

	Params::PCGStampBlueprintLibrary_SelectSplineAreaObjects Parms{};

	Parms.Spline = Spline;
	Parms.FilterKeys = std::move(FilterKeys);
	Parms.MinSize = MinSize;
	Parms.CurveStep = CurveStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.SetBuildingProceduralMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UProceduralMeshComponent*         proceduraMesh                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         polygonPoints                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::SetBuildingProceduralMesh(class UProceduralMeshComponent* proceduraMesh, const TArray<struct FVector2D>& polygonPoints, float Height, float BaseHeight, bool bEnableCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "SetBuildingProceduralMesh");

	Params::PCGStampBlueprintLibrary_SetBuildingProceduralMesh Parms{};

	Parms.proceduraMesh = proceduraMesh;
	Parms.polygonPoints = std::move(polygonPoints);
	Parms.Height = Height;
	Parms.BaseHeight = BaseHeight;
	Parms.bEnableCollision = bEnableCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PCGStamp.PCGStampBlueprintLibrary.SpawnActorFromAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          PrefabAsset                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UPCGStampBlueprintLibrary::SpawnActorFromAsset(class UObject* WorldContextObject, const struct FTransform& Transform, class UObject* PrefabAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "SpawnActorFromAsset");

	Params::PCGStampBlueprintLibrary_SpawnActorFromAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Transform = std::move(Transform);
	Parms.PrefabAsset = PrefabAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.SplineToProceduralMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             BuildMeshStep                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProceduralMeshComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProceduralMeshComponent* UPCGStampBlueprintLibrary::SplineToProceduralMesh(class USplineComponent* Spline, const float BuildMeshStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "SplineToProceduralMesh");

	Params::PCGStampBlueprintLibrary_SplineToProceduralMesh Parms{};

	Parms.Spline = Spline;
	Parms.BuildMeshStep = BuildMeshStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.SplineToProceduralMeshWithHeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UProceduralMeshComponent*         proceduraMesh                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             BuildMeshStep                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Height                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProceduralMeshComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProceduralMeshComponent* UPCGStampBlueprintLibrary::SplineToProceduralMeshWithHeight(class UProceduralMeshComponent* proceduraMesh, class USplineComponent* Spline, const float BuildMeshStep, const float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "SplineToProceduralMeshWithHeight");

	Params::PCGStampBlueprintLibrary_SplineToProceduralMeshWithHeight Parms{};

	Parms.proceduraMesh = proceduraMesh;
	Parms.Spline = Spline;
	Parms.BuildMeshStep = BuildMeshStep;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.TryGetSubBoxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 BaseSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         SubSize                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MaxDisFromEdge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDisFromOthers                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxSubCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxTryTimes                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanRotateSubSize                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBox2D>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBox2D> UPCGStampBlueprintLibrary::TryGetSubBoxes(const struct FVector2D& BaseSize, const TArray<struct FVector2D>& SubSize, float MaxDisFromEdge, float MinDisFromOthers, int32 MaxSubCount, int32 MaxTryTimes, bool bCanRotateSubSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "TryGetSubBoxes");

	Params::PCGStampBlueprintLibrary_TryGetSubBoxes Parms{};

	Parms.BaseSize = std::move(BaseSize);
	Parms.SubSize = std::move(SubSize);
	Parms.MaxDisFromEdge = MaxDisFromEdge;
	Parms.MinDisFromOthers = MinDisFromOthers;
	Parms.MaxSubCount = MaxSubCount;
	Parms.MaxTryTimes = MaxTryTimes;
	Parms.bCanRotateSubSize = bCanRotateSubSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PCGStamp.PCGStampBlueprintLibrary.TryReArrangeTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FTransform>&              InOutArray                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Dis                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox2D&                    Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPCGStampBlueprintLibrary::TryReArrangeTransform(TArray<struct FTransform>& InOutArray, float Dis, const struct FBox2D& Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PCGStampBlueprintLibrary", "TryReArrangeTransform");

	Params::PCGStampBlueprintLibrary_TryReArrangeTransform Parms{};

	Parms.InOutArray = std::move(InOutArray);
	Parms.Dis = Dis;
	Parms.Range = std::move(Range);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InOutArray = std::move(Parms.InOutArray);
}

}

