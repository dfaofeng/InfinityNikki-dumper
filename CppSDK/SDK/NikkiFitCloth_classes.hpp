#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NikkiFitCloth

#include "Basic.hpp"

#include "NikkiFitCloth_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class NikkiFitCloth.FitClothCacheAsset
// 0x0030 (0x0058 - 0x0028)
class UFitClothCacheAsset final : public UObject
{
public:
	ECacheAssetType                               CacheAssetType;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerPlatformInt                        MinLOD;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumLODs;                                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FitClothCacheAsset">();
	}
	static class UFitClothCacheAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFitClothCacheAsset>();
	}
};
static_assert(alignof(UFitClothCacheAsset) == 0x000008, "Wrong alignment on UFitClothCacheAsset");
static_assert(sizeof(UFitClothCacheAsset) == 0x000058, "Wrong size on UFitClothCacheAsset");
static_assert(offsetof(UFitClothCacheAsset, CacheAssetType) == 0x000028, "Member 'UFitClothCacheAsset::CacheAssetType' has a wrong offset!");
static_assert(offsetof(UFitClothCacheAsset, MinLOD) == 0x00002C, "Member 'UFitClothCacheAsset::MinLOD' has a wrong offset!");
static_assert(offsetof(UFitClothCacheAsset, NumLODs) == 0x000030, "Member 'UFitClothCacheAsset::NumLODs' has a wrong offset!");
static_assert(offsetof(UFitClothCacheAsset, AssetUserData) == 0x000038, "Member 'UFitClothCacheAsset::AssetUserData' has a wrong offset!");

// Class NikkiFitCloth.BoneNamePairsUserData
// 0x0020 (0x0048 - 0x0028)
class UBoneNamePairsUserData final : public UAssetUserData
{
public:
	TArray<struct FClothBodyBoneNamePair>         BoneNamePairs;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SmoothBoneNames;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneNamePairsUserData">();
	}
	static class UBoneNamePairsUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneNamePairsUserData>();
	}
};
static_assert(alignof(UBoneNamePairsUserData) == 0x000008, "Wrong alignment on UBoneNamePairsUserData");
static_assert(sizeof(UBoneNamePairsUserData) == 0x000048, "Wrong size on UBoneNamePairsUserData");
static_assert(offsetof(UBoneNamePairsUserData, BoneNamePairs) == 0x000028, "Member 'UBoneNamePairsUserData::BoneNamePairs' has a wrong offset!");
static_assert(offsetof(UBoneNamePairsUserData, SmoothBoneNames) == 0x000038, "Member 'UBoneNamePairsUserData::SmoothBoneNames' has a wrong offset!");

// Class NikkiFitCloth.MatchTwoClothEvent
// 0x0000 (0x0028 - 0x0028)
class UMatchTwoClothEvent final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckPrebuildClothData(class USkeletalMesh* ClothSkelMesh, class USkeletalMesh* BodySkelMesh);
	static bool CheckSkeletalMeshBone(const class USkeletalMesh* SkeletalMesh);
	static void ClearPairCache();
	static void ClearPrebuildClothData(class USkeletalMesh* ClothSkelMesh);
	static void ExtractCPUSkinVertexPositionsToFitChache(class USkeletalMesh* SkeletalMesh, const TArray<int32>& DisabledLODIndices, const TArray<class FName>& InBoneNames, const TArray<struct FTransform>& InBoneTransforms);
	static void FindBestMatchBetweenClothOfBody(class USkeletalMesh* InnerSkeletalMesh, class USkeletalMesh* OuterSkeletalMesh, class UFitClothCacheAsset* BodyCacheAsset, const struct FMatchClothParameter& MatchParam);
	static bool FindValidPairData(class USkeletalMesh* InnerSkelMesh, class USkeletalMesh* OuterSkelMesh);
	static void GeneratePrebuildBodyData(class USkeletalMesh* BodySkelMesh, const struct FMatchClothEditorParameter& MatchParam);
	static void GeneratePrebuildClothData(class USkeletalMesh* ClothSkelMesh, class USkeletalMesh* BodySkelMesh, class USkeletalMesh* RenderBodySkelMesh, const struct FMatchClothEditorParameter& MatchParam);
	static void GeneratePrebuildClothSkirtData(class USkeletalMesh* ClothSkelMesh, class USkeletalMesh* BodySkelMesh, class USkeletalMesh* RenderBodySkelMesh, const struct FMatchClothEditorParameter& MatchParam);
	static void GeneratePrebuildSkinClothData(class USkeletalMesh* ClothSkelMesh, class USkeletalMesh* BodySkelMesh, class USkeletalMesh* RenderBodySkelMesh, const struct FMatchClothEditorParameter& MatchParam, const TArray<class FName>& InBoneNames, const TArray<struct FTransform>& InBoneTransforms, bool bMultiplyBoneTransform);
	static int32 GetMaxPairCacheNum();
	static int32 GetPairCacheNum();
	static void ReleasePairCacheDataExceptInput(const TArray<class FString>& InMeshNames, const TArray<class FString>& OutMeshNames);
	static void ReleaseReferenceArray(const TArray<class USkeletalMesh*>& InSkelMeshArray);
	static void ReleaseReferenceData(class USkeletalMesh* InSkelMesh);
	static void SetMaxPairCacheNum(int32 InMaxPairCacheNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchTwoClothEvent">();
	}
	static class UMatchTwoClothEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchTwoClothEvent>();
	}
};
static_assert(alignof(UMatchTwoClothEvent) == 0x000008, "Wrong alignment on UMatchTwoClothEvent");
static_assert(sizeof(UMatchTwoClothEvent) == 0x000028, "Wrong size on UMatchTwoClothEvent");

// Class NikkiFitCloth.ClothVisibilityAndOffsetBlueprintLiabrary
// 0x0000 (0x0028 - 0x0028)
class UClothVisibilityAndOffsetBlueprintLiabrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAssetUserData* AddAssetUserData(class UFitClothCacheAsset* FitCacheAsset, TSubclassOf<class UAssetUserData> InUserDataClass, bool bEditorOnly);
	static void AddClothVisibilityAndOffsetProperty(class USkeletalMeshComponent* InnerComponent, class USkeletalMeshComponent* OuterComponent);
	static void ApplyClothVisibilityAndOffsetProperty(class USkeletalMeshComponent* InnerComponent, class USkeletalMeshComponent* OuterComponent);
	static void ApplyClothVisibilityByColor(class USkeletalMeshComponent* InnerComponent, const TArray<int32>& VertexColors);
	static void ClearClothPairCache();
	static void ClearClothRuntimeCache(class USkeletalMesh* ClothSkeletalMesh);
	static void ClearClothVisibilityAndOffsetProperty(class USkeletalMeshComponent* InnerComponent);
	static void CollectVisibilityData(const class USkeletalMesh* SkeletalMesh);
	static class UAssetUserData* GetAssetUserDataOfClass(class UFitClothCacheAsset* FitCacheAsset, TSubclassOf<class UAssetUserData> InUserDataClass);
	static void GetNameFromBoneNamePair(class FName* OutClothBoneName, class FName* OutBodyBoneName, const struct FClothBodyBoneNamePair& BoneNamePair);
	static bool GetNikkiPhysicsBoneWeights(TArray<class FName>* OutColliderBones, TArray<class FName>* OutAnimBones, class USkeletalMesh* InnerSkeletalMesh, float AnimMaskRatioThrshold, float ColliderMaskRatioThrshold);
	static void GetSkeletalMeshVisibilityProperty(TArray<int32>* ColorNumVertices, TArray<int32>* ColorNumHidedVertices, TArray<int32>* ColorValues, const class USkeletalMesh* ClothSkeletalMesh, const int32 LODIndex);
	static void PrintAllVisibilityData();
	static void PrintVisibilityData(const class USkeletalMesh* SkeletalMesh);
	static void PrintWholeBodyVisibilityData(const TArray<class USkeletalMesh*>& WholeSkeletalMeshes);
	static bool RemoveUserDataOfClass(class UFitClothCacheAsset* FitCacheAsset, TSubclassOf<class UAssetUserData> InUserDataClass);
	static void ResetAllVisibilityData();
	static void SaveCurrentClothVisibilityAndOffsetProperty(class USkeletalMeshComponent* InnerComponent, const class FString& SaveFilePath, const int32 LODIndex, bool bKeepDisable);
	static void SetChaosClothFixedVertices(TArray<class FString>* OutAssetNames, TArray<struct FLODVertexIndices>* OutLODFixedIndices, class USkeletalMeshComponent* InnerComponent, float FixedRatioThrshold);
	static bool SetNameToBoneNamePair(struct FClothBodyBoneNamePair* BoneNamePair, const class FName& InClothBoneName, const class FName& InBodyBoneName, const class USkeletalMesh* InSkeletalMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothVisibilityAndOffsetBlueprintLiabrary">();
	}
	static class UClothVisibilityAndOffsetBlueprintLiabrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClothVisibilityAndOffsetBlueprintLiabrary>();
	}
};
static_assert(alignof(UClothVisibilityAndOffsetBlueprintLiabrary) == 0x000008, "Wrong alignment on UClothVisibilityAndOffsetBlueprintLiabrary");
static_assert(sizeof(UClothVisibilityAndOffsetBlueprintLiabrary) == 0x000028, "Wrong size on UClothVisibilityAndOffsetBlueprintLiabrary");

// Class NikkiFitCloth.MatchPropertyAssetUserData
// 0x0030 (0x0058 - 0x0028)
class UMatchPropertyAssetUserData final : public UAssetUserData
{
public:
	TSoftObjectPtr<class UFitClothCacheAsset>     FitClothCacheAsset;                                // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFitClothCacheAsset*                    FitClothPtr;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchPropertyAssetUserData">();
	}
	static class UMatchPropertyAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchPropertyAssetUserData>();
	}
};
static_assert(alignof(UMatchPropertyAssetUserData) == 0x000008, "Wrong alignment on UMatchPropertyAssetUserData");
static_assert(sizeof(UMatchPropertyAssetUserData) == 0x000058, "Wrong size on UMatchPropertyAssetUserData");
static_assert(offsetof(UMatchPropertyAssetUserData, FitClothCacheAsset) == 0x000028, "Member 'UMatchPropertyAssetUserData::FitClothCacheAsset' has a wrong offset!");
static_assert(offsetof(UMatchPropertyAssetUserData, FitClothPtr) == 0x000050, "Member 'UMatchPropertyAssetUserData::FitClothPtr' has a wrong offset!");

// Class NikkiFitCloth.ClothTagAssetUserData
// 0x0010 (0x0038 - 0x0028)
class UClothTagAssetUserData final : public UAssetUserData
{
public:
	TArray<struct FLODVertexIndices>              LODVertexIndicesArray;                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothTagAssetUserData">();
	}
	static class UClothTagAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClothTagAssetUserData>();
	}
};
static_assert(alignof(UClothTagAssetUserData) == 0x000008, "Wrong alignment on UClothTagAssetUserData");
static_assert(sizeof(UClothTagAssetUserData) == 0x000038, "Wrong size on UClothTagAssetUserData");
static_assert(offsetof(UClothTagAssetUserData, LODVertexIndicesArray) == 0x000028, "Member 'UClothTagAssetUserData::LODVertexIndicesArray' has a wrong offset!");

// Class NikkiFitCloth.ClothPropertyAssetUserData
// 0x0048 (0x0070 - 0x0028)
class UClothPropertyAssetUserData final : public UAssetUserData
{
public:
	TArray<struct FClothLODSectionMapInfos>       GuideInnerSections;                                // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FClothLODSectionIndices>        ExcludeOuterSections;                              // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FClothLODSectionIndices>        DeformOnlyOuterSections;                           // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FClothLODSectionIndices>        MaskOnlyOuterSections;                             // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BoneAnimMaskRatio;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneColliderMaskRatio;                             // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothPropertyAssetUserData">();
	}
	static class UClothPropertyAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClothPropertyAssetUserData>();
	}
};
static_assert(alignof(UClothPropertyAssetUserData) == 0x000008, "Wrong alignment on UClothPropertyAssetUserData");
static_assert(sizeof(UClothPropertyAssetUserData) == 0x000070, "Wrong size on UClothPropertyAssetUserData");
static_assert(offsetof(UClothPropertyAssetUserData, GuideInnerSections) == 0x000028, "Member 'UClothPropertyAssetUserData::GuideInnerSections' has a wrong offset!");
static_assert(offsetof(UClothPropertyAssetUserData, ExcludeOuterSections) == 0x000038, "Member 'UClothPropertyAssetUserData::ExcludeOuterSections' has a wrong offset!");
static_assert(offsetof(UClothPropertyAssetUserData, DeformOnlyOuterSections) == 0x000048, "Member 'UClothPropertyAssetUserData::DeformOnlyOuterSections' has a wrong offset!");
static_assert(offsetof(UClothPropertyAssetUserData, MaskOnlyOuterSections) == 0x000058, "Member 'UClothPropertyAssetUserData::MaskOnlyOuterSections' has a wrong offset!");
static_assert(offsetof(UClothPropertyAssetUserData, BoneAnimMaskRatio) == 0x000068, "Member 'UClothPropertyAssetUserData::BoneAnimMaskRatio' has a wrong offset!");
static_assert(offsetof(UClothPropertyAssetUserData, BoneColliderMaskRatio) == 0x00006C, "Member 'UClothPropertyAssetUserData::BoneColliderMaskRatio' has a wrong offset!");

// Class NikkiFitCloth.BodyPropertyAssetUserData
// 0x0050 (0x0078 - 0x0028)
class UBodyPropertyAssetUserData final : public UAssetUserData
{
public:
	TArray<int32>                                 ExcludeSectionIndices;                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExcludeTrunkSectionIndices;                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SmoothSectionIndices;                              // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 TrunkSectionIndices;                               // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReferenceData>             BoneReferenceDataList;                             // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodyPropertyAssetUserData">();
	}
	static class UBodyPropertyAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodyPropertyAssetUserData>();
	}
};
static_assert(alignof(UBodyPropertyAssetUserData) == 0x000008, "Wrong alignment on UBodyPropertyAssetUserData");
static_assert(sizeof(UBodyPropertyAssetUserData) == 0x000078, "Wrong size on UBodyPropertyAssetUserData");
static_assert(offsetof(UBodyPropertyAssetUserData, ExcludeSectionIndices) == 0x000028, "Member 'UBodyPropertyAssetUserData::ExcludeSectionIndices' has a wrong offset!");
static_assert(offsetof(UBodyPropertyAssetUserData, ExcludeTrunkSectionIndices) == 0x000038, "Member 'UBodyPropertyAssetUserData::ExcludeTrunkSectionIndices' has a wrong offset!");
static_assert(offsetof(UBodyPropertyAssetUserData, SmoothSectionIndices) == 0x000048, "Member 'UBodyPropertyAssetUserData::SmoothSectionIndices' has a wrong offset!");
static_assert(offsetof(UBodyPropertyAssetUserData, TrunkSectionIndices) == 0x000058, "Member 'UBodyPropertyAssetUserData::TrunkSectionIndices' has a wrong offset!");
static_assert(offsetof(UBodyPropertyAssetUserData, BoneReferenceDataList) == 0x000068, "Member 'UBodyPropertyAssetUserData::BoneReferenceDataList' has a wrong offset!");

}

