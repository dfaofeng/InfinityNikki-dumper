#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: X6Game

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "StructUtils_structs.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "TargetingSystem_structs.hpp"


namespace SDK
{

// Enum X6Game.ELookAtEventType
// NumValues: 0x0007
enum class ELookAtEventType : uint8
{
	Event_None                               = 0,
	Event_StimulatedByNikki                  = 1,
	Event_DialogRequest                      = 2,
	Event_TakePhotoRequest                   = 3,
	Event_FaceTowards                        = 4,
	Event_InteractiveIdleBreak               = 5,
	Event_MAX                                = 6,
};

// Enum X6Game.ELookAtUpdateMode
// NumValues: 0x0003
enum class ELookAtUpdateMode : uint8
{
	Static                                   = 0,
	Dynamic                                  = 1,
	ELookAtUpdateMode_MAX                    = 2,
};

// Enum X6Game.EPreProcessConditionType
// NumValues: 0x0005
enum class EPreProcessConditionType : uint8
{
	StimuliTag                               = 0,
	IsSourceInRange                          = 1,
	TriggerTiming                            = 2,
	IsInSight                                = 3,
	EPreProcessConditionType_MAX             = 4,
};

// Enum X6Game.EX6InputTouchEvent
// NumValues: 0x0005
enum class EX6InputTouchEvent : uint8
{
	X6ITE_Pressed                            = 0,
	X6ITE_Released                           = 1,
	X6ITE_Moved                              = 2,
	X6ITE_Canceled                           = 3,
	X6ITE_MAX                                = 4,
};

// Enum X6Game.EX6InputDeviceKeyType
// NumValues: 0x0006
enum class EX6InputDeviceKeyType : uint8
{
	None                                     = 0,
	Keyboard                                 = 1,
	Mouse                                    = 2,
	GamePad                                  = 3,
	TouchScreen                              = 4,
	EX6InputDeviceKeyType_MAX                = 5,
};

// Enum X6Game.EGroundFlyMovementMode
// NumValues: 0x0006
enum class EGroundFlyMovementMode : uint8
{
	Default                                  = 0,
	GroundFly                                = 1,
	GroundFlyCustomHeight                    = 2,
	Land                                     = 3,
	Fly                                      = 4,
	EGroundFlyMovementMode_MAX               = 5,
};

// Enum X6Game.ECharacterSituationType
// NumValues: 0x0007
enum class ECharacterSituationType : uint8
{
	ECharacterSituationType_None             = 0,
	ECharacterSituationType_InWater          = 1,
	ECharacterSituationType_OnDynamicMovementBase = 2,
	ECharacterSituationType_InRain           = 3,
	ECharacterSituationType_TakingWoolenHeart = 4,
	ECharacterSituationType_Leisure          = 5,
	ECharacterSituationType_MAX              = 6,
};

// Enum X6Game.EFootstepEffectEnvironmentType
// NumValues: 0x0003
enum class EFootstepEffectEnvironmentType : uint8
{
	Default                                  = 0,
	Wet                                      = 1,
	EFootstepEffectEnvironmentType_MAX       = 2,
};

// Enum X6Game.EFootstepEffectShoeType
// NumValues: 0x0007
enum class EFootstepEffectShoeType : uint8
{
	BareFoot                                 = 0,
	Flattie                                  = 1,
	LowHeel                                  = 2,
	MidHeel                                  = 3,
	HighHeel                                 = 4,
	SuperHighHeel                            = 5,
	EFootstepEffectShoeType_MAX              = 6,
};

// Enum X6Game.EFootstepAnimationType
// NumValues: 0x000B
enum class EFootstepAnimationType : uint8
{
	None                                     = 0,
	JumpStart                                = 1,
	JumpStop                                 = 2,
	RunHeavy                                 = 3,
	RunLight                                 = 4,
	Bike_Loop                                = 5,
	Bike_Braking                             = 6,
	Bike_JumpFront                           = 7,
	Bike_JumpRear                            = 8,
	Bike_Landing                             = 9,
	EFootstepAnimationType_MAX               = 10,
};

// Enum X6Game.ELookAtMethod
// NumValues: 0x0004
enum class ELookAtMethod : uint8
{
	LookAtNone                               = 0,
	LookAtActor                              = 1,
	LookAtLocation                           = 2,
	ELookAtMethod_MAX                        = 3,
};

// Enum X6Game.ENikkiJumpState
// NumValues: 0x0005
enum class ENikkiJumpState : uint8
{
	ENJS_NONE                                = 0,
	ENJS_TAKEOFF                             = 1,
	ENJS_FLOAT                               = 2,
	ENJS_FALL                                = 3,
	ENJS_MAX                                 = 4,
};

// Enum X6Game.ENikkiJumpState_TakeOff
// NumValues: 0x0003
enum class ENikkiJumpState_TakeOff : uint8
{
	ENJS_TO_TAKEOFF                          = 0,
	ENJS_TO_VAULT                            = 1,
	ENJS_TO_MAX                              = 2,
};

// Enum X6Game.ENikkiJumpState_Fall
// NumValues: 0x0003
enum class ENikkiJumpState_Fall : uint8
{
	ENJS_F_TAKEOFF                           = 0,
	ENJS_F_VAULT                             = 1,
	ENJS_F_MAX                               = 2,
};

// Enum X6Game.EEaseMode
// NumValues: 0x0006
enum class EEaseMode : uint8
{
	LinearIn                                 = 0,
	QuadEaseIn                               = 1,
	QuadEaseOut                              = 2,
	CubicEaseIn                              = 3,
	CubicEaseOut                             = 4,
	EEaseMode_MAX                            = 5,
};

// Enum X6Game.ERuleTriggerTiming
// NumValues: 0x0004
enum class ERuleTriggerTiming : uint8
{
	OnRulePass                               = 0,
	OnFirstEnterRange                        = 1,
	OnFirstLeaveRange                        = 2,
	ERuleTriggerTiming_MAX                   = 3,
};

// Enum X6Game.ETargetSwitchMode
// NumValues: 0x0006
enum class ETargetSwitchMode : uint8
{
	TargetSwitchMode_None                    = 0,
	TargetSwitchMode_ActiveTryLocking        = 1,
	TargetSwitchMode_PlaySkill               = 2,
	TargetSwitchMode_Attacked                = 3,
	TargetSwitchMode_Death                   = 4,
	TargetSwitchMode_MAX                     = 5,
};

// Enum X6Game.EVisibilityClipMode
// NumValues: 0x0003
enum class EVisibilityClipMode : uint8
{
	OutOfViewport                            = 0,
	BelowViewport                            = 1,
	EVisibilityClipMode_MAX                  = 2,
};

// Enum X6Game.ESenseShapeProperty
// NumValues: 0x0007
enum class ESenseShapeProperty : uint8
{
	Radius                                   = 0,
	LostRadius                               = 1,
	Degrees                                  = 2,
	LostDegrees                              = 3,
	Height                                   = 4,
	LostHeight                               = 5,
	ESenseShapeProperty_MAX                  = 6,
};

// Enum X6Game.EX6AISenseSightResultType
// NumValues: 0x0004
enum class EX6AISenseSightResultType : uint8
{
	InSight                                  = 0,
	OutSight                                 = 1,
	TraceHit                                 = 2,
	EX6AISenseSightResultType_MAX            = 3,
};

// Enum X6Game.EX6ArcOrientation
// NumValues: 0x0005
enum class EX6ArcOrientation : uint8
{
	Top                                      = 0,
	Bottom                                   = 1,
	Left                                     = 2,
	Right                                    = 3,
	EX6ArcOrientation_MAX                    = 4,
};

// Enum X6Game.EX6AsyncTraceType
// NumValues: 0x0004
enum class EX6AsyncTraceType : uint8
{
	ATT_FastCheck                            = 0,
	ATT_Single                               = 1,
	ATT_Multi                                = 2,
	ATT_MAX                                  = 3,
};

// Enum X6Game.ETrackBehaviourType
// NumValues: 0x0005
enum class ETrackBehaviourType : uint8
{
	OneShot                                  = 0,
	OneShot_Reverse                          = 1,
	Loop_Reset                               = 2,
	PingPong                                 = 3,
	ETrackBehaviourType_MAX                  = 4,
};

// Enum X6Game.EInitializationMode
// NumValues: 0x0003
enum class EInitializationMode : uint8
{
	BySplineInputKey                         = 0,
	BySplineIndex                            = 1,
	EInitializationMode_MAX                  = 2,
};

// Enum X6Game.EX6BulletClass
// NumValues: 0x0004
enum class EX6BulletClass : uint8
{
	BC_Default                               = 0,
	EffectBullet                             = 1,
	EffectFlyItem                            = 2,
	EX6BulletClass_MAX                       = 3,
};

// Enum X6Game.EActorBuoyancyState
// NumValues: 0x0007
enum class EActorBuoyancyState : uint8
{
	EBuoyancyState_None                      = 0,
	EBuoyancyState_EnteringWater             = 1,
	EBuoyancyState_FloatOnWater              = 2,
	EBuoyancyState_FloatInWater              = 3,
	EBuoyancyState_StayAtWaterBottom         = 4,
	EBuoyancyState_FrozenByWaterIce          = 5,
	EBuoyancyState_MAX                       = 6,
};

// Enum X6Game.ESimulateWaterFlowType
// NumValues: 0x0005
enum class ESimulateWaterFlowType : uint8
{
	EWaterFlow_None                          = 0,
	EWaterFlow_TowardToTargetPoint           = 1,
	EWaterFlow_LeaveFromPoint                = 2,
	EWaterFlow_FlowAlongLine                 = 3,
	EWaterFlow_MAX                           = 4,
};

// Enum X6Game.EPlayerCameraWorkingState
// NumValues: 0x0003
enum class EPlayerCameraWorkingState : uint8
{
	ECameraState_None                        = 0,
	ECameraState_FocusOnActor                = 1,
	ECameraState_Max                         = 2,
};

// Enum X6Game.EPlayerCameraFocusType
// NumValues: 0x0007
enum class EPlayerCameraFocusType : uint8
{
	EFocus_None                              = 0,
	EFocus_LookAtStatically                  = 1,
	EFocus_LookAtShake                       = 2,
	EFocus_LookAtInCircleTrack               = 3,
	EFocus_LookAtMoveForward                 = 4,
	EFocus_LookAtZoomInOut                   = 5,
	EFocus_Max                               = 6,
};

// Enum X6Game.EPlayerCameraFocusBlendType
// NumValues: 0x0004
enum class EPlayerCameraFocusBlendType : uint8
{
	EFocusBlend_None                         = 0,
	EFocusBlend_InTime                       = 1,
	EFocusBlend_AtSpeed                      = 2,
	EFocusBlend_Max                          = 3,
};

// Enum X6Game.EPlayerCameraState
// NumValues: 0x0005
enum class EPlayerCameraState : uint8
{
	Idle                                     = 0,
	Sprint                                   = 1,
	Targeting                                = 2,
	SuperSkill                               = 3,
	EPlayerCameraState_MAX                   = 4,
};

// Enum X6Game.EBlendFunction
// NumValues: 0x0006
enum class EBlendFunction : uint8
{
	Cubic                                    = 0,
	EaseIn                                   = 1,
	EaseOut                                  = 2,
	EaseInOut                                = 3,
	Curve                                    = 4,
	EBlendFunction_MAX                       = 5,
};

// Enum X6Game.EX6ComponentRepInfoResolveMethod
// NumValues: 0x0004
enum class EX6ComponentRepInfoResolveMethod : uint32
{
	None                                     = 0,
	Path                                     = 1,
	OwnerSpawnerIDAndName                    = 2,
	EX6ComponentRepInfoResolveMethod_MAX     = 3,
};

// Enum X6Game.EBushType
// NumValues: 0x0005
enum class EBushType : uint8
{
	None                                     = 0,
	SmallBush                                = 1,
	BigBush                                  = 2,
	FlowerBush                               = 3,
	EBushType_MAX                            = 4,
};

// Enum X6Game.EX6CustomMovementMode
// NumValues: 0x0004
enum class EX6CustomMovementMode : uint8
{
	EX6CustomMove_None                       = 0,
	EX6CustomMove_EmotionPerformance         = 1,
	EX6CustomMove_Frozen                     = 2,
	EX6CustomMove_MAX                        = 3,
};

// Enum X6Game.EGameSavedDirType
// NumValues: 0x0003
enum class EGameSavedDirType : uint8
{
	Root                                     = 0,
	Temp                                     = 1,
	EGameSavedDirType_MAX                    = 2,
};

// Enum X6Game.EFollowSplineState
// NumValues: 0x000A
enum class EFollowSplineState : uint8
{
	Idle                                     = 0,
	Prepare                                  = 1,
	Start                                    = 2,
	Move                                     = 3,
	Stop                                     = 4,
	ShowTime                                 = 5,
	ReactToNikki                             = 6,
	End                                      = 7,
	WaitingReturnStart                       = 8,
	EFollowSplineState_MAX                   = 9,
};

// Enum X6Game.EMovingState
// NumValues: 0x0004
enum class EMovingState : uint8
{
	Center                                   = 0,
	Offset                                   = 1,
	ReturnCenter                             = 2,
	EMovingState_MAX                         = 3,
};

// Enum X6Game.EX6AbilityActivationPolicy
// NumValues: 0x0005
enum class EX6AbilityActivationPolicy : uint8
{
	OnInputTriggered                         = 0,
	OnSpawn                                  = 1,
	OnInputReleaseMonitor                    = 2,
	OnInputTimeoutMonitor                    = 3,
	EX6AbilityActivationPolicy_MAX           = 4,
};

// Enum X6Game.EX6BulletDestroyType
// NumValues: 0x0007
enum class EX6BulletDestroyType : uint8
{
	None                                     = 0,
	HitDestroy                               = 1,
	TimeOutDestroy                           = 2,
	StaticCollisionDestroy                   = 3,
	CollisionBulletDestroy                   = 4,
	CollisionSummonActor                     = 5,
	EX6BulletDestroyType_MAX                 = 6,
};

// Enum X6Game.ETraceSelect
// NumValues: 0x0009
enum class ETraceSelect : uint8
{
	LineTraceSingle                          = 0,
	LineTraceMulti                           = 1,
	SphereTraceSingle                        = 2,
	SphereTraceMulti                         = 3,
	BoxTraceSingle                           = 4,
	BoxTraceMulti                            = 5,
	CapsuleTraceSingle                       = 6,
	CapsuleTraceMulti                        = 7,
	ETraceSelect_MAX                         = 8,
};

// Enum X6Game.EFilterOutLineType
// NumValues: 0x0004
enum class EFilterOutLineType : uint8
{
	AlwaysAimingType                         = 0,
	ChargeUpPreAimingType                    = 1,
	ChargeUpFinishAimingType                 = 2,
	EFilterOutLineType_MAX                   = 3,
};

// Enum X6Game.EOutLineEffectType
// NumValues: 0x0004
enum class EOutLineEffectType : uint8
{
	WholeOutlineType                         = 0,
	StencilGradientOutlineType               = 1,
	StencilInvalidOutlineType                = 2,
	EOutLineEffectType_MAX                   = 3,
};

// Enum X6Game.EMovementBlockedByType
// NumValues: 0x0004
enum class EMovementBlockedByType : uint8
{
	MOVEBLOCKEDBY_None                       = 0,
	MOVEBLOCKEDBY_Lower                      = 1,
	MOVEBLOCKEDBY_Higher                     = 2,
	MOVEBLOCKEDBY_MAX                        = 3,
};

// Enum X6Game.EHandHeldObjType
// NumValues: 0x0004
enum class EHandHeldObjType : uint8
{
	EHandHeldObjType_Custom                  = 0,
	EHandHeldObjType_StaticMesh              = 1,
	EHandHeldObjType_SkeletalMesh            = 2,
	EHandHeldObjType_MAX                     = 3,
};

// Enum X6Game.EBuffDurationType
// NumValues: 0x0004
enum class EBuffDurationType : uint8
{
	Instant                                  = 0,
	Infinite                                 = 1,
	HasDuration                              = 2,
	EBuffDurationType_MAX                    = 3,
};

// Enum X6Game.ERegularLocomotionType
// NumValues: 0x0006
enum class ERegularLocomotionType : uint8
{
	EMovementType_None                       = 0,
	EMovementType_Walking                    = 1,
	EMovementType_Running                    = 2,
	EMovementType_Sprinting                  = 3,
	EMovementType_MAX                        = 4,
	Max                                      = 5,
};

// Enum X6Game.EPlayerRegularForbidInputType
// NumValues: 0x0006
enum class EPlayerRegularForbidInputType : uint8
{
	Common                                   = 0,
	Interactive                              = 1,
	AdjustTransform                          = 2,
	Mantle                                   = 3,
	Skill                                    = 4,
	EPlayerRegularForbidInputType_MAX        = 5,
};

// Enum X6Game.ERegularFloatingJumpStage
// NumValues: 0x0006
enum class ERegularFloatingJumpStage : uint8
{
	OnLand                                   = 0,
	Jump                                     = 1,
	Fall                                     = 2,
	Crash                                    = 3,
	Float                                    = 4,
	ERegularFloatingJumpStage_MAX            = 5,
};

// Enum X6Game.ERegularJumpActionType
// NumValues: 0x0005
enum class ERegularJumpActionType : uint8
{
	Jump                                     = 0,
	Rejump                                   = 1,
	Float                                    = 2,
	ReleaseToFall                            = 3,
	ERegularJumpActionType_MAX               = 4,
};

// Enum X6Game.ERegularJumpMode
// NumValues: 0x0006
enum class ERegularJumpMode : uint8
{
	Normal                                   = 0,
	Mantle                                   = 1,
	WalkingOffLedge                          = 2,
	LandingCache                             = 3,
	BeingLaunched                            = 4,
	ERegularJumpMode_MAX                     = 5,
};

// Enum X6Game.ERegularPlaySkillMovementType
// NumValues: 0x0006
enum class ERegularPlaySkillMovementType : uint8
{
	None                                     = 0,
	SlowDown                                 = 1,
	Stop                                     = 2,
	JustStopZ                                = 3,
	Crash                                    = 4,
	ERegularPlaySkillMovementType_MAX        = 5,
};

// Enum X6Game.EX6EnvResponseType
// NumValues: 0x0005
enum class EX6EnvResponseType : uint8
{
	None                                     = 0,
	IdleBreak                                = 1,
	OverlayBlend                             = 2,
	Montage                                  = 3,
	EX6EnvResponseType_MAX                   = 4,
};

// Enum X6Game.EX6InteractiveIdleBreakParticipantFacingDirection
// NumValues: 0x0004
enum class EX6InteractiveIdleBreakParticipantFacingDirection : uint8
{
	None                                     = 0,
	TowardsInitiator                         = 1,
	TowardsInitiatorForward                  = 2,
	EX6InteractiveIdleBreakParticipantFacingDirection_MAX = 3,
};

// Enum X6Game.EGlobalIlluminationMethod
// NumValues: 0x0004
enum class EGlobalIlluminationMethod : uint8
{
	None                                     = 0,
	Enlighten                                = 1,
	Lumen                                    = 2,
	EGlobalIlluminationMethod_MAX            = 3,
};

// Enum X6Game.ESceneDetailMode
// NumValues: 0x0005
enum class ESceneDetailMode : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	ESceneDetailMode_MAX                     = 4,
};

// Enum X6Game.EGUSAntiAliasingMethod
// NumValues: 0x000A
enum class EGUSAntiAliasingMethod : uint8
{
	Off                                      = 0,
	FXAA                                     = 1,
	TAA                                      = 2,
	MSAA                                     = 3,
	TSR                                      = 4,
	DLSS                                     = 5,
	FSR3                                     = 6,
	MobileFSR2                               = 7,
	MobileGSR2                               = 8,
	EGUSAntiAliasingMethod_MAX               = 9,
};

// Enum X6Game.EUpScaleMode
// NumValues: 0x0003
enum class EUpScaleMode : uint8
{
	Default                                  = 0,
	Custom                                   = 1,
	EUpScaleMode_MAX                         = 2,
};

// Enum X6Game.ET2StaticNpcDistanceLevel
// NumValues: 0x0007
enum class ET2StaticNpcDistanceLevel : uint8
{
	E_DistanceNone                           = 0,
	E_ClosestDistance                        = 1,
	E_MiddleDistance                         = 2,
	E_FarDistance                            = 3,
	E_FarAwayDistance                        = 4,
	E_DistanceMax                            = 5,
	E_MAX                                    = 6,
};

// Enum X6Game.EX6GameArea
// NumValues: 0x0003
enum class EX6GameArea : uint8
{
	Cn                                       = 0,
	Oversea                                  = 1,
	EX6GameArea_MAX                          = 2,
};

// Enum X6Game.EX6DirectMoveCheckMode
// NumValues: 0x0003
enum class EX6DirectMoveCheckMode : uint8
{
	LineCheck                                = 0,
	CapsuleCheck                             = 1,
	EX6DirectMoveCheckMode_MAX               = 2,
};

// Enum X6Game.EX6AIMoveRequestFlag
// NumValues: 0x0007
enum class EX6AIMoveRequestFlag : uint8
{
	None                                     = 0,
	KeepHeight                               = 1,
	UpdatePath                               = 2,
	DisableForceRepath                       = 4,
	SimulatePath                             = 8,
	FirstScriptFlagShift                     = 9,
	EX6AIMoveRequestFlag_MAX                 = 10,
};

// Enum X6Game.EX6FunctionExec
// NumValues: 0x0003
enum class EX6FunctionExec : uint8
{
	EAFE_Valid                               = 0,
	EAFE_InValid                             = 1,
	EAFE_MAX                                 = 2,
};

// Enum X6Game.EMantleTypeNative
// NumValues: 0x0006
enum class EMantleTypeNative : uint8
{
	NoMantle                                 = 0,
	LowMantle                                = 1,
	MidMantle                                = 2,
	HighMantle                               = 3,
	TransitionMantle                         = 4,
	EMantleTypeNative_MAX                    = 5,
};

// Enum X6Game.EX6TargetingAOEShape
// NumValues: 0x0006
enum class EX6TargetingAOEShape : uint8
{
	Box                                      = 0,
	Cylinder                                 = 1,
	Sphere                                   = 2,
	Capsule                                  = 3,
	SourceComponent                          = 4,
	EX6TargetingAOEShape_MAX                 = 5,
};

// Enum X6Game.EX6SystemMsgType
// NumValues: 0x0004
enum class EX6SystemMsgType : uint8
{
	StoreEmpty                               = 0,
	CameraNotConnected                       = 1,
	CommunicationRestriction                 = 2,
	EX6SystemMsgType_MAX                     = 3,
};

// Enum X6Game.EX6CommerceType
// NumValues: 0x0002
enum class EX6CommerceType : uint8
{
	Premium                                  = 0,
	EX6CommerceType_MAX                      = 1,
};

// Enum X6Game.ECarriageMovingState
// NumValues: 0x0003
enum class ECarriageMovingState : uint8
{
	Center                                   = 0,
	ReturnCenter                             = 1,
	ECarriageMovingState_MAX                 = 2,
};

// Enum X6Game.ECarriageFollowSplineState
// NumValues: 0x0008
enum class ECarriageFollowSplineState : uint8
{
	Idle                                     = 0,
	Prepare                                  = 1,
	Start                                    = 2,
	Move                                     = 3,
	Stop                                     = 4,
	PauseMove                                = 5,
	End                                      = 6,
	ECarriageFollowSplineState_MAX           = 7,
};

// Enum X6Game.EX6AbilityActivationGroup
// NumValues: 0x0004
enum class EX6AbilityActivationGroup : uint8
{
	Independent                              = 0,
	Exclusive_Replaceable                    = 1,
	Exclusive_Blocking                       = 2,
	MAX                                      = 3,
};

// ScriptStruct X6Game.DaMiaoInAirJumpAnimSet
// 0x0010 (0x0010 - 0x0000)
struct FDaMiaoInAirJumpAnimSet final
{
public:
	class UAnimSequence*                          JumpStart;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpStartLoop;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDaMiaoInAirJumpAnimSet) == 0x000008, "Wrong alignment on FDaMiaoInAirJumpAnimSet");
static_assert(sizeof(FDaMiaoInAirJumpAnimSet) == 0x000010, "Wrong size on FDaMiaoInAirJumpAnimSet");
static_assert(offsetof(FDaMiaoInAirJumpAnimSet, JumpStart) == 0x000000, "Member 'FDaMiaoInAirJumpAnimSet::JumpStart' has a wrong offset!");
static_assert(offsetof(FDaMiaoInAirJumpAnimSet, JumpStartLoop) == 0x000008, "Member 'FDaMiaoInAirJumpAnimSet::JumpStartLoop' has a wrong offset!");

// ScriptStruct X6Game.LookAtParams
// 0x000C (0x000C - 0x0000)
struct FLookAtParams final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideTriggerTurnAngle;                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepLookAtAngle;                                   // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAtParams) == 0x000004, "Wrong alignment on FLookAtParams");
static_assert(sizeof(FLookAtParams) == 0x00000C, "Wrong size on FLookAtParams");
static_assert(offsetof(FLookAtParams, LookAtEventType) == 0x000000, "Member 'FLookAtParams::LookAtEventType' has a wrong offset!");
static_assert(offsetof(FLookAtParams, OverrideTriggerTurnAngle) == 0x000004, "Member 'FLookAtParams::OverrideTriggerTurnAngle' has a wrong offset!");
static_assert(offsetof(FLookAtParams, KeepLookAtAngle) == 0x000008, "Member 'FLookAtParams::KeepLookAtAngle' has a wrong offset!");

// ScriptStruct X6Game.FoliageGeometryInfo
// 0x0080 (0x0080 - 0x0000)
struct FFoliageGeometryInfo final
{
public:
	struct FTransform                             InstanceTransform;                                 // 0x0000(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InstanceBoxExtent;                                 // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageGeometryInfo) == 0x000010, "Wrong alignment on FFoliageGeometryInfo");
static_assert(sizeof(FFoliageGeometryInfo) == 0x000080, "Wrong size on FFoliageGeometryInfo");
static_assert(offsetof(FFoliageGeometryInfo, InstanceTransform) == 0x000000, "Member 'FFoliageGeometryInfo::InstanceTransform' has a wrong offset!");
static_assert(offsetof(FFoliageGeometryInfo, InstanceBoxExtent) == 0x000060, "Member 'FFoliageGeometryInfo::InstanceBoxExtent' has a wrong offset!");

// ScriptStruct X6Game.BipedalGroundedMoveAnimSet
// 0x0048 (0x0048 - 0x0000)
struct FBipedalGroundedMoveAnimSet final
{
public:
	class UBlendSpace*                            WalkJogBlendSpace;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      WalkInPlace;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Walk;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardWalkSpeed;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Jog;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardJogSpeed;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardSprintSpeed;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Sprint;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            JogLeanAdditiveBlendSpace;                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SprintLeanAdditiveBlendSpace;                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBipedalGroundedMoveAnimSet) == 0x000008, "Wrong alignment on FBipedalGroundedMoveAnimSet");
static_assert(sizeof(FBipedalGroundedMoveAnimSet) == 0x000048, "Wrong size on FBipedalGroundedMoveAnimSet");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, WalkJogBlendSpace) == 0x000000, "Member 'FBipedalGroundedMoveAnimSet::WalkJogBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, WalkInPlace) == 0x000008, "Member 'FBipedalGroundedMoveAnimSet::WalkInPlace' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, Walk) == 0x000010, "Member 'FBipedalGroundedMoveAnimSet::Walk' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, StandardWalkSpeed) == 0x000018, "Member 'FBipedalGroundedMoveAnimSet::StandardWalkSpeed' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, Jog) == 0x000020, "Member 'FBipedalGroundedMoveAnimSet::Jog' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, StandardJogSpeed) == 0x000028, "Member 'FBipedalGroundedMoveAnimSet::StandardJogSpeed' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, StandardSprintSpeed) == 0x00002C, "Member 'FBipedalGroundedMoveAnimSet::StandardSprintSpeed' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, Sprint) == 0x000030, "Member 'FBipedalGroundedMoveAnimSet::Sprint' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, JogLeanAdditiveBlendSpace) == 0x000038, "Member 'FBipedalGroundedMoveAnimSet::JogLeanAdditiveBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedalGroundedMoveAnimSet, SprintLeanAdditiveBlendSpace) == 0x000040, "Member 'FBipedalGroundedMoveAnimSet::SprintLeanAdditiveBlendSpace' has a wrong offset!");

// ScriptStruct X6Game.RMBehaviorNodeInterface
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FRMBehaviorNodeInterface
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRMBehaviorNodeInterface) == 0x000008, "Wrong alignment on FRMBehaviorNodeInterface");
static_assert(sizeof(FRMBehaviorNodeInterface) == 0x000008, "Wrong size on FRMBehaviorNodeInterface");

// ScriptStruct X6Game.RMBehavior_OnGround_StartTurnAroundMovement
// 0x0008 (0x0010 - 0x0008)
struct FRMBehavior_OnGround_StartTurnAroundMovement final : public FRMBehaviorNodeInterface
{
public:
	class AX6PlayerCameraManager*                 CurPlayerCameraManager;                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRMBehavior_OnGround_StartTurnAroundMovement) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_StartTurnAroundMovement");
static_assert(sizeof(FRMBehavior_OnGround_StartTurnAroundMovement) == 0x000010, "Wrong size on FRMBehavior_OnGround_StartTurnAroundMovement");
static_assert(offsetof(FRMBehavior_OnGround_StartTurnAroundMovement, CurPlayerCameraManager) == 0x000008, "Member 'FRMBehavior_OnGround_StartTurnAroundMovement::CurPlayerCameraManager' has a wrong offset!");

// ScriptStruct X6Game.FootIKFeatureTargetData
// 0x0160 (0x0160 - 0x0000)
struct FFootIKFeatureTargetData final
{
public:
	struct FVector                                PelvisTargetOffset;                                // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisAlpha;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftFootLockAlpha;                                 // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftFootIKAlpha;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftFootTargetOffset;                              // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootOffset;                                    // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftFootRotationOffset;                            // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootLockLocation;                              // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftFootLockRotation;                              // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootWorldOffsetLocation;                       // 0x00A0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftFootInAir;                                    // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightFootLockAlpha;                                // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightFootIKAlpha;                                  // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RightFootTargetOffset;                             // 0x00C8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFootOffset;                                   // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightFootRotationOffset;                           // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightFootLockLocation;                             // 0x0110(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightFootLockRotation;                             // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightFootWorldOffsetLocation;                      // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightFootInAir;                                   // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootIKFeatureTargetData) == 0x000008, "Wrong alignment on FFootIKFeatureTargetData");
static_assert(sizeof(FFootIKFeatureTargetData) == 0x000160, "Wrong size on FFootIKFeatureTargetData");
static_assert(offsetof(FFootIKFeatureTargetData, PelvisTargetOffset) == 0x000000, "Member 'FFootIKFeatureTargetData::PelvisTargetOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, PelvisAlpha) == 0x000018, "Member 'FFootIKFeatureTargetData::PelvisAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootLockAlpha) == 0x00001C, "Member 'FFootIKFeatureTargetData::LeftFootLockAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootIKAlpha) == 0x000020, "Member 'FFootIKFeatureTargetData::LeftFootIKAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootTargetOffset) == 0x000028, "Member 'FFootIKFeatureTargetData::LeftFootTargetOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootOffset) == 0x000040, "Member 'FFootIKFeatureTargetData::LeftFootOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootRotationOffset) == 0x000058, "Member 'FFootIKFeatureTargetData::LeftFootRotationOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootLockLocation) == 0x000070, "Member 'FFootIKFeatureTargetData::LeftFootLockLocation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootLockRotation) == 0x000088, "Member 'FFootIKFeatureTargetData::LeftFootLockRotation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, LeftFootWorldOffsetLocation) == 0x0000A0, "Member 'FFootIKFeatureTargetData::LeftFootWorldOffsetLocation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, bLeftFootInAir) == 0x0000B8, "Member 'FFootIKFeatureTargetData::bLeftFootInAir' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootLockAlpha) == 0x0000BC, "Member 'FFootIKFeatureTargetData::RightFootLockAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootIKAlpha) == 0x0000C0, "Member 'FFootIKFeatureTargetData::RightFootIKAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootTargetOffset) == 0x0000C8, "Member 'FFootIKFeatureTargetData::RightFootTargetOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootOffset) == 0x0000E0, "Member 'FFootIKFeatureTargetData::RightFootOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootRotationOffset) == 0x0000F8, "Member 'FFootIKFeatureTargetData::RightFootRotationOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootLockLocation) == 0x000110, "Member 'FFootIKFeatureTargetData::RightFootLockLocation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootLockRotation) == 0x000128, "Member 'FFootIKFeatureTargetData::RightFootLockRotation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, RightFootWorldOffsetLocation) == 0x000140, "Member 'FFootIKFeatureTargetData::RightFootWorldOffsetLocation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetData, bRightFootInAir) == 0x000158, "Member 'FFootIKFeatureTargetData::bRightFootInAir' has a wrong offset!");

// ScriptStruct X6Game.NikkiAroundMeshInfo
// 0x0010 (0x0010 - 0x0000)
struct FNikkiAroundMeshInfo final
{
public:
	TArray<struct FVector2D>                      Info;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNikkiAroundMeshInfo) == 0x000008, "Wrong alignment on FNikkiAroundMeshInfo");
static_assert(sizeof(FNikkiAroundMeshInfo) == 0x000010, "Wrong size on FNikkiAroundMeshInfo");
static_assert(offsetof(FNikkiAroundMeshInfo, Info) == 0x000000, "Member 'FNikkiAroundMeshInfo::Info' has a wrong offset!");

// ScriptStruct X6Game.LookAtRequestParams
// 0x0020 (0x0020 - 0x0000)
struct FLookAtRequestParams final
{
public:
	ELookAtUpdateMode                             LookAtUpdateMode;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PriorityOrder;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocketName;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseAOHead;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryToLookAtWhenOutOfBounds;                       // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomAOSmoothingTime;                            // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTriggerTurn;                                  // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOSmoothingTime;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideTriggerTurnInPlaceAngle;                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlinkEyeWhenLargeOffset;                           // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForwardBaseOnNeckBone;                            // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookAtRequestParams) == 0x000004, "Wrong alignment on FLookAtRequestParams");
static_assert(sizeof(FLookAtRequestParams) == 0x000020, "Wrong size on FLookAtRequestParams");
static_assert(offsetof(FLookAtRequestParams, LookAtUpdateMode) == 0x000000, "Member 'FLookAtRequestParams::LookAtUpdateMode' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, PriorityOrder) == 0x000004, "Member 'FLookAtRequestParams::PriorityOrder' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, TargetSocketName) == 0x000008, "Member 'FLookAtRequestParams::TargetSocketName' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, bOnlyUseAOHead) == 0x000010, "Member 'FLookAtRequestParams::bOnlyUseAOHead' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, bTryToLookAtWhenOutOfBounds) == 0x000011, "Member 'FLookAtRequestParams::bTryToLookAtWhenOutOfBounds' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, bCustomAOSmoothingTime) == 0x000012, "Member 'FLookAtRequestParams::bCustomAOSmoothingTime' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, bNeedTriggerTurn) == 0x000013, "Member 'FLookAtRequestParams::bNeedTriggerTurn' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, AOSmoothingTime) == 0x000014, "Member 'FLookAtRequestParams::AOSmoothingTime' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, OverrideTriggerTurnInPlaceAngle) == 0x000018, "Member 'FLookAtRequestParams::OverrideTriggerTurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, BlinkEyeWhenLargeOffset) == 0x00001C, "Member 'FLookAtRequestParams::BlinkEyeWhenLargeOffset' has a wrong offset!");
static_assert(offsetof(FLookAtRequestParams, bForwardBaseOnNeckBone) == 0x00001D, "Member 'FLookAtRequestParams::bForwardBaseOnNeckBone' has a wrong offset!");

// ScriptStruct X6Game.QueryFlyingFollowPositionArgs
// 0x0038 (0x0038 - 0x0000)
struct FQueryFlyingFollowPositionArgs final
{
public:
	class FName                                   FollowSocket;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetToSocket;                                    // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFollowDistance;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredRelativeDegrees;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumbersOfPoints;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalOffsetAngle;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidCamera;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraAvoidDegrees;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueryFlyingFollowPositionArgs) == 0x000008, "Wrong alignment on FQueryFlyingFollowPositionArgs");
static_assert(sizeof(FQueryFlyingFollowPositionArgs) == 0x000038, "Wrong size on FQueryFlyingFollowPositionArgs");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, FollowSocket) == 0x000000, "Member 'FQueryFlyingFollowPositionArgs::FollowSocket' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, OffsetToSocket) == 0x000008, "Member 'FQueryFlyingFollowPositionArgs::OffsetToSocket' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, MaxFollowDistance) == 0x000020, "Member 'FQueryFlyingFollowPositionArgs::MaxFollowDistance' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, DesiredRelativeDegrees) == 0x000024, "Member 'FQueryFlyingFollowPositionArgs::DesiredRelativeDegrees' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, NumbersOfPoints) == 0x000028, "Member 'FQueryFlyingFollowPositionArgs::NumbersOfPoints' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, VerticalOffsetAngle) == 0x00002C, "Member 'FQueryFlyingFollowPositionArgs::VerticalOffsetAngle' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, bAvoidCamera) == 0x000030, "Member 'FQueryFlyingFollowPositionArgs::bAvoidCamera' has a wrong offset!");
static_assert(offsetof(FQueryFlyingFollowPositionArgs, CameraAvoidDegrees) == 0x000034, "Member 'FQueryFlyingFollowPositionArgs::CameraAvoidDegrees' has a wrong offset!");

// ScriptStruct X6Game.BipedalIdleAnimSet
// 0x0020 (0x0020 - 0x0000)
struct FBipedalIdleAnimSet final
{
public:
	class UAnimSequenceBase*                      IdleReady;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              IdleBreakArray;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         IdleBreakInterval;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBipedalIdleAnimSet) == 0x000008, "Wrong alignment on FBipedalIdleAnimSet");
static_assert(sizeof(FBipedalIdleAnimSet) == 0x000020, "Wrong size on FBipedalIdleAnimSet");
static_assert(offsetof(FBipedalIdleAnimSet, IdleReady) == 0x000000, "Member 'FBipedalIdleAnimSet::IdleReady' has a wrong offset!");
static_assert(offsetof(FBipedalIdleAnimSet, IdleBreakArray) == 0x000008, "Member 'FBipedalIdleAnimSet::IdleBreakArray' has a wrong offset!");
static_assert(offsetof(FBipedalIdleAnimSet, IdleBreakInterval) == 0x000018, "Member 'FBipedalIdleAnimSet::IdleBreakInterval' has a wrong offset!");

// ScriptStruct X6Game.BipedalInAirAnimSet
// 0x0020 (0x0020 - 0x0000)
struct FBipedalInAirAnimSet final
{
public:
	class UAnimSequenceBase*                      Jump;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FallLoop;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopFallLoop;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      LandRecoveryAdditive;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBipedalInAirAnimSet) == 0x000008, "Wrong alignment on FBipedalInAirAnimSet");
static_assert(sizeof(FBipedalInAirAnimSet) == 0x000020, "Wrong size on FBipedalInAirAnimSet");
static_assert(offsetof(FBipedalInAirAnimSet, Jump) == 0x000000, "Member 'FBipedalInAirAnimSet::Jump' has a wrong offset!");
static_assert(offsetof(FBipedalInAirAnimSet, FallLoop) == 0x000008, "Member 'FBipedalInAirAnimSet::FallLoop' has a wrong offset!");
static_assert(offsetof(FBipedalInAirAnimSet, bLoopFallLoop) == 0x000010, "Member 'FBipedalInAirAnimSet::bLoopFallLoop' has a wrong offset!");
static_assert(offsetof(FBipedalInAirAnimSet, LandRecoveryAdditive) == 0x000018, "Member 'FBipedalInAirAnimSet::LandRecoveryAdditive' has a wrong offset!");

// ScriptStruct X6Game.BipedalLocomotionAnimSet
// 0x0088 (0x0088 - 0x0000)
struct FBipedalLocomotionAnimSet final
{
public:
	struct FBipedalIdleAnimSet                    IdleAnimSet;                                       // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBipedalInAirAnimSet                   InAirAnimSet;                                      // 0x0020(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBipedalGroundedMoveAnimSet            GroundedMoveAnimSet;                               // 0x0040(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBipedalLocomotionAnimSet) == 0x000008, "Wrong alignment on FBipedalLocomotionAnimSet");
static_assert(sizeof(FBipedalLocomotionAnimSet) == 0x000088, "Wrong size on FBipedalLocomotionAnimSet");
static_assert(offsetof(FBipedalLocomotionAnimSet, IdleAnimSet) == 0x000000, "Member 'FBipedalLocomotionAnimSet::IdleAnimSet' has a wrong offset!");
static_assert(offsetof(FBipedalLocomotionAnimSet, InAirAnimSet) == 0x000020, "Member 'FBipedalLocomotionAnimSet::InAirAnimSet' has a wrong offset!");
static_assert(offsetof(FBipedalLocomotionAnimSet, GroundedMoveAnimSet) == 0x000040, "Member 'FBipedalLocomotionAnimSet::GroundedMoveAnimSet' has a wrong offset!");

// ScriptStruct X6Game.FootprintConfig
// 0x0050 (0x0050 - 0x0000)
struct FFootprintConfig final
{
public:
	TMap<EFootstepEffectShoeType, TSoftObjectPtr<class UFootstepDecalConfigTemplate>> ShoeTypeMap;   // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootprintConfig) == 0x000008, "Wrong alignment on FFootprintConfig");
static_assert(sizeof(FFootprintConfig) == 0x000050, "Wrong size on FFootprintConfig");
static_assert(offsetof(FFootprintConfig, ShoeTypeMap) == 0x000000, "Member 'FFootprintConfig::ShoeTypeMap' has a wrong offset!");

// ScriptStruct X6Game.FootstepEffectConfig
// 0x0078 (0x0078 - 0x0000)
struct FFootstepEffectConfig final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          NSConfig;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFootprintConfig                       FootprintConfig;                                   // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepEffectConfig) == 0x000008, "Wrong alignment on FFootstepEffectConfig");
static_assert(sizeof(FFootstepEffectConfig) == 0x000078, "Wrong size on FFootstepEffectConfig");
static_assert(offsetof(FFootstepEffectConfig, NSConfig) == 0x000000, "Member 'FFootstepEffectConfig::NSConfig' has a wrong offset!");
static_assert(offsetof(FFootstepEffectConfig, FootprintConfig) == 0x000028, "Member 'FFootstepEffectConfig::FootprintConfig' has a wrong offset!");

// ScriptStruct X6Game.FootstepEffectEnvironmentConfig
// 0x0050 (0x0050 - 0x0000)
struct FFootstepEffectEnvironmentConfig final
{
public:
	TMap<EFootstepEffectEnvironmentType, struct FFootstepEffectConfig> EnvironmentMap;               // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepEffectEnvironmentConfig) == 0x000008, "Wrong alignment on FFootstepEffectEnvironmentConfig");
static_assert(sizeof(FFootstepEffectEnvironmentConfig) == 0x000050, "Wrong size on FFootstepEffectEnvironmentConfig");
static_assert(offsetof(FFootstepEffectEnvironmentConfig, EnvironmentMap) == 0x000000, "Member 'FFootstepEffectEnvironmentConfig::EnvironmentMap' has a wrong offset!");

// ScriptStruct X6Game.InWaterFootstepEffectConfig
// 0x0080 (0x0080 - 0x0000)
struct FInWaterFootstepEffectConfig final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          NSConfig;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, struct FFootprintConfig> FootprintConfigMap;                              // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bConstantEffect;                                   // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInWaterFootstepEffectConfig) == 0x000008, "Wrong alignment on FInWaterFootstepEffectConfig");
static_assert(sizeof(FInWaterFootstepEffectConfig) == 0x000080, "Wrong size on FInWaterFootstepEffectConfig");
static_assert(offsetof(FInWaterFootstepEffectConfig, NSConfig) == 0x000000, "Member 'FInWaterFootstepEffectConfig::NSConfig' has a wrong offset!");
static_assert(offsetof(FInWaterFootstepEffectConfig, FootprintConfigMap) == 0x000028, "Member 'FInWaterFootstepEffectConfig::FootprintConfigMap' has a wrong offset!");
static_assert(offsetof(FInWaterFootstepEffectConfig, bConstantEffect) == 0x000078, "Member 'FInWaterFootstepEffectConfig::bConstantEffect' has a wrong offset!");

// ScriptStruct X6Game.FootstepEffectTableRow
// 0x0150 (0x0158 - 0x0008)
struct FFootstepEffectTableRow final : public FTableRowBase
{
public:
	TMap<EPhysicalSurface, struct FFootstepEffectEnvironmentConfig> PhysicalSurfaceMap;              // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInWaterFootstepEffectConfig           ShallowWaterFootstepConfig;                        // 0x0058(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInWaterFootstepEffectConfig           DeepWaterFootstepConfig;                           // 0x00D8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepEffectTableRow) == 0x000008, "Wrong alignment on FFootstepEffectTableRow");
static_assert(sizeof(FFootstepEffectTableRow) == 0x000158, "Wrong size on FFootstepEffectTableRow");
static_assert(offsetof(FFootstepEffectTableRow, PhysicalSurfaceMap) == 0x000008, "Member 'FFootstepEffectTableRow::PhysicalSurfaceMap' has a wrong offset!");
static_assert(offsetof(FFootstepEffectTableRow, ShallowWaterFootstepConfig) == 0x000058, "Member 'FFootstepEffectTableRow::ShallowWaterFootstepConfig' has a wrong offset!");
static_assert(offsetof(FFootstepEffectTableRow, DeepWaterFootstepConfig) == 0x0000D8, "Member 'FFootstepEffectTableRow::DeepWaterFootstepConfig' has a wrong offset!");

// ScriptStruct X6Game.RootMotionFromEverythingState
// 0x0010 (0x0010 - 0x0000)
struct FRootMotionFromEverythingState final
{
public:
	class FName                                   StateMachineName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionFromEverythingState) == 0x000004, "Wrong alignment on FRootMotionFromEverythingState");
static_assert(sizeof(FRootMotionFromEverythingState) == 0x000010, "Wrong size on FRootMotionFromEverythingState");
static_assert(offsetof(FRootMotionFromEverythingState, StateMachineName) == 0x000000, "Member 'FRootMotionFromEverythingState::StateMachineName' has a wrong offset!");
static_assert(offsetof(FRootMotionFromEverythingState, StateName) == 0x000008, "Member 'FRootMotionFromEverythingState::StateName' has a wrong offset!");

// ScriptStruct X6Game.DaMiaoGaitAnimSet
// 0x0050 (0x0050 - 0x0000)
struct FDaMiaoGaitAnimSet final
{
public:
	class UAnimSequence*                          Start;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SlowCycle;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Cycle;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            LeanAdditive;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardSpeed;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PlayRateCurve;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrideScaleCurve;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlendCycle;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CycleBlendSpeedAlphaCurve;                         // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDaMiaoGaitAnimSet) == 0x000008, "Wrong alignment on FDaMiaoGaitAnimSet");
static_assert(sizeof(FDaMiaoGaitAnimSet) == 0x000050, "Wrong size on FDaMiaoGaitAnimSet");
static_assert(offsetof(FDaMiaoGaitAnimSet, Start) == 0x000000, "Member 'FDaMiaoGaitAnimSet::Start' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, SlowCycle) == 0x000008, "Member 'FDaMiaoGaitAnimSet::SlowCycle' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, Cycle) == 0x000010, "Member 'FDaMiaoGaitAnimSet::Cycle' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, Stop) == 0x000018, "Member 'FDaMiaoGaitAnimSet::Stop' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, LeanAdditive) == 0x000020, "Member 'FDaMiaoGaitAnimSet::LeanAdditive' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, StandardSpeed) == 0x000028, "Member 'FDaMiaoGaitAnimSet::StandardSpeed' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, PlayRateCurve) == 0x000030, "Member 'FDaMiaoGaitAnimSet::PlayRateCurve' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, StrideScaleCurve) == 0x000038, "Member 'FDaMiaoGaitAnimSet::StrideScaleCurve' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, bShouldBlendCycle) == 0x000040, "Member 'FDaMiaoGaitAnimSet::bShouldBlendCycle' has a wrong offset!");
static_assert(offsetof(FDaMiaoGaitAnimSet, CycleBlendSpeedAlphaCurve) == 0x000048, "Member 'FDaMiaoGaitAnimSet::CycleBlendSpeedAlphaCurve' has a wrong offset!");

// ScriptStruct X6Game.DaMiaoGroundedLocomotionAnimSet
// 0x0100 (0x0100 - 0x0000)
struct FDaMiaoGroundedLocomotionAnimSet final
{
public:
	class UAnimSequence*                          IdleReady;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            TurnInPlaceBS;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaMiaoGaitAnimSet                     WalkGaitAnimSet;                                   // 0x0010(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaMiaoGaitAnimSet                     JogGaitAnimSet;                                    // 0x0060(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaMiaoGaitAnimSet                     SprintGaitAnimSet;                                 // 0x00B0(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDaMiaoGroundedLocomotionAnimSet) == 0x000008, "Wrong alignment on FDaMiaoGroundedLocomotionAnimSet");
static_assert(sizeof(FDaMiaoGroundedLocomotionAnimSet) == 0x000100, "Wrong size on FDaMiaoGroundedLocomotionAnimSet");
static_assert(offsetof(FDaMiaoGroundedLocomotionAnimSet, IdleReady) == 0x000000, "Member 'FDaMiaoGroundedLocomotionAnimSet::IdleReady' has a wrong offset!");
static_assert(offsetof(FDaMiaoGroundedLocomotionAnimSet, TurnInPlaceBS) == 0x000008, "Member 'FDaMiaoGroundedLocomotionAnimSet::TurnInPlaceBS' has a wrong offset!");
static_assert(offsetof(FDaMiaoGroundedLocomotionAnimSet, WalkGaitAnimSet) == 0x000010, "Member 'FDaMiaoGroundedLocomotionAnimSet::WalkGaitAnimSet' has a wrong offset!");
static_assert(offsetof(FDaMiaoGroundedLocomotionAnimSet, JogGaitAnimSet) == 0x000060, "Member 'FDaMiaoGroundedLocomotionAnimSet::JogGaitAnimSet' has a wrong offset!");
static_assert(offsetof(FDaMiaoGroundedLocomotionAnimSet, SprintGaitAnimSet) == 0x0000B0, "Member 'FDaMiaoGroundedLocomotionAnimSet::SprintGaitAnimSet' has a wrong offset!");

// ScriptStruct X6Game.LookAtEventInfo
// 0x0004 (0x0004 - 0x0000)
struct FLookAtEventInfo final
{
public:
	float                                         BaseScore;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAtEventInfo) == 0x000004, "Wrong alignment on FLookAtEventInfo");
static_assert(sizeof(FLookAtEventInfo) == 0x000004, "Wrong size on FLookAtEventInfo");
static_assert(offsetof(FLookAtEventInfo, BaseScore) == 0x000000, "Member 'FLookAtEventInfo::BaseScore' has a wrong offset!");

// ScriptStruct X6Game.LookAtEvent
// 0x0050 (0x0050 - 0x0000)
struct FLookAtEvent final
{
public:
	ELookAtEventType                              LookAtEventType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtMethod                                 LookAtMethod;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTurnInPlaceAngle;                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriorityOrder;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLookAtRequestParams                   RequestParams;                                     // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAtEvent) == 0x000008, "Wrong alignment on FLookAtEvent");
static_assert(sizeof(FLookAtEvent) == 0x000050, "Wrong size on FLookAtEvent");
static_assert(offsetof(FLookAtEvent, LookAtEventType) == 0x000000, "Member 'FLookAtEvent::LookAtEventType' has a wrong offset!");
static_assert(offsetof(FLookAtEvent, LookAtMethod) == 0x000001, "Member 'FLookAtEvent::LookAtMethod' has a wrong offset!");
static_assert(offsetof(FLookAtEvent, TargetActor) == 0x000004, "Member 'FLookAtEvent::TargetActor' has a wrong offset!");
static_assert(offsetof(FLookAtEvent, TargetLocation) == 0x000010, "Member 'FLookAtEvent::TargetLocation' has a wrong offset!");
static_assert(offsetof(FLookAtEvent, TriggerTurnInPlaceAngle) == 0x000028, "Member 'FLookAtEvent::TriggerTurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(FLookAtEvent, PriorityOrder) == 0x00002C, "Member 'FLookAtEvent::PriorityOrder' has a wrong offset!");
static_assert(offsetof(FLookAtEvent, RequestParams) == 0x000030, "Member 'FLookAtEvent::RequestParams' has a wrong offset!");

// ScriptStruct X6Game.MaskClip
// 0x0038 (0x0038 - 0x0000)
struct FMaskClip final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MaskTex;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaskPosition;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaskSize;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClipEnable;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaskClip) == 0x000008, "Wrong alignment on FMaskClip");
static_assert(sizeof(FMaskClip) == 0x000038, "Wrong size on FMaskClip");
static_assert(offsetof(FMaskClip, MaskTex) == 0x000008, "Member 'FMaskClip::MaskTex' has a wrong offset!");
static_assert(offsetof(FMaskClip, MaskPosition) == 0x000010, "Member 'FMaskClip::MaskPosition' has a wrong offset!");
static_assert(offsetof(FMaskClip, MaskSize) == 0x000020, "Member 'FMaskClip::MaskSize' has a wrong offset!");
static_assert(offsetof(FMaskClip, ClipEnable) == 0x000030, "Member 'FMaskClip::ClipEnable' has a wrong offset!");

// ScriptStruct X6Game.MaskWidgetStyle
// 0x01C8 (0x01D0 - 0x0008)
struct FMaskWidgetStyle final : public FSlateWidgetStyle
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BackgroundImage;                                   // 0x0010(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FMaskClip>                      MaskClips;                                         // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MaskMatBrush;                                      // 0x00F0(0x00D0)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaskWidgetStyle) == 0x000010, "Wrong alignment on FMaskWidgetStyle");
static_assert(sizeof(FMaskWidgetStyle) == 0x0001D0, "Wrong size on FMaskWidgetStyle");
static_assert(offsetof(FMaskWidgetStyle, BackgroundImage) == 0x000010, "Member 'FMaskWidgetStyle::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FMaskWidgetStyle, MaskClips) == 0x0000E0, "Member 'FMaskWidgetStyle::MaskClips' has a wrong offset!");
static_assert(offsetof(FMaskWidgetStyle, MaskMatBrush) == 0x0000F0, "Member 'FMaskWidgetStyle::MaskMatBrush' has a wrong offset!");

// ScriptStruct X6Game.JumpAnimationState
// 0x0003 (0x0003 - 0x0000)
struct FJumpAnimationState final
{
public:
	ENikkiJumpState                               JumpState;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENikkiJumpState_TakeOff                       JumpState_TakeOff;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENikkiJumpState_Fall                          JumpState_Fall;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJumpAnimationState) == 0x000001, "Wrong alignment on FJumpAnimationState");
static_assert(sizeof(FJumpAnimationState) == 0x000003, "Wrong size on FJumpAnimationState");
static_assert(offsetof(FJumpAnimationState, JumpState) == 0x000000, "Member 'FJumpAnimationState::JumpState' has a wrong offset!");
static_assert(offsetof(FJumpAnimationState, JumpState_TakeOff) == 0x000001, "Member 'FJumpAnimationState::JumpState_TakeOff' has a wrong offset!");
static_assert(offsetof(FJumpAnimationState, JumpState_Fall) == 0x000002, "Member 'FJumpAnimationState::JumpState_Fall' has a wrong offset!");

// ScriptStruct X6Game.NPCMovingAnimSet
// 0x0078 (0x0078 - 0x0000)
struct FNPCMovingAnimSet final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Start_L180_AnimSequence;                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_L90_AnimSequence;                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_F_AnimSequence;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Cycle_AnimSequence;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_AnimSequence;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_L90_AnimSequence;                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_L180_AnimSequence;                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_R90_AnimSequence;                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_R180_AnimSequence;                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_AnimSequence;                               // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_L90_AnimSequence;                           // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_L180_AnimSequence;                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_R90_AnimSequence;                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_R180_AnimSequence;                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCMovingAnimSet) == 0x000008, "Wrong alignment on FNPCMovingAnimSet");
static_assert(sizeof(FNPCMovingAnimSet) == 0x000078, "Wrong size on FNPCMovingAnimSet");
static_assert(offsetof(FNPCMovingAnimSet, MaxSpeed) == 0x000000, "Member 'FNPCMovingAnimSet::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Start_L180_AnimSequence) == 0x000008, "Member 'FNPCMovingAnimSet::Start_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Start_L90_AnimSequence) == 0x000010, "Member 'FNPCMovingAnimSet::Start_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Start_F_AnimSequence) == 0x000018, "Member 'FNPCMovingAnimSet::Start_F_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Cycle_AnimSequence) == 0x000020, "Member 'FNPCMovingAnimSet::Cycle_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_A_AnimSequence) == 0x000028, "Member 'FNPCMovingAnimSet::Stop_A_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_A_L90_AnimSequence) == 0x000030, "Member 'FNPCMovingAnimSet::Stop_A_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_A_L180_AnimSequence) == 0x000038, "Member 'FNPCMovingAnimSet::Stop_A_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_A_R90_AnimSequence) == 0x000040, "Member 'FNPCMovingAnimSet::Stop_A_R90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_A_R180_AnimSequence) == 0x000048, "Member 'FNPCMovingAnimSet::Stop_A_R180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_B_AnimSequence) == 0x000050, "Member 'FNPCMovingAnimSet::Stop_B_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_B_L90_AnimSequence) == 0x000058, "Member 'FNPCMovingAnimSet::Stop_B_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_B_L180_AnimSequence) == 0x000060, "Member 'FNPCMovingAnimSet::Stop_B_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_B_R90_AnimSequence) == 0x000068, "Member 'FNPCMovingAnimSet::Stop_B_R90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCMovingAnimSet, Stop_B_R180_AnimSequence) == 0x000070, "Member 'FNPCMovingAnimSet::Stop_B_R180_AnimSequence' has a wrong offset!");

// ScriptStruct X6Game.NPCLocomotionAnimSet
// 0x00B0 (0x00B0 - 0x0000)
struct FNPCLocomotionAnimSet final
{
public:
	class UAnimSequence*                          Idle_AnimSequence;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          MirrorIdleTransition_AnimSequence;                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TurnInPlace_L180_AnimSequence;                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TurnInPlace_L90_AnimSequence;                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TurnInPlace_L0_AnimSequence;                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAnimSetBySpeed;                             // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNPCMovingAnimSet>              MovingAnimSetBySpeed;                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_L180_AnimSequence;                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_L90_AnimSequence;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_F_AnimSequence;                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Cycle_AnimSequence;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_AnimSequence;                               // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_L90_AnimSequence;                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_L180_AnimSequence;                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_R90_AnimSequence;                           // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_A_R180_AnimSequence;                          // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_AnimSequence;                               // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_L90_AnimSequence;                           // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_L180_AnimSequence;                          // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_R90_AnimSequence;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_B_R180_AnimSequence;                          // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCLocomotionAnimSet) == 0x000008, "Wrong alignment on FNPCLocomotionAnimSet");
static_assert(sizeof(FNPCLocomotionAnimSet) == 0x0000B0, "Wrong size on FNPCLocomotionAnimSet");
static_assert(offsetof(FNPCLocomotionAnimSet, Idle_AnimSequence) == 0x000000, "Member 'FNPCLocomotionAnimSet::Idle_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, MirrorIdleTransition_AnimSequence) == 0x000008, "Member 'FNPCLocomotionAnimSet::MirrorIdleTransition_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, TurnInPlace_L180_AnimSequence) == 0x000010, "Member 'FNPCLocomotionAnimSet::TurnInPlace_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, TurnInPlace_L90_AnimSequence) == 0x000018, "Member 'FNPCLocomotionAnimSet::TurnInPlace_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, TurnInPlace_L0_AnimSequence) == 0x000020, "Member 'FNPCLocomotionAnimSet::TurnInPlace_L0_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, bEnableAnimSetBySpeed) == 0x000028, "Member 'FNPCLocomotionAnimSet::bEnableAnimSetBySpeed' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, MovingAnimSetBySpeed) == 0x000030, "Member 'FNPCLocomotionAnimSet::MovingAnimSetBySpeed' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Start_L180_AnimSequence) == 0x000040, "Member 'FNPCLocomotionAnimSet::Start_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Start_L90_AnimSequence) == 0x000048, "Member 'FNPCLocomotionAnimSet::Start_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Start_F_AnimSequence) == 0x000050, "Member 'FNPCLocomotionAnimSet::Start_F_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Cycle_AnimSequence) == 0x000058, "Member 'FNPCLocomotionAnimSet::Cycle_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_A_AnimSequence) == 0x000060, "Member 'FNPCLocomotionAnimSet::Stop_A_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_A_L90_AnimSequence) == 0x000068, "Member 'FNPCLocomotionAnimSet::Stop_A_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_A_L180_AnimSequence) == 0x000070, "Member 'FNPCLocomotionAnimSet::Stop_A_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_A_R90_AnimSequence) == 0x000078, "Member 'FNPCLocomotionAnimSet::Stop_A_R90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_A_R180_AnimSequence) == 0x000080, "Member 'FNPCLocomotionAnimSet::Stop_A_R180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_B_AnimSequence) == 0x000088, "Member 'FNPCLocomotionAnimSet::Stop_B_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_B_L90_AnimSequence) == 0x000090, "Member 'FNPCLocomotionAnimSet::Stop_B_L90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_B_L180_AnimSequence) == 0x000098, "Member 'FNPCLocomotionAnimSet::Stop_B_L180_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_B_R90_AnimSequence) == 0x0000A0, "Member 'FNPCLocomotionAnimSet::Stop_B_R90_AnimSequence' has a wrong offset!");
static_assert(offsetof(FNPCLocomotionAnimSet, Stop_B_R180_AnimSequence) == 0x0000A8, "Member 'FNPCLocomotionAnimSet::Stop_B_R180_AnimSequence' has a wrong offset!");

// ScriptStruct X6Game.PlayerCameraContext
// 0x0038 (0x0038 - 0x0000)
struct FPlayerCameraContext final
{
public:
	struct FRotator                               CurrentCameraRotation;                             // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreCameraRotation;                                 // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bCameraStateChanged : 1;                           // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnNewTargetCameraBlendEnd : 1;                    // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerCameraContext) == 0x000008, "Wrong alignment on FPlayerCameraContext");
static_assert(sizeof(FPlayerCameraContext) == 0x000038, "Wrong size on FPlayerCameraContext");
static_assert(offsetof(FPlayerCameraContext, CurrentCameraRotation) == 0x000000, "Member 'FPlayerCameraContext::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(FPlayerCameraContext, PreCameraRotation) == 0x000018, "Member 'FPlayerCameraContext::PreCameraRotation' has a wrong offset!");

// ScriptStruct X6Game.RMCameraContext
// 0x0038 (0x0038 - 0x0000)
struct FRMCameraContext final
{
public:
	struct FRotator                               CurrentCameraRotation;                             // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreCameraRotation;                                 // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCameraStateChanged;                               // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraStateChangedByCameraVolume;                 // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnNewTargetCameraBlendEnd;                        // 0x0032(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnNewTargetCameraBlendEndByCameraVolume;          // 0x0033(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRMCameraContext) == 0x000008, "Wrong alignment on FRMCameraContext");
static_assert(sizeof(FRMCameraContext) == 0x000038, "Wrong size on FRMCameraContext");
static_assert(offsetof(FRMCameraContext, CurrentCameraRotation) == 0x000000, "Member 'FRMCameraContext::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(FRMCameraContext, PreCameraRotation) == 0x000018, "Member 'FRMCameraContext::PreCameraRotation' has a wrong offset!");
static_assert(offsetof(FRMCameraContext, bCameraStateChanged) == 0x000030, "Member 'FRMCameraContext::bCameraStateChanged' has a wrong offset!");
static_assert(offsetof(FRMCameraContext, bCameraStateChangedByCameraVolume) == 0x000031, "Member 'FRMCameraContext::bCameraStateChangedByCameraVolume' has a wrong offset!");
static_assert(offsetof(FRMCameraContext, bOnNewTargetCameraBlendEnd) == 0x000032, "Member 'FRMCameraContext::bOnNewTargetCameraBlendEnd' has a wrong offset!");
static_assert(offsetof(FRMCameraContext, bOnNewTargetCameraBlendEndByCameraVolume) == 0x000033, "Member 'FRMCameraContext::bOnNewTargetCameraBlendEndByCameraVolume' has a wrong offset!");

// ScriptStruct X6Game.AngularInputDeadZoneConfig
// 0x0018 (0x0018 - 0x0000)
struct FAngularInputDeadZoneConfig final
{
public:
	struct FVector2D                              StandardDirection;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDeadZoneHalfAngle;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedDeadZoneHalfAngle;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAngularInputDeadZoneConfig) == 0x000008, "Wrong alignment on FAngularInputDeadZoneConfig");
static_assert(sizeof(FAngularInputDeadZoneConfig) == 0x000018, "Wrong size on FAngularInputDeadZoneConfig");
static_assert(offsetof(FAngularInputDeadZoneConfig, StandardDirection) == 0x000000, "Member 'FAngularInputDeadZoneConfig::StandardDirection' has a wrong offset!");
static_assert(offsetof(FAngularInputDeadZoneConfig, BaseDeadZoneHalfAngle) == 0x000010, "Member 'FAngularInputDeadZoneConfig::BaseDeadZoneHalfAngle' has a wrong offset!");
static_assert(offsetof(FAngularInputDeadZoneConfig, MaxSpeedDeadZoneHalfAngle) == 0x000014, "Member 'FAngularInputDeadZoneConfig::MaxSpeedDeadZoneHalfAngle' has a wrong offset!");

// ScriptStruct X6Game.RMInputConfig
// 0x0070 (0x0070 - 0x0000)
struct FRMInputConfig final
{
public:
	bool                                          bEnableInputLimitFeature;                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardInputLowerLimit;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardInputUpperLimit;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOutputLowerLimit;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOutputUpperLimit;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightInputLowerLimit;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightInputUpperLimit;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightOutputLowerLimit;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightOutputUpperLimit;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LogicalFramesPerSecond;                            // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreStartFrames;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStartMovingInputCache;                      // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMovingInputCacheFrames;                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMutationCache;                              // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MutationInputCacheFrames;                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MutationInputSizeThreshold;                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MutationInputDirectionThreshold;                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInvalidInput;                               // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvalidInputFrames;                                // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time_CacheSkillDashInput;                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAngularDeadZone;                            // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAngularInputDeadZoneConfig>    AngularDeadZoneConfigList;                         // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxSpeedDeadZoneDelaySeconds;                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedDeadZoneLerpSeconds;                       // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRMInputConfig) == 0x000008, "Wrong alignment on FRMInputConfig");
static_assert(sizeof(FRMInputConfig) == 0x000070, "Wrong size on FRMInputConfig");
static_assert(offsetof(FRMInputConfig, bEnableInputLimitFeature) == 0x000000, "Member 'FRMInputConfig::bEnableInputLimitFeature' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, ForwardInputLowerLimit) == 0x000004, "Member 'FRMInputConfig::ForwardInputLowerLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, ForwardInputUpperLimit) == 0x000008, "Member 'FRMInputConfig::ForwardInputUpperLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, ForwardOutputLowerLimit) == 0x00000C, "Member 'FRMInputConfig::ForwardOutputLowerLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, ForwardOutputUpperLimit) == 0x000010, "Member 'FRMInputConfig::ForwardOutputUpperLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, RightInputLowerLimit) == 0x000014, "Member 'FRMInputConfig::RightInputLowerLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, RightInputUpperLimit) == 0x000018, "Member 'FRMInputConfig::RightInputUpperLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, RightOutputLowerLimit) == 0x00001C, "Member 'FRMInputConfig::RightOutputLowerLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, RightOutputUpperLimit) == 0x000020, "Member 'FRMInputConfig::RightOutputUpperLimit' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, LogicalFramesPerSecond) == 0x000024, "Member 'FRMInputConfig::LogicalFramesPerSecond' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, PreStartFrames) == 0x000028, "Member 'FRMInputConfig::PreStartFrames' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, bEnableStartMovingInputCache) == 0x00002C, "Member 'FRMInputConfig::bEnableStartMovingInputCache' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, StartMovingInputCacheFrames) == 0x000030, "Member 'FRMInputConfig::StartMovingInputCacheFrames' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, bEnableMutationCache) == 0x000034, "Member 'FRMInputConfig::bEnableMutationCache' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, MutationInputCacheFrames) == 0x000038, "Member 'FRMInputConfig::MutationInputCacheFrames' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, MutationInputSizeThreshold) == 0x00003C, "Member 'FRMInputConfig::MutationInputSizeThreshold' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, MutationInputDirectionThreshold) == 0x000040, "Member 'FRMInputConfig::MutationInputDirectionThreshold' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, bEnableInvalidInput) == 0x000044, "Member 'FRMInputConfig::bEnableInvalidInput' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, InvalidInputFrames) == 0x000048, "Member 'FRMInputConfig::InvalidInputFrames' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, Time_CacheSkillDashInput) == 0x00004C, "Member 'FRMInputConfig::Time_CacheSkillDashInput' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, bEnableAngularDeadZone) == 0x000050, "Member 'FRMInputConfig::bEnableAngularDeadZone' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, AngularDeadZoneConfigList) == 0x000058, "Member 'FRMInputConfig::AngularDeadZoneConfigList' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, MaxSpeedDeadZoneDelaySeconds) == 0x000068, "Member 'FRMInputConfig::MaxSpeedDeadZoneDelaySeconds' has a wrong offset!");
static_assert(offsetof(FRMInputConfig, MaxSpeedDeadZoneLerpSeconds) == 0x00006C, "Member 'FRMInputConfig::MaxSpeedDeadZoneLerpSeconds' has a wrong offset!");

// ScriptStruct X6Game.FrameInputContext
// 0x0018 (0x0018 - 0x0000)
struct FFrameInputContext
{
public:
	float                                         PolishInputValForMoveForward;                      // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishInputValForMoveRight;                        // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreInputValForMoveForward;                   // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreInputValForMoveRight;                     // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurPolishInputForMoveValid;                     // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurDeltaTime;                                      // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameInputContext) == 0x000004, "Wrong alignment on FFrameInputContext");
static_assert(sizeof(FFrameInputContext) == 0x000018, "Wrong size on FFrameInputContext");
static_assert(offsetof(FFrameInputContext, PolishInputValForMoveForward) == 0x000000, "Member 'FFrameInputContext::PolishInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(FFrameInputContext, PolishInputValForMoveRight) == 0x000004, "Member 'FFrameInputContext::PolishInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(FFrameInputContext, PolishPreInputValForMoveForward) == 0x000008, "Member 'FFrameInputContext::PolishPreInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(FFrameInputContext, PolishPreInputValForMoveRight) == 0x00000C, "Member 'FFrameInputContext::PolishPreInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(FFrameInputContext, bIsCurPolishInputForMoveValid) == 0x000010, "Member 'FFrameInputContext::bIsCurPolishInputForMoveValid' has a wrong offset!");
static_assert(offsetof(FFrameInputContext, CurDeltaTime) == 0x000014, "Member 'FFrameInputContext::CurDeltaTime' has a wrong offset!");

// ScriptStruct X6Game.RMInputContext
// 0x00A0 (0x00B8 - 0x0018)
struct FRMInputContext final : public FFrameInputContext
{
public:
	EX6InputDeviceKeyType                         CurInputDeviceKeyType;                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurInputValueForCrash;                            // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurInputValueForJump;                             // 0x001A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurInputValueForFloat;                            // 0x001B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurInputValueForSprint;                           // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurInputValueForWalk;                             // 0x001D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentInputValForMoveForward;                     // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentInputValForMoveRight;                       // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreCacheInputValForMoveForward;              // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PolishPreCacheInputValForMoveRight;                // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForbidHandlePlayerInput;                        // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedDeadZoneConfigEnableTimeToGo;              // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedDeadZoneConfigLerpTimeToGo;                // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMInputConfig                         RMInputConfigContext;                              // 0x0040(0x0070)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRMInputContext) == 0x000008, "Wrong alignment on FRMInputContext");
static_assert(sizeof(FRMInputContext) == 0x0000B8, "Wrong size on FRMInputContext");
static_assert(offsetof(FRMInputContext, CurInputDeviceKeyType) == 0x000018, "Member 'FRMInputContext::CurInputDeviceKeyType' has a wrong offset!");
static_assert(offsetof(FRMInputContext, bCurInputValueForCrash) == 0x000019, "Member 'FRMInputContext::bCurInputValueForCrash' has a wrong offset!");
static_assert(offsetof(FRMInputContext, bCurInputValueForJump) == 0x00001A, "Member 'FRMInputContext::bCurInputValueForJump' has a wrong offset!");
static_assert(offsetof(FRMInputContext, bCurInputValueForFloat) == 0x00001B, "Member 'FRMInputContext::bCurInputValueForFloat' has a wrong offset!");
static_assert(offsetof(FRMInputContext, bCurInputValueForSprint) == 0x00001C, "Member 'FRMInputContext::bCurInputValueForSprint' has a wrong offset!");
static_assert(offsetof(FRMInputContext, bCurInputValueForWalk) == 0x00001D, "Member 'FRMInputContext::bCurInputValueForWalk' has a wrong offset!");
static_assert(offsetof(FRMInputContext, CurrentInputValForMoveForward) == 0x000020, "Member 'FRMInputContext::CurrentInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(FRMInputContext, CurrentInputValForMoveRight) == 0x000024, "Member 'FRMInputContext::CurrentInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(FRMInputContext, PolishPreCacheInputValForMoveForward) == 0x000028, "Member 'FRMInputContext::PolishPreCacheInputValForMoveForward' has a wrong offset!");
static_assert(offsetof(FRMInputContext, PolishPreCacheInputValForMoveRight) == 0x00002C, "Member 'FRMInputContext::PolishPreCacheInputValForMoveRight' has a wrong offset!");
static_assert(offsetof(FRMInputContext, bIsForbidHandlePlayerInput) == 0x000030, "Member 'FRMInputContext::bIsForbidHandlePlayerInput' has a wrong offset!");
static_assert(offsetof(FRMInputContext, MaxSpeedDeadZoneConfigEnableTimeToGo) == 0x000034, "Member 'FRMInputContext::MaxSpeedDeadZoneConfigEnableTimeToGo' has a wrong offset!");
static_assert(offsetof(FRMInputContext, MaxSpeedDeadZoneConfigLerpTimeToGo) == 0x000038, "Member 'FRMInputContext::MaxSpeedDeadZoneConfigLerpTimeToGo' has a wrong offset!");
static_assert(offsetof(FRMInputContext, RMInputConfigContext) == 0x000040, "Member 'FRMInputContext::RMInputConfigContext' has a wrong offset!");

// ScriptStruct X6Game.PlayerLocotionInputConfigContext
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FPlayerLocotionInputConfigContext final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerLocotionInputConfigContext) == 0x000004, "Wrong alignment on FPlayerLocotionInputConfigContext");
static_assert(sizeof(FPlayerLocotionInputConfigContext) == 0x000024, "Wrong size on FPlayerLocotionInputConfigContext");

// ScriptStruct X6Game.RMBehavior_InAir_GatherInputAndCameraInfo
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_InAir_GatherInputAndCameraInfo final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_InAir_GatherInputAndCameraInfo) == 0x000008, "Wrong alignment on FRMBehavior_InAir_GatherInputAndCameraInfo");
static_assert(sizeof(FRMBehavior_InAir_GatherInputAndCameraInfo) == 0x000008, "Wrong size on FRMBehavior_InAir_GatherInputAndCameraInfo");

// ScriptStruct X6Game.RMBehavior_InAir_InputMovement
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_InAir_InputMovement final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_InAir_InputMovement) == 0x000008, "Wrong alignment on FRMBehavior_InAir_InputMovement");
static_assert(sizeof(FRMBehavior_InAir_InputMovement) == 0x000008, "Wrong size on FRMBehavior_InAir_InputMovement");

// ScriptStruct X6Game.RMBehavior_InAir_StartLocomotion
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_InAir_StartLocomotion final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_InAir_StartLocomotion) == 0x000008, "Wrong alignment on FRMBehavior_InAir_StartLocomotion");
static_assert(sizeof(FRMBehavior_InAir_StartLocomotion) == 0x000008, "Wrong size on FRMBehavior_InAir_StartLocomotion");

// ScriptStruct X6Game.RMBehavior_InAir_StopLocomotion
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_InAir_StopLocomotion final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_InAir_StopLocomotion) == 0x000008, "Wrong alignment on FRMBehavior_InAir_StopLocomotion");
static_assert(sizeof(FRMBehavior_InAir_StopLocomotion) == 0x000008, "Wrong size on FRMBehavior_InAir_StopLocomotion");

// ScriptStruct X6Game.RMBehavior_InAir_TurnAroundMovement
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_InAir_TurnAroundMovement final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_InAir_TurnAroundMovement) == 0x000008, "Wrong alignment on FRMBehavior_InAir_TurnAroundMovement");
static_assert(sizeof(FRMBehavior_InAir_TurnAroundMovement) == 0x000008, "Wrong size on FRMBehavior_InAir_TurnAroundMovement");

// ScriptStruct X6Game.RMBehavior_InAir_UpdateMovementAttributes
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_InAir_UpdateMovementAttributes final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_InAir_UpdateMovementAttributes) == 0x000008, "Wrong alignment on FRMBehavior_InAir_UpdateMovementAttributes");
static_assert(sizeof(FRMBehavior_InAir_UpdateMovementAttributes) == 0x000008, "Wrong size on FRMBehavior_InAir_UpdateMovementAttributes");

// ScriptStruct X6Game.RMBehavior_OnGround_GaitBase
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_GaitBase : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_OnGround_GaitBase) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_GaitBase");
static_assert(sizeof(FRMBehavior_OnGround_GaitBase) == 0x000008, "Wrong size on FRMBehavior_OnGround_GaitBase");

// ScriptStruct X6Game.RMBehavior_OnGround_NormalSprint
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_NormalSprint final : public FRMBehavior_OnGround_GaitBase
{
};
static_assert(alignof(FRMBehavior_OnGround_NormalSprint) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_NormalSprint");
static_assert(sizeof(FRMBehavior_OnGround_NormalSprint) == 0x000008, "Wrong size on FRMBehavior_OnGround_NormalSprint");

// ScriptStruct X6Game.RMBehavior_OnGround_Run
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_Run final : public FRMBehavior_OnGround_GaitBase
{
};
static_assert(alignof(FRMBehavior_OnGround_Run) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_Run");
static_assert(sizeof(FRMBehavior_OnGround_Run) == 0x000008, "Wrong size on FRMBehavior_OnGround_Run");

// ScriptStruct X6Game.RMBehavior_OnGround_Walk
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_Walk final : public FRMBehavior_OnGround_GaitBase
{
};
static_assert(alignof(FRMBehavior_OnGround_Walk) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_Walk");
static_assert(sizeof(FRMBehavior_OnGround_Walk) == 0x000008, "Wrong size on FRMBehavior_OnGround_Walk");

// ScriptStruct X6Game.RMBehavior_OnGround_GatherCameraInfo
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_GatherCameraInfo final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_OnGround_GatherCameraInfo) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_GatherCameraInfo");
static_assert(sizeof(FRMBehavior_OnGround_GatherCameraInfo) == 0x000008, "Wrong size on FRMBehavior_OnGround_GatherCameraInfo");

// ScriptStruct X6Game.RMBehavior_OnGround_GatherInputInfo
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_GatherInputInfo final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_OnGround_GatherInputInfo) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_GatherInputInfo");
static_assert(sizeof(FRMBehavior_OnGround_GatherInputInfo) == 0x000008, "Wrong size on FRMBehavior_OnGround_GatherInputInfo");

// ScriptStruct X6Game.RMBehavior_OnGround_InputMovement
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_InputMovement final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_OnGround_InputMovement) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_InputMovement");
static_assert(sizeof(FRMBehavior_OnGround_InputMovement) == 0x000008, "Wrong size on FRMBehavior_OnGround_InputMovement");

// ScriptStruct X6Game.RMBehavior_OnGround_StartLocomotion
// 0x0010 (0x0018 - 0x0008)
struct FRMBehavior_OnGround_StartLocomotion final : public FRMBehaviorNodeInterface
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRMBehavior_OnGround_StartLocomotion) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_StartLocomotion");
static_assert(sizeof(FRMBehavior_OnGround_StartLocomotion) == 0x000018, "Wrong size on FRMBehavior_OnGround_StartLocomotion");

// ScriptStruct X6Game.RMBehavior_OnGround_StopLocomotion
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_StopLocomotion final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_OnGround_StopLocomotion) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_StopLocomotion");
static_assert(sizeof(FRMBehavior_OnGround_StopLocomotion) == 0x000008, "Wrong size on FRMBehavior_OnGround_StopLocomotion");

// ScriptStruct X6Game.RMBehavior_OnGround_TurnAroundMovement
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_OnGround_TurnAroundMovement final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_OnGround_TurnAroundMovement) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_TurnAroundMovement");
static_assert(sizeof(FRMBehavior_OnGround_TurnAroundMovement) == 0x000008, "Wrong size on FRMBehavior_OnGround_TurnAroundMovement");

// ScriptStruct X6Game.RMBehavior_RemoteInAir_StopLocomotion
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_RemoteInAir_StopLocomotion final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_RemoteInAir_StopLocomotion) == 0x000008, "Wrong alignment on FRMBehavior_RemoteInAir_StopLocomotion");
static_assert(sizeof(FRMBehavior_RemoteInAir_StopLocomotion) == 0x000008, "Wrong size on FRMBehavior_RemoteInAir_StopLocomotion");

// ScriptStruct X6Game.RMBehavior_RemoteOnGround_StopLocomotion
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_RemoteOnGround_StopLocomotion final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_RemoteOnGround_StopLocomotion) == 0x000008, "Wrong alignment on FRMBehavior_RemoteOnGround_StopLocomotion");
static_assert(sizeof(FRMBehavior_RemoteOnGround_StopLocomotion) == 0x000008, "Wrong size on FRMBehavior_RemoteOnGround_StopLocomotion");

// ScriptStruct X6Game.RMBehavior_InAir_Main
// 0x0030 (0x0038 - 0x0008)
struct FRMBehavior_InAir_Main final : public FRMBehaviorNodeInterface
{
public:
	struct FRMBehavior_InAir_GatherInputAndCameraInfo RMBehavior_InAir_GatherInputAndCameraInfo;     // 0x0008(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_InputMovement        RMBehavior_InAir_InputMovement;                    // 0x0010(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_StartLocomotion      RMBehavior_InAir_StartLocomotion;                  // 0x0018(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_StopLocomotion       RMBehavior_InAir_StopLocomotion;                   // 0x0020(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_TurnAroundMovement   RMBehavior_InAir_TurnAroundMovement;               // 0x0028(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_UpdateMovementAttributes RMBehavior_InAir_UpdateMovementAttributes;     // 0x0030(0x0008)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRMBehavior_InAir_Main) == 0x000008, "Wrong alignment on FRMBehavior_InAir_Main");
static_assert(sizeof(FRMBehavior_InAir_Main) == 0x000038, "Wrong size on FRMBehavior_InAir_Main");
static_assert(offsetof(FRMBehavior_InAir_Main, RMBehavior_InAir_GatherInputAndCameraInfo) == 0x000008, "Member 'FRMBehavior_InAir_Main::RMBehavior_InAir_GatherInputAndCameraInfo' has a wrong offset!");
static_assert(offsetof(FRMBehavior_InAir_Main, RMBehavior_InAir_InputMovement) == 0x000010, "Member 'FRMBehavior_InAir_Main::RMBehavior_InAir_InputMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_InAir_Main, RMBehavior_InAir_StartLocomotion) == 0x000018, "Member 'FRMBehavior_InAir_Main::RMBehavior_InAir_StartLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_InAir_Main, RMBehavior_InAir_StopLocomotion) == 0x000020, "Member 'FRMBehavior_InAir_Main::RMBehavior_InAir_StopLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_InAir_Main, RMBehavior_InAir_TurnAroundMovement) == 0x000028, "Member 'FRMBehavior_InAir_Main::RMBehavior_InAir_TurnAroundMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_InAir_Main, RMBehavior_InAir_UpdateMovementAttributes) == 0x000030, "Member 'FRMBehavior_InAir_Main::RMBehavior_InAir_UpdateMovementAttributes' has a wrong offset!");

// ScriptStruct X6Game.RMBehavior_OnGround_Main
// 0x0050 (0x0058 - 0x0008)
struct FRMBehavior_OnGround_Main final : public FRMBehaviorNodeInterface
{
public:
	struct FRMBehavior_OnGround_GatherInputInfo   RMBehavior_OnGround_GatherInputInfo;               // 0x0008(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_GatherCameraInfo  RMBehavior_OnGround_GatherCameraInfo;              // 0x0010(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_StopLocomotion    RMBehavior_OnGround_StopLocomotion;                // 0x0018(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_TurnAroundMovement RMBehavior_OnGround_TurnAroundMovement;           // 0x0020(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_StartLocomotion   RMBehavior_OnGround_StartLocomotion;               // 0x0028(0x0018)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_InputMovement     RMBehavior_OnGround_InputMovement;                 // 0x0040(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_StartTurnAroundMovement RMBehavior_OnGround_StartTurnAroundMovement; // 0x0048(0x0010)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRMBehavior_OnGround_Main) == 0x000008, "Wrong alignment on FRMBehavior_OnGround_Main");
static_assert(sizeof(FRMBehavior_OnGround_Main) == 0x000058, "Wrong size on FRMBehavior_OnGround_Main");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_GatherInputInfo) == 0x000008, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_GatherInputInfo' has a wrong offset!");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_GatherCameraInfo) == 0x000010, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_GatherCameraInfo' has a wrong offset!");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_StopLocomotion) == 0x000018, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_StopLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_TurnAroundMovement) == 0x000020, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_TurnAroundMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_StartLocomotion) == 0x000028, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_StartLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_InputMovement) == 0x000040, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_InputMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_OnGround_Main, RMBehavior_OnGround_StartTurnAroundMovement) == 0x000048, "Member 'FRMBehavior_OnGround_Main::RMBehavior_OnGround_StartTurnAroundMovement' has a wrong offset!");

// ScriptStruct X6Game.RMBehavior_PlayerDrivedByAI_OnGround_Main
// 0x0008 (0x0010 - 0x0008)
struct FRMBehavior_PlayerDrivedByAI_OnGround_Main final : public FRMBehaviorNodeInterface
{
public:
	struct FRMBehavior_OnGround_TurnAroundMovement RMBehavior_OnGround_TurnAroundMovement;           // 0x0008(0x0008)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRMBehavior_PlayerDrivedByAI_OnGround_Main) == 0x000008, "Wrong alignment on FRMBehavior_PlayerDrivedByAI_OnGround_Main");
static_assert(sizeof(FRMBehavior_PlayerDrivedByAI_OnGround_Main) == 0x000010, "Wrong size on FRMBehavior_PlayerDrivedByAI_OnGround_Main");
static_assert(offsetof(FRMBehavior_PlayerDrivedByAI_OnGround_Main, RMBehavior_OnGround_TurnAroundMovement) == 0x000008, "Member 'FRMBehavior_PlayerDrivedByAI_OnGround_Main::RMBehavior_OnGround_TurnAroundMovement' has a wrong offset!");

// ScriptStruct X6Game.RMBehavior_RemoteSimulated_InAir_Main
// 0x0030 (0x0038 - 0x0008)
struct FRMBehavior_RemoteSimulated_InAir_Main final : public FRMBehaviorNodeInterface
{
public:
	struct FRMBehavior_InAir_GatherInputAndCameraInfo RMBehavior_InAir_GatherInputAndCameraInfo;     // 0x0008(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_InputMovement        RMBehavior_InAir_InputMovement;                    // 0x0010(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_StartLocomotion      RMBehavior_InAir_StartLocomotion;                  // 0x0018(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_RemoteInAir_StopLocomotion RMBehavior_InAir_StopLocomotion;                   // 0x0020(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_TurnAroundMovement   RMBehavior_InAir_TurnAroundMovement;               // 0x0028(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_InAir_UpdateMovementAttributes RMBehavior_InAir_UpdateMovementAttributes;     // 0x0030(0x0008)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRMBehavior_RemoteSimulated_InAir_Main) == 0x000008, "Wrong alignment on FRMBehavior_RemoteSimulated_InAir_Main");
static_assert(sizeof(FRMBehavior_RemoteSimulated_InAir_Main) == 0x000038, "Wrong size on FRMBehavior_RemoteSimulated_InAir_Main");
static_assert(offsetof(FRMBehavior_RemoteSimulated_InAir_Main, RMBehavior_InAir_GatherInputAndCameraInfo) == 0x000008, "Member 'FRMBehavior_RemoteSimulated_InAir_Main::RMBehavior_InAir_GatherInputAndCameraInfo' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_InAir_Main, RMBehavior_InAir_InputMovement) == 0x000010, "Member 'FRMBehavior_RemoteSimulated_InAir_Main::RMBehavior_InAir_InputMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_InAir_Main, RMBehavior_InAir_StartLocomotion) == 0x000018, "Member 'FRMBehavior_RemoteSimulated_InAir_Main::RMBehavior_InAir_StartLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_InAir_Main, RMBehavior_InAir_StopLocomotion) == 0x000020, "Member 'FRMBehavior_RemoteSimulated_InAir_Main::RMBehavior_InAir_StopLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_InAir_Main, RMBehavior_InAir_TurnAroundMovement) == 0x000028, "Member 'FRMBehavior_RemoteSimulated_InAir_Main::RMBehavior_InAir_TurnAroundMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_InAir_Main, RMBehavior_InAir_UpdateMovementAttributes) == 0x000030, "Member 'FRMBehavior_RemoteSimulated_InAir_Main::RMBehavior_InAir_UpdateMovementAttributes' has a wrong offset!");

// ScriptStruct X6Game.RMBehavior_RemoteSimulated_OnGround_Main
// 0x0050 (0x0058 - 0x0008)
struct FRMBehavior_RemoteSimulated_OnGround_Main final : public FRMBehaviorNodeInterface
{
public:
	struct FRMBehavior_OnGround_GatherInputInfo   RMBehavior_OnGround_GatherInputInfo;               // 0x0008(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_GatherCameraInfo  RMBehavior_OnGround_GatherCameraInfo;              // 0x0010(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_RemoteOnGround_StopLocomotion RMBehavior_OnGround_StopLocomotion;             // 0x0018(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_TurnAroundMovement RMBehavior_OnGround_TurnAroundMovement;           // 0x0020(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_StartLocomotion   RMBehavior_OnGround_StartLocomotion;               // 0x0028(0x0018)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_InputMovement     RMBehavior_OnGround_InputMovement;                 // 0x0040(0x0008)(NativeAccessSpecifierPrivate)
	struct FRMBehavior_OnGround_StartTurnAroundMovement RMBehavior_OnGround_StartTurnAroundMovement; // 0x0048(0x0010)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRMBehavior_RemoteSimulated_OnGround_Main) == 0x000008, "Wrong alignment on FRMBehavior_RemoteSimulated_OnGround_Main");
static_assert(sizeof(FRMBehavior_RemoteSimulated_OnGround_Main) == 0x000058, "Wrong size on FRMBehavior_RemoteSimulated_OnGround_Main");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_GatherInputInfo) == 0x000008, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_GatherInputInfo' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_GatherCameraInfo) == 0x000010, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_GatherCameraInfo' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_StopLocomotion) == 0x000018, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_StopLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_TurnAroundMovement) == 0x000020, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_TurnAroundMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_StartLocomotion) == 0x000028, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_StartLocomotion' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_InputMovement) == 0x000040, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_InputMovement' has a wrong offset!");
static_assert(offsetof(FRMBehavior_RemoteSimulated_OnGround_Main, RMBehavior_OnGround_StartTurnAroundMovement) == 0x000048, "Member 'FRMBehavior_RemoteSimulated_OnGround_Main::RMBehavior_OnGround_StartTurnAroundMovement' has a wrong offset!");

// ScriptStruct X6Game.RMBehavior_Simplified_OnGround_Main
// 0x0000 (0x0008 - 0x0008)
struct FRMBehavior_Simplified_OnGround_Main final : public FRMBehaviorNodeInterface
{
};
static_assert(alignof(FRMBehavior_Simplified_OnGround_Main) == 0x000008, "Wrong alignment on FRMBehavior_Simplified_OnGround_Main");
static_assert(sizeof(FRMBehavior_Simplified_OnGround_Main) == 0x000008, "Wrong size on FRMBehavior_Simplified_OnGround_Main");

// ScriptStruct X6Game.StimuliSource
// 0x0018 (0x0018 - 0x0000)
struct FStimuliSource final
{
public:
	int32                                         StimuliTag;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLifeTimeInfinity : 1;                             // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceRadius;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextTickTime;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStimuliSource) == 0x000004, "Wrong alignment on FStimuliSource");
static_assert(sizeof(FStimuliSource) == 0x000018, "Wrong size on FStimuliSource");
static_assert(offsetof(FStimuliSource, StimuliTag) == 0x000000, "Member 'FStimuliSource::StimuliTag' has a wrong offset!");
static_assert(offsetof(FStimuliSource, LifeTime) == 0x000008, "Member 'FStimuliSource::LifeTime' has a wrong offset!");
static_assert(offsetof(FStimuliSource, SourceRadius) == 0x00000C, "Member 'FStimuliSource::SourceRadius' has a wrong offset!");
static_assert(offsetof(FStimuliSource, TickInterval) == 0x000010, "Member 'FStimuliSource::TickInterval' has a wrong offset!");
static_assert(offsetof(FStimuliSource, NextTickTime) == 0x000014, "Member 'FStimuliSource::NextTickTime' has a wrong offset!");

// ScriptStruct X6Game.StimuliSourceSet
// 0x0038 (0x0038 - 0x0000)
struct FStimuliSourceSet final
{
public:
	int64                                         Identifier;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerActor;                                        // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStimuliSource>                 SourceArray;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStimuliSourceSet) == 0x000008, "Wrong alignment on FStimuliSourceSet");
static_assert(sizeof(FStimuliSourceSet) == 0x000038, "Wrong size on FStimuliSourceSet");
static_assert(offsetof(FStimuliSourceSet, Identifier) == 0x000000, "Member 'FStimuliSourceSet::Identifier' has a wrong offset!");
static_assert(offsetof(FStimuliSourceSet, OwnerActor) == 0x000008, "Member 'FStimuliSourceSet::OwnerActor' has a wrong offset!");
static_assert(offsetof(FStimuliSourceSet, Location) == 0x000010, "Member 'FStimuliSourceSet::Location' has a wrong offset!");
static_assert(offsetof(FStimuliSourceSet, SourceArray) == 0x000028, "Member 'FStimuliSourceSet::SourceArray' has a wrong offset!");

// ScriptStruct X6Game.StimuliPreprocessorRule
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FStimuliPreprocessorRule final
{
public:
	int32                                         RuleID;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StimuliTag;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERuleTriggerTiming                            TriggerTiming;                                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInSight : 1;                                      // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SenseRadius;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SenseAngle;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SenseAngleOffset;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStimuliPreprocessorRule) == 0x000008, "Wrong alignment on FStimuliPreprocessorRule");
static_assert(sizeof(FStimuliPreprocessorRule) == 0x000070, "Wrong size on FStimuliPreprocessorRule");
static_assert(offsetof(FStimuliPreprocessorRule, RuleID) == 0x000000, "Member 'FStimuliPreprocessorRule::RuleID' has a wrong offset!");
static_assert(offsetof(FStimuliPreprocessorRule, Priority) == 0x000004, "Member 'FStimuliPreprocessorRule::Priority' has a wrong offset!");
static_assert(offsetof(FStimuliPreprocessorRule, StimuliTag) == 0x000008, "Member 'FStimuliPreprocessorRule::StimuliTag' has a wrong offset!");
static_assert(offsetof(FStimuliPreprocessorRule, TriggerTiming) == 0x00000C, "Member 'FStimuliPreprocessorRule::TriggerTiming' has a wrong offset!");
static_assert(offsetof(FStimuliPreprocessorRule, SenseRadius) == 0x000014, "Member 'FStimuliPreprocessorRule::SenseRadius' has a wrong offset!");
static_assert(offsetof(FStimuliPreprocessorRule, SenseAngle) == 0x000018, "Member 'FStimuliPreprocessorRule::SenseAngle' has a wrong offset!");
static_assert(offsetof(FStimuliPreprocessorRule, SenseAngleOffset) == 0x00001C, "Member 'FStimuliPreprocessorRule::SenseAngleOffset' has a wrong offset!");

// ScriptStruct X6Game.StimuliPreprocessor
// 0x0010 (0x0010 - 0x0000)
struct FStimuliPreprocessor final
{
public:
	TArray<struct FStimuliPreprocessorRule>       Rules;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStimuliPreprocessor) == 0x000008, "Wrong alignment on FStimuliPreprocessor");
static_assert(sizeof(FStimuliPreprocessor) == 0x000010, "Wrong size on FStimuliPreprocessor");
static_assert(offsetof(FStimuliPreprocessor, Rules) == 0x000000, "Member 'FStimuliPreprocessor::Rules' has a wrong offset!");

// ScriptStruct X6Game.BVHNode
// 0x0040 (0x0048 - 0x0008)
struct FBVHNode final : public FTableRowBase
{
public:
	struct FBox                                   AABB;                                              // 0x0008(0x0038)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LeftIndex;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightIndex;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBVHNode) == 0x000008, "Wrong alignment on FBVHNode");
static_assert(sizeof(FBVHNode) == 0x000048, "Wrong size on FBVHNode");
static_assert(offsetof(FBVHNode, AABB) == 0x000008, "Member 'FBVHNode::AABB' has a wrong offset!");
static_assert(offsetof(FBVHNode, LeftIndex) == 0x000040, "Member 'FBVHNode::LeftIndex' has a wrong offset!");
static_assert(offsetof(FBVHNode, RightIndex) == 0x000044, "Member 'FBVHNode::RightIndex' has a wrong offset!");

// ScriptStruct X6Game.ConsumeTimeInfo
// 0x000C (0x000C - 0x0000)
struct FConsumeTimeInfo final
{
public:
	class FName                                   FunctionName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BudgetTime;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConsumeTimeInfo) == 0x000004, "Wrong alignment on FConsumeTimeInfo");
static_assert(sizeof(FConsumeTimeInfo) == 0x00000C, "Wrong size on FConsumeTimeInfo");
static_assert(offsetof(FConsumeTimeInfo, FunctionName) == 0x000000, "Member 'FConsumeTimeInfo::FunctionName' has a wrong offset!");
static_assert(offsetof(FConsumeTimeInfo, BudgetTime) == 0x000008, "Member 'FConsumeTimeInfo::BudgetTime' has a wrong offset!");

// ScriptStruct X6Game.X6AISightTargetSample
// 0x000C (0x000C - 0x0000)
struct FX6AISightTargetSample final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6AISightTargetSample) == 0x000004, "Wrong alignment on FX6AISightTargetSample");
static_assert(sizeof(FX6AISightTargetSample) == 0x00000C, "Wrong size on FX6AISightTargetSample");
static_assert(offsetof(FX6AISightTargetSample, SocketName) == 0x000000, "Member 'FX6AISightTargetSample::SocketName' has a wrong offset!");
static_assert(offsetof(FX6AISightTargetSample, Weight) == 0x000008, "Member 'FX6AISightTargetSample::Weight' has a wrong offset!");

// ScriptStruct X6Game.ClothMeshSetting
// 0x0030 (0x0030 - 0x0000)
struct FClothMeshSetting final
{
public:
	int32                                         ClothID;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           mesh;                                              // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClothMeshSetting) == 0x000008, "Wrong alignment on FClothMeshSetting");
static_assert(sizeof(FClothMeshSetting) == 0x000030, "Wrong size on FClothMeshSetting");
static_assert(offsetof(FClothMeshSetting, ClothID) == 0x000000, "Member 'FClothMeshSetting::ClothID' has a wrong offset!");
static_assert(offsetof(FClothMeshSetting, mesh) == 0x000008, "Member 'FClothMeshSetting::mesh' has a wrong offset!");

// ScriptStruct X6Game.AvatarConfigInfo
// 0x00A8 (0x00B0 - 0x0008)
struct FAvatarConfigInfo final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MainSkeletalMesh;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCharacterGenAsset>      CharacterGenAsset;                                 // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRuntimeData;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SuitId;                                            // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FClothMeshSetting>   PartToClothMeshMapping;                            // 0x0060(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvatarConfigInfo) == 0x000008, "Wrong alignment on FAvatarConfigInfo");
static_assert(sizeof(FAvatarConfigInfo) == 0x0000B0, "Wrong size on FAvatarConfigInfo");
static_assert(offsetof(FAvatarConfigInfo, MainSkeletalMesh) == 0x000008, "Member 'FAvatarConfigInfo::MainSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FAvatarConfigInfo, CharacterGenAsset) == 0x000030, "Member 'FAvatarConfigInfo::CharacterGenAsset' has a wrong offset!");
static_assert(offsetof(FAvatarConfigInfo, bUseRuntimeData) == 0x000058, "Member 'FAvatarConfigInfo::bUseRuntimeData' has a wrong offset!");
static_assert(offsetof(FAvatarConfigInfo, SuitId) == 0x00005C, "Member 'FAvatarConfigInfo::SuitId' has a wrong offset!");
static_assert(offsetof(FAvatarConfigInfo, PartToClothMeshMapping) == 0x000060, "Member 'FAvatarConfigInfo::PartToClothMeshMapping' has a wrong offset!");

// ScriptStruct X6Game.TrackSegmentOverride
// 0x0020 (0x0020 - 0x0000)
struct FTrackSegmentOverride final
{
public:
	bool                                          bOverrideSpeed;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedOverride;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSpeedBlendOutTime;                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutTimeOverride;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayOnEnter;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayTime;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLaunchTime;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchTime;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackSegmentOverride) == 0x000004, "Wrong alignment on FTrackSegmentOverride");
static_assert(sizeof(FTrackSegmentOverride) == 0x000020, "Wrong size on FTrackSegmentOverride");
static_assert(offsetof(FTrackSegmentOverride, bOverrideSpeed) == 0x000000, "Member 'FTrackSegmentOverride::bOverrideSpeed' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, SpeedOverride) == 0x000004, "Member 'FTrackSegmentOverride::SpeedOverride' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, bOverrideSpeedBlendOutTime) == 0x000008, "Member 'FTrackSegmentOverride::bOverrideSpeedBlendOutTime' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, BlendOutTimeOverride) == 0x00000C, "Member 'FTrackSegmentOverride::BlendOutTimeOverride' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, bStayOnEnter) == 0x000010, "Member 'FTrackSegmentOverride::bStayOnEnter' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, StayTime) == 0x000014, "Member 'FTrackSegmentOverride::StayTime' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, bOverrideLaunchTime) == 0x000018, "Member 'FTrackSegmentOverride::bOverrideLaunchTime' has a wrong offset!");
static_assert(offsetof(FTrackSegmentOverride, LaunchTime) == 0x00001C, "Member 'FTrackSegmentOverride::LaunchTime' has a wrong offset!");

// ScriptStruct X6Game.GetP4GameVersionProcHandle
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGetP4GameVersionProcHandle final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetP4GameVersionProcHandle) == 0x000008, "Wrong alignment on FGetP4GameVersionProcHandle");
static_assert(sizeof(FGetP4GameVersionProcHandle) == 0x000020, "Wrong size on FGetP4GameVersionProcHandle");

// ScriptStruct X6Game.X6BulletShapeTraceContext
// 0x0028 (0x0028 - 0x0000)
struct FX6BulletShapeTraceContext final
{
public:
	int32                                         TraceSelect;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6BulletShapeTraceContext) == 0x000008, "Wrong alignment on FX6BulletShapeTraceContext");
static_assert(sizeof(FX6BulletShapeTraceContext) == 0x000028, "Wrong size on FX6BulletShapeTraceContext");
static_assert(offsetof(FX6BulletShapeTraceContext, TraceSelect) == 0x000000, "Member 'FX6BulletShapeTraceContext::TraceSelect' has a wrong offset!");
static_assert(offsetof(FX6BulletShapeTraceContext, Radius) == 0x000004, "Member 'FX6BulletShapeTraceContext::Radius' has a wrong offset!");
static_assert(offsetof(FX6BulletShapeTraceContext, HalfSize) == 0x000008, "Member 'FX6BulletShapeTraceContext::HalfSize' has a wrong offset!");
static_assert(offsetof(FX6BulletShapeTraceContext, HalfHeight) == 0x000020, "Member 'FX6BulletShapeTraceContext::HalfHeight' has a wrong offset!");

// ScriptStruct X6Game.SimulateWaterFlowKeyPoint
// 0x0010 (0x0010 - 0x0000)
struct FSimulateWaterFlowKeyPoint final
{
public:
	class ATargetPoint*                           KeyPointActor;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeyPointFlowSpeed;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimulateWaterFlowKeyPoint) == 0x000008, "Wrong alignment on FSimulateWaterFlowKeyPoint");
static_assert(sizeof(FSimulateWaterFlowKeyPoint) == 0x000010, "Wrong size on FSimulateWaterFlowKeyPoint");
static_assert(offsetof(FSimulateWaterFlowKeyPoint, KeyPointActor) == 0x000000, "Member 'FSimulateWaterFlowKeyPoint::KeyPointActor' has a wrong offset!");
static_assert(offsetof(FSimulateWaterFlowKeyPoint, KeyPointFlowSpeed) == 0x000008, "Member 'FSimulateWaterFlowKeyPoint::KeyPointFlowSpeed' has a wrong offset!");

// ScriptStruct X6Game.CameraShakeParams
// 0x0010 (0x0018 - 0x0008)
struct FCameraShakeParams final : public FTableRowBase
{
public:
	TSubclassOf<class UCameraShakeBase>           ShakeClass;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraShakeParams) == 0x000008, "Wrong alignment on FCameraShakeParams");
static_assert(sizeof(FCameraShakeParams) == 0x000018, "Wrong size on FCameraShakeParams");
static_assert(offsetof(FCameraShakeParams, ShakeClass) == 0x000008, "Member 'FCameraShakeParams::ShakeClass' has a wrong offset!");
static_assert(offsetof(FCameraShakeParams, Scale) == 0x000010, "Member 'FCameraShakeParams::Scale' has a wrong offset!");

// ScriptStruct X6Game.CameraDOFParams
// 0x0858 (0x0860 - 0x0008)
struct FCameraDOFParams final : public FTableRowBase
{
public:
	bool                                          bIsEnableDOF;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoFocus;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   DOFSettings;                                       // 0x0010(0x0850)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraDOFParams) == 0x000010, "Wrong alignment on FCameraDOFParams");
static_assert(sizeof(FCameraDOFParams) == 0x000860, "Wrong size on FCameraDOFParams");
static_assert(offsetof(FCameraDOFParams, bIsEnableDOF) == 0x000008, "Member 'FCameraDOFParams::bIsEnableDOF' has a wrong offset!");
static_assert(offsetof(FCameraDOFParams, bIsAutoFocus) == 0x000009, "Member 'FCameraDOFParams::bIsAutoFocus' has a wrong offset!");
static_assert(offsetof(FCameraDOFParams, DOFSettings) == 0x000010, "Member 'FCameraDOFParams::DOFSettings' has a wrong offset!");

// ScriptStruct X6Game.X6PrimitiveComponentRepInfo
// 0x0028 (0x0028 - 0x0000)
struct FX6PrimitiveComponentRepInfo final
{
public:
	EX6ComponentRepInfoResolveMethod              ResolveMethod;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Path;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SpawnerID;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6PrimitiveComponentRepInfo) == 0x000008, "Wrong alignment on FX6PrimitiveComponentRepInfo");
static_assert(sizeof(FX6PrimitiveComponentRepInfo) == 0x000028, "Wrong size on FX6PrimitiveComponentRepInfo");
static_assert(offsetof(FX6PrimitiveComponentRepInfo, ResolveMethod) == 0x000000, "Member 'FX6PrimitiveComponentRepInfo::ResolveMethod' has a wrong offset!");
static_assert(offsetof(FX6PrimitiveComponentRepInfo, Path) == 0x000008, "Member 'FX6PrimitiveComponentRepInfo::Path' has a wrong offset!");
static_assert(offsetof(FX6PrimitiveComponentRepInfo, SpawnerID) == 0x000018, "Member 'FX6PrimitiveComponentRepInfo::SpawnerID' has a wrong offset!");
static_assert(offsetof(FX6PrimitiveComponentRepInfo, ComponentName) == 0x000020, "Member 'FX6PrimitiveComponentRepInfo::ComponentName' has a wrong offset!");

// ScriptStruct X6Game.X6MovementBaseInfo
// 0x0040 (0x0040 - 0x0000)
struct FX6MovementBaseInfo final
{
public:
	uint16                                        BaseID;                                            // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6PrimitiveComponentRepInfo           MovementBase;                                      // 0x0008(0x0028)(NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeRotation;                                 // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerHasBaseComponent;                           // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6MovementBaseInfo) == 0x000008, "Wrong alignment on FX6MovementBaseInfo");
static_assert(sizeof(FX6MovementBaseInfo) == 0x000040, "Wrong size on FX6MovementBaseInfo");
static_assert(offsetof(FX6MovementBaseInfo, BaseID) == 0x000000, "Member 'FX6MovementBaseInfo::BaseID' has a wrong offset!");
static_assert(offsetof(FX6MovementBaseInfo, MovementBase) == 0x000008, "Member 'FX6MovementBaseInfo::MovementBase' has a wrong offset!");
static_assert(offsetof(FX6MovementBaseInfo, BoneName) == 0x000030, "Member 'FX6MovementBaseInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FX6MovementBaseInfo, bRelativeRotation) == 0x000038, "Member 'FX6MovementBaseInfo::bRelativeRotation' has a wrong offset!");
static_assert(offsetof(FX6MovementBaseInfo, bServerHasBaseComponent) == 0x000039, "Member 'FX6MovementBaseInfo::bServerHasBaseComponent' has a wrong offset!");

// ScriptStruct X6Game.X6BasedMovementStateInfo
// 0x0040 (0x0040 - 0x0000)
struct FX6BasedMovementStateInfo final
{
public:
	uint16                                        BaseID;                                            // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 Location;                                          // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bServerHasVelocity;                                // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6BasedMovementStateInfo) == 0x000008, "Wrong alignment on FX6BasedMovementStateInfo");
static_assert(sizeof(FX6BasedMovementStateInfo) == 0x000040, "Wrong size on FX6BasedMovementStateInfo");
static_assert(offsetof(FX6BasedMovementStateInfo, BaseID) == 0x000000, "Member 'FX6BasedMovementStateInfo::BaseID' has a wrong offset!");
static_assert(offsetof(FX6BasedMovementStateInfo, Location) == 0x000008, "Member 'FX6BasedMovementStateInfo::Location' has a wrong offset!");
static_assert(offsetof(FX6BasedMovementStateInfo, Rotation) == 0x000020, "Member 'FX6BasedMovementStateInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FX6BasedMovementStateInfo, bServerHasVelocity) == 0x000038, "Member 'FX6BasedMovementStateInfo::bServerHasVelocity' has a wrong offset!");

// ScriptStruct X6Game.X6ReplicatedMovement
// 0x0068 (0x0068 - 0x0000)
struct FX6ReplicatedMovement final
{
public:
	struct FVector                                LinearVelocity;                                    // 0x0000(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0018(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6ReplicatedMovement) == 0x000008, "Wrong alignment on FX6ReplicatedMovement");
static_assert(sizeof(FX6ReplicatedMovement) == 0x000068, "Wrong size on FX6ReplicatedMovement");
static_assert(offsetof(FX6ReplicatedMovement, LinearVelocity) == 0x000000, "Member 'FX6ReplicatedMovement::LinearVelocity' has a wrong offset!");
static_assert(offsetof(FX6ReplicatedMovement, AngularVelocity) == 0x000018, "Member 'FX6ReplicatedMovement::AngularVelocity' has a wrong offset!");
static_assert(offsetof(FX6ReplicatedMovement, Location) == 0x000030, "Member 'FX6ReplicatedMovement::Location' has a wrong offset!");
static_assert(offsetof(FX6ReplicatedMovement, Rotation) == 0x000048, "Member 'FX6ReplicatedMovement::Rotation' has a wrong offset!");
static_assert(offsetof(FX6ReplicatedMovement, MovementMode) == 0x000060, "Member 'FX6ReplicatedMovement::MovementMode' has a wrong offset!");

// ScriptStruct X6Game.MovementModeCache
// 0x000C (0x000C - 0x0000)
struct FMovementModeCache final
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CustomMovementMode;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementModeCache) == 0x000004, "Wrong alignment on FMovementModeCache");
static_assert(sizeof(FMovementModeCache) == 0x00000C, "Wrong size on FMovementModeCache");
static_assert(offsetof(FMovementModeCache, MovementMode) == 0x000000, "Member 'FMovementModeCache::MovementMode' has a wrong offset!");
static_assert(offsetof(FMovementModeCache, CustomMovementMode) == 0x000001, "Member 'FMovementModeCache::CustomMovementMode' has a wrong offset!");
static_assert(offsetof(FMovementModeCache, Tag) == 0x000004, "Member 'FMovementModeCache::Tag' has a wrong offset!");

// ScriptStruct X6Game.DissolvePitchLimit
// 0x0008 (0x0008 - 0x0000)
struct FDissolvePitchLimit final
{
public:
	float                                         DissolvePitchMin;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolvePitchMax;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDissolvePitchLimit) == 0x000004, "Wrong alignment on FDissolvePitchLimit");
static_assert(sizeof(FDissolvePitchLimit) == 0x000008, "Wrong size on FDissolvePitchLimit");
static_assert(offsetof(FDissolvePitchLimit, DissolvePitchMin) == 0x000000, "Member 'FDissolvePitchLimit::DissolvePitchMin' has a wrong offset!");
static_assert(offsetof(FDissolvePitchLimit, DissolvePitchMax) == 0x000004, "Member 'FDissolvePitchLimit::DissolvePitchMax' has a wrong offset!");

// ScriptStruct X6Game.DissolveCondition
// 0x0018 (0x0018 - 0x0000)
struct FDissolveCondition final
{
public:
	float                                         DissolveDistance;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolveByPitchMaxDistance;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDissolvePitchLimit>            DissolvePitchLimitsArray;                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDissolveCondition) == 0x000008, "Wrong alignment on FDissolveCondition");
static_assert(sizeof(FDissolveCondition) == 0x000018, "Wrong size on FDissolveCondition");
static_assert(offsetof(FDissolveCondition, DissolveDistance) == 0x000000, "Member 'FDissolveCondition::DissolveDistance' has a wrong offset!");
static_assert(offsetof(FDissolveCondition, DissolveByPitchMaxDistance) == 0x000004, "Member 'FDissolveCondition::DissolveByPitchMaxDistance' has a wrong offset!");
static_assert(offsetof(FDissolveCondition, DissolvePitchLimitsArray) == 0x000008, "Member 'FDissolveCondition::DissolvePitchLimitsArray' has a wrong offset!");

// ScriptStruct X6Game.AttachSlotDefinition
// 0x0050 (0x0050 - 0x0000)
struct FAttachSlotDefinition final
{
public:
	TArray<class FName>                           SlotTags;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ParentComponentName;                               // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttacedSocketName;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachSlotDefinition) == 0x000008, "Wrong alignment on FAttachSlotDefinition");
static_assert(sizeof(FAttachSlotDefinition) == 0x000050, "Wrong size on FAttachSlotDefinition");
static_assert(offsetof(FAttachSlotDefinition, SlotTags) == 0x000000, "Member 'FAttachSlotDefinition::SlotTags' has a wrong offset!");
static_assert(offsetof(FAttachSlotDefinition, Offset) == 0x000010, "Member 'FAttachSlotDefinition::Offset' has a wrong offset!");
static_assert(offsetof(FAttachSlotDefinition, Rotation) == 0x000028, "Member 'FAttachSlotDefinition::Rotation' has a wrong offset!");
static_assert(offsetof(FAttachSlotDefinition, ParentComponentName) == 0x000040, "Member 'FAttachSlotDefinition::ParentComponentName' has a wrong offset!");
static_assert(offsetof(FAttachSlotDefinition, AttacedSocketName) == 0x000048, "Member 'FAttachSlotDefinition::AttacedSocketName' has a wrong offset!");

// ScriptStruct X6Game.X6FlyItemTraceContext
// 0x0028 (0x0028 - 0x0000)
struct FX6FlyItemTraceContext final
{
public:
	int32                                         TraceSelect;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6FlyItemTraceContext) == 0x000008, "Wrong alignment on FX6FlyItemTraceContext");
static_assert(sizeof(FX6FlyItemTraceContext) == 0x000028, "Wrong size on FX6FlyItemTraceContext");
static_assert(offsetof(FX6FlyItemTraceContext, TraceSelect) == 0x000000, "Member 'FX6FlyItemTraceContext::TraceSelect' has a wrong offset!");
static_assert(offsetof(FX6FlyItemTraceContext, Radius) == 0x000004, "Member 'FX6FlyItemTraceContext::Radius' has a wrong offset!");
static_assert(offsetof(FX6FlyItemTraceContext, HalfSize) == 0x000008, "Member 'FX6FlyItemTraceContext::HalfSize' has a wrong offset!");
static_assert(offsetof(FX6FlyItemTraceContext, HalfHeight) == 0x000020, "Member 'FX6FlyItemTraceContext::HalfHeight' has a wrong offset!");

// ScriptStruct X6Game.SplinePathNodeInfo
// 0x0020 (0x0020 - 0x0000)
struct FSplinePathNodeInfo final
{
public:
	bool                                          bHaveShowTime;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShowTimeAnimPath;                                  // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowTimeLength;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowTimeRotationYaw;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplinePathNodeInfo) == 0x000008, "Wrong alignment on FSplinePathNodeInfo");
static_assert(sizeof(FSplinePathNodeInfo) == 0x000020, "Wrong size on FSplinePathNodeInfo");
static_assert(offsetof(FSplinePathNodeInfo, bHaveShowTime) == 0x000000, "Member 'FSplinePathNodeInfo::bHaveShowTime' has a wrong offset!");
static_assert(offsetof(FSplinePathNodeInfo, ShowTimeAnimPath) == 0x000008, "Member 'FSplinePathNodeInfo::ShowTimeAnimPath' has a wrong offset!");
static_assert(offsetof(FSplinePathNodeInfo, ShowTimeLength) == 0x000018, "Member 'FSplinePathNodeInfo::ShowTimeLength' has a wrong offset!");
static_assert(offsetof(FSplinePathNodeInfo, ShowTimeRotationYaw) == 0x00001C, "Member 'FSplinePathNodeInfo::ShowTimeRotationYaw' has a wrong offset!");

// ScriptStruct X6Game.T2MovableNPCIKConfig
// 0x002C (0x002C - 0x0000)
struct FT2MovableNPCIKConfig final
{
public:
	float                                         IKTraceUpOffset;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKTraceDownOffset;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnGroundJudgeThreshold;                            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnkleToRootOffset;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRootMOffset;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepFinalThreshold;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSphereRadius;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnkleOffsetLerpSpeed;                              // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitAnkleRlativeX;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAnkleOffset;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecalculateStepTime;                               // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FT2MovableNPCIKConfig) == 0x000004, "Wrong alignment on FT2MovableNPCIKConfig");
static_assert(sizeof(FT2MovableNPCIKConfig) == 0x00002C, "Wrong size on FT2MovableNPCIKConfig");
static_assert(offsetof(FT2MovableNPCIKConfig, IKTraceUpOffset) == 0x000000, "Member 'FT2MovableNPCIKConfig::IKTraceUpOffset' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, IKTraceDownOffset) == 0x000004, "Member 'FT2MovableNPCIKConfig::IKTraceDownOffset' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, OnGroundJudgeThreshold) == 0x000008, "Member 'FT2MovableNPCIKConfig::OnGroundJudgeThreshold' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, AnkleToRootOffset) == 0x00000C, "Member 'FT2MovableNPCIKConfig::AnkleToRootOffset' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, MaxRootMOffset) == 0x000010, "Member 'FT2MovableNPCIKConfig::MaxRootMOffset' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, StepFinalThreshold) == 0x000014, "Member 'FT2MovableNPCIKConfig::StepFinalThreshold' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, TraceSphereRadius) == 0x000018, "Member 'FT2MovableNPCIKConfig::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, AnkleOffsetLerpSpeed) == 0x00001C, "Member 'FT2MovableNPCIKConfig::AnkleOffsetLerpSpeed' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, InitAnkleRlativeX) == 0x000020, "Member 'FT2MovableNPCIKConfig::InitAnkleRlativeX' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, MaxAnkleOffset) == 0x000024, "Member 'FT2MovableNPCIKConfig::MaxAnkleOffset' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCIKConfig, RecalculateStepTime) == 0x000028, "Member 'FT2MovableNPCIKConfig::RecalculateStepTime' has a wrong offset!");

// ScriptStruct X6Game.ActivationSettings
// 0x0001 (0x0001 - 0x0000)
struct FActivationSettings
{
public:
	EX6AbilityActivationPolicy                    ActivationPolicy;                                  // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActivationSettings) == 0x000001, "Wrong alignment on FActivationSettings");
static_assert(sizeof(FActivationSettings) == 0x000001, "Wrong size on FActivationSettings");
static_assert(offsetof(FActivationSettings, ActivationPolicy) == 0x000000, "Member 'FActivationSettings::ActivationPolicy' has a wrong offset!");

// ScriptStruct X6Game.ActivateWhenTrigger
// 0x0000 (0x0001 - 0x0001)
struct FActivateWhenTrigger final : public FActivationSettings
{
};
static_assert(alignof(FActivateWhenTrigger) == 0x000001, "Wrong alignment on FActivateWhenTrigger");
static_assert(sizeof(FActivateWhenTrigger) == 0x000001, "Wrong size on FActivateWhenTrigger");

// ScriptStruct X6Game.ActivateWhenRelease
// 0x0007 (0x0008 - 0x0001)
struct FActivateWhenRelease final : public FActivationSettings
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDuration;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActivateWhenRelease) == 0x000004, "Wrong alignment on FActivateWhenRelease");
static_assert(sizeof(FActivateWhenRelease) == 0x000008, "Wrong size on FActivateWhenRelease");
static_assert(offsetof(FActivateWhenRelease, MaxDuration) == 0x000004, "Member 'FActivateWhenRelease::MaxDuration' has a wrong offset!");

// ScriptStruct X6Game.ActivateWhenTimeOut
// 0x0007 (0x0008 - 0x0001)
struct FActivateWhenTimeOut final : public FActivationSettings
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeoutPeriod;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActivateWhenTimeOut) == 0x000004, "Wrong alignment on FActivateWhenTimeOut");
static_assert(sizeof(FActivateWhenTimeOut) == 0x000008, "Wrong size on FActivateWhenTimeOut");
static_assert(offsetof(FActivateWhenTimeOut, TimeoutPeriod) == 0x000004, "Member 'FActivateWhenTimeOut::TimeoutPeriod' has a wrong offset!");

// ScriptStruct X6Game.CombatTargetInfo
// 0x0010 (0x0010 - 0x0000)
struct FCombatTargetInfo final
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         TargetComponent;                                   // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCombatTargetInfo) == 0x000004, "Wrong alignment on FCombatTargetInfo");
static_assert(sizeof(FCombatTargetInfo) == 0x000010, "Wrong size on FCombatTargetInfo");
static_assert(offsetof(FCombatTargetInfo, TargetActor) == 0x000000, "Member 'FCombatTargetInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FCombatTargetInfo, TargetComponent) == 0x000008, "Member 'FCombatTargetInfo::TargetComponent' has a wrong offset!");

// ScriptStruct X6Game.HandObjBase
// 0x0001 (0x0001 - 0x0000)
struct FHandObjBase
{
public:
	EHandHeldObjType                              WeaponType;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandObjBase) == 0x000001, "Wrong alignment on FHandObjBase");
static_assert(sizeof(FHandObjBase) == 0x000001, "Wrong size on FHandObjBase");
static_assert(offsetof(FHandObjBase, WeaponType) == 0x000000, "Member 'FHandObjBase::WeaponType' has a wrong offset!");

// ScriptStruct X6Game.X6CustomWeapon
// 0x003F (0x0040 - 0x0001)
struct FX6CustomWeapon final : public FHandObjBase
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WeaponActor;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SocketNameList;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6CustomWeapon) == 0x000008, "Wrong alignment on FX6CustomWeapon");
static_assert(sizeof(FX6CustomWeapon) == 0x000040, "Wrong size on FX6CustomWeapon");
static_assert(offsetof(FX6CustomWeapon, WeaponActor) == 0x000008, "Member 'FX6CustomWeapon::WeaponActor' has a wrong offset!");
static_assert(offsetof(FX6CustomWeapon, SocketNameList) == 0x000030, "Member 'FX6CustomWeapon::SocketNameList' has a wrong offset!");

// ScriptStruct X6Game.X6StaticMeshWeapon
// 0x002F (0x0030 - 0x0001)
struct FX6StaticMeshWeapon final : public FHandObjBase
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6StaticMeshWeapon) == 0x000008, "Wrong alignment on FX6StaticMeshWeapon");
static_assert(sizeof(FX6StaticMeshWeapon) == 0x000030, "Wrong size on FX6StaticMeshWeapon");
static_assert(offsetof(FX6StaticMeshWeapon, StaticMesh) == 0x000008, "Member 'FX6StaticMeshWeapon::StaticMesh' has a wrong offset!");

// ScriptStruct X6Game.X6SkeletalMeshWeapon
// 0x003F (0x0040 - 0x0001)
struct FX6SkeletalMeshWeapon final : public FHandObjBase
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SocketNameList;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6SkeletalMeshWeapon) == 0x000008, "Wrong alignment on FX6SkeletalMeshWeapon");
static_assert(sizeof(FX6SkeletalMeshWeapon) == 0x000040, "Wrong size on FX6SkeletalMeshWeapon");
static_assert(offsetof(FX6SkeletalMeshWeapon, SkeletalMesh) == 0x000008, "Member 'FX6SkeletalMeshWeapon::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FX6SkeletalMeshWeapon, SocketNameList) == 0x000030, "Member 'FX6SkeletalMeshWeapon::SocketNameList' has a wrong offset!");

// ScriptStruct X6Game.X6EnvResponseInstanceStruct
// 0x0010 (0x0010 - 0x0000)
struct FX6EnvResponseInstanceStruct final
{
public:
	struct FInstancedStruct                       InstancedStruct;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6EnvResponseInstanceStruct) == 0x000008, "Wrong alignment on FX6EnvResponseInstanceStruct");
static_assert(sizeof(FX6EnvResponseInstanceStruct) == 0x000010, "Wrong size on FX6EnvResponseInstanceStruct");
static_assert(offsetof(FX6EnvResponseInstanceStruct, InstancedStruct) == 0x000000, "Member 'FX6EnvResponseInstanceStruct::InstancedStruct' has a wrong offset!");

// ScriptStruct X6Game.X6EnvResponseBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FX6EnvResponseBase
{
};
#pragma pack(pop)
static_assert(alignof(FX6EnvResponseBase) == 0x000001, "Wrong alignment on FX6EnvResponseBase");
static_assert(sizeof(FX6EnvResponseBase) == 0x000001, "Wrong size on FX6EnvResponseBase");

// ScriptStruct X6Game.X6InteractiveIdleBreakParticipantConfig
// 0x0058 (0x0058 - 0x0000)
struct FX6InteractiveIdleBreakParticipantConfig final
{
public:
	struct FGameplayTag                           CharacterTag;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           IdleBreakSequence;                                 // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtInitiator;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        InteractionLocations;                              // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6InteractiveIdleBreakParticipantFacingDirection FacingDirection;                               // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacingDirectionThreshold;                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6InteractiveIdleBreakParticipantConfig) == 0x000008, "Wrong alignment on FX6InteractiveIdleBreakParticipantConfig");
static_assert(sizeof(FX6InteractiveIdleBreakParticipantConfig) == 0x000058, "Wrong size on FX6InteractiveIdleBreakParticipantConfig");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, CharacterTag) == 0x000000, "Member 'FX6InteractiveIdleBreakParticipantConfig::CharacterTag' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, IdleBreakSequence) == 0x000008, "Member 'FX6InteractiveIdleBreakParticipantConfig::IdleBreakSequence' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, bLookAtInitiator) == 0x000030, "Member 'FX6InteractiveIdleBreakParticipantConfig::bLookAtInitiator' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, InteractionLocations) == 0x000038, "Member 'FX6InteractiveIdleBreakParticipantConfig::InteractionLocations' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, AcceptanceRadius) == 0x000048, "Member 'FX6InteractiveIdleBreakParticipantConfig::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, FacingDirection) == 0x00004C, "Member 'FX6InteractiveIdleBreakParticipantConfig::FacingDirection' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreakParticipantConfig, FacingDirectionThreshold) == 0x000050, "Member 'FX6InteractiveIdleBreakParticipantConfig::FacingDirectionThreshold' has a wrong offset!");

// ScriptStruct X6Game.X6InteractiveIdleBreak
// 0x0088 (0x0088 - 0x0000)
struct FX6InteractiveIdleBreak final
{
public:
	TSoftObjectPtr<class UAnimSequence>           IdleBreakSequence;                                 // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtParticipant;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6InteractiveIdleBreakParticipantConfig ParticipantConfig;                               // 0x0030(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6InteractiveIdleBreak) == 0x000008, "Wrong alignment on FX6InteractiveIdleBreak");
static_assert(sizeof(FX6InteractiveIdleBreak) == 0x000088, "Wrong size on FX6InteractiveIdleBreak");
static_assert(offsetof(FX6InteractiveIdleBreak, IdleBreakSequence) == 0x000000, "Member 'FX6InteractiveIdleBreak::IdleBreakSequence' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreak, bLookAtParticipant) == 0x000028, "Member 'FX6InteractiveIdleBreak::bLookAtParticipant' has a wrong offset!");
static_assert(offsetof(FX6InteractiveIdleBreak, ParticipantConfig) == 0x000030, "Member 'FX6InteractiveIdleBreak::ParticipantConfig' has a wrong offset!");

// ScriptStruct X6Game.X6EnvResponse_IdleBreak
// 0x0020 (0x0020 - 0x0000)
struct FX6EnvResponse_IdleBreak final : public FX6EnvResponseBase
{
public:
	TArray<TSoftObjectPtr<class UAnimSequence>>   IdleBreakSequences;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FX6InteractiveIdleBreak>        InteractiveIdleBreaks;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6EnvResponse_IdleBreak) == 0x000008, "Wrong alignment on FX6EnvResponse_IdleBreak");
static_assert(sizeof(FX6EnvResponse_IdleBreak) == 0x000020, "Wrong size on FX6EnvResponse_IdleBreak");
static_assert(offsetof(FX6EnvResponse_IdleBreak, IdleBreakSequences) == 0x000000, "Member 'FX6EnvResponse_IdleBreak::IdleBreakSequences' has a wrong offset!");
static_assert(offsetof(FX6EnvResponse_IdleBreak, InteractiveIdleBreaks) == 0x000010, "Member 'FX6EnvResponse_IdleBreak::InteractiveIdleBreaks' has a wrong offset!");

// ScriptStruct X6Game.X6EnvResponse_OverlayBlend
// 0x0030 (0x0030 - 0x0000)
struct FX6EnvResponse_OverlayBlend final : public FX6EnvResponseBase
{
public:
	TSoftObjectPtr<class UX6OverlayData>          OverlayData;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6EnvResponse_OverlayBlend) == 0x000008, "Wrong alignment on FX6EnvResponse_OverlayBlend");
static_assert(sizeof(FX6EnvResponse_OverlayBlend) == 0x000030, "Wrong size on FX6EnvResponse_OverlayBlend");
static_assert(offsetof(FX6EnvResponse_OverlayBlend, OverlayData) == 0x000000, "Member 'FX6EnvResponse_OverlayBlend::OverlayData' has a wrong offset!");
static_assert(offsetof(FX6EnvResponse_OverlayBlend, Duration) == 0x000028, "Member 'FX6EnvResponse_OverlayBlend::Duration' has a wrong offset!");

// ScriptStruct X6Game.RecommendQualityLevels
// 0x0044 (0x0044 - 0x0000)
struct FRecommendQualityLevels final
{
public:
	float                                         ResolutionQuality;                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewDistanceQuality;                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingQuality;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQuality;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalIlluminationQuality;                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReflectionQuality;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessQuality;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQuality;                                    // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQuality;                                    // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoliageQuality;                                    // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadingQuality;                                    // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomUpscaleRate;                                 // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGUSAntiAliasingMethod                        RecommendAntiAliasingMethod;                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGlobalIlluminationMethod                     GlobalIlluminationMethod;                          // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneDetailMode                              RecommendSceneDetailMode;                          // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              RecommendResolution;                               // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         X6GamePlayQuality;                                 // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X6DisplayGamma;                                    // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecommendQualityLevels) == 0x000004, "Wrong alignment on FRecommendQualityLevels");
static_assert(sizeof(FRecommendQualityLevels) == 0x000044, "Wrong size on FRecommendQualityLevels");
static_assert(offsetof(FRecommendQualityLevels, ResolutionQuality) == 0x000000, "Member 'FRecommendQualityLevels::ResolutionQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, ViewDistanceQuality) == 0x000004, "Member 'FRecommendQualityLevels::ViewDistanceQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, AntiAliasingQuality) == 0x000008, "Member 'FRecommendQualityLevels::AntiAliasingQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, ShadowQuality) == 0x00000C, "Member 'FRecommendQualityLevels::ShadowQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, GlobalIlluminationQuality) == 0x000010, "Member 'FRecommendQualityLevels::GlobalIlluminationQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, ReflectionQuality) == 0x000014, "Member 'FRecommendQualityLevels::ReflectionQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, PostProcessQuality) == 0x000018, "Member 'FRecommendQualityLevels::PostProcessQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, TextureQuality) == 0x00001C, "Member 'FRecommendQualityLevels::TextureQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, EffectsQuality) == 0x000020, "Member 'FRecommendQualityLevels::EffectsQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, FoliageQuality) == 0x000024, "Member 'FRecommendQualityLevels::FoliageQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, ShadingQuality) == 0x000028, "Member 'FRecommendQualityLevels::ShadingQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, CustomUpscaleRate) == 0x00002C, "Member 'FRecommendQualityLevels::CustomUpscaleRate' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, RecommendAntiAliasingMethod) == 0x000030, "Member 'FRecommendQualityLevels::RecommendAntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, GlobalIlluminationMethod) == 0x000031, "Member 'FRecommendQualityLevels::GlobalIlluminationMethod' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, RecommendSceneDetailMode) == 0x000032, "Member 'FRecommendQualityLevels::RecommendSceneDetailMode' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, RecommendResolution) == 0x000034, "Member 'FRecommendQualityLevels::RecommendResolution' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, X6GamePlayQuality) == 0x00003C, "Member 'FRecommendQualityLevels::X6GamePlayQuality' has a wrong offset!");
static_assert(offsetof(FRecommendQualityLevels, X6DisplayGamma) == 0x000040, "Member 'FRecommendQualityLevels::X6DisplayGamma' has a wrong offset!");

// ScriptStruct X6Game.T2MovableNPCFeetIKInfo
// 0x0038 (0x0038 - 0x0000)
struct FT2MovableNPCFeetIKInfo final
{
public:
	float                                         PelvisOffset;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FootLockLeft;                                      // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootLockRight;                                     // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FT2MovableNPCFeetIKInfo) == 0x000008, "Wrong alignment on FT2MovableNPCFeetIKInfo");
static_assert(sizeof(FT2MovableNPCFeetIKInfo) == 0x000038, "Wrong size on FT2MovableNPCFeetIKInfo");
static_assert(offsetof(FT2MovableNPCFeetIKInfo, PelvisOffset) == 0x000000, "Member 'FT2MovableNPCFeetIKInfo::PelvisOffset' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCFeetIKInfo, FootLockLeft) == 0x000008, "Member 'FT2MovableNPCFeetIKInfo::FootLockLeft' has a wrong offset!");
static_assert(offsetof(FT2MovableNPCFeetIKInfo, FootLockRight) == 0x000020, "Member 'FT2MovableNPCFeetIKInfo::FootLockRight' has a wrong offset!");

// ScriptStruct X6Game.GroundFlyMovementSettings
// 0x0028 (0x0028 - 0x0000)
struct FGroundFlyMovementSettings final
{
public:
	EGroundFlyMovementMode                        MoveMode;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroundFlyMovementMode                        ArriveMode;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetArriveLocation;                              // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomHeight;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroundFlyMovementSettings) == 0x000008, "Wrong alignment on FGroundFlyMovementSettings");
static_assert(sizeof(FGroundFlyMovementSettings) == 0x000028, "Wrong size on FGroundFlyMovementSettings");
static_assert(offsetof(FGroundFlyMovementSettings, MoveMode) == 0x000000, "Member 'FGroundFlyMovementSettings::MoveMode' has a wrong offset!");
static_assert(offsetof(FGroundFlyMovementSettings, ArriveMode) == 0x000001, "Member 'FGroundFlyMovementSettings::ArriveMode' has a wrong offset!");
static_assert(offsetof(FGroundFlyMovementSettings, TargetArriveLocation) == 0x000008, "Member 'FGroundFlyMovementSettings::TargetArriveLocation' has a wrong offset!");
static_assert(offsetof(FGroundFlyMovementSettings, CustomHeight) == 0x000020, "Member 'FGroundFlyMovementSettings::CustomHeight' has a wrong offset!");

// ScriptStruct X6Game.X6BlueprintInputTouchDelegateBinding
// 0x0018 (0x001C - 0x0004)
struct FX6BlueprintInputTouchDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	EX6InputTouchEvent                            X6InputTouchEvent;                                 // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JudgeSize;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x8];                                       // 0x0014(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6BlueprintInputTouchDelegateBinding) == 0x000004, "Wrong alignment on FX6BlueprintInputTouchDelegateBinding");
static_assert(sizeof(FX6BlueprintInputTouchDelegateBinding) == 0x00001C, "Wrong size on FX6BlueprintInputTouchDelegateBinding");
static_assert(offsetof(FX6BlueprintInputTouchDelegateBinding, X6InputTouchEvent) == 0x000004, "Member 'FX6BlueprintInputTouchDelegateBinding::X6InputTouchEvent' has a wrong offset!");
static_assert(offsetof(FX6BlueprintInputTouchDelegateBinding, FunctionNameToBind) == 0x000008, "Member 'FX6BlueprintInputTouchDelegateBinding::FunctionNameToBind' has a wrong offset!");
static_assert(offsetof(FX6BlueprintInputTouchDelegateBinding, JudgeSize) == 0x000010, "Member 'FX6BlueprintInputTouchDelegateBinding::JudgeSize' has a wrong offset!");

// ScriptStruct X6Game.InteractSlotCameraDataBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FInteractSlotCameraDataBase
{
};
#pragma pack(pop)
static_assert(alignof(FInteractSlotCameraDataBase) == 0x000001, "Wrong alignment on FInteractSlotCameraDataBase");
static_assert(sizeof(FInteractSlotCameraDataBase) == 0x000001, "Wrong size on FInteractSlotCameraDataBase");

// ScriptStruct X6Game.InteractSlotCameraData
// 0x0008 (0x0008 - 0x0000)
struct FInteractSlotCameraData final : public FInteractSlotCameraDataBase
{
public:
	class FName                                   CameraConfigKey;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractSlotCameraData) == 0x000004, "Wrong alignment on FInteractSlotCameraData");
static_assert(sizeof(FInteractSlotCameraData) == 0x000008, "Wrong size on FInteractSlotCameraData");
static_assert(offsetof(FInteractSlotCameraData, CameraConfigKey) == 0x000000, "Member 'FInteractSlotCameraData::CameraConfigKey' has a wrong offset!");

// ScriptStruct X6Game.InteractSlotDefinition
// 0x0060 (0x0060 - 0x0000)
struct FInteractSlotDefinition final
{
public:
	class FName                                   SlotTag;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UInteractSlotDataAsset*                 Data;                                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInstancedStruct                       CameraData;                                        // 0x0040(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   ParentComponentName;                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttacedSocketName;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractSlotDefinition) == 0x000008, "Wrong alignment on FInteractSlotDefinition");
static_assert(sizeof(FInteractSlotDefinition) == 0x000060, "Wrong size on FInteractSlotDefinition");
static_assert(offsetof(FInteractSlotDefinition, SlotTag) == 0x000000, "Member 'FInteractSlotDefinition::SlotTag' has a wrong offset!");
static_assert(offsetof(FInteractSlotDefinition, Offset) == 0x000008, "Member 'FInteractSlotDefinition::Offset' has a wrong offset!");
static_assert(offsetof(FInteractSlotDefinition, Rotation) == 0x000020, "Member 'FInteractSlotDefinition::Rotation' has a wrong offset!");
static_assert(offsetof(FInteractSlotDefinition, Data) == 0x000038, "Member 'FInteractSlotDefinition::Data' has a wrong offset!");
static_assert(offsetof(FInteractSlotDefinition, CameraData) == 0x000040, "Member 'FInteractSlotDefinition::CameraData' has a wrong offset!");
static_assert(offsetof(FInteractSlotDefinition, ParentComponentName) == 0x000050, "Member 'FInteractSlotDefinition::ParentComponentName' has a wrong offset!");
static_assert(offsetof(FInteractSlotDefinition, AttacedSocketName) == 0x000058, "Member 'FInteractSlotDefinition::AttacedSocketName' has a wrong offset!");

// ScriptStruct X6Game.ChatBubbleSlotDefinition
// 0x0030 (0x0030 - 0x0000)
struct FChatBubbleSlotDefinition final
{
public:
	class FName                                   ChatBubbleWidgetAttachComponentTag;                // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChatBubbleWidgetAttachSocketName;                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0010(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleOffsetDependonCamera;                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatBubbleSlotDefinition) == 0x000008, "Wrong alignment on FChatBubbleSlotDefinition");
static_assert(sizeof(FChatBubbleSlotDefinition) == 0x000030, "Wrong size on FChatBubbleSlotDefinition");
static_assert(offsetof(FChatBubbleSlotDefinition, ChatBubbleWidgetAttachComponentTag) == 0x000000, "Member 'FChatBubbleSlotDefinition::ChatBubbleWidgetAttachComponentTag' has a wrong offset!");
static_assert(offsetof(FChatBubbleSlotDefinition, ChatBubbleWidgetAttachSocketName) == 0x000008, "Member 'FChatBubbleSlotDefinition::ChatBubbleWidgetAttachSocketName' has a wrong offset!");
static_assert(offsetof(FChatBubbleSlotDefinition, Offset) == 0x000010, "Member 'FChatBubbleSlotDefinition::Offset' has a wrong offset!");
static_assert(offsetof(FChatBubbleSlotDefinition, bScaleOffsetDependonCamera) == 0x000028, "Member 'FChatBubbleSlotDefinition::bScaleOffsetDependonCamera' has a wrong offset!");

// ScriptStruct X6Game.LoadProperty
// 0x0018 (0x0018 - 0x0000)
struct FLoadProperty final
{
public:
	class UClass*                                 PropertyClass;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        PropertyObjects;                                   // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadProperty) == 0x000008, "Wrong alignment on FLoadProperty");
static_assert(sizeof(FLoadProperty) == 0x000018, "Wrong size on FLoadProperty");
static_assert(offsetof(FLoadProperty, PropertyClass) == 0x000000, "Member 'FLoadProperty::PropertyClass' has a wrong offset!");
static_assert(offsetof(FLoadProperty, PropertyObjects) == 0x000008, "Member 'FLoadProperty::PropertyObjects' has a wrong offset!");

// ScriptStruct X6Game.AreaInfo
// 0x0020 (0x0020 - 0x0000)
struct FAreaInfo final
{
public:
	class FString                                 AreaLanguage;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AreaSound;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaInfo) == 0x000008, "Wrong alignment on FAreaInfo");
static_assert(sizeof(FAreaInfo) == 0x000020, "Wrong size on FAreaInfo");
static_assert(offsetof(FAreaInfo, AreaLanguage) == 0x000000, "Member 'FAreaInfo::AreaLanguage' has a wrong offset!");
static_assert(offsetof(FAreaInfo, AreaSound) == 0x000010, "Member 'FAreaInfo::AreaSound' has a wrong offset!");

// ScriptStruct X6Game.FootPlacementIKContext
// 0x0190 (0x0190 - 0x0000)
struct FFootPlacementIKContext final
{
public:
	struct FTransform                             LastRootTransform;                                 // 0x0000(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             OriginalRootTransform;                             // 0x0060(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastOriginalFootLocation;                          // 0x00C0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                OriginalFootLocation;                              // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ExpectedFootTargetLocation;                        // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               ExpectedFootTargetRotation;                        // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         CurSlopeAngle;                                     // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RealFootTargetLocationOffset;                      // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RealFootTargetRotation;                            // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PelvisTargetOffset;                                // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationWeight;                                 // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationWeight;                                    // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnkleName;                                         // 0x0164(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VirtualAnkleName;                                  // 0x016C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToesName;                                          // 0x0174(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VirtualToesName;                                   // 0x017C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0xC];                                      // 0x0184(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootPlacementIKContext) == 0x000010, "Wrong alignment on FFootPlacementIKContext");
static_assert(sizeof(FFootPlacementIKContext) == 0x000190, "Wrong size on FFootPlacementIKContext");
static_assert(offsetof(FFootPlacementIKContext, LastRootTransform) == 0x000000, "Member 'FFootPlacementIKContext::LastRootTransform' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, OriginalRootTransform) == 0x000060, "Member 'FFootPlacementIKContext::OriginalRootTransform' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, LastOriginalFootLocation) == 0x0000C0, "Member 'FFootPlacementIKContext::LastOriginalFootLocation' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, OriginalFootLocation) == 0x0000D8, "Member 'FFootPlacementIKContext::OriginalFootLocation' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, ExpectedFootTargetLocation) == 0x0000F0, "Member 'FFootPlacementIKContext::ExpectedFootTargetLocation' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, ExpectedFootTargetRotation) == 0x000108, "Member 'FFootPlacementIKContext::ExpectedFootTargetRotation' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, CurSlopeAngle) == 0x000120, "Member 'FFootPlacementIKContext::CurSlopeAngle' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, RealFootTargetLocationOffset) == 0x000128, "Member 'FFootPlacementIKContext::RealFootTargetLocationOffset' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, RealFootTargetRotation) == 0x000140, "Member 'FFootPlacementIKContext::RealFootTargetRotation' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, PelvisTargetOffset) == 0x000158, "Member 'FFootPlacementIKContext::PelvisTargetOffset' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, TranslationWeight) == 0x00015C, "Member 'FFootPlacementIKContext::TranslationWeight' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, RotationWeight) == 0x000160, "Member 'FFootPlacementIKContext::RotationWeight' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, AnkleName) == 0x000164, "Member 'FFootPlacementIKContext::AnkleName' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, VirtualAnkleName) == 0x00016C, "Member 'FFootPlacementIKContext::VirtualAnkleName' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, ToesName) == 0x000174, "Member 'FFootPlacementIKContext::ToesName' has a wrong offset!");
static_assert(offsetof(FFootPlacementIKContext, VirtualToesName) == 0x00017C, "Member 'FFootPlacementIKContext::VirtualToesName' has a wrong offset!");

// ScriptStruct X6Game.FootIKCalculateDependenceParameter
// 0x0020 (0x0020 - 0x0000)
struct FFootIKCalculateDependenceParameter final
{
public:
	class FName                                   LeftIKCurveName;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLockCurveName;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightIKCurveName;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLockCurveName;                                // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootIKCalculateDependenceParameter) == 0x000004, "Wrong alignment on FFootIKCalculateDependenceParameter");
static_assert(sizeof(FFootIKCalculateDependenceParameter) == 0x000020, "Wrong size on FFootIKCalculateDependenceParameter");
static_assert(offsetof(FFootIKCalculateDependenceParameter, LeftIKCurveName) == 0x000000, "Member 'FFootIKCalculateDependenceParameter::LeftIKCurveName' has a wrong offset!");
static_assert(offsetof(FFootIKCalculateDependenceParameter, LeftLockCurveName) == 0x000008, "Member 'FFootIKCalculateDependenceParameter::LeftLockCurveName' has a wrong offset!");
static_assert(offsetof(FFootIKCalculateDependenceParameter, RightIKCurveName) == 0x000010, "Member 'FFootIKCalculateDependenceParameter::RightIKCurveName' has a wrong offset!");
static_assert(offsetof(FFootIKCalculateDependenceParameter, RightLockCurveName) == 0x000018, "Member 'FFootIKCalculateDependenceParameter::RightLockCurveName' has a wrong offset!");

// ScriptStruct X6Game.FootIKFeatureTargetDataV2
// 0x00A0 (0x00A0 - 0x0000)
struct FFootIKFeatureTargetDataV2 final
{
public:
	float                                         PelvisAlpha;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PelvisTargetOffset;                                // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftFootTargetLocationAlpha;                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftFootTargetLocationOffset;                      // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftFootTargetRotationAlpha;                       // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LeftFootTargetRotation;                            // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RightFootTargetLocationAlpha;                      // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RightFootTargetLocationOffset;                     // 0x0068(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightFootTargetRotationAlpha;                      // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RightFootTargetRotation;                           // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootIKFeatureTargetDataV2) == 0x000008, "Wrong alignment on FFootIKFeatureTargetDataV2");
static_assert(sizeof(FFootIKFeatureTargetDataV2) == 0x0000A0, "Wrong size on FFootIKFeatureTargetDataV2");
static_assert(offsetof(FFootIKFeatureTargetDataV2, PelvisAlpha) == 0x000000, "Member 'FFootIKFeatureTargetDataV2::PelvisAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, PelvisTargetOffset) == 0x000008, "Member 'FFootIKFeatureTargetDataV2::PelvisTargetOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, LeftFootTargetLocationAlpha) == 0x000020, "Member 'FFootIKFeatureTargetDataV2::LeftFootTargetLocationAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, LeftFootTargetLocationOffset) == 0x000028, "Member 'FFootIKFeatureTargetDataV2::LeftFootTargetLocationOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, LeftFootTargetRotationAlpha) == 0x000040, "Member 'FFootIKFeatureTargetDataV2::LeftFootTargetRotationAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, LeftFootTargetRotation) == 0x000048, "Member 'FFootIKFeatureTargetDataV2::LeftFootTargetRotation' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, RightFootTargetLocationAlpha) == 0x000060, "Member 'FFootIKFeatureTargetDataV2::RightFootTargetLocationAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, RightFootTargetLocationOffset) == 0x000068, "Member 'FFootIKFeatureTargetDataV2::RightFootTargetLocationOffset' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, RightFootTargetRotationAlpha) == 0x000080, "Member 'FFootIKFeatureTargetDataV2::RightFootTargetRotationAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKFeatureTargetDataV2, RightFootTargetRotation) == 0x000088, "Member 'FFootIKFeatureTargetDataV2::RightFootTargetRotation' has a wrong offset!");

// ScriptStruct X6Game.T2NpcRadiusHalfHeightStruct
// 0x0010 (0x0010 - 0x0000)
struct FT2NpcRadiusHalfHeightStruct final
{
public:
	class AActor*                                 npcActor;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FT2NpcRadiusHalfHeightStruct) == 0x000008, "Wrong alignment on FT2NpcRadiusHalfHeightStruct");
static_assert(sizeof(FT2NpcRadiusHalfHeightStruct) == 0x000010, "Wrong size on FT2NpcRadiusHalfHeightStruct");
static_assert(offsetof(FT2NpcRadiusHalfHeightStruct, npcActor) == 0x000000, "Member 'FT2NpcRadiusHalfHeightStruct::npcActor' has a wrong offset!");
static_assert(offsetof(FT2NpcRadiusHalfHeightStruct, Radius) == 0x000008, "Member 'FT2NpcRadiusHalfHeightStruct::Radius' has a wrong offset!");
static_assert(offsetof(FT2NpcRadiusHalfHeightStruct, HalfHeight) == 0x00000C, "Member 'FT2NpcRadiusHalfHeightStruct::HalfHeight' has a wrong offset!");

// ScriptStruct X6Game.T2NpcGroupDataStruct
// 0x0020 (0x0020 - 0x0000)
struct FT2NpcGroupDataStruct final
{
public:
	int64                                         SpawnerID;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NpcGroupActor;                                     // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FT2NpcRadiusHalfHeightStruct>   NpcActors;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FT2NpcGroupDataStruct) == 0x000008, "Wrong alignment on FT2NpcGroupDataStruct");
static_assert(sizeof(FT2NpcGroupDataStruct) == 0x000020, "Wrong size on FT2NpcGroupDataStruct");
static_assert(offsetof(FT2NpcGroupDataStruct, SpawnerID) == 0x000000, "Member 'FT2NpcGroupDataStruct::SpawnerID' has a wrong offset!");
static_assert(offsetof(FT2NpcGroupDataStruct, NpcGroupActor) == 0x000008, "Member 'FT2NpcGroupDataStruct::NpcGroupActor' has a wrong offset!");
static_assert(offsetof(FT2NpcGroupDataStruct, NpcActors) == 0x000010, "Member 'FT2NpcGroupDataStruct::NpcActors' has a wrong offset!");

// ScriptStruct X6Game.X6OctreeElement
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FX6OctreeElement final
{
public:
	TSoftObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0028(0x0038)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x50];                                      // 0x0060(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6OctreeElement) == 0x000010, "Wrong alignment on FX6OctreeElement");
static_assert(sizeof(FX6OctreeElement) == 0x0000B0, "Wrong size on FX6OctreeElement");
static_assert(offsetof(FX6OctreeElement, Actor) == 0x000000, "Member 'FX6OctreeElement::Actor' has a wrong offset!");
static_assert(offsetof(FX6OctreeElement, Bounds) == 0x000028, "Member 'FX6OctreeElement::Bounds' has a wrong offset!");

// ScriptStruct X6Game.AirPathingRequest
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAirPathingRequest final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAirPathingRequest) == 0x000008, "Wrong alignment on FAirPathingRequest");
static_assert(sizeof(FAirPathingRequest) == 0x000010, "Wrong size on FAirPathingRequest");

// ScriptStruct X6Game.RepathObserverInfo
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FRepathObserverInfo final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepathObserverInfo) == 0x000008, "Wrong alignment on FRepathObserverInfo");
static_assert(sizeof(FRepathObserverInfo) == 0x000080, "Wrong size on FRepathObserverInfo");

// ScriptStruct X6Game.DirectMoveParams
// 0x0018 (0x0018 - 0x0000)
struct FDirectMoveParams final
{
public:
	float                                         MaxDistanceToGoal;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchToGoal;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchToGoal;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpTraceOffset;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableBelowTraceDistance;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BelowTraceOffset;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectMoveParams) == 0x000004, "Wrong alignment on FDirectMoveParams");
static_assert(sizeof(FDirectMoveParams) == 0x000018, "Wrong size on FDirectMoveParams");
static_assert(offsetof(FDirectMoveParams, MaxDistanceToGoal) == 0x000000, "Member 'FDirectMoveParams::MaxDistanceToGoal' has a wrong offset!");
static_assert(offsetof(FDirectMoveParams, MaxPitchToGoal) == 0x000004, "Member 'FDirectMoveParams::MaxPitchToGoal' has a wrong offset!");
static_assert(offsetof(FDirectMoveParams, MinPitchToGoal) == 0x000008, "Member 'FDirectMoveParams::MinPitchToGoal' has a wrong offset!");
static_assert(offsetof(FDirectMoveParams, UpTraceOffset) == 0x00000C, "Member 'FDirectMoveParams::UpTraceOffset' has a wrong offset!");
static_assert(offsetof(FDirectMoveParams, EnableBelowTraceDistance) == 0x000010, "Member 'FDirectMoveParams::EnableBelowTraceDistance' has a wrong offset!");
static_assert(offsetof(FDirectMoveParams, BelowTraceOffset) == 0x000014, "Member 'FDirectMoveParams::BelowTraceOffset' has a wrong offset!");

// ScriptStruct X6Game.SmoothPathParams
// 0x0020 (0x0020 - 0x0000)
struct FSmoothPathParams final
{
public:
	float                                         RVOIgnoredAngleCos;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RVOIgnoredDistanceSqr;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothAngleCos;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothNextPathRadiusSqr;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothPerSegmentLength;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothPerMaxLength;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothCheckLength;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrictCheck;                                      // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmoothPathParams) == 0x000004, "Wrong alignment on FSmoothPathParams");
static_assert(sizeof(FSmoothPathParams) == 0x000020, "Wrong size on FSmoothPathParams");
static_assert(offsetof(FSmoothPathParams, RVOIgnoredAngleCos) == 0x000000, "Member 'FSmoothPathParams::RVOIgnoredAngleCos' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, RVOIgnoredDistanceSqr) == 0x000004, "Member 'FSmoothPathParams::RVOIgnoredDistanceSqr' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, SmoothAngleCos) == 0x000008, "Member 'FSmoothPathParams::SmoothAngleCos' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, SmoothNextPathRadiusSqr) == 0x00000C, "Member 'FSmoothPathParams::SmoothNextPathRadiusSqr' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, SmoothPerSegmentLength) == 0x000010, "Member 'FSmoothPathParams::SmoothPerSegmentLength' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, SmoothPerMaxLength) == 0x000014, "Member 'FSmoothPathParams::SmoothPerMaxLength' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, SmoothCheckLength) == 0x000018, "Member 'FSmoothPathParams::SmoothCheckLength' has a wrong offset!");
static_assert(offsetof(FSmoothPathParams, bStrictCheck) == 0x00001C, "Member 'FSmoothPathParams::bStrictCheck' has a wrong offset!");

// ScriptStruct X6Game.CameraCutsExitCondition
// 0x0002 (0x0002 - 0x0000)
struct FCameraCutsExitCondition final
{
public:
	bool                                          bWithBlend;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithoutBlend;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraCutsExitCondition) == 0x000001, "Wrong alignment on FCameraCutsExitCondition");
static_assert(sizeof(FCameraCutsExitCondition) == 0x000002, "Wrong size on FCameraCutsExitCondition");
static_assert(offsetof(FCameraCutsExitCondition, bWithBlend) == 0x000000, "Member 'FCameraCutsExitCondition::bWithBlend' has a wrong offset!");
static_assert(offsetof(FCameraCutsExitCondition, bWithoutBlend) == 0x000001, "Member 'FCameraCutsExitCondition::bWithoutBlend' has a wrong offset!");

// ScriptStruct X6Game.BoxDropDownTrackResult
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FBoxDropDownTrackResult final
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxDropDownTrackResult) == 0x000008, "Wrong alignment on FBoxDropDownTrackResult");
static_assert(sizeof(FBoxDropDownTrackResult) == 0x000108, "Wrong size on FBoxDropDownTrackResult");

// ScriptStruct X6Game.X6RadialSliderStyle
// 0x0768 (0x0770 - 0x0008)
struct FX6RadialSliderStyle final : public FSlateWidgetStyle
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            NormalBarImage;                                    // 0x0010(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoveredBarImage;                                   // 0x00E0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DisabledBarImage;                                  // 0x01B0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            NormalThumbImage;                                  // 0x0280(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoveredThumbImage;                                 // 0x0350(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PressedThumbImage;                                 // 0x0420(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DisabledThumbImage;                                // 0x04F0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BackgroundImage;                                   // 0x05C0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            StartThumbImage;                                   // 0x0690(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BarThickness;                                      // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThumbOffset;                                       // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6RadialSliderStyle) == 0x000010, "Wrong alignment on FX6RadialSliderStyle");
static_assert(sizeof(FX6RadialSliderStyle) == 0x000770, "Wrong size on FX6RadialSliderStyle");
static_assert(offsetof(FX6RadialSliderStyle, NormalBarImage) == 0x000010, "Member 'FX6RadialSliderStyle::NormalBarImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, HoveredBarImage) == 0x0000E0, "Member 'FX6RadialSliderStyle::HoveredBarImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, DisabledBarImage) == 0x0001B0, "Member 'FX6RadialSliderStyle::DisabledBarImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, NormalThumbImage) == 0x000280, "Member 'FX6RadialSliderStyle::NormalThumbImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, HoveredThumbImage) == 0x000350, "Member 'FX6RadialSliderStyle::HoveredThumbImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, PressedThumbImage) == 0x000420, "Member 'FX6RadialSliderStyle::PressedThumbImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, DisabledThumbImage) == 0x0004F0, "Member 'FX6RadialSliderStyle::DisabledThumbImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, BackgroundImage) == 0x0005C0, "Member 'FX6RadialSliderStyle::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, StartThumbImage) == 0x000690, "Member 'FX6RadialSliderStyle::StartThumbImage' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, BarThickness) == 0x000760, "Member 'FX6RadialSliderStyle::BarThickness' has a wrong offset!");
static_assert(offsetof(FX6RadialSliderStyle, ThumbOffset) == 0x000764, "Member 'FX6RadialSliderStyle::ThumbOffset' has a wrong offset!");

// ScriptStruct X6Game.X6RMInAirReplicatedMovementData
// 0x0020 (0x0020 - 0x0000)
struct FX6RMInAirReplicatedMovementData final
{
public:
	struct FVector                                ReplicatedInputMovingDirection;                    // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplicatedTurnAroundAngle;                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularJumpMode                              ReplicatedJumpMode;                                // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6RMInAirReplicatedMovementData) == 0x000008, "Wrong alignment on FX6RMInAirReplicatedMovementData");
static_assert(sizeof(FX6RMInAirReplicatedMovementData) == 0x000020, "Wrong size on FX6RMInAirReplicatedMovementData");
static_assert(offsetof(FX6RMInAirReplicatedMovementData, ReplicatedInputMovingDirection) == 0x000000, "Member 'FX6RMInAirReplicatedMovementData::ReplicatedInputMovingDirection' has a wrong offset!");
static_assert(offsetof(FX6RMInAirReplicatedMovementData, ReplicatedTurnAroundAngle) == 0x000018, "Member 'FX6RMInAirReplicatedMovementData::ReplicatedTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(FX6RMInAirReplicatedMovementData, ReplicatedJumpMode) == 0x00001C, "Member 'FX6RMInAirReplicatedMovementData::ReplicatedJumpMode' has a wrong offset!");

// ScriptStruct X6Game.X6RMInAirComponentPostPhysicsTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FX6RMInAirComponentPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6RMInAirComponentPostPhysicsTickFunction) == 0x000008, "Wrong alignment on FX6RMInAirComponentPostPhysicsTickFunction");
static_assert(sizeof(FX6RMInAirComponentPostPhysicsTickFunction) == 0x000038, "Wrong size on FX6RMInAirComponentPostPhysicsTickFunction");

// ScriptStruct X6Game.X6RMWalkingReplicatedMovementData
// 0x0028 (0x0028 - 0x0000)
struct FX6RMWalkingReplicatedMovementData final
{
public:
	ERegularLocomotionType                        ReplicatedAllowedGait;                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReplicatedInputMovingDirection;                    // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplicatedTurnAroundAngle;                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FX6RMWalkingReplicatedMovementData) == 0x000008, "Wrong alignment on FX6RMWalkingReplicatedMovementData");
static_assert(sizeof(FX6RMWalkingReplicatedMovementData) == 0x000028, "Wrong size on FX6RMWalkingReplicatedMovementData");
static_assert(offsetof(FX6RMWalkingReplicatedMovementData, ReplicatedAllowedGait) == 0x000000, "Member 'FX6RMWalkingReplicatedMovementData::ReplicatedAllowedGait' has a wrong offset!");
static_assert(offsetof(FX6RMWalkingReplicatedMovementData, ReplicatedInputMovingDirection) == 0x000008, "Member 'FX6RMWalkingReplicatedMovementData::ReplicatedInputMovingDirection' has a wrong offset!");
static_assert(offsetof(FX6RMWalkingReplicatedMovementData, ReplicatedTurnAroundAngle) == 0x000020, "Member 'FX6RMWalkingReplicatedMovementData::ReplicatedTurnAroundAngle' has a wrong offset!");

// ScriptStruct X6Game.X6TrackContent
// 0x0010 (0x0010 - 0x0000)
struct FX6TrackContent final
{
public:
	TSubclassOf<class UMovieSceneTrack>           TrackClass;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionBegin;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionEnd;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6TrackContent) == 0x000008, "Wrong alignment on FX6TrackContent");
static_assert(sizeof(FX6TrackContent) == 0x000010, "Wrong size on FX6TrackContent");
static_assert(offsetof(FX6TrackContent, TrackClass) == 0x000000, "Member 'FX6TrackContent::TrackClass' has a wrong offset!");
static_assert(offsetof(FX6TrackContent, SectionBegin) == 0x000008, "Member 'FX6TrackContent::SectionBegin' has a wrong offset!");
static_assert(offsetof(FX6TrackContent, SectionEnd) == 0x00000C, "Member 'FX6TrackContent::SectionEnd' has a wrong offset!");

// ScriptStruct X6Game.X6SkillAvailableStage
// 0x0004 (0x0004 - 0x0000)
struct FX6SkillAvailableStage final
{
public:
	int32                                         Stage;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6SkillAvailableStage) == 0x000004, "Wrong alignment on FX6SkillAvailableStage");
static_assert(sizeof(FX6SkillAvailableStage) == 0x000004, "Wrong size on FX6SkillAvailableStage");
static_assert(offsetof(FX6SkillAvailableStage, Stage) == 0x000000, "Member 'FX6SkillAvailableStage::Stage' has a wrong offset!");

// ScriptStruct X6Game.X6TargetingShapeScale
// 0x0018 (0x0018 - 0x0000)
struct FX6TargetingShapeScale final : public FTargetingExtentParamsBase
{
public:
	struct FVector                                ShapeScale;                                        // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6TargetingShapeScale) == 0x000008, "Wrong alignment on FX6TargetingShapeScale");
static_assert(sizeof(FX6TargetingShapeScale) == 0x000018, "Wrong size on FX6TargetingShapeScale");
static_assert(offsetof(FX6TargetingShapeScale, ShapeScale) == 0x000000, "Member 'FX6TargetingShapeScale::ShapeScale' has a wrong offset!");

// ScriptStruct X6Game.X6AbilityMontageFailureMessage
// 0x0030 (0x0030 - 0x0000)
struct FX6AbilityMontageFailureMessage final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FailureTags;                                       // 0x0008(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FailureMontage;                                    // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6AbilityMontageFailureMessage) == 0x000008, "Wrong alignment on FX6AbilityMontageFailureMessage");
static_assert(sizeof(FX6AbilityMontageFailureMessage) == 0x000030, "Wrong size on FX6AbilityMontageFailureMessage");
static_assert(offsetof(FX6AbilityMontageFailureMessage, PlayerController) == 0x000000, "Member 'FX6AbilityMontageFailureMessage::PlayerController' has a wrong offset!");
static_assert(offsetof(FX6AbilityMontageFailureMessage, FailureTags) == 0x000008, "Member 'FX6AbilityMontageFailureMessage::FailureTags' has a wrong offset!");
static_assert(offsetof(FX6AbilityMontageFailureMessage, FailureMontage) == 0x000028, "Member 'FX6AbilityMontageFailureMessage::FailureMontage' has a wrong offset!");

// ScriptStruct X6Game.X6MotionDeltaTrack
// 0x0090 (0x0090 - 0x0000)
struct FX6MotionDeltaTrack final
{
public:
	TArray<struct FTransform>                     BoneTransformTrack;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        DeltaTranslationTrack;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       DeltaRotationTrack;                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                TotalTranslation;                                  // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TotalRotation;                                     // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BlendOutTranslation;                               // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BlendOutRotation;                                  // 0x0078(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6MotionDeltaTrack) == 0x000008, "Wrong alignment on FX6MotionDeltaTrack");
static_assert(sizeof(FX6MotionDeltaTrack) == 0x000090, "Wrong size on FX6MotionDeltaTrack");
static_assert(offsetof(FX6MotionDeltaTrack, BoneTransformTrack) == 0x000000, "Member 'FX6MotionDeltaTrack::BoneTransformTrack' has a wrong offset!");
static_assert(offsetof(FX6MotionDeltaTrack, DeltaTranslationTrack) == 0x000010, "Member 'FX6MotionDeltaTrack::DeltaTranslationTrack' has a wrong offset!");
static_assert(offsetof(FX6MotionDeltaTrack, DeltaRotationTrack) == 0x000020, "Member 'FX6MotionDeltaTrack::DeltaRotationTrack' has a wrong offset!");
static_assert(offsetof(FX6MotionDeltaTrack, TotalTranslation) == 0x000030, "Member 'FX6MotionDeltaTrack::TotalTranslation' has a wrong offset!");
static_assert(offsetof(FX6MotionDeltaTrack, TotalRotation) == 0x000048, "Member 'FX6MotionDeltaTrack::TotalRotation' has a wrong offset!");
static_assert(offsetof(FX6MotionDeltaTrack, BlendOutTranslation) == 0x000060, "Member 'FX6MotionDeltaTrack::BlendOutTranslation' has a wrong offset!");
static_assert(offsetof(FX6MotionDeltaTrack, BlendOutRotation) == 0x000078, "Member 'FX6MotionDeltaTrack::BlendOutRotation' has a wrong offset!");

// ScriptStruct X6Game.X6MotionDeltaTrackContainer
// 0x0010 (0x0010 - 0x0000)
struct FX6MotionDeltaTrackContainer final
{
public:
	TArray<struct FX6MotionDeltaTrack>            Tracks;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6MotionDeltaTrackContainer) == 0x000008, "Wrong alignment on FX6MotionDeltaTrackContainer");
static_assert(sizeof(FX6MotionDeltaTrackContainer) == 0x000010, "Wrong size on FX6MotionDeltaTrackContainer");
static_assert(offsetof(FX6MotionDeltaTrackContainer, Tracks) == 0x000000, "Member 'FX6MotionDeltaTrackContainer::Tracks' has a wrong offset!");

// ScriptStruct X6Game.X6AbilitySet_GameplayAbility
// 0x0010 (0x0010 - 0x0000)
struct FX6AbilitySet_GameplayAbility final
{
public:
	TSubclassOf<class UX6GameplayAbility>         Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6AbilitySet_GameplayAbility) == 0x000008, "Wrong alignment on FX6AbilitySet_GameplayAbility");
static_assert(sizeof(FX6AbilitySet_GameplayAbility) == 0x000010, "Wrong size on FX6AbilitySet_GameplayAbility");
static_assert(offsetof(FX6AbilitySet_GameplayAbility, Ability) == 0x000000, "Member 'FX6AbilitySet_GameplayAbility::Ability' has a wrong offset!");
static_assert(offsetof(FX6AbilitySet_GameplayAbility, InputTag) == 0x000008, "Member 'FX6AbilitySet_GameplayAbility::InputTag' has a wrong offset!");

// ScriptStruct X6Game.X6AbilitySet_GrantedHandles
// 0x0010 (0x0010 - 0x0000)
struct FX6AbilitySet_GrantedHandles final
{
public:
	TArray<struct FGameplayAbilitySpecHandle>     AbilitySpecHandles;                                // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FX6AbilitySet_GrantedHandles) == 0x000008, "Wrong alignment on FX6AbilitySet_GrantedHandles");
static_assert(sizeof(FX6AbilitySet_GrantedHandles) == 0x000010, "Wrong size on FX6AbilitySet_GrantedHandles");
static_assert(offsetof(FX6AbilitySet_GrantedHandles, AbilitySpecHandles) == 0x000000, "Member 'FX6AbilitySet_GrantedHandles::AbilitySpecHandles' has a wrong offset!");

// ScriptStruct X6Game.GameplayAbilityLocalAnimMontageForMesh
// 0x0030 (0x0030 - 0x0000)
struct FGameplayAbilityLocalAnimMontageForMesh final
{
public:
	class USkeletalMeshComponent*                 mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityLocalAnimMontage       LocalMontageInfo;                                  // 0x0008(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityLocalAnimMontageForMesh) == 0x000008, "Wrong alignment on FGameplayAbilityLocalAnimMontageForMesh");
static_assert(sizeof(FGameplayAbilityLocalAnimMontageForMesh) == 0x000030, "Wrong size on FGameplayAbilityLocalAnimMontageForMesh");
static_assert(offsetof(FGameplayAbilityLocalAnimMontageForMesh, mesh) == 0x000000, "Member 'FGameplayAbilityLocalAnimMontageForMesh::mesh' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontageForMesh, LocalMontageInfo) == 0x000008, "Member 'FGameplayAbilityLocalAnimMontageForMesh::LocalMontageInfo' has a wrong offset!");

// ScriptStruct X6Game.CombatInputHeldSpecHandle
// 0x0008 (0x0008 - 0x0000)
struct FCombatInputHeldSpecHandle final
{
public:
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputHeldTimeSeconds;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCombatInputHeldSpecHandle) == 0x000004, "Wrong alignment on FCombatInputHeldSpecHandle");
static_assert(sizeof(FCombatInputHeldSpecHandle) == 0x000008, "Wrong size on FCombatInputHeldSpecHandle");
static_assert(offsetof(FCombatInputHeldSpecHandle, AbilitySpecHandle) == 0x000000, "Member 'FCombatInputHeldSpecHandle::AbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FCombatInputHeldSpecHandle, InputHeldTimeSeconds) == 0x000004, "Member 'FCombatInputHeldSpecHandle::InputHeldTimeSeconds' has a wrong offset!");

// ScriptStruct X6Game.X6AbilityTagRelationship
// 0x0088 (0x0088 - 0x0000)
struct FX6AbilityTagRelationship final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToBlock;                                // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToCancel;                               // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6AbilityTagRelationship) == 0x000008, "Wrong alignment on FX6AbilityTagRelationship");
static_assert(sizeof(FX6AbilityTagRelationship) == 0x000088, "Wrong size on FX6AbilityTagRelationship");
static_assert(offsetof(FX6AbilityTagRelationship, AbilityTag) == 0x000000, "Member 'FX6AbilityTagRelationship::AbilityTag' has a wrong offset!");
static_assert(offsetof(FX6AbilityTagRelationship, AbilityTagsToBlock) == 0x000008, "Member 'FX6AbilityTagRelationship::AbilityTagsToBlock' has a wrong offset!");
static_assert(offsetof(FX6AbilityTagRelationship, AbilityTagsToCancel) == 0x000028, "Member 'FX6AbilityTagRelationship::AbilityTagsToCancel' has a wrong offset!");
static_assert(offsetof(FX6AbilityTagRelationship, ActivationRequiredTags) == 0x000048, "Member 'FX6AbilityTagRelationship::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(FX6AbilityTagRelationship, ActivationBlockedTags) == 0x000068, "Member 'FX6AbilityTagRelationship::ActivationBlockedTags' has a wrong offset!");

// ScriptStruct X6Game.X6AbilityGrant
// 0x0028 (0x0028 - 0x0000)
struct FX6AbilityGrant final
{
public:
	TSoftClassPtr<class UClass>                   AbilityType;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6AbilityGrant) == 0x000008, "Wrong alignment on FX6AbilityGrant");
static_assert(sizeof(FX6AbilityGrant) == 0x000028, "Wrong size on FX6AbilityGrant");
static_assert(offsetof(FX6AbilityGrant, AbilityType) == 0x000000, "Member 'FX6AbilityGrant::AbilityType' has a wrong offset!");

// ScriptStruct X6Game.X6AttributeSetGrant
// 0x0050 (0x0050 - 0x0000)
struct FX6AttributeSetGrant final
{
public:
	TSoftClassPtr<class UClass>                   AttributeSetType;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              InitializationData;                                // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FX6AttributeSetGrant) == 0x000008, "Wrong alignment on FX6AttributeSetGrant");
static_assert(sizeof(FX6AttributeSetGrant) == 0x000050, "Wrong size on FX6AttributeSetGrant");
static_assert(offsetof(FX6AttributeSetGrant, AttributeSetType) == 0x000000, "Member 'FX6AttributeSetGrant::AttributeSetType' has a wrong offset!");
static_assert(offsetof(FX6AttributeSetGrant, InitializationData) == 0x000028, "Member 'FX6AttributeSetGrant::InitializationData' has a wrong offset!");

// ScriptStruct X6Game.GameFeatureAbilitiesEntry
// 0x0048 (0x0048 - 0x0000)
struct FGameFeatureAbilitiesEntry final
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FX6AbilityGrant>                GrantedAbilities;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UX6AbilitySet>>   GrantedAbilitySets;                                // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameFeatureAbilitiesEntry) == 0x000008, "Wrong alignment on FGameFeatureAbilitiesEntry");
static_assert(sizeof(FGameFeatureAbilitiesEntry) == 0x000048, "Wrong size on FGameFeatureAbilitiesEntry");
static_assert(offsetof(FGameFeatureAbilitiesEntry, ActorClass) == 0x000000, "Member 'FGameFeatureAbilitiesEntry::ActorClass' has a wrong offset!");
static_assert(offsetof(FGameFeatureAbilitiesEntry, GrantedAbilities) == 0x000028, "Member 'FGameFeatureAbilitiesEntry::GrantedAbilities' has a wrong offset!");
static_assert(offsetof(FGameFeatureAbilitiesEntry, GrantedAbilitySets) == 0x000038, "Member 'FGameFeatureAbilitiesEntry::GrantedAbilitySets' has a wrong offset!");

}

