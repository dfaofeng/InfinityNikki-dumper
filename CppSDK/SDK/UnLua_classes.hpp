#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UnLua

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class UnLua.LuaDelegateHandler
// 0x00A0 (0x00C8 - 0x0028)
class ULuaDelegateHandler final : public UObject
{
public:
	uint8                                         Pad_28[0xA0];                                      // 0x0028(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Dummy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaDelegateHandler">();
	}
	static class ULuaDelegateHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaDelegateHandler>();
	}
};
static_assert(alignof(ULuaDelegateHandler) == 0x000008, "Wrong alignment on ULuaDelegateHandler");
static_assert(sizeof(ULuaDelegateHandler) == 0x0000C8, "Wrong size on ULuaDelegateHandler");

// Class UnLua.DelegateHandlerCollector
// 0x0000 (0x0028 - 0x0028)
class UDelegateHandlerCollector final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelegateHandlerCollector">();
	}
	static class UDelegateHandlerCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelegateHandlerCollector>();
	}
};
static_assert(alignof(UDelegateHandlerCollector) == 0x000008, "Wrong alignment on UDelegateHandlerCollector");
static_assert(sizeof(UDelegateHandlerCollector) == 0x000028, "Wrong size on UDelegateHandlerCollector");

// Class UnLua.LuaTableWrapTest
// 0x0000 (0x0028 - 0x0028)
class ULuaTableWrapTest final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaTableWrapTest">();
	}
	static class ULuaTableWrapTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaTableWrapTest>();
	}
};
static_assert(alignof(ULuaTableWrapTest) == 0x000008, "Wrong alignment on ULuaTableWrapTest");
static_assert(sizeof(ULuaTableWrapTest) == 0x000028, "Wrong size on ULuaTableWrapTest");

// Class UnLua.Testcase_LocalVariableCheck
// 0x0010 (0x0038 - 0x0028)
class UTestcase_LocalVariableCheck final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FTransform& Transform, const TArray<class FString>& StrArray)> Testcase_LocalVariableCheck_Delegate; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void Testcase_CallCPPWithOutParameter(class FString* OutString);
	void Testcase_CallLuaWithLocalVariable();
	struct FVector Testcase_ReturnLocalVariable();
	void Testcase_UseMemberLocalVariable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Testcase_LocalVariableCheck">();
	}
	static class UTestcase_LocalVariableCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestcase_LocalVariableCheck>();
	}
};
static_assert(alignof(UTestcase_LocalVariableCheck) == 0x000008, "Wrong alignment on UTestcase_LocalVariableCheck");
static_assert(sizeof(UTestcase_LocalVariableCheck) == 0x000038, "Wrong size on UTestcase_LocalVariableCheck");
static_assert(offsetof(UTestcase_LocalVariableCheck, Testcase_LocalVariableCheck_Delegate) == 0x000028, "Member 'UTestcase_LocalVariableCheck::Testcase_LocalVariableCheck_Delegate' has a wrong offset!");

// Class UnLua.TutorialTestInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialTestInterface final : public IInterface
{
public:
	void DoTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialTestInterface">();
	}
	static class ITutorialTestInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialTestInterface>();
	}
};
static_assert(alignof(ITutorialTestInterface) == 0x000001, "Wrong alignment on ITutorialTestInterface");
static_assert(sizeof(ITutorialTestInterface) == 0x000001, "Wrong size on ITutorialTestInterface");

// Class UnLua.TutorialBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTutorialBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CallDelegate(TDelegate<void(int32 nValue)> InDelegate, int32 Num);
	static void CallLuaByFLuaTable();
	static void CallLuaByGlobalTable();
	static void KillObject(class UObject* obj);
	static void SetupCustomLoader(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialBlueprintFunctionLibrary">();
	}
	static class UTutorialBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTutorialBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTutorialBlueprintFunctionLibrary");
static_assert(sizeof(UTutorialBlueprintFunctionLibrary) == 0x000028, "Wrong size on UTutorialBlueprintFunctionLibrary");

// Class UnLua.UnLuaInterface
// 0x0000 (0x0000 - 0x0000)
class IUnLuaInterface final : public IInterface
{
public:
	class FString GetModuleName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnLuaInterface">();
	}
	static class IUnLuaInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnLuaInterface>();
	}
};
static_assert(alignof(IUnLuaInterface) == 0x000001, "Wrong alignment on IUnLuaInterface");
static_assert(sizeof(IUnLuaInterface) == 0x000001, "Wrong size on IUnLuaInterface");

// Class UnLua.UnLuaManager
// 0x03C0 (0x03E8 - 0x0028)
class UUnLuaManager final : public UObject
{
public:
	uint8                                         Pad_28[0x3C0];                                     // 0x0028(0x03C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputAction(const struct FKey& Key);
	void InputAxis(float AxisValue);
	void InputGesture(float Value);
	void InputTouch(ETouchIndex FingerIndex, const struct FVector& Location);
	void InputVectorAxis(const struct FVector& AxisValue);
	void OnLatentActionCompleted(int32 LinkID);
	void TriggerAnimNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnLuaManager">();
	}
	static class UUnLuaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnLuaManager>();
	}
};
static_assert(alignof(UUnLuaManager) == 0x000008, "Wrong alignment on UUnLuaManager");
static_assert(sizeof(UUnLuaManager) == 0x0003E8, "Wrong size on UUnLuaManager");

// Class UnLua.UnLuaPerformanceTestProxy
// 0x0078 (0x0420 - 0x03A8)
class AUnLuaPerformanceTestProxy final : public AActor
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TestID;                                            // 0x03B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MeshId;                                            // 0x03B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MeshName;                                          // 0x03B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                COM;                                               // 0x03C8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 Indices;                                           // 0x03E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        Positions;                                         // 0x03F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        PredictedPositions;                                // 0x0400(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(int32 nIndex)>  Delegate;                                          // 0x0410(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void CallLuaActor(int32 Count, class AActor* InActor);
	void CallLuaInt(int32 Count);
	void CallLuaTSet(int32 Count, const TSet<struct FVector>& InPositions);
	void ExeDelegate(int32 Count);
	class AActor* GetActor();
	void NOP();
	void OverrideFunctionActor(class AActor* InActor);
	void OverrideFunctionInt(int32 In);
	void OverrideFunctionTSet(const TSet<struct FVector>& InPositions);
	void SetActor(class AActor* InActor);
	void SetDelegate(TDelegate<void(int32 nIndex)> InDelegate);
	void Simulate(float DeltaTime);
	void UpdateIndices(const TArray<int32>& NewIndices);
	int32 UpdateMeshID(int32 NewID);
	class FString UpdateMeshName(const class FString& NewName);
	void UpdatePositions(const TArray<struct FVector>& NewPositions);

	const struct FVector GetCOM() const;
	void GetIndices(TArray<int32>* OutIndices) const;
	int32 GetMeshID() const;
	bool GetMeshInfo(int32* OutMeshID, class FString* OutMeshName, struct FVector* OutCOM, TArray<int32>* OutIndices, TArray<struct FVector>* OutPositions, TArray<struct FVector>* OutPredictedPositions) const;
	class FString GetMeshName() const;
	void GetPositions(TArray<struct FVector>* OutPositions) const;
	const TArray<struct FVector> GetPredictedPositions() const;
	bool Raycast(const struct FVector& Origin, const struct FVector& Direction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnLuaPerformanceTestProxy">();
	}
	static class AUnLuaPerformanceTestProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnLuaPerformanceTestProxy>();
	}
};
static_assert(alignof(AUnLuaPerformanceTestProxy) == 0x000008, "Wrong alignment on AUnLuaPerformanceTestProxy");
static_assert(sizeof(AUnLuaPerformanceTestProxy) == 0x000420, "Wrong size on AUnLuaPerformanceTestProxy");
static_assert(offsetof(AUnLuaPerformanceTestProxy, TestID) == 0x0003B0, "Member 'AUnLuaPerformanceTestProxy::TestID' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, MeshId) == 0x0003B4, "Member 'AUnLuaPerformanceTestProxy::MeshId' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, MeshName) == 0x0003B8, "Member 'AUnLuaPerformanceTestProxy::MeshName' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, COM) == 0x0003C8, "Member 'AUnLuaPerformanceTestProxy::COM' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, Indices) == 0x0003E0, "Member 'AUnLuaPerformanceTestProxy::Indices' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, Positions) == 0x0003F0, "Member 'AUnLuaPerformanceTestProxy::Positions' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, PredictedPositions) == 0x000400, "Member 'AUnLuaPerformanceTestProxy::PredictedPositions' has a wrong offset!");
static_assert(offsetof(AUnLuaPerformanceTestProxy, Delegate) == 0x000410, "Member 'AUnLuaPerformanceTestProxy::Delegate' has a wrong offset!");

}

