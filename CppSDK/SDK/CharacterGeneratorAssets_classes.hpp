#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterGeneratorAssets

#include "Basic.hpp"

#include "CharacterGeneratorAssets_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class CharacterGeneratorAssets.CharacterGenAsset
// 0x03A8 (0x03D0 - 0x0028)
class UCharacterGenAsset final : public UObject
{
public:
	class UThumbnailInfo*                         ThumbnailInfo;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      bodyCategoryValueMap;                              // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCharacterGenDataAsset*                 bodyDataAsset;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      faceCategoryValueMap;                              // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCharacterGenDataAsset*                 faceDataAsset;                                     // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class USkeletalMesh*>     SkeletalMeshLib;                                   // 0x00E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FClothesStaticMeshData> StaticMeshLib;                                // 0x0130(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class USkeletalMesh*>     BakedSkeletalMeshLib;                              // 0x0180(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMaterialItem>       MaterialItem;                                      // 0x01D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FMaterialItem>                  MaterialItemsForBakedMesh;                         // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSpecifiedSlotMaterialItem> SpecifiedSlotMaterialItem;                  // 0x0230(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMaterialSkinData                      SkinData;                                          // 0x0280(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMaterialItem>       GlobalMaterialItem;                                // 0x02D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverlayMaterial;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UMaterialInterface*>        SectionOverrideOverlayMaterial;                    // 0x0328(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CharacterHeight;                                   // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTransform>          SkeletonMorphDetail;                               // 0x0380(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	class UCharacterGenAsset* SaveCharacterGenAsset(const class FString& InPackagePathOuter, class FName InAssetName, bool bCheckDirty);
	void UpdateCharacterGenDataAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterGenAsset">();
	}
	static class UCharacterGenAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterGenAsset>();
	}
};
static_assert(alignof(UCharacterGenAsset) == 0x000008, "Wrong alignment on UCharacterGenAsset");
static_assert(sizeof(UCharacterGenAsset) == 0x0003D0, "Wrong size on UCharacterGenAsset");
static_assert(offsetof(UCharacterGenAsset, ThumbnailInfo) == 0x000028, "Member 'UCharacterGenAsset::ThumbnailInfo' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, bodyCategoryValueMap) == 0x000030, "Member 'UCharacterGenAsset::bodyCategoryValueMap' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, bodyDataAsset) == 0x000080, "Member 'UCharacterGenAsset::bodyDataAsset' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, faceCategoryValueMap) == 0x000088, "Member 'UCharacterGenAsset::faceCategoryValueMap' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, faceDataAsset) == 0x0000D8, "Member 'UCharacterGenAsset::faceDataAsset' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, SkeletalMeshLib) == 0x0000E0, "Member 'UCharacterGenAsset::SkeletalMeshLib' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, StaticMeshLib) == 0x000130, "Member 'UCharacterGenAsset::StaticMeshLib' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, BakedSkeletalMeshLib) == 0x000180, "Member 'UCharacterGenAsset::BakedSkeletalMeshLib' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, MaterialItem) == 0x0001D0, "Member 'UCharacterGenAsset::MaterialItem' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, MaterialItemsForBakedMesh) == 0x000220, "Member 'UCharacterGenAsset::MaterialItemsForBakedMesh' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, SpecifiedSlotMaterialItem) == 0x000230, "Member 'UCharacterGenAsset::SpecifiedSlotMaterialItem' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, SkinData) == 0x000280, "Member 'UCharacterGenAsset::SkinData' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, GlobalMaterialItem) == 0x0002D0, "Member 'UCharacterGenAsset::GlobalMaterialItem' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, OverlayMaterial) == 0x000320, "Member 'UCharacterGenAsset::OverlayMaterial' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, SectionOverrideOverlayMaterial) == 0x000328, "Member 'UCharacterGenAsset::SectionOverrideOverlayMaterial' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, CharacterHeight) == 0x000378, "Member 'UCharacterGenAsset::CharacterHeight' has a wrong offset!");
static_assert(offsetof(UCharacterGenAsset, SkeletonMorphDetail) == 0x000380, "Member 'UCharacterGenAsset::SkeletonMorphDetail' has a wrong offset!");

// Class CharacterGeneratorAssets.CharacterGenAssetActor
// 0x0010 (0x07A0 - 0x0790)
class ACharacterGenAssetActor final : public ACharacter
{
public:
	class UCharacterGenAsset*                     CharacterGenAsset;                                 // 0x0788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        X6ClothPreviewComp;                                // 0x0790(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_798[0x8];                                      // 0x0798(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterGenAssetActor">();
	}
	static class ACharacterGenAssetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterGenAssetActor>();
	}
};
static_assert(alignof(ACharacterGenAssetActor) == 0x000010, "Wrong alignment on ACharacterGenAssetActor");
static_assert(sizeof(ACharacterGenAssetActor) == 0x0007A0, "Wrong size on ACharacterGenAssetActor");
static_assert(offsetof(ACharacterGenAssetActor, CharacterGenAsset) == 0x000788, "Member 'ACharacterGenAssetActor::CharacterGenAsset' has a wrong offset!");
static_assert(offsetof(ACharacterGenAssetActor, X6ClothPreviewComp) == 0x000790, "Member 'ACharacterGenAssetActor::X6ClothPreviewComp' has a wrong offset!");

// Class CharacterGeneratorAssets.CharacterGenDataAsset
// 0x0030 (0x0060 - 0x0030)
class UCharacterGenDataAsset final : public UDataAsset
{
public:
	TArray<struct FCategoryItem>                  CategoryItem;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreKeepLocationRotation;                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreKeepScale;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterGenDataAsset">();
	}
	static class UCharacterGenDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterGenDataAsset>();
	}
};
static_assert(alignof(UCharacterGenDataAsset) == 0x000008, "Wrong alignment on UCharacterGenDataAsset");
static_assert(sizeof(UCharacterGenDataAsset) == 0x000060, "Wrong size on UCharacterGenDataAsset");
static_assert(offsetof(UCharacterGenDataAsset, CategoryItem) == 0x000030, "Member 'UCharacterGenDataAsset::CategoryItem' has a wrong offset!");
static_assert(offsetof(UCharacterGenDataAsset, IgnoreKeepLocationRotation) == 0x000040, "Member 'UCharacterGenDataAsset::IgnoreKeepLocationRotation' has a wrong offset!");
static_assert(offsetof(UCharacterGenDataAsset, IgnoreKeepScale) == 0x000050, "Member 'UCharacterGenDataAsset::IgnoreKeepScale' has a wrong offset!");

// Class CharacterGeneratorAssets.TransformUserData
// 0x0068 (0x0090 - 0x0028)
class UTransformUserData final : public UAssetUserData
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0030(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformUserData">();
	}
	static class UTransformUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformUserData>();
	}
};
static_assert(alignof(UTransformUserData) == 0x000010, "Wrong alignment on UTransformUserData");
static_assert(sizeof(UTransformUserData) == 0x000090, "Wrong size on UTransformUserData");
static_assert(offsetof(UTransformUserData, Transform) == 0x000030, "Member 'UTransformUserData::Transform' has a wrong offset!");

// Class CharacterGeneratorAssets.ColorBlockUserData
// 0x0010 (0x0038 - 0x0028)
class UColorBlockUserData final : public UAssetUserData
{
public:
	TArray<struct FColorBlock>                    Blocks;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlockUserData">();
	}
	static class UColorBlockUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorBlockUserData>();
	}
};
static_assert(alignof(UColorBlockUserData) == 0x000008, "Wrong alignment on UColorBlockUserData");
static_assert(sizeof(UColorBlockUserData) == 0x000038, "Wrong size on UColorBlockUserData");
static_assert(offsetof(UColorBlockUserData, Blocks) == 0x000028, "Member 'UColorBlockUserData::Blocks' has a wrong offset!");

// Class CharacterGeneratorAssets.CharacterPgBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCharacterPgBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddNewRowIntoDataTable(class UDataTable* InDataTable, class FName InRowName, const struct FTableRowBase& InRow, bool InReplaceExisted, bool InCheckoutAndSave);
	static void BeginDrawCanvasToRenderTarget2DArray(class UObject* WorldContextObject, class UTextureRenderTarget2DArray* TextureRenderTarget, class UCanvas** Canvas, struct FVector2D* Size, struct FDrawToRenderTarget2DArrayContext* Context);
	static void CharacterPgGenAssetToReset(class UCharacterPGComponent* InPgComponent, class USkeletalMeshComponent* InMeshComponent, class USkeletalMeshComponent* InMergedComponent, const class UMaterialInterface* SkipOverrideMaterial, bool bMergeMesh);
	static void CopyAssetUserDataBetweenSkeletalMesh(class USkeletalMesh* SrcSkeletalMesh, class USkeletalMesh* DstSkeletalMesh);
	static void CopyStringToClipboard(const class FString& InString);
	static class UMaterialParameterTexture2D* CreateMPT(const class FString& InPackagePath, class FName InAssetName, bool bShouldSave);
	static class UTexture2D* CreateTexture2D(int32 SrcWidth, int32 SrcHeight, const TArray<struct FColor>& SrcData, class UObject* Outer_0, const class FString& Name_0);
	static void DestroyActorComponent(class UActorComponent* Component);
	static class UObject* DuplicateAsset(class UObject* SourceObject, const class FString& PackagePath, class FName AssetName, bool bShouldSave);
	static void EndDrawCanvasToRenderTarget2DArray(class UObject* WorldContextObject, const struct FDrawToRenderTarget2DArrayContext& Context);
	static class UAssetUserData* GetAssetUserData(class UObject* InObject, TSubclassOf<class UAssetUserData> InUserDataClass);
	static class UAssetUserData* GetAssetUserDataInMaterial(class UMaterialInterface* InMaterialInterface, TSubclassOf<class UAssetUserData> InUserDataClass);
	static struct FVector GetCharacterBoneLocation(class USkeletalMeshComponent* InMeshComponent, class FName InBoneName);
	static float GetCharacterHeightFromVertex(class USkeletalMeshComponent* InMeshComponent);
	static void GetCollectionNames(TArray<class FName>* OutCollectionNames);
	static void GetCollectionsContainingObject(const struct FSoftObjectPath& InSoftObjectPath, TArray<class FName>* OutCollectionNames);
	static struct FColor GetColorTexturePixelData(int32 PixelX, int32 PixelY, class UTexture2D* InTexture);
	static float GetDebugPrimitiveGPUTime();
	static int32 GetNumberFromString(const class FString& InStr);
	static class UTexture2D* GetObjectThumbnailTexture2D(class UObject* InObject);
	static int32 GetPartIDByName(const class FString& PartName);
	static TArray<class AActor*> GetSelectedActors();
	static class USkeleton* GetSkeletonOfAnimSequence(class UAnimSequence* AnimSequence);
	static bool GetStaticSwitchParameterValue(class UMaterialInstance* Instance, class FName ParameterName, EMaterialParameterAssociation Association);
	static TMap<ECharacterCreatorStatisticType, float> GetStatisticsInfo(class USkeletalMeshComponent* InMeshComponent, const TArray<class FName>& InExcludeTags, TArray<class UTexture*>* OutTextureMoreInfo, bool IncludeChildren);
	static TArray<class UTexture2D*> GetTexture2DArray(class UTexture2DArray* TextureArray);
	static struct FColor GetVertexColorFromID(int32 ID);
	static void IndexColorBlock(class UTexture2D* InTexture, int32 Gradual, int32 MinLength);
	static bool IsSkeletalMeshModelValid(class USkeletalMesh* SkeletalMesh);
	static void MoveLevelActorsToPersistentLevel(class ULevel* Level);
	static void OverrideRefPoseFromMeshes(class USkeletalMeshComponent* InMeshComponent, const TArray<class USkeletalMesh*>& InSkeletalMeshes);
	static void PreClientTravel();
	static bool PromptForCheckoutAndSaveAssets(const TArray<class UObject*>& AssetsToSave);
	static void ResizeRenderTarget2DArray(class UTextureRenderTarget2DArray* RenderTarget, int32 InSizeX, int32 InSizeY);
	static bool SaveAsset(const class UObject* AssetToSave);
	static class UCharacterGenAsset* SaveCharacterGenAssetWithDialogue(class UCharacterGenAsset* ToSaveAsset, const class FString& InDefaultPath);
	static class FString SaveColorBlockTextureWithDialogue(class UTextureRenderTarget2DArray* RenderTarget, const class FString& InDefaultPath);
	static class FString SaveNpcEcologyLevelWithDialogue(const TArray<class AActor*>& Actors, const class FString& InDefaultPath);
	static void SaveSkeletonMorphDetail(class USkeletalMeshComponent* InMeshComponent, class UCharacterGenAsset* GenAsset);
	static class UTexture2D* SaveTextureWithDialogue(int32 SrcWidth, int32 SrcHeight, const TArray<struct FColor>& SrcData, const class FString& InDefaultPath);
	static class UTexture2D* SaveTextureWithObjectPath(int32 SrcWidth, int32 SrcHeight, const TArray<struct FColor>& SrcData, const class FString& InSaveObjectPath);
	static bool SearchAssetsByCollectionName(class FName CollectionName, TArray<struct FSoftObjectPath>* OutAssetPaths);
	static void SetCPUSkinningEnabled(class USkinnedMeshComponent* mesh, bool bEnable, bool bRecreateRenderStateImmediately);
	static void SetPartsLODParent(class USkeletalMeshComponent* InMeshComponent, class USkeletalMeshComponent* InMergeComponent, float MinDrawDistance);
	static void SetupMaterialByGenAssetForDetachedMesh(const class UCharacterGenAsset* GenAsset, class UMeshComponent* MeshComponent, class FName MeshName);
	static void SetupMeshByGenAsset(const class UCharacterGenAsset* GenAsset, class USkeletalMeshComponent* InMeshComponent, bool bReinitPose);
	static void SetupMeshByGenAssetByDetachedMesh(const class UCharacterGenAsset* GenAsset, class USkeletalMeshComponent* InMeshComponent, bool IsNeedSave, bool bReinitPose);
	static void SetupMeshByGenAssetForMergedMesh(const class UCharacterGenAsset* GenAsset, class USkeletalMeshComponent* InMeshComponent, bool bReinitPose);
	static void SetViewportClientLocationAndRotation(const struct FTransform& Transform);
	static class AActor* SpawnActorFromAsset(class UObject* WorldContextObject, const struct FTransform& Transform, class UObject* PrefabAsset);
	static void UpdateMPT(class UMaterialInstance* MaterialInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPgBPFunctionLibrary">();
	}
	static class UCharacterPgBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPgBPFunctionLibrary>();
	}
};
static_assert(alignof(UCharacterPgBPFunctionLibrary) == 0x000008, "Wrong alignment on UCharacterPgBPFunctionLibrary");
static_assert(sizeof(UCharacterPgBPFunctionLibrary) == 0x000028, "Wrong size on UCharacterPgBPFunctionLibrary");

// Class CharacterGeneratorAssets.CharacterPGComponent
// 0x0008 (0x00B0 - 0x00A8)
class UCharacterPGComponent final : public UActorComponent
{
public:
	class UCharacterGenAsset*                     CharacterGenAsset;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool AddARow(class UDataTable* InDataTable, const class FName& Name_0, const struct FNPCRowStruct& rowBase, class FString* CSVString);
	static void ConvertToString(const struct FNPCRowStruct& rowBase, class FString* OutString);
	static bool FillDataTableFromCSVFile(class UDataTable* DataTable, const class FString& CSVFilePath);
	static bool FillDataTableFromCSVString_1(class UDataTable* DataTable, const class FString& CSVString);
	static bool FillDataTableFromJSONFile(class UDataTable* DataTable, const class FString& JSONFilePath);
	static bool FillDataTableFromJSONString(class UDataTable* DataTable, const class FString& JsonString);
	static void GetDataTableAsCSVFile(class UDataTable* DataTable, const class FString& CSVFilePath);
	static void GetDataTableAsCSVString(class UDataTable* DataTable, class FString* CSVString);
	static bool ModifyRow(class UDataTable* InDataTable, const class FName& Name_0, const class FString& streaming);
	static bool RemoveRow(class UDataTable* InDataTable, const class FName& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPGComponent">();
	}
	static class UCharacterPGComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPGComponent>();
	}
};
static_assert(alignof(UCharacterPGComponent) == 0x000008, "Wrong alignment on UCharacterPGComponent");
static_assert(sizeof(UCharacterPGComponent) == 0x0000B0, "Wrong size on UCharacterPGComponent");
static_assert(offsetof(UCharacterPGComponent, CharacterGenAsset) == 0x0000A8, "Member 'UCharacterPGComponent::CharacterGenAsset' has a wrong offset!");

// Class CharacterGeneratorAssets.ItemBase
// 0x01B8 (0x01E8 - 0x0030)
class UItemBase final : public UPrimaryDataAsset
{
public:
	struct FNPCRowStruct                          ItemProperty;                                      // 0x0030(0x01B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBase">();
	}
	static class UItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemBase>();
	}
};
static_assert(alignof(UItemBase) == 0x000008, "Wrong alignment on UItemBase");
static_assert(sizeof(UItemBase) == 0x0001E8, "Wrong size on UItemBase");
static_assert(offsetof(UItemBase, ItemProperty) == 0x000030, "Member 'UItemBase::ItemProperty' has a wrong offset!");

// Class CharacterGeneratorAssets.MyDataFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMyDataFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyDataFunctionLibrary">();
	}
	static class UMyDataFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyDataFunctionLibrary>();
	}
};
static_assert(alignof(UMyDataFunctionLibrary) == 0x000008, "Wrong alignment on UMyDataFunctionLibrary");
static_assert(sizeof(UMyDataFunctionLibrary) == 0x000028, "Wrong size on UMyDataFunctionLibrary");

}

