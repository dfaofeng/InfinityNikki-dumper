#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PaperStreamingRuntime

#include "Basic.hpp"

#include "PaperPartitionRuntime_structs.hpp"
#include "PaperStreamingRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class PaperStreamingRuntime.LoadMapTestSetting
// 0x0098 (0x00C0 - 0x0028)
class ULoadMapTestSetting final : public UObject
{
public:
	TArray<class FString>                         LevelRegexs;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoadMapFolders;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         BlackListFloderPath;                               // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoadMaps;                                          // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 SaveJsonName;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PostUrl;                                           // 0x0078(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TriangleMax;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureMemoryMax;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelAndPos>                   MemoryRecordPosArray;                              // 0x0090(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 MemoryRecordRelativeSavePath;                      // 0x00A0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MemorySendUrl;                                     // 0x00B0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadMapTestSetting">();
	}
	static class ULoadMapTestSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadMapTestSetting>();
	}
};
static_assert(alignof(ULoadMapTestSetting) == 0x000008, "Wrong alignment on ULoadMapTestSetting");
static_assert(sizeof(ULoadMapTestSetting) == 0x0000C0, "Wrong size on ULoadMapTestSetting");
static_assert(offsetof(ULoadMapTestSetting, LevelRegexs) == 0x000028, "Member 'ULoadMapTestSetting::LevelRegexs' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, LoadMapFolders) == 0x000038, "Member 'ULoadMapTestSetting::LoadMapFolders' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, BlackListFloderPath) == 0x000048, "Member 'ULoadMapTestSetting::BlackListFloderPath' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, LoadMaps) == 0x000058, "Member 'ULoadMapTestSetting::LoadMaps' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, SaveJsonName) == 0x000068, "Member 'ULoadMapTestSetting::SaveJsonName' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, PostUrl) == 0x000078, "Member 'ULoadMapTestSetting::PostUrl' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, TriangleMax) == 0x000088, "Member 'ULoadMapTestSetting::TriangleMax' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, TextureMemoryMax) == 0x00008C, "Member 'ULoadMapTestSetting::TextureMemoryMax' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, MemoryRecordPosArray) == 0x000090, "Member 'ULoadMapTestSetting::MemoryRecordPosArray' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, MemoryRecordRelativeSavePath) == 0x0000A0, "Member 'ULoadMapTestSetting::MemoryRecordRelativeSavePath' has a wrong offset!");
static_assert(offsetof(ULoadMapTestSetting, MemorySendUrl) == 0x0000B0, "Member 'ULoadMapTestSetting::MemorySendUrl' has a wrong offset!");

// Class PaperStreamingRuntime.PaperGraphicsPipelineRenderTargetsInfo
// 0x0070 (0x0098 - 0x0028)
class UPaperGraphicsPipelineRenderTargetsInfo final : public UObject
{
public:
	uint32                                        RenderTargetsEnabled;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat0;                               // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat1;                               // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat2;                               // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat3;                               // 0x002F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat4;                               // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat5;                               // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat6;                               // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RenderTargetFormat7;                               // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        RenderTargetFlag0;                                 // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag1;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag2;                                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag3;                                 // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag4;                                 // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag5;                                 // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag6;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RenderTargetFlag7;                                 // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthStencilTargetFormat;                          // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        DepthStencilTargetFlag;                            // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthTargetLoadAction;                             // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthTargetStoreAction;                            // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StencilTargetLoadAction;                           // 0x008A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StencilTargetStoreAction;                          // 0x008B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthStencilAccess;                                // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x1];                                       // 0x008D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        NumSamples;                                        // 0x008E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MultiViewCount;                                    // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFragmentDensityAttachment;                     // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SubpassIndex;                                      // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SubpassHint;                                       // 0x0093(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperGraphicsPipelineRenderTargetsInfo">();
	}
	static class UPaperGraphicsPipelineRenderTargetsInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperGraphicsPipelineRenderTargetsInfo>();
	}
};
static_assert(alignof(UPaperGraphicsPipelineRenderTargetsInfo) == 0x000008, "Wrong alignment on UPaperGraphicsPipelineRenderTargetsInfo");
static_assert(sizeof(UPaperGraphicsPipelineRenderTargetsInfo) == 0x000098, "Wrong size on UPaperGraphicsPipelineRenderTargetsInfo");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetsEnabled) == 0x000028, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetsEnabled' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat0) == 0x00002C, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat0' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat1) == 0x00002D, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat1' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat2) == 0x00002E, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat2' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat3) == 0x00002F, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat3' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat4) == 0x000030, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat4' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat5) == 0x000031, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat5' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat6) == 0x000032, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat6' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFormat7) == 0x000033, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFormat7' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag0) == 0x000038, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag0' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag1) == 0x000040, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag1' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag2) == 0x000048, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag2' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag3) == 0x000050, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag3' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag4) == 0x000058, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag4' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag5) == 0x000060, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag5' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag6) == 0x000068, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag6' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, RenderTargetFlag7) == 0x000070, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::RenderTargetFlag7' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, DepthStencilTargetFormat) == 0x000078, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::DepthStencilTargetFormat' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, DepthStencilTargetFlag) == 0x000080, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::DepthStencilTargetFlag' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, DepthTargetLoadAction) == 0x000088, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::DepthTargetLoadAction' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, DepthTargetStoreAction) == 0x000089, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::DepthTargetStoreAction' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, StencilTargetLoadAction) == 0x00008A, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::StencilTargetLoadAction' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, StencilTargetStoreAction) == 0x00008B, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::StencilTargetStoreAction' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, DepthStencilAccess) == 0x00008C, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::DepthStencilAccess' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, NumSamples) == 0x00008E, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::NumSamples' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, MultiViewCount) == 0x000090, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::MultiViewCount' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, bHasFragmentDensityAttachment) == 0x000091, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::bHasFragmentDensityAttachment' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, SubpassIndex) == 0x000092, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::SubpassIndex' has a wrong offset!");
static_assert(offsetof(UPaperGraphicsPipelineRenderTargetsInfo, SubpassHint) == 0x000093, "Member 'UPaperGraphicsPipelineRenderTargetsInfo::SubpassHint' has a wrong offset!");

// Class PaperStreamingRuntime.PaperPSOPrecachingApplyRenderTargetSettings
// 0x01D0 (0x0208 - 0x0038)
class UPaperPSOPrecachingApplyRenderTargetSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPaperMeshPass, struct FPaperGraphicsPipelineRenderTargetsInfoSettings> UltraHighSettings;  // 0x0040(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<EPaperMeshPass, struct FPaperGraphicsPipelineRenderTargetsInfoSettings> HighSettings;       // 0x0090(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<EPaperMeshPass, struct FPaperGraphicsPipelineRenderTargetsInfoSettings> MiddleSettings;     // 0x00E0(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<EPaperMeshPass, struct FPaperGraphicsPipelineRenderTargetsInfoSettings> LowSettings;        // 0x0130(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FString, struct FPaperGraphicsPipelineRenderTargetsInfoSettings> DeviceOverrideSettings; // 0x0180(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	class UPaperGraphicsPipelineRenderTargetsInfo* _RTInfo;                                          // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x30];                                     // 0x01D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPaperPSOPrecachingApplyRenderTargetSettings* Get(bool bForceReload, const class FString& ConfigPath);

	void RegisterExtension();
	void SetStartupQuality(int32 InQuality);
	void UnregisterExtension();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPSOPrecachingApplyRenderTargetSettings">();
	}
	static class UPaperPSOPrecachingApplyRenderTargetSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPSOPrecachingApplyRenderTargetSettings>();
	}
};
static_assert(alignof(UPaperPSOPrecachingApplyRenderTargetSettings) == 0x000008, "Wrong alignment on UPaperPSOPrecachingApplyRenderTargetSettings");
static_assert(sizeof(UPaperPSOPrecachingApplyRenderTargetSettings) == 0x000208, "Wrong size on UPaperPSOPrecachingApplyRenderTargetSettings");
static_assert(offsetof(UPaperPSOPrecachingApplyRenderTargetSettings, UltraHighSettings) == 0x000040, "Member 'UPaperPSOPrecachingApplyRenderTargetSettings::UltraHighSettings' has a wrong offset!");
static_assert(offsetof(UPaperPSOPrecachingApplyRenderTargetSettings, HighSettings) == 0x000090, "Member 'UPaperPSOPrecachingApplyRenderTargetSettings::HighSettings' has a wrong offset!");
static_assert(offsetof(UPaperPSOPrecachingApplyRenderTargetSettings, MiddleSettings) == 0x0000E0, "Member 'UPaperPSOPrecachingApplyRenderTargetSettings::MiddleSettings' has a wrong offset!");
static_assert(offsetof(UPaperPSOPrecachingApplyRenderTargetSettings, LowSettings) == 0x000130, "Member 'UPaperPSOPrecachingApplyRenderTargetSettings::LowSettings' has a wrong offset!");
static_assert(offsetof(UPaperPSOPrecachingApplyRenderTargetSettings, DeviceOverrideSettings) == 0x000180, "Member 'UPaperPSOPrecachingApplyRenderTargetSettings::DeviceOverrideSettings' has a wrong offset!");
static_assert(offsetof(UPaperPSOPrecachingApplyRenderTargetSettings, _RTInfo) == 0x0001D0, "Member 'UPaperPSOPrecachingApplyRenderTargetSettings::_RTInfo' has a wrong offset!");

// Class PaperStreamingRuntime.PaperStreamingComposition
// 0x0440 (0x0610 - 0x01D0)
class alignas(0x10) UPaperStreamingComposition final : public UWorldComposition
{
public:
	uint8                                         Pad_1D0[0x18];                                     // 0x01D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         WPConvertSubLevelPaths;                            // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x418];                                    // 0x01F8(0x0418)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperStreamingComposition">();
	}
	static class UPaperStreamingComposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperStreamingComposition>();
	}
};
static_assert(alignof(UPaperStreamingComposition) == 0x000010, "Wrong alignment on UPaperStreamingComposition");
static_assert(sizeof(UPaperStreamingComposition) == 0x000610, "Wrong size on UPaperStreamingComposition");
static_assert(offsetof(UPaperStreamingComposition, WPConvertSubLevelPaths) == 0x0001E8, "Member 'UPaperStreamingComposition::WPConvertSubLevelPaths' has a wrong offset!");

// Class PaperStreamingRuntime.PaperStreamingSettings
// 0x0230 (0x0258 - 0x0028)
class UPaperStreamingSettings final : public UObject
{
public:
	struct FSoftObjectPath                        BigWorldMap;                                       // 0x0028(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, struct FSoftObjectPath> BigWorldNecessities;                        // 0x0048(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 LevelAlwaysUnnecessities;                          // 0x0098(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                BigWorldUnnecessities;                             // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, struct FSoftObjectPath> AntipodalLevels;                            // 0x00B8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bCanUseFullWorldComposition;                       // 0x0108(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            DynamicVariables;                                  // 0x0110(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         HandleDetailModePhysLevels;                        // 0x0160(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint32                                        LevelBoundsThreshHold;                             // 0x0170(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePPCollisionTest;                            // 0x0174(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CollisionCellRelativedPaths;                       // 0x0178(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         CollisionCellWCBlackFlags;                         // 0x0188(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            LoadByPlatformSuffix;                              // 0x0198(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         BigWorldList;                                      // 0x01E8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                NotReuseUnloadedLevels;                            // 0x01F8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, int32>           ShouldUnloadFirstLevels;                           // 0x0208(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperStreamingSettings">();
	}
	static class UPaperStreamingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperStreamingSettings>();
	}
};
static_assert(alignof(UPaperStreamingSettings) == 0x000008, "Wrong alignment on UPaperStreamingSettings");
static_assert(sizeof(UPaperStreamingSettings) == 0x000258, "Wrong size on UPaperStreamingSettings");
static_assert(offsetof(UPaperStreamingSettings, BigWorldMap) == 0x000028, "Member 'UPaperStreamingSettings::BigWorldMap' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, BigWorldNecessities) == 0x000048, "Member 'UPaperStreamingSettings::BigWorldNecessities' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, LevelAlwaysUnnecessities) == 0x000098, "Member 'UPaperStreamingSettings::LevelAlwaysUnnecessities' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, BigWorldUnnecessities) == 0x0000A8, "Member 'UPaperStreamingSettings::BigWorldUnnecessities' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, AntipodalLevels) == 0x0000B8, "Member 'UPaperStreamingSettings::AntipodalLevels' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, bCanUseFullWorldComposition) == 0x000108, "Member 'UPaperStreamingSettings::bCanUseFullWorldComposition' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, DynamicVariables) == 0x000110, "Member 'UPaperStreamingSettings::DynamicVariables' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, HandleDetailModePhysLevels) == 0x000160, "Member 'UPaperStreamingSettings::HandleDetailModePhysLevels' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, LevelBoundsThreshHold) == 0x000170, "Member 'UPaperStreamingSettings::LevelBoundsThreshHold' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, bEnablePPCollisionTest) == 0x000174, "Member 'UPaperStreamingSettings::bEnablePPCollisionTest' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, CollisionCellRelativedPaths) == 0x000178, "Member 'UPaperStreamingSettings::CollisionCellRelativedPaths' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, CollisionCellWCBlackFlags) == 0x000188, "Member 'UPaperStreamingSettings::CollisionCellWCBlackFlags' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, LoadByPlatformSuffix) == 0x000198, "Member 'UPaperStreamingSettings::LoadByPlatformSuffix' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, BigWorldList) == 0x0001E8, "Member 'UPaperStreamingSettings::BigWorldList' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, NotReuseUnloadedLevels) == 0x0001F8, "Member 'UPaperStreamingSettings::NotReuseUnloadedLevels' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSettings, ShouldUnloadFirstLevels) == 0x000208, "Member 'UPaperStreamingSettings::ShouldUnloadFirstLevels' has a wrong offset!");

// Class PaperStreamingRuntime.X6WorldPartitionConvertBriefData
// 0x0050 (0x0078 - 0x0028)
class UX6WorldPartitionConvertBriefData final : public UObject
{
public:
	struct FSoftObjectPath                        ConvertMap;                                        // 0x0028(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TargetMap;                                         // 0x0048(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ConvertSubLevelPaths;                              // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6WorldPartitionConvertBriefData">();
	}
	static class UX6WorldPartitionConvertBriefData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6WorldPartitionConvertBriefData>();
	}
};
static_assert(alignof(UX6WorldPartitionConvertBriefData) == 0x000008, "Wrong alignment on UX6WorldPartitionConvertBriefData");
static_assert(sizeof(UX6WorldPartitionConvertBriefData) == 0x000078, "Wrong size on UX6WorldPartitionConvertBriefData");
static_assert(offsetof(UX6WorldPartitionConvertBriefData, ConvertMap) == 0x000028, "Member 'UX6WorldPartitionConvertBriefData::ConvertMap' has a wrong offset!");
static_assert(offsetof(UX6WorldPartitionConvertBriefData, TargetMap) == 0x000048, "Member 'UX6WorldPartitionConvertBriefData::TargetMap' has a wrong offset!");
static_assert(offsetof(UX6WorldPartitionConvertBriefData, ConvertSubLevelPaths) == 0x000068, "Member 'UX6WorldPartitionConvertBriefData::ConvertSubLevelPaths' has a wrong offset!");

// Class PaperStreamingRuntime.PaperStreamingSubsystem
// 0x0688 (0x06B8 - 0x0030)
class UPaperStreamingSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& LevelPath)> OnLevelStreamingBegin;            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& LevelPath, float Progress)> OnLevelStreamingProgress; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& LevelPath, bool Result)> OnLevelStreamingFinished; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBox2D& StreamingSourceRange, const TArray<struct FBox2D>& LoadingRanges)> OnLoadLevelRangeChanged; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FIntPoint>* TargetCells, bool bReadied, class FString* WorldTag)> OnCollisionCellStatusChange; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x2F0];                                     // 0x0088(0x02F0)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 StreamingSourceActor;                              // 0x0378(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x338];                                    // 0x0380(0x0338)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FName> GetActorLayers(class AActor* InActor);
	static class FString GetBigWorldPath();
	static class FString GetEffectivePreviewPlatformName();
	static class UPaperStreamingSubsystem* Instance();
	static bool IsBigWorldMap(const class FString& InPath);
	static bool IsNeedLoadingInLocation(const struct FVector& InLocation);

	void AddOrUpdateExtraStreamingSource(class UObject* InWorldContextObject, const class FString& InSourceTag, const struct FVector& InLocation, float InScale, const TMap<int32, int32>& InStreamerRange);
	void BindLayerChangedEvent(const class FString& InLayerName, TDelegate<void(const TArray<class AActor*>& Actors, bool IsAdd)> InOnLayerChanged);
	void BindLayerVisibilityChangedEvent(const class FString& InLayerName, TDelegate<void(const TArray<class AActor*>& Actors, bool IsVisible)> InOnLayerVisibilityChanged);
	void ClearExternalDistance();
	void ClearLayersVisibility();
	void EnableGrassUpdate(bool bEnable);
	void EnableVirtualTextureUpdate(bool bEnable);
	void ForceUpdateAllLayersVisibility();
	void Freeze();
	void GatherExternalLevels(class UObject* InWorldContextObject);
	const TArray<class AActor*> GetActorsByLayer(const class FString& LayerName);
	TArray<class FName> GetAllSocketNames(class USceneComponent* InComponent);
	TArray<struct FIntPoint> GetCellCollisionActiveCells();
	TMap<struct FIntPoint, bool> GetCellCollisionStateInfo();
	TArray<class FString> GetCellCollisionStateLevelInfo(int32 X, int32 Y);
	class FString GetCellInfo(int32 X, int32 Y);
	class FString GetCollisionStreamingInfo(const float InRange, const class FString& InFilterName, TMap<struct FVector2D, int32>* CollisionInfos);
	int32 GetCollisionStreamingRange();
	class FString GetCurrentWorldTag();
	class ULevelStreaming* GetLevelStreaming(class UObject* InWorldContextObject, const class FString& Path);
	int32 GetPaperPartitionCellSize();
	int32 GetPaperPartitionCollisionRange();
	struct FVector GetSocketLocation(class USceneComponent* InComponent, class FName InSocketName);
	struct FQuat GetSocketQuaternion(class USceneComponent* InComponent, class FName InSocketName);
	struct FRotator GetSocketRotation(class USceneComponent* InComponent, class FName InSocketName);
	struct FTransform GetSocketTransform(class USceneComponent* InComponent, class FName InSocketName, ERelativeTransformSpace TransformSpace);
	bool GetSubLevelsByPath(class UObject* InWorldContextObject, const class FString& LevelPath, bool bAlwaysLoadedOnly, bool bSkipBigWorldNecessary, TArray<class FString>* OutSubLevels);
	void HandleDetailModeComponentsPhys(class ULevel* InLevel);
	bool IsActorInLayer(class AActor* InActor, const class FString& InLayerName);
	bool IsEnableCellCollisionTest();
	bool IsEnableExternalLevels();
	bool IsLayerVisible(const class FString& InLayerName);
	bool IsPaperPartitionCellComplete(const struct FVector& Position, int32 Range, ELoadStateCheckType CheckType);
	bool LoadAssetAsync(const TArray<struct FSoftObjectPath>& AssetsPath, TDelegate<void(const TArray<class UObject*>& Loaded)> Callback, bool ForceLoadBPClass);
	bool LoadMap(const class FString& Path, const struct FVector& InLocation);
	bool LoadMapInVisible(const class FString& Path, const struct FVector& InLocation, TArray<class FString>* InVisibleLevels, const class FString& Options, const class FString& WorldTag);
	bool LoadMapsInVisible(const TArray<struct FLoadMapParams>& InLoadMapParams, const class FString& Options);
	bool LoadSubLevels(const TArray<class FString>& SubLevelPaths, const TArray<struct FVector>& Locations, TDelegate<void(const TArray<class FString>& LevelPaths)> Callback);
	bool LoadSubLevelToWorld(const class FString& SubLevelPath, const struct FVector& LoadLocation);
	void ReleaseShaderCodes();
	void RemoveExternalDistance(const class FString& Path, int32 Distance);
	void RemoveExtraStreamingSource(class UObject* InWorldContextObject, const class FString& InSourceTag);
	void SetExternalDistance(const class FString& Path, int32 Distance);
	void SetExtraConditionLevelInfo(class UObject* InWorldContextObject, const class FString& InLevelKeyword, bool bInCanLoad);
	void SetLayerVisibility(const class FString& InLayerName, bool bVisible, bool bUpdateImmediately);
	void SetOverrideLoadingRanges(const TMap<int32, int32>& InOverrideLoadingRanges);
	void SetPaperPartitionBoost(bool bIsBoost);
	void SetPlayerStreamingSourceEnable(class UObject* InWorldContextObject, bool bEnable);
	void SetStreamingEnable(bool bEnable);
	void SetUseFullWorldComposition(bool bInUseFullWorldComposition);
	void UnbindLayerChangedEvent(const class FString& InLayerName, TDelegate<void(const TArray<class AActor*>& Actors, bool IsAdd)> InOnLayerChanged);
	void UnbindLayerVisibilityChangedEvent(const class FString& InLayerName, TDelegate<void(const TArray<class AActor*>& Actors, bool IsVisible)> InOnLayerVisibilityChanged);
	void UnFreeze();
	bool UnloadSubLevels(const TArray<class FString>& SubLevelPaths);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperStreamingSubsystem">();
	}
	static class UPaperStreamingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperStreamingSubsystem>();
	}
};
static_assert(alignof(UPaperStreamingSubsystem) == 0x000008, "Wrong alignment on UPaperStreamingSubsystem");
static_assert(sizeof(UPaperStreamingSubsystem) == 0x0006B8, "Wrong size on UPaperStreamingSubsystem");
static_assert(offsetof(UPaperStreamingSubsystem, OnLevelStreamingBegin) == 0x000038, "Member 'UPaperStreamingSubsystem::OnLevelStreamingBegin' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSubsystem, OnLevelStreamingProgress) == 0x000048, "Member 'UPaperStreamingSubsystem::OnLevelStreamingProgress' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSubsystem, OnLevelStreamingFinished) == 0x000058, "Member 'UPaperStreamingSubsystem::OnLevelStreamingFinished' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSubsystem, OnLoadLevelRangeChanged) == 0x000068, "Member 'UPaperStreamingSubsystem::OnLoadLevelRangeChanged' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSubsystem, OnCollisionCellStatusChange) == 0x000078, "Member 'UPaperStreamingSubsystem::OnCollisionCellStatusChange' has a wrong offset!");
static_assert(offsetof(UPaperStreamingSubsystem, StreamingSourceActor) == 0x000378, "Member 'UPaperStreamingSubsystem::StreamingSourceActor' has a wrong offset!");

// Class PaperStreamingRuntime.X6LoadMapDialog
// 0x0050 (0x0078 - 0x0028)
class UX6LoadMapDialog final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6LoadMapDialog">();
	}
	static class UX6LoadMapDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6LoadMapDialog>();
	}
};
static_assert(alignof(UX6LoadMapDialog) == 0x000008, "Wrong alignment on UX6LoadMapDialog");
static_assert(sizeof(UX6LoadMapDialog) == 0x000078, "Wrong size on UX6LoadMapDialog");

// Class PaperStreamingRuntime.X6LoadMapTest
// 0x0458 (0x0480 - 0x0028)
class UX6LoadMapTest final : public UObject
{
public:
	uint8                                         Pad_28[0x458];                                     // 0x0028(0x0458)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelShown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6LoadMapTest">();
	}
	static class UX6LoadMapTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6LoadMapTest>();
	}
};
static_assert(alignof(UX6LoadMapTest) == 0x000008, "Wrong alignment on UX6LoadMapTest");
static_assert(sizeof(UX6LoadMapTest) == 0x000480, "Wrong size on UX6LoadMapTest");

}

