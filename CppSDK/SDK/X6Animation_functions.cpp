#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: X6Animation

#include "Basic.hpp"

#include "X6Animation_classes.hpp"
#include "X6Animation_parameters.hpp"


namespace SDK
{

// Function X6Animation.ANS_MantleRootMotionControl.CheckEnableRootMotionConditionBP
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           SkelMeshComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                SequenceAsset                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UANS_MantleRootMotionControl::CheckEnableRootMotionConditionBP(class USkeletalMeshComponent* SkelMeshComponent, class UAnimSequenceBase* SequenceAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANS_MantleRootMotionControl", "CheckEnableRootMotionConditionBP");

	Params::ANS_MantleRootMotionControl_CheckEnableRootMotionConditionBP Parms{};

	Parms.SkelMeshComponent = SkelMeshComponent;
	Parms.SequenceAsset = SequenceAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.ContextualAnimationSystem.AddContextual
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FContextualData&           InContextualData                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::AddContextual(uint8 ID, const struct FContextualData& InContextualData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "AddContextual");

	Params::ContextualAnimationSystem_AddContextual Parms{};

	Parms.ID = ID;
	Parms.InContextualData = std::move(InContextualData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.DisableContextualAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::DisableContextualAnimation(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "DisableContextualAnimation");

	Params::ContextualAnimationSystem_DisableContextualAnimation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.EnableContextualAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::EnableContextualAnimation(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "EnableContextualAnimation");

	Params::ContextualAnimationSystem_EnableContextualAnimation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.IsCurrentContextualAnimiationPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContextualAnimationSystem::IsCurrentContextualAnimiationPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "IsCurrentContextualAnimiationPlaying");

	Params::ContextualAnimationSystem_IsCurrentContextualAnimiationPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.ContextualAnimationSystem.OnContextualEnd
// (Final, Native, Public, BlueprintCallable)

void UContextualAnimationSystem::OnContextualEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "OnContextualEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.OnContextualEndByID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::OnContextualEndByID(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "OnContextualEndByID");

	Params::ContextualAnimationSystem_OnContextualEndByID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.RemoveContextual
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::RemoveContextual(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "RemoveContextual");

	Params::ContextualAnimationSystem_RemoveContextual Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.ResumeContextualAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::ResumeContextualAnimation(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "ResumeContextualAnimation");

	Params::ContextualAnimationSystem_ResumeContextualAnimation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.SetContextualAnimationEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::SetContextualAnimationEnable(uint8 ID, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "SetContextualAnimationEnable");

	Params::ContextualAnimationSystem_SetContextualAnimationEnable Parms{};

	Parms.ID = ID;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.SetContextualSystemEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::SetContextualSystemEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "SetContextualSystemEnable");

	Params::ContextualAnimationSystem_SetContextualSystemEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.ContextualAnimationSystem.SuspendContextualAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualAnimationSystem::SuspendContextualAnimation(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualAnimationSystem", "SuspendContextualAnimation");

	Params::ContextualAnimationSystem_SuspendContextualAnimation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.PlayerLocomotionAnimInstance.BlueprintCustomLateUpdate
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::BlueprintCustomLateUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "BlueprintCustomLateUpdate");

	Params::PlayerLocomotionAnimInstance_BlueprintCustomLateUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function X6Animation.PlayerLocomotionAnimInstance.BlueprintCustomPreUpdate
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::BlueprintCustomPreUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "BlueprintCustomPreUpdate");

	Params::PlayerLocomotionAnimInstance_BlueprintCustomPreUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function X6Animation.PlayerLocomotionAnimInstance.BlueprintCustomUpdate
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::BlueprintCustomUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "BlueprintCustomUpdate");

	Params::PlayerLocomotionAnimInstance_BlueprintCustomUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function X6Animation.PlayerLocomotionAnimInstance.DeterminTransToRightFoot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   bTranstoRight                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::DeterminTransToRightFoot(bool* bTranstoRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "DeterminTransToRightFoot");

	Params::PlayerLocomotionAnimInstance_DeterminTransToRightFoot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bTranstoRight != nullptr)
		*bTranstoRight = Parms.bTranstoRight;
}


// Function X6Animation.PlayerLocomotionAnimInstance.SetLocomotionLogicStates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELocomotionGait                         InAllowGait                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::SetLocomotionLogicStates(ELocomotionGait InAllowGait)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "SetLocomotionLogicStates");

	Params::PlayerLocomotionAnimInstance_SetLocomotionLogicStates Parms{};

	Parms.InAllowGait = InAllowGait;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.PlayerLocomotionAnimInstance.SetLocomotionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELocomotionType                         LocomotionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::SetLocomotionType(ELocomotionType LocomotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "SetLocomotionType");

	Params::PlayerLocomotionAnimInstance_SetLocomotionType Parms{};

	Parms.LocomotionType = LocomotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.PlayerLocomotionAnimInstance.UpdateLocomotionLogicValues
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InMovementInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxAcceleration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTurnAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSlopeAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLocomotionAnimInstance::UpdateLocomotionLogicValues(const struct FVector& InVelocity, const struct FVector& InMovementInput, float InMaxAcceleration, float InTurnAngle, float InSlopeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocomotionAnimInstance", "UpdateLocomotionLogicValues");

	Params::PlayerLocomotionAnimInstance_UpdateLocomotionLogicValues Parms{};

	Parms.InVelocity = std::move(InVelocity);
	Parms.InMovementInput = std::move(InMovementInput);
	Parms.InMaxAcceleration = InMaxAcceleration;
	Parms.InTurnAngle = InTurnAngle;
	Parms.InSlopeAngle = InSlopeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.BP_UpdateActualGait
// (Final, Native, Public, BlueprintCallable)

void UNikkiGroundAnimInstance::BP_UpdateActualGait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "BP_UpdateActualGait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.DetermineStartGait
// (Final, Native, Public, BlueprintCallable)

void UNikkiGroundAnimInstance::DetermineStartGait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "DetermineStartGait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.NotifyTransitionToPivot
// (Final, Native, Public, BlueprintCallable)

void UNikkiGroundAnimInstance::NotifyTransitionToPivot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "NotifyTransitionToPivot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.PopForbidTransitionToMove
// (Final, Native, Public, BlueprintCallable)

void UNikkiGroundAnimInstance::PopForbidTransitionToMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "PopForbidTransitionToMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.PushForbidTransitionToMove
// (Final, Native, Public, BlueprintCallable)

void UNikkiGroundAnimInstance::PushForbidTransitionToMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "PushForbidTransitionToMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.SetAllowSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAllowWalkSpeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAllowRunSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAllowSprintSpeed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNikkiGroundAnimInstance::SetAllowSpeed(float InAllowWalkSpeed, float InAllowRunSpeed, float InAllowSprintSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "SetAllowSpeed");

	Params::NikkiGroundAnimInstance_SetAllowSpeed Parms{};

	Parms.InAllowWalkSpeed = InAllowWalkSpeed;
	Parms.InAllowRunSpeed = InAllowRunSpeed;
	Parms.InAllowSprintSpeed = InAllowSprintSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.SetAnimBenchmarkSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAnimationSprintSpeed                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAnimationRunSpeed                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAnimationWalkSpeed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAnimationWalkSlowSpeed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNikkiGroundAnimInstance::SetAnimBenchmarkSpeed(float InAnimationSprintSpeed, float InAnimationRunSpeed, float InAnimationWalkSpeed, float InAnimationWalkSlowSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "SetAnimBenchmarkSpeed");

	Params::NikkiGroundAnimInstance_SetAnimBenchmarkSpeed Parms{};

	Parms.InAnimationSprintSpeed = InAnimationSprintSpeed;
	Parms.InAnimationRunSpeed = InAnimationRunSpeed;
	Parms.InAnimationWalkSpeed = InAnimationWalkSpeed;
	Parms.InAnimationWalkSlowSpeed = InAnimationWalkSlowSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.SetAnimMainState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELocomotionGroundMainState              MainState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNikkiGroundAnimInstance::SetAnimMainState(ELocomotionGroundMainState MainState, bool bEnter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "SetAnimMainState");

	Params::NikkiGroundAnimInstance_SetAnimMainState Parms{};

	Parms.MainState = MainState;
	Parms.bEnter = bEnter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.SetBoardSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAllowWalkSlowSpeed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentMaxSpeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentConfigAllowSpeed                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNikkiGroundAnimInstance::SetBoardSpeed(float InAllowWalkSlowSpeed, float InCurrentMaxSpeed, float InCurrentConfigAllowSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "SetBoardSpeed");

	Params::NikkiGroundAnimInstance_SetBoardSpeed Parms{};

	Parms.InAllowWalkSlowSpeed = InAllowWalkSlowSpeed;
	Parms.InCurrentMaxSpeed = InCurrentMaxSpeed;
	Parms.InCurrentConfigAllowSpeed = InCurrentConfigAllowSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.SetIdleState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELocomotionGroundIdleState              IdleState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNikkiGroundAnimInstance::SetIdleState(ELocomotionGroundIdleState IdleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "SetIdleState");

	Params::NikkiGroundAnimInstance_SetIdleState Parms{};

	Parms.IdleState = IdleState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.NikkiGroundAnimInstance.UpdateStartTurnParams
// (Final, Native, Protected, BlueprintCallable)

void UNikkiGroundAnimInstance::UpdateStartTurnParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NikkiGroundAnimInstance", "UpdateStartTurnParams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.ChangeMontageSegmentRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage**                    InOutMontage                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TrimStartTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TrimEndTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrackIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UX6AnimationFunctionLibrary::ChangeMontageSegmentRange(class UAnimMontage** InOutMontage, float TrimStartTime, float TrimEndTime, int32 TrackIndex, int32 SegmentIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ChangeMontageSegmentRange");

	Params::X6AnimationFunctionLibrary_ChangeMontageSegmentRange Parms{};

	Parms.TrimStartTime = TrimStartTime;
	Parms.TrimEndTime = TrimEndTime;
	Parms.TrackIndex = TrackIndex;
	Parms.SegmentIndex = SegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InOutMontage != nullptr)
		*InOutMontage = Parms.InOutMontage;

	return Parms.ReturnValue;
}


// Function X6Animation.X6AnimationFunctionLibrary.ClearAllInertialization
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIncludeLinkedAniminstance                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::ClearAllInertialization(const struct FAnimUpdateContext& Context, bool bIncludeLinkedAniminstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ClearAllInertialization");

	Params::X6AnimationFunctionLibrary_ClearAllInertialization Parms{};

	Parms.Context = std::move(Context);
	Parms.bIncludeLinkedAniminstance = bIncludeLinkedAniminstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.ClearAllInertializationOfThisAniminstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeLinkedAniminstance                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::ClearAllInertializationOfThisAniminstance(class UAnimInstance* AnimInstance, bool bIncludeLinkedAniminstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ClearAllInertializationOfThisAniminstance");

	Params::X6AnimationFunctionLibrary_ClearAllInertializationOfThisAniminstance Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.bIncludeLinkedAniminstance = bIncludeLinkedAniminstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.ClearInertializationBeforeThisNode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::ClearInertializationBeforeThisNode(const struct FAnimUpdateContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ClearInertializationBeforeThisNode");

	Params::X6AnimationFunctionLibrary_ClearInertializationBeforeThisNode Parms{};

	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.CreatePoseSnapshotOfAnimInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    LocalTransforms                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPoseSnapshot*                   PoseSnapshot                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::CreatePoseSnapshotOfAnimInstance(class UAnimInstance* AnimInstance, const class FString& LocalTransforms, struct FPoseSnapshot* PoseSnapshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "CreatePoseSnapshotOfAnimInstance");

	Params::X6AnimationFunctionLibrary_CreatePoseSnapshotOfAnimInstance Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.LocalTransforms = std::move(LocalTransforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PoseSnapshot != nullptr)
		*PoseSnapshot = std::move(Parms.PoseSnapshot);
}


// Function X6Animation.X6AnimationFunctionLibrary.ForceConsiderInertializationDeficitThisFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::ForceConsiderInertializationDeficitThisFrame(const struct FAnimUpdateContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ForceConsiderInertializationDeficitThisFrame");

	Params::X6AnimationFunctionLibrary_ForceConsiderInertializationDeficitThisFrame Parms{};

	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.ForceIgnoreInertializationDeficitThisFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::ForceIgnoreInertializationDeficitThisFrame(const struct FAnimUpdateContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ForceIgnoreInertializationDeficitThisFrame");

	Params::X6AnimationFunctionLibrary_ForceIgnoreInertializationDeficitThisFrame Parms{};

	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.ForceToStopSlotAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::ForceToStopSlotAnimation(class UAnimInstance* AnimInstance, float InBlendOutTime, class FName SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "ForceToStopSlotAnimation");

	Params::X6AnimationFunctionLibrary_ForceToStopSlotAnimation Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.InBlendOutTime = InBlendOutTime;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6AnimationFunctionLibrary.GetAnimationSequencesBySlotNameInAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SlotNodeName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimSequenceBase*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAnimSequenceBase*> UX6AnimationFunctionLibrary::GetAnimationSequencesBySlotNameInAnimMontage(class UAnimMontage* AnimMontage, const class FName& SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "GetAnimationSequencesBySlotNameInAnimMontage");

	Params::X6AnimationFunctionLibrary_GetAnimationSequencesBySlotNameInAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6AnimationFunctionLibrary.GetAnimationSequencesInTargetSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SlotNodeName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimSequenceBase*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAnimSequenceBase*> UX6AnimationFunctionLibrary::GetAnimationSequencesInTargetSlot(class UAnimInstance* AnimInstance, const class FName& SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "GetAnimationSequencesInTargetSlot");

	Params::X6AnimationFunctionLibrary_GetAnimationSequencesInTargetSlot Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6AnimationFunctionLibrary.GetLinkedAnimLayersInstanceByClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimInstance*>*           OutLinkedInstances                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UX6AnimationFunctionLibrary::GetLinkedAnimLayersInstanceByClass(class UAnimInstance* AnimInstance, TSubclassOf<class UAnimInstance> InClass, TArray<class UAnimInstance*>* OutLinkedInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "GetLinkedAnimLayersInstanceByClass");

	Params::X6AnimationFunctionLibrary_GetLinkedAnimLayersInstanceByClass Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLinkedInstances != nullptr)
		*OutLinkedInstances = std::move(Parms.OutLinkedInstances);
}


// Function X6Animation.X6AnimationFunctionLibrary.GetMontagePositionAndTotalLengthBySlotNameInAnimInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SlotNodeName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutCurPosition                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutTotalLength                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UX6AnimationFunctionLibrary::GetMontagePositionAndTotalLengthBySlotNameInAnimInstance(class UAnimInstance* AnimInstance, const class FName& SlotNodeName, float* OutCurPosition, float* OutTotalLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "GetMontagePositionAndTotalLengthBySlotNameInAnimInstance");

	Params::X6AnimationFunctionLibrary_GetMontagePositionAndTotalLengthBySlotNameInAnimInstance Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCurPosition != nullptr)
		*OutCurPosition = Parms.OutCurPosition;

	if (OutTotalLength != nullptr)
		*OutTotalLength = Parms.OutTotalLength;

	return Parms.ReturnValue;
}


// Function X6Animation.X6AnimationFunctionLibrary.GetPoseDataFromCurrentPose
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UX6AnimationFunctionLibrary::GetPoseDataFromCurrentPose(class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "GetPoseDataFromCurrentPose");

	Params::X6AnimationFunctionLibrary_GetPoseDataFromCurrentPose Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6AnimationFunctionLibrary.IsAnimSequenceValidCurveName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCurveName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UX6AnimationFunctionLibrary::IsAnimSequenceValidCurveName(class UAnimSequenceBase* InAnimSequence, class FName InCurveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6AnimationFunctionLibrary", "IsAnimSequenceValidCurveName");

	Params::X6AnimationFunctionLibrary_IsAnimSequenceValidCurveName Parms{};

	Parms.InAnimSequence = InAnimSequence;
	Parms.InCurveName = InCurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6ClothAnimInstance.AddClothExternalAcc
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InClothExternalAcc                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InClothExternalAccDuration                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6ClothAnimInstance::AddClothExternalAcc(const struct FVector& InClothExternalAcc, float InClothExternalAccDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("X6ClothAnimInstance", "AddClothExternalAcc");

	Params::X6ClothAnimInstance_AddClothExternalAcc Parms{};

	Parms.InClothExternalAcc = std::move(InClothExternalAcc);
	Parms.InClothExternalAccDuration = InClothExternalAccDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6ClothAnimInstance.ConsumeClothExternalAcc
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FClothExternalData*              OutClothExternalData                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UX6ClothAnimInstance::ConsumeClothExternalAcc(struct FClothExternalData* OutClothExternalData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("X6ClothAnimInstance", "ConsumeClothExternalAcc");

	Params::X6ClothAnimInstance_ConsumeClothExternalAcc Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutClothExternalData != nullptr)
		*OutClothExternalData = std::move(Parms.OutClothExternalData);
}


// Function X6Animation.X6PlayMontageCallbackProxy.CreateProxyObjectForPlayMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMirror                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRootMotionTranslationScale                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayWithShadow                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UX6PlayMontageCallbackProxy*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UX6PlayMontageCallbackProxy* UX6PlayMontageCallbackProxy::CreateProxyObjectForPlayMontage(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, class FName StartingSection, bool bMirror, float AnimRootMotionTranslationScale, bool bReplicate, bool bPlayWithShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6PlayMontageCallbackProxy", "CreateProxyObjectForPlayMontage");

	Params::X6PlayMontageCallbackProxy_CreateProxyObjectForPlayMontage Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;
	Parms.MontageToPlay = MontageToPlay;
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;
	Parms.bMirror = bMirror;
	Parms.AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;
	Parms.bReplicate = bReplicate;
	Parms.bPlayWithShadow = bPlayWithShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6PlayMontageCallbackProxy.CreateProxyObjectForPlayMontageWithParam
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayWithShadow                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FX6PlayMontageParams&      MontageParams                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UX6PlayMontageCallbackProxy*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UX6PlayMontageCallbackProxy* UX6PlayMontageCallbackProxy::CreateProxyObjectForPlayMontageWithParam(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, bool bReplicate, bool bPlayWithShadow, const struct FX6PlayMontageParams& MontageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6PlayMontageCallbackProxy", "CreateProxyObjectForPlayMontageWithParam");

	Params::X6PlayMontageCallbackProxy_CreateProxyObjectForPlayMontageWithParam Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;
	Parms.MontageToPlay = MontageToPlay;
	Parms.bReplicate = bReplicate;
	Parms.bPlayWithShadow = bPlayWithShadow;
	Parms.MontageParams = std::move(MontageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6PlayMontageCallbackProxy.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6PlayMontageCallbackProxy::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("X6PlayMontageCallbackProxy", "OnMontageBlendingOut");

	Params::X6PlayMontageCallbackProxy_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6PlayMontageCallbackProxy.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6PlayMontageCallbackProxy::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("X6PlayMontageCallbackProxy", "OnMontageEnded");

	Params::X6PlayMontageCallbackProxy_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6PlayMontageCallbackProxy.OnNotifyBeginReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UX6PlayMontageCallbackProxy::OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("X6PlayMontageCallbackProxy", "OnNotifyBeginReceived");

	Params::X6PlayMontageCallbackProxy_OnNotifyBeginReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6PlayMontageCallbackProxy.OnNotifyEndReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UX6PlayMontageCallbackProxy::OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("X6PlayMontageCallbackProxy", "OnNotifyEndReceived");

	Params::X6PlayMontageCallbackProxy_OnNotifyEndReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6SequencePlayerLibrary.ClearCachedBlendWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UX6SequencePlayerLibrary::ClearCachedBlendWeight(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "ClearCachedBlendWeight");

	Params::X6SequencePlayerLibrary_ClearCachedBlendWeight Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6SequencePlayerLibrary.ComputePlayRateFromDuration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::ComputePlayRateFromDuration(const struct FX6SequencePlayerReference& SequencePlayer, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "ComputePlayRateFromDuration");

	Params::X6SequencePlayerLibrary_ComputePlayRateFromDuration Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.ConvertToSequencePlayerPure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference*      SequencePlayer                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6SequencePlayerLibrary::ConvertToSequencePlayerPure(const struct FAnimNodeReference& Node, struct FX6SequencePlayerReference* SequencePlayer, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "ConvertToSequencePlayerPure");

	Params::X6SequencePlayerLibrary_ConvertToSequencePlayerPure Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SequencePlayer != nullptr)
		*SequencePlayer = std::move(Parms.SequencePlayer);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function X6Animation.X6SequencePlayerLibrary.ConvertToX6OverlayBlend
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6OverlayBlendReference         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6OverlayBlendReference UX6SequencePlayerLibrary::ConvertToX6OverlayBlend(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "ConvertToX6OverlayBlend");

	Params::X6SequencePlayerLibrary_ConvertToX6OverlayBlend Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.ConvertToX6SequencePlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::ConvertToX6SequencePlayer(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "ConvertToX6SequencePlayer");

	Params::X6SequencePlayerLibrary_ConvertToX6SequencePlayer Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.ConvertToX6StylizedOverlayBlend
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6StylizedOverlayBlendReference ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6StylizedOverlayBlendReference UX6SequencePlayerLibrary::ConvertToX6StylizedOverlayBlend(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "ConvertToX6StylizedOverlayBlend");

	Params::X6SequencePlayerLibrary_ConvertToX6StylizedOverlayBlend Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.DeactivateBlendThisFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6OverlayBlendReference&  OverlayBlend                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6OverlayBlendReference         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6OverlayBlendReference UX6SequencePlayerLibrary::DeactivateBlendThisFrame(const struct FX6OverlayBlendReference& OverlayBlend, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "DeactivateBlendThisFrame");

	Params::X6SequencePlayerLibrary_DeactivateBlendThisFrame Parms{};

	Parms.OverlayBlend = std::move(OverlayBlend);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.DeactivateStylizedBlendThisFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6StylizedOverlayBlendReference&OverlayBlend                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6StylizedOverlayBlendReference ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6StylizedOverlayBlendReference UX6SequencePlayerLibrary::DeactivateStylizedBlendThisFrame(const struct FX6StylizedOverlayBlendReference& OverlayBlend, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "DeactivateStylizedBlendThisFrame");

	Params::X6SequencePlayerLibrary_DeactivateStylizedBlendThisFrame Parms{};

	Parms.OverlayBlend = std::move(OverlayBlend);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetAccumulatedTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::GetAccumulatedTime(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetAccumulatedTime");

	Params::X6SequencePlayerLibrary_GetAccumulatedTime Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetAnimTimeRemaining
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::GetAnimTimeRemaining(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetAnimTimeRemaining");

	Params::X6SequencePlayerLibrary_GetAnimTimeRemaining Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetAnimTimeRemainingFraction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::GetAnimTimeRemainingFraction(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetAnimTimeRemainingFraction");

	Params::X6SequencePlayerLibrary_GetAnimTimeRemainingFraction Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetCachedBlendWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::GetCachedBlendWeight(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetCachedBlendWeight");

	Params::X6SequencePlayerLibrary_GetCachedBlendWeight Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetIsMirroredByPoseMatch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UX6SequencePlayerLibrary::GetIsMirroredByPoseMatch(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetIsMirroredByPoseMatch");

	Params::X6SequencePlayerLibrary_GetIsMirroredByPoseMatch Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetLoopAnimation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UX6SequencePlayerLibrary::GetLoopAnimation(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetLoopAnimation");

	Params::X6SequencePlayerLibrary_GetLoopAnimation Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetPlayRate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::GetPlayRate(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetPlayRate");

	Params::X6SequencePlayerLibrary_GetPlayRate Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*&               SequenceBase                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::GetSequence(const struct FX6SequencePlayerReference& SequencePlayer, class UAnimSequenceBase*& SequenceBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetSequence");

	Params::X6SequencePlayerLibrary_GetSequence Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.SequenceBase = SequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SequenceBase = Parms.SequenceBase;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetSequencePure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UX6SequencePlayerLibrary::GetSequencePure(const struct FX6SequencePlayerReference& SequencePlayer, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetSequencePure");

	Params::X6SequencePlayerLibrary_GetSequencePure Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.GetStartPosition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UX6SequencePlayerLibrary::GetStartPosition(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "GetStartPosition");

	Params::X6SequencePlayerLibrary_GetStartPosition Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.IsEnableRootMotion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UX6SequencePlayerLibrary::IsEnableRootMotion(const struct FX6SequencePlayerReference& SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "IsEnableRootMotion");

	Params::X6SequencePlayerLibrary_IsEnableRootMotion Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.SetAccumulatedTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::SetAccumulatedTime(const struct FX6SequencePlayerReference& SequencePlayer, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetAccumulatedTime");

	Params::X6SequencePlayerLibrary_SetAccumulatedTime Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.SetDistanceToMatch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const float                             DistanceToMatch                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::SetDistanceToMatch(const struct FX6SequencePlayerReference& SequencePlayer, const float DistanceToMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetDistanceToMatch");

	Params::X6SequencePlayerLibrary_SetDistanceToMatch Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.DistanceToMatch = DistanceToMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.SetEnableRootMotion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableRootMotion                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6SequencePlayerLibrary::SetEnableRootMotion(const struct FX6SequencePlayerReference& SequencePlayer, bool bEnableRootMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetEnableRootMotion");

	Params::X6SequencePlayerLibrary_SetEnableRootMotion Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.bEnableRootMotion = bEnableRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6SequencePlayerLibrary.SetMirror
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bMirror                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UX6SequencePlayerLibrary::SetMirror(const struct FX6SequencePlayerReference& SequencePlayer, bool bMirror)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetMirror");

	Params::X6SequencePlayerLibrary_SetMirror Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.bMirror = bMirror;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function X6Animation.X6SequencePlayerLibrary.SetPlayRate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::SetPlayRate(const struct FX6SequencePlayerReference& SequencePlayer, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetPlayRate");

	Params::X6SequencePlayerLibrary_SetPlayRate Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.SetSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::SetSequence(const struct FX6SequencePlayerReference& SequencePlayer, class UAnimSequenceBase* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetSequence");

	Params::X6SequencePlayerLibrary_SetSequence Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.SetSequenceWithInertialBlending
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        UpdateContext                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::SetSequenceWithInertialBlending(const struct FAnimUpdateContext& UpdateContext, const struct FX6SequencePlayerReference& SequencePlayer, class UAnimSequenceBase* Sequence, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetSequenceWithInertialBlending");

	Params::X6SequencePlayerLibrary_SetSequenceWithInertialBlending Parms{};

	Parms.UpdateContext = std::move(UpdateContext);
	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.Sequence = Sequence;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function X6Animation.X6SequencePlayerLibrary.SetStartPosition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FX6SequencePlayerReference&SequencePlayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   StartPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FX6SequencePlayerReference       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FX6SequencePlayerReference UX6SequencePlayerLibrary::SetStartPosition(const struct FX6SequencePlayerReference& SequencePlayer, float StartPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("X6SequencePlayerLibrary", "SetStartPosition");

	Params::X6SequencePlayerLibrary_SetStartPosition Parms{};

	Parms.SequencePlayer = std::move(SequencePlayer);
	Parms.StartPosition = StartPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

