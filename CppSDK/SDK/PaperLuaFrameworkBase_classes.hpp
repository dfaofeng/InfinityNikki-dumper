#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PaperLuaFrameworkBase

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NetCore_structs.hpp"
#include "Engine_classes.hpp"
#include "PaperLuaFrameworkBase_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"


namespace SDK
{

// Class PaperLuaFrameworkBase.BinMMapMgr
// 0x0098 (0x00C0 - 0x0028)
class UBinMMapMgr final : public UObject
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBinMMapMgr* GetInstance();

	void AddBuffer(const class FString& InBinName);
	void Clear();
	void PostLoad();
	void SetMMapTag(bool InMMapTag);
	void SetRootDir(const class FString& InRootDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BinMMapMgr">();
	}
	static class UBinMMapMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBinMMapMgr>();
	}
};
static_assert(alignof(UBinMMapMgr) == 0x000008, "Wrong alignment on UBinMMapMgr");
static_assert(sizeof(UBinMMapMgr) == 0x0000C0, "Wrong size on UBinMMapMgr");

// Class PaperLuaFrameworkBase.LevelStreamingInstanceVolume
// 0x0018 (0x03F8 - 0x03E0)
class ALevelStreamingInstanceVolume final : public AVolume
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          LoadingLevelPathList;                              // 0x03E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          BoxShouldVisable;                                  // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingInstanceVolume">();
	}
	static class ALevelStreamingInstanceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelStreamingInstanceVolume>();
	}
};
static_assert(alignof(ALevelStreamingInstanceVolume) == 0x000008, "Wrong alignment on ALevelStreamingInstanceVolume");
static_assert(sizeof(ALevelStreamingInstanceVolume) == 0x0003F8, "Wrong size on ALevelStreamingInstanceVolume");
static_assert(offsetof(ALevelStreamingInstanceVolume, LoadingLevelPathList) == 0x0003E0, "Member 'ALevelStreamingInstanceVolume::LoadingLevelPathList' has a wrong offset!");
static_assert(offsetof(ALevelStreamingInstanceVolume, BoxShouldVisable) == 0x0003F0, "Member 'ALevelStreamingInstanceVolume::BoxShouldVisable' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperAssetManager
// 0x01E0 (0x06B0 - 0x04D0)
class UPaperAssetManager : public UAssetManager
{
public:
	TMulticastInlineDelegate<void(int32 AsyncId, float Progress)> OnAssetLoadProgress;               // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 AsyncId, const TArray<class UObject*>& LoadedObjects)> OnAssetLoadFinished; // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	int32                                         CurAsyncID;                                        // 0x04F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x1BC];                                    // 0x04F4(0x01BC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPaperAssetManager* GetInstance();

	bool AsyncLoadPrimaryAssetEx(const TArray<class FString>& InAssetsToLoad, float InTimeLimit);
	void CancelAsyncLoadingWithAsyncID(int32 AsyncId);
	float GetAsyncLoadingProgessWithAsyncID(int32 AsyncId);
	int32 GetCurrentAsyncID();
	class UObject* NormalizeAssetPathAndResolve(const class FString& InAssetPath);
	bool SyncLoadPrimaryAssetEx(const TArray<class FString>& InAssetsToLoad, float InTimeLimit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperAssetManager">();
	}
	static class UPaperAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperAssetManager>();
	}
};
static_assert(alignof(UPaperAssetManager) == 0x000008, "Wrong alignment on UPaperAssetManager");
static_assert(sizeof(UPaperAssetManager) == 0x0006B0, "Wrong size on UPaperAssetManager");
static_assert(offsetof(UPaperAssetManager, OnAssetLoadProgress) == 0x0004D0, "Member 'UPaperAssetManager::OnAssetLoadProgress' has a wrong offset!");
static_assert(offsetof(UPaperAssetManager, OnAssetLoadFinished) == 0x0004E0, "Member 'UPaperAssetManager::OnAssetLoadFinished' has a wrong offset!");
static_assert(offsetof(UPaperAssetManager, CurAsyncID) == 0x0004F0, "Member 'UPaperAssetManager::CurAsyncID' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperGameInstanceSubsystemBase
// 0x0010 (0x0040 - 0x0030)
class UPaperGameInstanceSubsystemBase : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperGameInstanceSubsystemBase">();
	}
	static class UPaperGameInstanceSubsystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperGameInstanceSubsystemBase>();
	}
};
static_assert(alignof(UPaperGameInstanceSubsystemBase) == 0x000008, "Wrong alignment on UPaperGameInstanceSubsystemBase");
static_assert(sizeof(UPaperGameInstanceSubsystemBase) == 0x000040, "Wrong size on UPaperGameInstanceSubsystemBase");

// Class PaperLuaFrameworkBase.PaperAssetSubsystem
// 0x0008 (0x0048 - 0x0040)
class UPaperAssetSubsystem final : public UPaperGameInstanceSubsystemBase
{
public:
	class UPaperAssetManager*                     PaperAssetManager;                                 // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperAssetSubsystem">();
	}
	static class UPaperAssetSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperAssetSubsystem>();
	}
};
static_assert(alignof(UPaperAssetSubsystem) == 0x000008, "Wrong alignment on UPaperAssetSubsystem");
static_assert(sizeof(UPaperAssetSubsystem) == 0x000048, "Wrong size on UPaperAssetSubsystem");
static_assert(offsetof(UPaperAssetSubsystem, PaperAssetManager) == 0x000040, "Member 'UPaperAssetSubsystem::PaperAssetManager' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperConsoleManager
// 0x0050 (0x0078 - 0x0028)
class UPaperConsoleManager final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearLuaCommand();
	void RegisterLuaCommand(const class FString& Cmd, const class FString& Help);
	void UnregisterLuaCommand(const class FString& Cmd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperConsoleManager">();
	}
	static class UPaperConsoleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperConsoleManager>();
	}
};
static_assert(alignof(UPaperConsoleManager) == 0x000008, "Wrong alignment on UPaperConsoleManager");
static_assert(sizeof(UPaperConsoleManager) == 0x000078, "Wrong size on UPaperConsoleManager");

// Class PaperLuaFrameworkBase.PaperInputProcessorHelper
// 0x0010 (0x0038 - 0x0028)
class UPaperInputProcessorHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindAnalogInputEvent(TDelegate<void(const struct FAnalogInputEvent& AnalogInputEvent)> InOnAnalogInput, int32 InPriority);
	void BindGestureEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnGesture, int32 InPriority);
	void BindInputDeviceEvent(TDelegate<void(EPaperInputDeviceKeyType InputDeviceKeyType)> InOnInputDevice);
	void BindKeyDownEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyDown, int32 InPriority);
	void BindKeyUpEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyUp, int32 InPriority);
	void BindMotionDetectedEvent(TDelegate<void(const struct FMotionEvent& MotionEvent)> InOnMotionDetected, int32 InPriority);
	void BindMouseButtonDoubleClickEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDoubleClick, int32 InPriority);
	void BindMouseButtonDownEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDown, int32 InPriority);
	void BindMouseButtonUpEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonUp, int32 InPriority);
	void BindMouseMoveEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseMove, int32 InPriority);
	void BindMouseWheelEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseWheel, int32 InPriority);
	void DeInit();
	EPaperInputDeviceKeyType GetCurInputDeviceKeyType();
	bool GetMouseResponseDisabled();
	void Init();
	void SetInputDeviceIgnoreValue(float InInputDeviceIgnoreValue);
	bool SetMouseResponseDisabled(bool bDisable);
	void UnbindAnalogInputEvent(TDelegate<void(const struct FAnalogInputEvent& AnalogInputEvent)> InOnAnalogInput, int32 InPriority);
	void UnbindGestureEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnGesture, int32 InPriority);
	void UnbindInputDeviceEvent(TDelegate<void(EPaperInputDeviceKeyType InputDeviceKeyType)> InOnInputDevice);
	void UnbindKeyDownEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyDown, int32 InPriority);
	void UnbindKeyUpEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyUp, int32 InPriority);
	void UnbindMotionDetectedEvent(TDelegate<void(const struct FMotionEvent& MotionEvent)> InOnMotionDetected, int32 InPriority);
	void UnbindMouseButtonDoubleClickEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDoubleClick, int32 InPriority);
	void UnbindMouseButtonDownEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDown, int32 InPriority);
	void UnbindMouseButtonUpEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonUp, int32 InPriority);
	void UnbindMouseMoveEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseMove, int32 InPriority);
	void UnbindMouseWheelEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseWheel, int32 InPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperInputProcessorHelper">();
	}
	static class UPaperInputProcessorHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperInputProcessorHelper>();
	}
};
static_assert(alignof(UPaperInputProcessorHelper) == 0x000008, "Wrong alignment on UPaperInputProcessorHelper");
static_assert(sizeof(UPaperInputProcessorHelper) == 0x000038, "Wrong size on UPaperInputProcessorHelper");

// Class PaperLuaFrameworkBase.PaperLevelMgr
// 0x01C0 (0x0200 - 0x0040)
class UPaperLevelMgr final : public UPaperGameInstanceSubsystemBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& LevelPath)> OnLevelStreamingBegin;            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& LevelPath, float Progress)> OnLevelStreamingProgress; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& LevelPath, bool Result)> OnLevelStreamingFinished; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x188];                                     // 0x0078(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllPersistentLevels();
	void ClearPersistentLevel(const class FString& LevelPath);
	bool DungeonTeleportPlayer(const struct FVector& TargetLocation);
	class FString GetCurrentWorldPath();
	class ULevelStreaming* GetLevelStreaming(const class FString& LevelPath);
	bool LoadLevelToWorld(const class FString& LevelPath, const struct FVector& LoadLocation, const struct FVector& PlayerPosition, bool WithoutProgress);
	bool LoadSubLevelToWorld(const class FString& SubLevelPath, const struct FVector& LoadLocation);
	bool OpenNewWorld(const class FString& WorldPath, const struct FVector& PlayerPosition, const class FString& Option);
	bool ReturnToWorld(const struct FVector& LoadLocation);
	void SetPersistentLevel(const class FString& LevelPath);
	bool TeleportPlayer(const struct FVector& TargetLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperLevelMgr">();
	}
	static class UPaperLevelMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperLevelMgr>();
	}
};
static_assert(alignof(UPaperLevelMgr) == 0x000008, "Wrong alignment on UPaperLevelMgr");
static_assert(sizeof(UPaperLevelMgr) == 0x000200, "Wrong size on UPaperLevelMgr");
static_assert(offsetof(UPaperLevelMgr, OnLevelStreamingBegin) == 0x000048, "Member 'UPaperLevelMgr::OnLevelStreamingBegin' has a wrong offset!");
static_assert(offsetof(UPaperLevelMgr, OnLevelStreamingProgress) == 0x000058, "Member 'UPaperLevelMgr::OnLevelStreamingProgress' has a wrong offset!");
static_assert(offsetof(UPaperLevelMgr, OnLevelStreamingFinished) == 0x000068, "Member 'UPaperLevelMgr::OnLevelStreamingFinished' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperLuaBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPaperLuaBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* DeserializeComponent(class AActor* Owner, const class FString& ComponentName, const TMap<class FString, class FString>& Properties, bool bIsCustomImportText);
	static class UObject* DeserializeLocalProperty(class AActor* Owner, const class FString& ComponentName, const TMap<class FString, class FString>& Properties, bool bIsCustomImportText);
	static void FinishSpawning(class AActor* Actor, const struct FTransform& Transform, bool bIsDefaultTransform);
	static class FString GetActorNameWithMap(class AActor* Actor);
	static bool GetBoolFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static void GetCurrentPerformanceData(TMap<class FString, float>* PerfData);
	static int64 GetCurrentTotalMillisecond();
	static class FString GetDefaultDeviceProfileName();
	static int64 GetFrameCostMicroSeconds();
	static int64 GetFrameCount();
	static int32 GetIntFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static class FString GetLevelPackageName(class ULevel* InLevel);
	static class FString GetMapCleanName(const class FString& StrMapName);
	static int32 GetNumTasksPrecompiled();
	static TArray<class FString> GetStringArrayFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static class FString GetStringFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static int32 GetTotalNumTasks();
	static bool HasActorBegunPlay(class AActor* Actor);
	static bool IsLuaCallErrorNotifyEnable();
	static bool IsPSOPrecompiling();
	static bool IsWithEditor();
	static void ManualShowWindowsVirtualKeyboard(bool bShow);
	static class FString NormalizeConfigIniPath(const class FString& Path);
	static int32 NumPSOPrecompilesRemaining();
	static void SetActorPreferEnlightenThanLightmass(class AActor* Actor, bool bInPreferEnlightenThanLightmass);
	static void SetBoolToConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool Value, bool bFlush);
	static void SetIntToConfig(const class FString& Session, const class FString& Key, const class FString& Path, int32 Value, bool bFlush);
	static void SetLuaCallErrorNotify(bool bEnable);
	static void SetMobileGameState(bool bLoading, int32 InMode);
	static void SetStringToConfig(const class FString& Session, const class FString& Key, const class FString& Path, const class FString& Value, bool bFlush);
	static void SimulateMouseClick();
	static class AActor* SpawnActor(class UObject* WorldContextObject, class UClass* SpawnClass, const struct FVector& Postion, const struct FRotator& Rotation, const struct FVector& Scale, const class FString& Name_0, bool bAddToDefaultSoloLevel, bool bDeferConstruction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperLuaBlueprintLibrary">();
	}
	static class UPaperLuaBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperLuaBlueprintLibrary>();
	}
};
static_assert(alignof(UPaperLuaBlueprintLibrary) == 0x000008, "Wrong alignment on UPaperLuaBlueprintLibrary");
static_assert(sizeof(UPaperLuaBlueprintLibrary) == 0x000028, "Wrong size on UPaperLuaBlueprintLibrary");

// Class PaperLuaFrameworkBase.PaperFrameworkSettings
// 0x0020 (0x0058 - 0x0038)
class UPaperFrameworkSettings final : public UDeveloperSettings
{
public:
	struct FSoftClassPath                         PaperLuaSubSystemClassName;                        // 0x0038(0x0020)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperFrameworkSettings">();
	}
	static class UPaperFrameworkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperFrameworkSettings>();
	}
};
static_assert(alignof(UPaperFrameworkSettings) == 0x000008, "Wrong alignment on UPaperFrameworkSettings");
static_assert(sizeof(UPaperFrameworkSettings) == 0x000058, "Wrong size on UPaperFrameworkSettings");
static_assert(offsetof(UPaperFrameworkSettings, PaperLuaSubSystemClassName) == 0x000038, "Member 'UPaperFrameworkSettings::PaperLuaSubSystemClassName' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperLuaInsightMgr
// 0x0028 (0x0050 - 0x0028)
class UPaperLuaInsightMgr final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperLuaInsightMgr">();
	}
	static class UPaperLuaInsightMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperLuaInsightMgr>();
	}
};
static_assert(alignof(UPaperLuaInsightMgr) == 0x000008, "Wrong alignment on UPaperLuaInsightMgr");
static_assert(sizeof(UPaperLuaInsightMgr) == 0x000050, "Wrong size on UPaperLuaInsightMgr");

// Class PaperLuaFrameworkBase.PaperLuaSubsystem
// 0x0088 (0x00C8 - 0x0040)
class UPaperLuaSubsystem final : public UPaperGameInstanceSubsystemBase
{
public:
	uint8                                         Pad_40[0x88];                                      // 0x0040(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperLuaSubsystem">();
	}
	static class UPaperLuaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperLuaSubsystem>();
	}
};
static_assert(alignof(UPaperLuaSubsystem) == 0x000008, "Wrong alignment on UPaperLuaSubsystem");
static_assert(sizeof(UPaperLuaSubsystem) == 0x0000C8, "Wrong size on UPaperLuaSubsystem");

// Class PaperLuaFrameworkBase.PaperNetSystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPaperNetSystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsMultiPlayerMode(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperNetSystemBlueprintLibrary">();
	}
	static class UPaperNetSystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperNetSystemBlueprintLibrary>();
	}
};
static_assert(alignof(UPaperNetSystemBlueprintLibrary) == 0x000008, "Wrong alignment on UPaperNetSystemBlueprintLibrary");
static_assert(sizeof(UPaperNetSystemBlueprintLibrary) == 0x000028, "Wrong size on UPaperNetSystemBlueprintLibrary");

// Class PaperLuaFrameworkBase.PaperNetworkDataCollector
// 0x0068 (0x0090 - 0x0028)
class UPaperNetworkDataCollector final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPaperNetworkDataCollector* GetInstance();

	TMap<class FString, struct FNetworkCollectedData> GetCollectedDataMap();
	void Reset();
	void SetEnabled(bool bEnable);
	void WriteToFile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperNetworkDataCollector">();
	}
	static class UPaperNetworkDataCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperNetworkDataCollector>();
	}
};
static_assert(alignof(UPaperNetworkDataCollector) == 0x000008, "Wrong alignment on UPaperNetworkDataCollector");
static_assert(sizeof(UPaperNetworkDataCollector) == 0x000090, "Wrong size on UPaperNetworkDataCollector");

// Class PaperLuaFrameworkBase.PaperNetworkMgr
// 0x0070 (0x0098 - 0x0028)
class UPaperNetworkMgr final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(bool bSuccess, int32 ResponseCode)> InternalOnHttpRequestContentCompleted;        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Connect(const class FString& ipAddress, int32 Port);
	bool CreateNetCrypter();
	bool DestroyNetCrypter();
	void DisConnect();
	double GetNetLatency();
	bool HandleCryptAck(int32 PubKeyLen);
	void HttpGetWithAuthUser(const class FString& URL, const class FString& szAuth, const class FString& szUserName, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpPostEx(const class FString& szURL, const TMap<class FString, class FString>& mapHeader, const class FString& szCont, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpPostFileEx(const class FString& szURL, const TMap<class FString, class FString>& mapHeader, const class FString& szFilePath, const TMap<class FString, class FString>& mapPara, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpPostFileExNew(const class FString& szURL, const TMap<class FString, class FString>& mapHeader, const class FString& szFilePath, const TMap<class FString, class FString>& mapPara, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpPostFileWithAuthUser(const class FString& szURL, const class FString& szAuth, const class FString& szUserName, const class FString& szFilePath, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpPostWithAuthUser(const class FString& szURL, const class FString& szAuth, const class FString& szUserName, const class FString& szContType, const class FString& szCont, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpRequest(const class FString& URL, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);
	void HttpRequestContent(const class FString& URL, TDelegate<void(bool bSuccess, int32 ResponseCode)> OnHttpRequestContentCompleted, TArray<uint8>* ResponseContent);
	void HttpRequestContent2(const class FString& URL, TDelegate<void(bool bSuccess, int32 ResponseCode, const TArray<uint8>& ResponseContent)> onHttpRequestCompleted);
	bool InitAndGenNetCrypt();
	bool InitCrypt(const int32 g_len, const int32 p_len, const int32 pub_key_len);
	bool IsConnected();
	bool IsConnecting();
	bool IsNetCrypterExists();
	bool IsUnLuaAsyncTime();
	void NetTraceReadDataProto();
	void NetTraceSendDataProto();
	int32 ReadDataToByteBuf();
	void SendDataFromByteBuf();
	void SendDataFromByteBufSync();
	void SetAesCryptMode(int32 InMode);
	void SetConnectTimeout(float Timeout, bool autoDisconnect);
	void SetHandlerMode(EPaperNetworkHandler Mode);
	void SetHeartbeatInterval(float Interval);
	void SetNetProtoId(int32 ProtoId);
	void StartHeartbeatDataFromByteBuf();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperNetworkMgr">();
	}
	static class UPaperNetworkMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperNetworkMgr>();
	}
};
static_assert(alignof(UPaperNetworkMgr) == 0x000008, "Wrong alignment on UPaperNetworkMgr");
static_assert(sizeof(UPaperNetworkMgr) == 0x000098, "Wrong size on UPaperNetworkMgr");
static_assert(offsetof(UPaperNetworkMgr, InternalOnHttpRequestContentCompleted) == 0x000040, "Member 'UPaperNetworkMgr::InternalOnHttpRequestContentCompleted' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperNetworkSubsystem
// 0x0010 (0x0050 - 0x0040)
class UPaperNetworkSubsystem final : public UPaperGameInstanceSubsystemBase
{
public:
	class UPaperNetworkMgr*                       PaperNetworkMgr;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPaperNetworkMgr* GetPaperNetworkMgr() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperNetworkSubsystem">();
	}
	static class UPaperNetworkSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperNetworkSubsystem>();
	}
};
static_assert(alignof(UPaperNetworkSubsystem) == 0x000008, "Wrong alignment on UPaperNetworkSubsystem");
static_assert(sizeof(UPaperNetworkSubsystem) == 0x000050, "Wrong size on UPaperNetworkSubsystem");
static_assert(offsetof(UPaperNetworkSubsystem, PaperNetworkMgr) == 0x000040, "Member 'UPaperNetworkSubsystem::PaperNetworkMgr' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperPlatformGameInstance
// 0x02C8 (0x0558 - 0x0290)
class UPaperPlatformGameInstance : public UPlatformGameInstance
{
public:
	uint8                                         Pad_290[0x2B8];                                    // 0x0290(0x02B8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstanceId;                                        // 0x0548(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0xC];                                      // 0x054C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GC(bool bForceLua);
	void Lua(const class FString& LuaString);
	void Restart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPlatformGameInstance">();
	}
	static class UPaperPlatformGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPlatformGameInstance>();
	}
};
static_assert(alignof(UPaperPlatformGameInstance) == 0x000008, "Wrong alignment on UPaperPlatformGameInstance");
static_assert(sizeof(UPaperPlatformGameInstance) == 0x000558, "Wrong size on UPaperPlatformGameInstance");
static_assert(offsetof(UPaperPlatformGameInstance, InstanceId) == 0x000548, "Member 'UPaperPlatformGameInstance::InstanceId' has a wrong offset!");

// Class PaperLuaFrameworkBase.PaperPlayerPrefsMgr
// 0x0010 (0x0038 - 0x0028)
class UPaperPlayerPrefsMgr final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPaperPlayerPrefsMgr* GetInstance();

	void EmptyPaperProfileSection();
	bool GetBool(const class FString& Key, bool* Value);
	bool GetFloat(const class FString& Key, float* Value);
	bool GetInt(const class FString& Key, int32* Value);
	class FString GetStr(const class FString& Key);
	bool GetString(const class FString& Key, class FString* Value);
	void Init();
	void SetBool(const class FString& Key, bool Value);
	void SetFloat(const class FString& Key, float Value);
	void SetInt(const class FString& Key, int32 Value);
	void SetString(const class FString& Key, const class FString& Value);
	void Shutdown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaperPlayerPrefsMgr">();
	}
	static class UPaperPlayerPrefsMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaperPlayerPrefsMgr>();
	}
};
static_assert(alignof(UPaperPlayerPrefsMgr) == 0x000008, "Wrong alignment on UPaperPlayerPrefsMgr");
static_assert(sizeof(UPaperPlayerPrefsMgr) == 0x000038, "Wrong size on UPaperPlayerPrefsMgr");

// Class PaperLuaFrameworkBase.X6IpNetDriver
// 0x0068 (0x09E0 - 0x0978)
class UX6IpNetDriver final : public UIpNetDriver
{
public:
	uint8                                         Pad_978[0x58];                                     // 0x0978(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DefaultChannelReplicationPaused;                   // 0x09D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D1[0xF];                                      // 0x09D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6IpNetDriver">();
	}
	static class UX6IpNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6IpNetDriver>();
	}
};
static_assert(alignof(UX6IpNetDriver) == 0x000008, "Wrong alignment on UX6IpNetDriver");
static_assert(sizeof(UX6IpNetDriver) == 0x0009E0, "Wrong size on UX6IpNetDriver");
static_assert(offsetof(UX6IpNetDriver, DefaultChannelReplicationPaused) == 0x0009D0, "Member 'UX6IpNetDriver::DefaultChannelReplicationPaused' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6IpNetDriverV2
// 0x0038 (0x09B0 - 0x0978)
class UX6IpNetDriverV2 final : public UIpNetDriver
{
public:
	uint8                                         Pad_978[0x8];                                      // 0x0978(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EX6ConnectionCharacteristic                   ConnectionCharacteristic;                          // 0x0980(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CreateBufferConnection;                            // 0x0981(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_982[0x6];                                      // 0x0982(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        RPCProcessFrequency;                               // 0x0988(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_990[0x8];                                      // 0x0990(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6NetConnectionV2*                     BufferConnection;                                  // 0x0998(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6NetConnectionV2*                     RecvBufferConnection;                              // 0x09A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A8[0x8];                                      // 0x09A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleForceReplicate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6IpNetDriverV2">();
	}
	static class UX6IpNetDriverV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6IpNetDriverV2>();
	}
};
static_assert(alignof(UX6IpNetDriverV2) == 0x000008, "Wrong alignment on UX6IpNetDriverV2");
static_assert(sizeof(UX6IpNetDriverV2) == 0x0009B0, "Wrong size on UX6IpNetDriverV2");
static_assert(offsetof(UX6IpNetDriverV2, ConnectionCharacteristic) == 0x000980, "Member 'UX6IpNetDriverV2::ConnectionCharacteristic' has a wrong offset!");
static_assert(offsetof(UX6IpNetDriverV2, CreateBufferConnection) == 0x000981, "Member 'UX6IpNetDriverV2::CreateBufferConnection' has a wrong offset!");
static_assert(offsetof(UX6IpNetDriverV2, RPCProcessFrequency) == 0x000988, "Member 'UX6IpNetDriverV2::RPCProcessFrequency' has a wrong offset!");
static_assert(offsetof(UX6IpNetDriverV2, BufferConnection) == 0x000998, "Member 'UX6IpNetDriverV2::BufferConnection' has a wrong offset!");
static_assert(offsetof(UX6IpNetDriverV2, RecvBufferConnection) == 0x0009A0, "Member 'UX6IpNetDriverV2::RecvBufferConnection' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6NetClient
// 0x02C8 (0x02F8 - 0x0030)
class UX6NetClient final : public UGameInstanceSubsystem
{
public:
	TDelegate<void(int64 NetID, ENetCloseResult CloseResult)> OnConnectionClose;                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x2B8];                                     // 0x0040(0x02B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayer(int64 NetID);
	void BindSimulatedActor(const int64& NetClientID, const int64& NetEntityID);
	void Debug_SetChannelReplicationPaused(class AActor* TargetActor, bool bPause);
	void Debug_SetConnectionLight(bool bLight);
	void DebugConnectionLog_Lua(bool bDebug);
	int32 GetMultiPlayerMode();
	int64 GetSeverTime();
	bool IsMultiPlayerMode();
	void OnConnected();
	void OnDisconnected();
	void OnWorldBeginPlay();
	void RegisterActorNetGUID_Lua(int64 NetID, class AActor* Actor);
	void RemovePlayer(int64 NetID);
	void SetChannelReplicationPaused(const int64& NetClientID, const int64& NetEntityID, bool bPause);
	void SetConnectionLight(const int64& NetClientID, const bool bLight);
	void SetConnectionPriority(const int64& NetClientID, int32 NewReplicatePriority);
	void SetLocalNetID(int64 NetID);
	void SetMultiPlayerMode(int32 Mode);
	void SetNetProtoId(int32 SendProtoId, int32 RecvProtoId);
	void SetSeverTime(int64 Time);
	void UnbindSimulatedActor(const int64& NetClientID);
	void UnregisterNetGUID_Lua(int64 NetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NetClient">();
	}
	static class UX6NetClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NetClient>();
	}
};
static_assert(alignof(UX6NetClient) == 0x000008, "Wrong alignment on UX6NetClient");
static_assert(sizeof(UX6NetClient) == 0x0002F8, "Wrong size on UX6NetClient");
static_assert(offsetof(UX6NetClient, OnConnectionClose) == 0x000030, "Member 'UX6NetClient::OnConnectionClose' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6NetClientV2
// 0x0310 (0x0340 - 0x0030)
class UX6NetClientV2 final : public UGameInstanceSubsystem
{
public:
	TDelegate<void(int64 NetID, ENetCloseResult CloseResult)> OnConnectionClose;                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x300];                                     // 0x0040(0x0300)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayer(int64 NetID, int64 EntityID);
	void BindSimulatedActor(const int64& NetClientID, const int64& NetEntityID);
	void DebugConnectionLog_Lua(bool bDebug);
	void DeInitConnection();
	int32 GetMultiPlayerMode();
	int64 GetSeverTime();
	void InitConnection();
	bool IsMultiPlayerMode();
	void OnConnected();
	void OnDisconnected();
	void OnWorldBeginPlay();
	void RegisterActorNetGUID_Lua(int64 NetID, class AActor* Actor);
	void RemovePlayer(int64 NetID);
	void SetLocalNetID(int64 NetID);
	void SetMultiPlayerMode(int32 Mode);
	void SetNetProtoId(int32 SendProtoId, int32 RecvProtoId);
	void SetPlayerCustomReplicate(const int64& playerId, const bool bCustomReplicate);
	void SetPlayerForceReplicate(const int64& playerId);
	void SetPlayerLightweight(const int64& playerId, const bool bLightweight);
	void SetSeverTime(int64 Time);
	void UnbindSimulatedActor(const int64& NetClientID);
	void UnregisterNetGUID_Lua(int64 NetID);
	bool UploadNetLog(const bool& InternalEnv, const class FString& SessionId, const class FString& LogFilePath, TDelegate<void(bool bSuccess, int32 ResponseCode, const class FString& ResponseString)> onHttpRequestCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NetClientV2">();
	}
	static class UX6NetClientV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NetClientV2>();
	}
};
static_assert(alignof(UX6NetClientV2) == 0x000008, "Wrong alignment on UX6NetClientV2");
static_assert(sizeof(UX6NetClientV2) == 0x000340, "Wrong size on UX6NetClientV2");
static_assert(offsetof(UX6NetClientV2, OnConnectionClose) == 0x000030, "Member 'UX6NetClientV2::OnConnectionClose' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6NetConnection
// 0x00D8 (0x1F78 - 0x1EA0)
class UX6NetConnection final : public UIpConnection
{
public:
	TMap<float, double>                           FrequencyMap;                                      // 0x1EA0(0x0050)(Config, NativeAccessSpecifierPublic)
	TArray<float>                                 PriorityMap;                                       // 0x1EF0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          OpenCongestionSchedule;                            // 0x1F00(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F01[0x77];                                    // 0x1F01(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NetConnection">();
	}
	static class UX6NetConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NetConnection>();
	}
};
static_assert(alignof(UX6NetConnection) == 0x000008, "Wrong alignment on UX6NetConnection");
static_assert(sizeof(UX6NetConnection) == 0x001F78, "Wrong size on UX6NetConnection");
static_assert(offsetof(UX6NetConnection, FrequencyMap) == 0x001EA0, "Member 'UX6NetConnection::FrequencyMap' has a wrong offset!");
static_assert(offsetof(UX6NetConnection, PriorityMap) == 0x001EF0, "Member 'UX6NetConnection::PriorityMap' has a wrong offset!");
static_assert(offsetof(UX6NetConnection, OpenCongestionSchedule) == 0x001F00, "Member 'UX6NetConnection::OpenCongestionSchedule' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6NetConnectionV2
// 0x0110 (0x1FB0 - 0x1EA0)
class UX6NetConnectionV2 final : public UIpConnection
{
public:
	TMap<double, double>                          FrequencyMap;                                      // 0x1EA0(0x0050)(Config, NativeAccessSpecifierPublic)
	bool                                          OpenCongestionSchedule;                            // 0x1EF0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF1[0xBF];                                    // 0x1EF1(0x00BF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NetConnectionV2">();
	}
	static class UX6NetConnectionV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NetConnectionV2>();
	}
};
static_assert(alignof(UX6NetConnectionV2) == 0x000008, "Wrong alignment on UX6NetConnectionV2");
static_assert(sizeof(UX6NetConnectionV2) == 0x001FB0, "Wrong size on UX6NetConnectionV2");
static_assert(offsetof(UX6NetConnectionV2, FrequencyMap) == 0x001EA0, "Member 'UX6NetConnectionV2::FrequencyMap' has a wrong offset!");
static_assert(offsetof(UX6NetConnectionV2, OpenCongestionSchedule) == 0x001EF0, "Member 'UX6NetConnectionV2::OpenCongestionSchedule' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6NetLogSettings
// 0x0030 (0x0058 - 0x0028)
class UX6NetLogSettings final : public UObject
{
public:
	class FString                                 Token;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InternalUploadUrl;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OSSUploadUrl;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static const class UX6NetLogSettings* GetX6NetLogSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NetLogSettings">();
	}
	static class UX6NetLogSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NetLogSettings>();
	}
};
static_assert(alignof(UX6NetLogSettings) == 0x000008, "Wrong alignment on UX6NetLogSettings");
static_assert(sizeof(UX6NetLogSettings) == 0x000058, "Wrong size on UX6NetLogSettings");
static_assert(offsetof(UX6NetLogSettings, Token) == 0x000028, "Member 'UX6NetLogSettings::Token' has a wrong offset!");
static_assert(offsetof(UX6NetLogSettings, InternalUploadUrl) == 0x000038, "Member 'UX6NetLogSettings::InternalUploadUrl' has a wrong offset!");
static_assert(offsetof(UX6NetLogSettings, OSSUploadUrl) == 0x000048, "Member 'UX6NetLogSettings::OSSUploadUrl' has a wrong offset!");

// Class PaperLuaFrameworkBase.X6ReplicateInterface
// 0x0000 (0x0000 - 0x0000)
class IX6ReplicateInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ReplicateInterface">();
	}
	static class IX6ReplicateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6ReplicateInterface>();
	}
};
static_assert(alignof(IX6ReplicateInterface) == 0x000001, "Wrong alignment on IX6ReplicateInterface");
static_assert(sizeof(IX6ReplicateInterface) == 0x000001, "Wrong size on IX6ReplicateInterface");

}

