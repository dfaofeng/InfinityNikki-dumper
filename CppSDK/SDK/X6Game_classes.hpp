#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: X6Game

#include "Basic.hpp"

#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "TargetingSystem_structs.hpp"
#include "TargetingSystem_classes.hpp"
#include "X6Game_structs.hpp"
#include "X6Camera_structs.hpp"
#include "X6Camera_classes.hpp"
#include "X6Animation_structs.hpp"
#include "X6Animation_classes.hpp"
#include "SlateCore_structs.hpp"
#include "MotionWarping_structs.hpp"
#include "MotionWarping_classes.hpp"
#include "NikkiPhysics_structs.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "InputCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "PaperPathFinding_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PaperLuaFrameworkBase_classes.hpp"
#include "MovieScene_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "X6ExportRuntime_structs.hpp"
#include "UIPF_structs.hpp"
#include "StructUtils_structs.hpp"
#include "PaperLuaFrameworkApp_classes.hpp"
#include "CinematicCamera_classes.hpp"
#include "GameFeatures_classes.hpp"


namespace SDK
{

// Class X6Game.ActorEventListener
// 0x0050 (0x0078 - 0x0028)
class UActorEventListener final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPooledActorDestroyed(class AActor* InActorAboutToDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorEventListener">();
	}
	static class UActorEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorEventListener>();
	}
};
static_assert(alignof(UActorEventListener) == 0x000008, "Wrong alignment on UActorEventListener");
static_assert(sizeof(UActorEventListener) == 0x000078, "Wrong size on UActorEventListener");

// Class X6Game.AsyncQueryPositionTask
// 0x0010 (0x0038 - 0x0028)
class UAsyncQueryPositionTask final : public UObject
{
public:
	TDelegate<void(const struct FVector& Position, const struct FVector& RelativePosition)> ReceiveFlyingFollowPosition; // 0x0028(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool QueryFlyingFollowPosition(class AActor* GoalActor, class AActor* FollowingActor, const struct FQueryFlyingFollowPositionArgs& Args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncQueryPositionTask">();
	}
	static class UAsyncQueryPositionTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncQueryPositionTask>();
	}
};
static_assert(alignof(UAsyncQueryPositionTask) == 0x000008, "Wrong alignment on UAsyncQueryPositionTask");
static_assert(sizeof(UAsyncQueryPositionTask) == 0x000038, "Wrong size on UAsyncQueryPositionTask");
static_assert(offsetof(UAsyncQueryPositionTask, ReceiveFlyingFollowPosition) == 0x000028, "Member 'UAsyncQueryPositionTask::ReceiveFlyingFollowPosition' has a wrong offset!");

// Class X6Game.AISenseEvent_Blueprint
// 0x0008 (0x0030 - 0x0028)
class UAISenseEvent_Blueprint final : public UAISenseEvent
{
public:
	TSubclassOf<class UAISense>                   RouteSense;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Blueprint">();
	}
	static class UAISenseEvent_Blueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Blueprint>();
	}
};
static_assert(alignof(UAISenseEvent_Blueprint) == 0x000008, "Wrong alignment on UAISenseEvent_Blueprint");
static_assert(sizeof(UAISenseEvent_Blueprint) == 0x000030, "Wrong size on UAISenseEvent_Blueprint");
static_assert(offsetof(UAISenseEvent_Blueprint, RouteSense) == 0x000028, "Member 'UAISenseEvent_Blueprint::RouteSense' has a wrong offset!");

// Class X6Game.AnimNotifyState_AdjustmentBlendWarp
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_AdjustmentBlendWarp final : public UAnimNotifyState
{
public:
	class UMotionModifier_AdjustmentBlendWarp*    RootMotionModifier;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AdjustmentBlendWarp">();
	}
	static class UAnimNotifyState_AdjustmentBlendWarp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AdjustmentBlendWarp>();
	}
};
static_assert(alignof(UAnimNotifyState_AdjustmentBlendWarp) == 0x000008, "Wrong alignment on UAnimNotifyState_AdjustmentBlendWarp");
static_assert(sizeof(UAnimNotifyState_AdjustmentBlendWarp) == 0x000038, "Wrong size on UAnimNotifyState_AdjustmentBlendWarp");
static_assert(offsetof(UAnimNotifyState_AdjustmentBlendWarp, RootMotionModifier) == 0x000030, "Member 'UAnimNotifyState_AdjustmentBlendWarp::RootMotionModifier' has a wrong offset!");

// Class X6Game.AnimNotifyState_NoTransToMove
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_NoTransToMove final : public UAnimNotifyState
{
public:
	class FName                                   AnimInstanceTag;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_NoTransToMove">();
	}
	static class UAnimNotifyState_NoTransToMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_NoTransToMove>();
	}
};
static_assert(alignof(UAnimNotifyState_NoTransToMove) == 0x000008, "Wrong alignment on UAnimNotifyState_NoTransToMove");
static_assert(sizeof(UAnimNotifyState_NoTransToMove) == 0x000038, "Wrong size on UAnimNotifyState_NoTransToMove");
static_assert(offsetof(UAnimNotifyState_NoTransToMove, AnimInstanceTag) == 0x000030, "Member 'UAnimNotifyState_NoTransToMove::AnimInstanceTag' has a wrong offset!");

// Class X6Game.AnimNotifyState_SetActorEffect
// 0x0028 (0x0058 - 0x0030)
class UAnimNotifyState_SetActorEffect final : public UAnimNotifyState
{
public:
	class FName                                   ParamName;                                         // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ParamCurve;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SetActorEffect">();
	}
	static class UAnimNotifyState_SetActorEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SetActorEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_SetActorEffect) == 0x000008, "Wrong alignment on UAnimNotifyState_SetActorEffect");
static_assert(sizeof(UAnimNotifyState_SetActorEffect) == 0x000058, "Wrong size on UAnimNotifyState_SetActorEffect");
static_assert(offsetof(UAnimNotifyState_SetActorEffect, ParamName) == 0x000030, "Member 'UAnimNotifyState_SetActorEffect::ParamName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SetActorEffect, ParamCurve) == 0x000038, "Member 'UAnimNotifyState_SetActorEffect::ParamCurve' has a wrong offset!");

// Class X6Game.AnimNotifyState_SetCustomDissolve
// 0x0028 (0x0058 - 0x0030)
class UAnimNotifyState_SetCustomDissolve final : public UAnimNotifyState
{
public:
	class UCurveFloat*                            ParamCurve;                                        // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SetCustomDissolve">();
	}
	static class UAnimNotifyState_SetCustomDissolve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SetCustomDissolve>();
	}
};
static_assert(alignof(UAnimNotifyState_SetCustomDissolve) == 0x000008, "Wrong alignment on UAnimNotifyState_SetCustomDissolve");
static_assert(sizeof(UAnimNotifyState_SetCustomDissolve) == 0x000058, "Wrong size on UAnimNotifyState_SetCustomDissolve");
static_assert(offsetof(UAnimNotifyState_SetCustomDissolve, ParamCurve) == 0x000030, "Member 'UAnimNotifyState_SetCustomDissolve::ParamCurve' has a wrong offset!");

// Class X6Game.AnimNotifyState_SkillHitFrame
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_SkillHitFrame final : public UAnimNotifyState
{
public:
	TArray<class UX6AbilityModifierBase*>         Modifies;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SkillHitFrame">();
	}
	static class UAnimNotifyState_SkillHitFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SkillHitFrame>();
	}
};
static_assert(alignof(UAnimNotifyState_SkillHitFrame) == 0x000008, "Wrong alignment on UAnimNotifyState_SkillHitFrame");
static_assert(sizeof(UAnimNotifyState_SkillHitFrame) == 0x000040, "Wrong size on UAnimNotifyState_SkillHitFrame");
static_assert(offsetof(UAnimNotifyState_SkillHitFrame, Modifies) == 0x000030, "Member 'UAnimNotifyState_SkillHitFrame::Modifies' has a wrong offset!");

// Class X6Game.AnimNotify_PlayFootstepEffect
// 0x0078 (0x00B0 - 0x0038)
class UAnimNotify_PlayFootstepEffect final : public UAnimNotify
{
public:
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultMirrorConfig;                           // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRowName(const class FName& NewRowName) const;
	void SetSocketName(const class FName& NewSocketName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayFootstepEffect">();
	}
	static class UAnimNotify_PlayFootstepEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayFootstepEffect>();
	}
};
static_assert(alignof(UAnimNotify_PlayFootstepEffect) == 0x000008, "Wrong alignment on UAnimNotify_PlayFootstepEffect");
static_assert(sizeof(UAnimNotify_PlayFootstepEffect) == 0x0000B0, "Wrong size on UAnimNotify_PlayFootstepEffect");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, SocketName) == 0x000038, "Member 'UAnimNotify_PlayFootstepEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, LocationOffset) == 0x000040, "Member 'UAnimNotify_PlayFootstepEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, RotationOffset) == 0x000058, "Member 'UAnimNotify_PlayFootstepEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, Scale) == 0x000070, "Member 'UAnimNotify_PlayFootstepEffect::Scale' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, RowName) == 0x000088, "Member 'UAnimNotify_PlayFootstepEffect::RowName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, bAttached) == 0x000090, "Member 'UAnimNotify_PlayFootstepEffect::bAttached' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, bUseDefaultMirrorConfig) == 0x000091, "Member 'UAnimNotify_PlayFootstepEffect::bUseDefaultMirrorConfig' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayFootstepEffect, MirrorDataTable) == 0x000098, "Member 'UAnimNotify_PlayFootstepEffect::MirrorDataTable' has a wrong offset!");

// Class X6Game.ANS_TimedBikeTraceEffect
// 0x00C8 (0x00F8 - 0x0030)
class UANS_TimedBikeTraceEffect final : public UAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefreshEffectConfigInternal;                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x68];                                      // 0x0090(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_TimedBikeTraceEffect">();
	}
	static class UANS_TimedBikeTraceEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_TimedBikeTraceEffect>();
	}
};
static_assert(alignof(UANS_TimedBikeTraceEffect) == 0x000008, "Wrong alignment on UANS_TimedBikeTraceEffect");
static_assert(sizeof(UANS_TimedBikeTraceEffect) == 0x0000F8, "Wrong size on UANS_TimedBikeTraceEffect");
static_assert(offsetof(UANS_TimedBikeTraceEffect, SocketName) == 0x000030, "Member 'UANS_TimedBikeTraceEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UANS_TimedBikeTraceEffect, RowName) == 0x000038, "Member 'UANS_TimedBikeTraceEffect::RowName' has a wrong offset!");
static_assert(offsetof(UANS_TimedBikeTraceEffect, LocationOffset) == 0x000040, "Member 'UANS_TimedBikeTraceEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UANS_TimedBikeTraceEffect, RotationOffset) == 0x000058, "Member 'UANS_TimedBikeTraceEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UANS_TimedBikeTraceEffect, Scale) == 0x000070, "Member 'UANS_TimedBikeTraceEffect::Scale' has a wrong offset!");
static_assert(offsetof(UANS_TimedBikeTraceEffect, bDestroyAtEnd) == 0x000088, "Member 'UANS_TimedBikeTraceEffect::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(UANS_TimedBikeTraceEffect, RefreshEffectConfigInternal) == 0x00008C, "Member 'UANS_TimedBikeTraceEffect::RefreshEffectConfigInternal' has a wrong offset!");

// Class X6Game.ANS_TimedPlayFootstepEffect
// 0x0070 (0x00A0 - 0x0030)
class UANS_TimedPlayFootstepEffect final : public UAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x17];                                      // 0x0089(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_TimedPlayFootstepEffect">();
	}
	static class UANS_TimedPlayFootstepEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_TimedPlayFootstepEffect>();
	}
};
static_assert(alignof(UANS_TimedPlayFootstepEffect) == 0x000008, "Wrong alignment on UANS_TimedPlayFootstepEffect");
static_assert(sizeof(UANS_TimedPlayFootstepEffect) == 0x0000A0, "Wrong size on UANS_TimedPlayFootstepEffect");
static_assert(offsetof(UANS_TimedPlayFootstepEffect, SocketName) == 0x000030, "Member 'UANS_TimedPlayFootstepEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UANS_TimedPlayFootstepEffect, LocationOffset) == 0x000038, "Member 'UANS_TimedPlayFootstepEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UANS_TimedPlayFootstepEffect, RotationOffset) == 0x000050, "Member 'UANS_TimedPlayFootstepEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UANS_TimedPlayFootstepEffect, Scale) == 0x000068, "Member 'UANS_TimedPlayFootstepEffect::Scale' has a wrong offset!");
static_assert(offsetof(UANS_TimedPlayFootstepEffect, RowName) == 0x000080, "Member 'UANS_TimedPlayFootstepEffect::RowName' has a wrong offset!");
static_assert(offsetof(UANS_TimedPlayFootstepEffect, bAttached) == 0x000088, "Member 'UANS_TimedPlayFootstepEffect::bAttached' has a wrong offset!");

// Class X6Game.ANS_X6HoldItemPlayMaterialAnim
// 0x0008 (0x0038 - 0x0030)
class UANS_X6HoldItemPlayMaterialAnim final : public UAnimNotifyState
{
public:
	class FName                                   HoldItemTag;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANS_X6HoldItemPlayMaterialAnim">();
	}
	static class UANS_X6HoldItemPlayMaterialAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UANS_X6HoldItemPlayMaterialAnim>();
	}
};
static_assert(alignof(UANS_X6HoldItemPlayMaterialAnim) == 0x000008, "Wrong alignment on UANS_X6HoldItemPlayMaterialAnim");
static_assert(sizeof(UANS_X6HoldItemPlayMaterialAnim) == 0x000038, "Wrong size on UANS_X6HoldItemPlayMaterialAnim");
static_assert(offsetof(UANS_X6HoldItemPlayMaterialAnim, HoldItemTag) == 0x000030, "Member 'UANS_X6HoldItemPlayMaterialAnim::HoldItemTag' has a wrong offset!");

// Class X6Game.AN_CanInterruptLocomotionState
// 0x0000 (0x0038 - 0x0038)
class UAN_CanInterruptLocomotionState final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AN_CanInterruptLocomotionState">();
	}
	static class UAN_CanInterruptLocomotionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAN_CanInterruptLocomotionState>();
	}
};
static_assert(alignof(UAN_CanInterruptLocomotionState) == 0x000008, "Wrong alignment on UAN_CanInterruptLocomotionState");
static_assert(sizeof(UAN_CanInterruptLocomotionState) == 0x000038, "Wrong size on UAN_CanInterruptLocomotionState");

// Class X6Game.X6MovieSceneLookAtPreviewPoint
// 0x0060 (0x0408 - 0x03A8)
class AX6MovieSceneLookAtPreviewPoint final : public AActor
{
public:
	bool                                          bUseLookAt;                                        // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtUpdateMode                             LookAtUpdateMode;                                  // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseAOHead;                                    // 0x03AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AB[0x5];                                      // 0x03AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LookAtTargetActor;                                 // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtOffsetLocation;                              // 0x03B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LookAtTargetSocketName;                            // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseAimOffset;                                   // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtSmoothingTime;                               // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTriggerTurn;                                  // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideTriggerTurnInPlaceAngle;                   // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryToLookAtWhenOutOfBounds;                       // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomBlinkRange;                                 // 0x03F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRuntimeBlink;                               // 0x03F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F3[0x5];                                      // 0x03F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LookAtOwnerActor;                                  // 0x0400(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6MovieSceneLookAtPreviewPoint">();
	}
	static class AX6MovieSceneLookAtPreviewPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6MovieSceneLookAtPreviewPoint>();
	}
};
static_assert(alignof(AX6MovieSceneLookAtPreviewPoint) == 0x000008, "Wrong alignment on AX6MovieSceneLookAtPreviewPoint");
static_assert(sizeof(AX6MovieSceneLookAtPreviewPoint) == 0x000408, "Wrong size on AX6MovieSceneLookAtPreviewPoint");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bUseLookAt) == 0x0003A8, "Member 'AX6MovieSceneLookAtPreviewPoint::bUseLookAt' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, LookAtUpdateMode) == 0x0003A9, "Member 'AX6MovieSceneLookAtPreviewPoint::LookAtUpdateMode' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bOnlyUseAOHead) == 0x0003AA, "Member 'AX6MovieSceneLookAtPreviewPoint::bOnlyUseAOHead' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, LookAtTargetActor) == 0x0003B0, "Member 'AX6MovieSceneLookAtPreviewPoint::LookAtTargetActor' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, LookAtOffsetLocation) == 0x0003B8, "Member 'AX6MovieSceneLookAtPreviewPoint::LookAtOffsetLocation' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, LookAtTargetSocketName) == 0x0003D0, "Member 'AX6MovieSceneLookAtPreviewPoint::LookAtTargetSocketName' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bPauseAimOffset) == 0x0003E0, "Member 'AX6MovieSceneLookAtPreviewPoint::bPauseAimOffset' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, LookAtSmoothingTime) == 0x0003E4, "Member 'AX6MovieSceneLookAtPreviewPoint::LookAtSmoothingTime' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bNeedTriggerTurn) == 0x0003E8, "Member 'AX6MovieSceneLookAtPreviewPoint::bNeedTriggerTurn' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, OverrideTriggerTurnInPlaceAngle) == 0x0003EC, "Member 'AX6MovieSceneLookAtPreviewPoint::OverrideTriggerTurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bTryToLookAtWhenOutOfBounds) == 0x0003F0, "Member 'AX6MovieSceneLookAtPreviewPoint::bTryToLookAtWhenOutOfBounds' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bRandomBlinkRange) == 0x0003F1, "Member 'AX6MovieSceneLookAtPreviewPoint::bRandomBlinkRange' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, bEnableRuntimeBlink) == 0x0003F2, "Member 'AX6MovieSceneLookAtPreviewPoint::bEnableRuntimeBlink' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, StaticMeshComponent) == 0x0003F8, "Member 'AX6MovieSceneLookAtPreviewPoint::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AX6MovieSceneLookAtPreviewPoint, LookAtOwnerActor) == 0x000400, "Member 'AX6MovieSceneLookAtPreviewPoint::LookAtOwnerActor' has a wrong offset!");

// Class X6Game.BipedalLocomotionAnimInstance
// 0x00C0 (0x0490 - 0x03D0)
class UBipedalLocomotionAnimInstance final : public UAnimInstance
{
public:
	class UBipedalLocomotionDataContainer*        DataContainer;                                     // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6GeneralAnimationDataComponent*       OwnerDataComponent;                                // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandRecoveryStandardFallingDuration;               // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBipedalLocomotionAnimSet              AnimSet;                                           // 0x03E0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         PlayRateMin;                                       // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRateMax;                                       // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingLandAdditiveAlpha;                           // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleLandAdditiveAlpha;                             // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalcPlayerSpeedByInput;                           // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceIdleReadyInIdleState;                        // 0x0479(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47A[0x16];                                     // 0x047A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintPostInitializeDataContainer();
	float GetAdditiveAlpha();
	float GetLandRecoveryAlpha();
	class UAnimSequenceBase* GetNextIdleBreak();
	bool HasAnyIdleBreak();
	bool IsForcingIdleReadyInIdleState();
	bool UseFallLoopAsJump();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BipedalLocomotionAnimInstance">();
	}
	static class UBipedalLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBipedalLocomotionAnimInstance>();
	}
};
static_assert(alignof(UBipedalLocomotionAnimInstance) == 0x000010, "Wrong alignment on UBipedalLocomotionAnimInstance");
static_assert(sizeof(UBipedalLocomotionAnimInstance) == 0x000490, "Wrong size on UBipedalLocomotionAnimInstance");
static_assert(offsetof(UBipedalLocomotionAnimInstance, DataContainer) == 0x0003C8, "Member 'UBipedalLocomotionAnimInstance::DataContainer' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, OwnerDataComponent) == 0x0003D0, "Member 'UBipedalLocomotionAnimInstance::OwnerDataComponent' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, LandRecoveryStandardFallingDuration) == 0x0003D8, "Member 'UBipedalLocomotionAnimInstance::LandRecoveryStandardFallingDuration' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, AnimSet) == 0x0003E0, "Member 'UBipedalLocomotionAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, PlayRateMin) == 0x000468, "Member 'UBipedalLocomotionAnimInstance::PlayRateMin' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, PlayRateMax) == 0x00046C, "Member 'UBipedalLocomotionAnimInstance::PlayRateMax' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, MovingLandAdditiveAlpha) == 0x000470, "Member 'UBipedalLocomotionAnimInstance::MovingLandAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, IdleLandAdditiveAlpha) == 0x000474, "Member 'UBipedalLocomotionAnimInstance::IdleLandAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, bCalcPlayerSpeedByInput) == 0x000478, "Member 'UBipedalLocomotionAnimInstance::bCalcPlayerSpeedByInput' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionAnimInstance, bForceIdleReadyInIdleState) == 0x000479, "Member 'UBipedalLocomotionAnimInstance::bForceIdleReadyInIdleState' has a wrong offset!");

// Class X6Game.LocomotionDataContainerBase
// 0x0010 (0x0038 - 0x0028)
class ULocomotionDataContainerBase : public UObject
{
public:
	class UX6GeneralAnimationDataComponent*       OwnerAnimDataComponent;                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAnimInstance(class UAnimInstance* AnimInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionDataContainerBase">();
	}
	static class ULocomotionDataContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionDataContainerBase>();
	}
};
static_assert(alignof(ULocomotionDataContainerBase) == 0x000008, "Wrong alignment on ULocomotionDataContainerBase");
static_assert(sizeof(ULocomotionDataContainerBase) == 0x000038, "Wrong size on ULocomotionDataContainerBase");
static_assert(offsetof(ULocomotionDataContainerBase, OwnerAnimDataComponent) == 0x000028, "Member 'ULocomotionDataContainerBase::OwnerAnimDataComponent' has a wrong offset!");

// Class X6Game.BipedalLocomotionDataContainer
// 0x00A8 (0x00E0 - 0x0038)
class UBipedalLocomotionDataContainer final : public ULocomotionDataContainerBase
{
public:
	struct FVector                                PlayerVelocity;                                    // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSpeed;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGroundedMoving;                                 // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x1];                                       // 0x0056(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasInput;                                         // 0x0057(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocomotionGait                               AllowGait;                                         // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWalking;                                        // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJoging;                                         // 0x005A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprinting;                                      // 0x005B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentAllowSpeed;                                 // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditiveLeanAngle;                                 // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x10];                                      // 0x006C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CycleBlendSpaceInput;                              // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableJogLeanAdditive;                            // 0x0084(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0xB];                                       // 0x0085(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         CurrentFloatingJumpStage;                          // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAir;                                          // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJump;                                           // 0x0092(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x0093(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDuration;                                      // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInJumpingLoop;                                  // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x0099(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            OwnerCharacterMovement;                            // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PrevCustomMode);
	void SetStandardSpeeds(float InStandardWalkSpeed, float InStandardJogSpeed, float InStandardSprintSpeed);
	void UpdateFloatingJumpStates(uint8 InFloatingJumpStage);
	void UpdatePlayerMovementStates(EMovementMode InMovementMode, ELocomotionGait InAllowGait, float InAllowSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BipedalLocomotionDataContainer">();
	}
	static class UBipedalLocomotionDataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBipedalLocomotionDataContainer>();
	}
};
static_assert(alignof(UBipedalLocomotionDataContainer) == 0x000008, "Wrong alignment on UBipedalLocomotionDataContainer");
static_assert(sizeof(UBipedalLocomotionDataContainer) == 0x0000E0, "Wrong size on UBipedalLocomotionDataContainer");
static_assert(offsetof(UBipedalLocomotionDataContainer, PlayerVelocity) == 0x000038, "Member 'UBipedalLocomotionDataContainer::PlayerVelocity' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, PlayerSpeed) == 0x000050, "Member 'UBipedalLocomotionDataContainer::PlayerSpeed' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsMoving) == 0x000054, "Member 'UBipedalLocomotionDataContainer::bIsMoving' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsGroundedMoving) == 0x000055, "Member 'UBipedalLocomotionDataContainer::bIsGroundedMoving' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bHasInput) == 0x000057, "Member 'UBipedalLocomotionDataContainer::bHasInput' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, AllowGait) == 0x000058, "Member 'UBipedalLocomotionDataContainer::AllowGait' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsWalking) == 0x000059, "Member 'UBipedalLocomotionDataContainer::bIsWalking' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsJoging) == 0x00005A, "Member 'UBipedalLocomotionDataContainer::bIsJoging' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsSprinting) == 0x00005B, "Member 'UBipedalLocomotionDataContainer::bIsSprinting' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, CurrentAllowSpeed) == 0x00005C, "Member 'UBipedalLocomotionDataContainer::CurrentAllowSpeed' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, TurnAngle) == 0x000060, "Member 'UBipedalLocomotionDataContainer::TurnAngle' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, AdditiveLeanAngle) == 0x000068, "Member 'UBipedalLocomotionDataContainer::AdditiveLeanAngle' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, PlayRate) == 0x00007C, "Member 'UBipedalLocomotionDataContainer::PlayRate' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, CycleBlendSpaceInput) == 0x000080, "Member 'UBipedalLocomotionDataContainer::CycleBlendSpaceInput' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bEnableJogLeanAdditive) == 0x000084, "Member 'UBipedalLocomotionDataContainer::bEnableJogLeanAdditive' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, CurrentFloatingJumpStage) == 0x000090, "Member 'UBipedalLocomotionDataContainer::CurrentFloatingJumpStage' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsInAir) == 0x000091, "Member 'UBipedalLocomotionDataContainer::bIsInAir' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsJump) == 0x000092, "Member 'UBipedalLocomotionDataContainer::bIsJump' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsFalling) == 0x000093, "Member 'UBipedalLocomotionDataContainer::bIsFalling' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, FallDuration) == 0x000094, "Member 'UBipedalLocomotionDataContainer::FallDuration' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsInJumpingLoop) == 0x000098, "Member 'UBipedalLocomotionDataContainer::bIsInJumpingLoop' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, bIsFlying) == 0x000099, "Member 'UBipedalLocomotionDataContainer::bIsFlying' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, OwnerCharacter) == 0x0000A0, "Member 'UBipedalLocomotionDataContainer::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UBipedalLocomotionDataContainer, OwnerCharacterMovement) == 0x0000A8, "Member 'UBipedalLocomotionDataContainer::OwnerCharacterMovement' has a wrong offset!");

// Class X6Game.BTComposite_RandomSelector
// 0x0068 (0x00E8 - 0x0080)
class UBTComposite_RandomSelector final : public UBTCompositeNode
{
public:
	uint8                                         bReRandomWhenFailed : 1;                           // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                BranchWeightArray;                                 // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTComposite_RandomSelector">();
	}
	static class UBTComposite_RandomSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTComposite_RandomSelector>();
	}
};
static_assert(alignof(UBTComposite_RandomSelector) == 0x000008, "Wrong alignment on UBTComposite_RandomSelector");
static_assert(sizeof(UBTComposite_RandomSelector) == 0x0000E8, "Wrong size on UBTComposite_RandomSelector");
static_assert(offsetof(UBTComposite_RandomSelector, BranchWeightArray) == 0x000088, "Member 'UBTComposite_RandomSelector::BranchWeightArray' has a wrong offset!");

// Class X6Game.CameraModifierVolumeActor
// 0x0038 (0x03E0 - 0x03A8)
class ACameraModifierVolumeActor final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EnterBox;                                          // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ExitBox;                                           // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModifierKey;                                       // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEnterVolume(class AActor* Actor);
	void OnActorLeaveVolume(class AActor* Actor);
	void OnEnterBoxComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnExitBoxBoxComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifierVolumeActor">();
	}
	static class ACameraModifierVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraModifierVolumeActor>();
	}
};
static_assert(alignof(ACameraModifierVolumeActor) == 0x000008, "Wrong alignment on ACameraModifierVolumeActor");
static_assert(sizeof(ACameraModifierVolumeActor) == 0x0003E0, "Wrong size on ACameraModifierVolumeActor");
static_assert(offsetof(ACameraModifierVolumeActor, Root) == 0x0003A8, "Member 'ACameraModifierVolumeActor::Root' has a wrong offset!");
static_assert(offsetof(ACameraModifierVolumeActor, EnterBox) == 0x0003B0, "Member 'ACameraModifierVolumeActor::EnterBox' has a wrong offset!");
static_assert(offsetof(ACameraModifierVolumeActor, ExitBox) == 0x0003B8, "Member 'ACameraModifierVolumeActor::ExitBox' has a wrong offset!");
static_assert(offsetof(ACameraModifierVolumeActor, ModifierKey) == 0x0003C0, "Member 'ACameraModifierVolumeActor::ModifierKey' has a wrong offset!");

// Class X6Game.CameraModifier_CameraBlur
// 0x0028 (0x0070 - 0x0048)
class UCameraModifier_CameraBlur final : public UCameraModifier
{
public:
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AX6PlayerCameraManager>  X6CameraOwner;                                     // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeBlend(const float BlendInTime, const float BlendOutTime);
	void InitializeMotionBlur(const float InBlurAmount, const float InBlurMax);
	void InitializeRadiusBlur(const float InOffset, const float InRadius, const float InHardness, const float InSwitchDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_CameraBlur">();
	}
	static class UCameraModifier_CameraBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_CameraBlur>();
	}
};
static_assert(alignof(UCameraModifier_CameraBlur) == 0x000008, "Wrong alignment on UCameraModifier_CameraBlur");
static_assert(sizeof(UCameraModifier_CameraBlur) == 0x000070, "Wrong size on UCameraModifier_CameraBlur");
static_assert(offsetof(UCameraModifier_CameraBlur, X6CameraOwner) == 0x000068, "Member 'UCameraModifier_CameraBlur::X6CameraOwner' has a wrong offset!");

// Class X6Game.FootstepDecalConfigTemplate
// 0x0038 (0x0068 - 0x0030)
class UFootstepDecalConfigTemplate final : public UDataAsset
{
public:
	class UMaterialInstance*                      Material;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftScaleZ;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightScaleZ;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepDecalConfigTemplate">();
	}
	static class UFootstepDecalConfigTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepDecalConfigTemplate>();
	}
};
static_assert(alignof(UFootstepDecalConfigTemplate) == 0x000008, "Wrong alignment on UFootstepDecalConfigTemplate");
static_assert(sizeof(UFootstepDecalConfigTemplate) == 0x000068, "Wrong size on UFootstepDecalConfigTemplate");
static_assert(offsetof(UFootstepDecalConfigTemplate, Material) == 0x000030, "Member 'UFootstepDecalConfigTemplate::Material' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, Size) == 0x000038, "Member 'UFootstepDecalConfigTemplate::Size' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, Duration) == 0x000050, "Member 'UFootstepDecalConfigTemplate::Duration' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, FadeOutTime) == 0x000054, "Member 'UFootstepDecalConfigTemplate::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, Pitch) == 0x000058, "Member 'UFootstepDecalConfigTemplate::Pitch' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, Roll) == 0x00005C, "Member 'UFootstepDecalConfigTemplate::Roll' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, LeftScaleZ) == 0x000060, "Member 'UFootstepDecalConfigTemplate::LeftScaleZ' has a wrong offset!");
static_assert(offsetof(UFootstepDecalConfigTemplate, RightScaleZ) == 0x000064, "Member 'UFootstepDecalConfigTemplate::RightScaleZ' has a wrong offset!");

// Class X6Game.CustomNavLinkMoveInterface
// 0x0000 (0x0000 - 0x0000)
class ICustomNavLinkMoveInterface final : public IInterface
{
public:
	void OnLanded();
	void OnLinkMoveRemoved(class UX6PathFollowingComponent* PathComp);
	bool OnLinkMoveStart(class UX6PathFollowingComponent* PathComp, const struct FVector& StartPoint, const struct FVector& DestPoint);
	void OnLinkMoveStop(class UX6PathFollowingComponent* PathComp);

	bool StopBlockDetectionInNavLink() const;
	bool StopCheckingReachTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomNavLinkMoveInterface">();
	}
	static class ICustomNavLinkMoveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICustomNavLinkMoveInterface>();
	}
};
static_assert(alignof(ICustomNavLinkMoveInterface) == 0x000001, "Wrong alignment on ICustomNavLinkMoveInterface");
static_assert(sizeof(ICustomNavLinkMoveInterface) == 0x000001, "Wrong size on ICustomNavLinkMoveInterface");

// Class X6Game.X6TickObject
// 0x0010 (0x0038 - 0x0028)
class UX6TickObject : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeInit();
	void Init();
	void ReceiveTick(float DeltaTime);
	void SetTickable(bool IsTickable);
	void SetTickableWhenPaused(bool IsTickableWhenPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TickObject">();
	}
	static class UX6TickObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TickObject>();
	}
};
static_assert(alignof(UX6TickObject) == 0x000008, "Wrong alignment on UX6TickObject");
static_assert(sizeof(UX6TickObject) == 0x000038, "Wrong size on UX6TickObject");

// Class X6Game.CustomNavLinkMoveBase
// 0x0008 (0x0040 - 0x0038)
class UCustomNavLinkMoveBase : public UX6TickObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomNavLinkMoveBase">();
	}
	static class UCustomNavLinkMoveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomNavLinkMoveBase>();
	}
};
static_assert(alignof(UCustomNavLinkMoveBase) == 0x000008, "Wrong alignment on UCustomNavLinkMoveBase");
static_assert(sizeof(UCustomNavLinkMoveBase) == 0x000040, "Wrong size on UCustomNavLinkMoveBase");

// Class X6Game.DaMiaoLocomotionAnimInstance
// 0x0470 (0x0840 - 0x03D0)
class UDaMiaoLocomotionAnimInstance final : public UX6PlayerAnimInstance
{
public:
	struct FVector2D                              SlowCycleBlendSpeedAlphaInRange;                   // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAssetsBlendTime;                              // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartStateStrideWarpingBlendInOffset;              // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartStateStrideWarpingBlendInDuration;            // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHasVelocitySpeed;                               // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaMiaoInAirJumpAnimSet                DefaultJumpAnimSet;                                // 0x03F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaMiaoInAirJumpAnimSet                InAirJumpAnimSet;                                  // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaMiaoInAirJumpAnimSet                MantleJumpAnimSet;                                 // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StaticAdditiveAlpha;                               // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAdditiveAlpha;                               // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandRecoveryFullWeightFallDownSeconds;             // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleSpeedScale;                               // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            LeanAngleRange;                                    // 0x0438(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleInterpSpeed;                              // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOrientationWarping;                         // 0x044C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStrideWarping;                              // 0x044D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44E[0x2];                                      // 0x044E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            SpeedWarpingPlayRateRange;                         // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamiaoBSXDir;                                      // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamiaoBSYDir;                                      // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFloatRelaxAnim;                             // 0x0468(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFloatBS;                                    // 0x0469(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotInFloating;                                    // 0x046A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46B[0x1];                                      // 0x046B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelaxAnimLength;                                   // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelaxAnimInterval;                                 // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurAccumulateRelaxAnimInterval;                    // 0x0474(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimSequence>>   DamiaoRelaxSequence;                               // 0x0478(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurrentDamiaoRelaxSequence;                        // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RootSpeedCurveName;                                // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootDistanceCurveName;                             // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootMoveDirectionCurveName;                        // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ReJumpPoseSnapshotName;                            // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRootMotionFromEverythingState> RootMotionFromEverythingStates;                    // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 OwnerActor;                                        // 0x04C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x1C];                                     // 0x04C8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAdditiveLeanAngle;                             // 0x04E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENativePlayerFloatingJumpStage                NativeFloatingJumpStage;                           // 0x04E8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENativePlayerLocomotionType                   NativeAllowGait;                                   // 0x04E9(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInAimOffset;                                      // 0x04EA(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMantleJump;                                       // 0x04EB(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInDash;                                         // 0x04EC(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDashChanged;                                      // 0x04ED(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EE[0x72];                                     // 0x04EE(0x0072)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrideScale;                                       // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x0564(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrideWarpingAlpha;                                // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OrientationAngle;                                  // 0x056C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StrideDirection;                                   // 0x0570(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JogGaitStopBlendAlpha;                             // 0x0588(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CycleBlendAlpha;                                   // 0x058C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x22];                                     // 0x0590(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInAir;                                            // 0x05B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovingOnGround;                                   // 0x05B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStaticOnGround;                                   // 0x05B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTurnInPlace;                                      // 0x05B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B6[0x2];                                      // 0x05B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceAngle;                                  // 0x05B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x24];                                     // 0x05BC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSkipStartState;                                   // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartStateEnableLeanAdditive;                     // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENativePlayerLocomotionType                   StartStateLocomotionGait;                          // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E3[0x11];                                     // 0x05E3(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWalkGait;                                         // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJogGait;                                          // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintGait;                                       // 0x05F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F7[0x1];                                      // 0x05F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CurrentSlowStopSequence;                           // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentStopSequence;                               // 0x0600(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFallLand;                                         // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpLoop;                                         // 0x0609(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReEnterJump;                                      // 0x060A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasJumpLoop;                                      // 0x060B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInAirJump;                                        // 0x060C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60D[0x3];                                      // 0x060D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaMiaoInAirJumpAnimSet                CurrentJumpAnimSet;                                // 0x0610(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DoubleJumpToHightestTime;                          // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoubleJumpHeight;                                  // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x4];                                      // 0x0628(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditiveAlpha;                                     // 0x062C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandRecoveryAlpha;                                 // 0x0630(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaMiaoGroundedLocomotionAnimSet       DefaultGroundedLocomotionAnimSet;                  // 0x0638(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaMiaoGroundedLocomotionAnimSet       CurrentGroundedLocomotionAnimSet;                  // 0x0738(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x8];                                      // 0x0838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BlueprintPrepareDependencies();
	void BlueprintUpdatePlayerStates(const float DeltaSeconds);
	void LoadDamiaoRelaxAnimCompeted(int32 AsyncId, const TArray<class UObject*>& InLoadedObjects);
	void OnApplyAdditiveUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCycleStateMachineUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnJumpStartStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnLandRecoveryAdditiveStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnReJumpStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartLeanAdditiveBlendSpacePlayerUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartSequencePlayerUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartStateUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopSequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnTurnInPlaceStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void ReEnterJump();
	void ResetPendingGroundedLocomotionAnimSet();
	void SetDashState(bool IsInDash);
	void SetPendingGroundedLocomotionAnimSet(const struct FDaMiaoGroundedLocomotionAnimSet& InGroundedLocomotionAnimSet);
	void UpdateDamiaoFloatParam(float DeltaTime);
	void UpdateNativeAllowGait(const ENativePlayerLocomotionType InGait);
	void UpdateNativeFloatingJumpStage(const ENativePlayerFloatingJumpStage InStage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaMiaoLocomotionAnimInstance">();
	}
	static class UDaMiaoLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaMiaoLocomotionAnimInstance>();
	}
};
static_assert(alignof(UDaMiaoLocomotionAnimInstance) == 0x000010, "Wrong alignment on UDaMiaoLocomotionAnimInstance");
static_assert(sizeof(UDaMiaoLocomotionAnimInstance) == 0x000840, "Wrong size on UDaMiaoLocomotionAnimInstance");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, SlowCycleBlendSpeedAlphaInRange) == 0x0003C8, "Member 'UDaMiaoLocomotionAnimInstance::SlowCycleBlendSpeedAlphaInRange' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StartAssetsBlendTime) == 0x0003E8, "Member 'UDaMiaoLocomotionAnimInstance::StartAssetsBlendTime' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StartStateStrideWarpingBlendInOffset) == 0x0003EC, "Member 'UDaMiaoLocomotionAnimInstance::StartStateStrideWarpingBlendInOffset' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StartStateStrideWarpingBlendInDuration) == 0x0003F0, "Member 'UDaMiaoLocomotionAnimInstance::StartStateStrideWarpingBlendInDuration' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, MinHasVelocitySpeed) == 0x0003F4, "Member 'UDaMiaoLocomotionAnimInstance::MinHasVelocitySpeed' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DefaultJumpAnimSet) == 0x0003F8, "Member 'UDaMiaoLocomotionAnimInstance::DefaultJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, InAirJumpAnimSet) == 0x000408, "Member 'UDaMiaoLocomotionAnimInstance::InAirJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, MantleJumpAnimSet) == 0x000418, "Member 'UDaMiaoLocomotionAnimInstance::MantleJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StaticAdditiveAlpha) == 0x000428, "Member 'UDaMiaoLocomotionAnimInstance::StaticAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, MovingAdditiveAlpha) == 0x00042C, "Member 'UDaMiaoLocomotionAnimInstance::MovingAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, LandRecoveryFullWeightFallDownSeconds) == 0x000430, "Member 'UDaMiaoLocomotionAnimInstance::LandRecoveryFullWeightFallDownSeconds' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, LeanAngleSpeedScale) == 0x000434, "Member 'UDaMiaoLocomotionAnimInstance::LeanAngleSpeedScale' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, LeanAngleRange) == 0x000438, "Member 'UDaMiaoLocomotionAnimInstance::LeanAngleRange' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, LeanAngleInterpSpeed) == 0x000448, "Member 'UDaMiaoLocomotionAnimInstance::LeanAngleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bEnableOrientationWarping) == 0x00044C, "Member 'UDaMiaoLocomotionAnimInstance::bEnableOrientationWarping' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bEnableStrideWarping) == 0x00044D, "Member 'UDaMiaoLocomotionAnimInstance::bEnableStrideWarping' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, SpeedWarpingPlayRateRange) == 0x000450, "Member 'UDaMiaoLocomotionAnimInstance::SpeedWarpingPlayRateRange' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DamiaoBSXDir) == 0x000460, "Member 'UDaMiaoLocomotionAnimInstance::DamiaoBSXDir' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DamiaoBSYDir) == 0x000464, "Member 'UDaMiaoLocomotionAnimInstance::DamiaoBSYDir' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bEnableFloatRelaxAnim) == 0x000468, "Member 'UDaMiaoLocomotionAnimInstance::bEnableFloatRelaxAnim' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bEnableFloatBS) == 0x000469, "Member 'UDaMiaoLocomotionAnimInstance::bEnableFloatBS' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bNotInFloating) == 0x00046A, "Member 'UDaMiaoLocomotionAnimInstance::bNotInFloating' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, RelaxAnimLength) == 0x00046C, "Member 'UDaMiaoLocomotionAnimInstance::RelaxAnimLength' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, RelaxAnimInterval) == 0x000470, "Member 'UDaMiaoLocomotionAnimInstance::RelaxAnimInterval' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CurAccumulateRelaxAnimInterval) == 0x000474, "Member 'UDaMiaoLocomotionAnimInstance::CurAccumulateRelaxAnimInterval' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DamiaoRelaxSequence) == 0x000478, "Member 'UDaMiaoLocomotionAnimInstance::DamiaoRelaxSequence' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CurrentDamiaoRelaxSequence) == 0x000488, "Member 'UDaMiaoLocomotionAnimInstance::CurrentDamiaoRelaxSequence' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, RootSpeedCurveName) == 0x000490, "Member 'UDaMiaoLocomotionAnimInstance::RootSpeedCurveName' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, RootDistanceCurveName) == 0x000498, "Member 'UDaMiaoLocomotionAnimInstance::RootDistanceCurveName' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, RootMoveDirectionCurveName) == 0x0004A0, "Member 'UDaMiaoLocomotionAnimInstance::RootMoveDirectionCurveName' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, ReJumpPoseSnapshotName) == 0x0004A8, "Member 'UDaMiaoLocomotionAnimInstance::ReJumpPoseSnapshotName' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, RootMotionFromEverythingStates) == 0x0004B0, "Member 'UDaMiaoLocomotionAnimInstance::RootMotionFromEverythingStates' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, OwnerActor) == 0x0004C0, "Member 'UDaMiaoLocomotionAnimInstance::OwnerActor' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, TurnAdditiveLeanAngle) == 0x0004E4, "Member 'UDaMiaoLocomotionAnimInstance::TurnAdditiveLeanAngle' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, NativeFloatingJumpStage) == 0x0004E8, "Member 'UDaMiaoLocomotionAnimInstance::NativeFloatingJumpStage' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, NativeAllowGait) == 0x0004E9, "Member 'UDaMiaoLocomotionAnimInstance::NativeAllowGait' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bInAimOffset) == 0x0004EA, "Member 'UDaMiaoLocomotionAnimInstance::bInAimOffset' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bMantleJump) == 0x0004EB, "Member 'UDaMiaoLocomotionAnimInstance::bMantleJump' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bIsInDash) == 0x0004EC, "Member 'UDaMiaoLocomotionAnimInstance::bIsInDash' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bDashChanged) == 0x0004ED, "Member 'UDaMiaoLocomotionAnimInstance::bDashChanged' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StrideScale) == 0x000560, "Member 'UDaMiaoLocomotionAnimInstance::StrideScale' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, PlayRate) == 0x000564, "Member 'UDaMiaoLocomotionAnimInstance::PlayRate' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StrideWarpingAlpha) == 0x000568, "Member 'UDaMiaoLocomotionAnimInstance::StrideWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, OrientationAngle) == 0x00056C, "Member 'UDaMiaoLocomotionAnimInstance::OrientationAngle' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StrideDirection) == 0x000570, "Member 'UDaMiaoLocomotionAnimInstance::StrideDirection' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, JogGaitStopBlendAlpha) == 0x000588, "Member 'UDaMiaoLocomotionAnimInstance::JogGaitStopBlendAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CycleBlendAlpha) == 0x00058C, "Member 'UDaMiaoLocomotionAnimInstance::CycleBlendAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bInAir) == 0x0005B2, "Member 'UDaMiaoLocomotionAnimInstance::bInAir' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bMovingOnGround) == 0x0005B3, "Member 'UDaMiaoLocomotionAnimInstance::bMovingOnGround' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bStaticOnGround) == 0x0005B4, "Member 'UDaMiaoLocomotionAnimInstance::bStaticOnGround' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bTurnInPlace) == 0x0005B5, "Member 'UDaMiaoLocomotionAnimInstance::bTurnInPlace' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, TurnInPlaceAngle) == 0x0005B8, "Member 'UDaMiaoLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bSkipStartState) == 0x0005E0, "Member 'UDaMiaoLocomotionAnimInstance::bSkipStartState' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bStartStateEnableLeanAdditive) == 0x0005E1, "Member 'UDaMiaoLocomotionAnimInstance::bStartStateEnableLeanAdditive' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, StartStateLocomotionGait) == 0x0005E2, "Member 'UDaMiaoLocomotionAnimInstance::StartStateLocomotionGait' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bWalkGait) == 0x0005F4, "Member 'UDaMiaoLocomotionAnimInstance::bWalkGait' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bJogGait) == 0x0005F5, "Member 'UDaMiaoLocomotionAnimInstance::bJogGait' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bSprintGait) == 0x0005F6, "Member 'UDaMiaoLocomotionAnimInstance::bSprintGait' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CurrentSlowStopSequence) == 0x0005F8, "Member 'UDaMiaoLocomotionAnimInstance::CurrentSlowStopSequence' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CurrentStopSequence) == 0x000600, "Member 'UDaMiaoLocomotionAnimInstance::CurrentStopSequence' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bFallLand) == 0x000608, "Member 'UDaMiaoLocomotionAnimInstance::bFallLand' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bJumpLoop) == 0x000609, "Member 'UDaMiaoLocomotionAnimInstance::bJumpLoop' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bReEnterJump) == 0x00060A, "Member 'UDaMiaoLocomotionAnimInstance::bReEnterJump' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bHasJumpLoop) == 0x00060B, "Member 'UDaMiaoLocomotionAnimInstance::bHasJumpLoop' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, bInAirJump) == 0x00060C, "Member 'UDaMiaoLocomotionAnimInstance::bInAirJump' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CurrentJumpAnimSet) == 0x000610, "Member 'UDaMiaoLocomotionAnimInstance::CurrentJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DoubleJumpToHightestTime) == 0x000620, "Member 'UDaMiaoLocomotionAnimInstance::DoubleJumpToHightestTime' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DoubleJumpHeight) == 0x000624, "Member 'UDaMiaoLocomotionAnimInstance::DoubleJumpHeight' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, AdditiveAlpha) == 0x00062C, "Member 'UDaMiaoLocomotionAnimInstance::AdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, LandRecoveryAlpha) == 0x000630, "Member 'UDaMiaoLocomotionAnimInstance::LandRecoveryAlpha' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, DefaultGroundedLocomotionAnimSet) == 0x000638, "Member 'UDaMiaoLocomotionAnimInstance::DefaultGroundedLocomotionAnimSet' has a wrong offset!");
static_assert(offsetof(UDaMiaoLocomotionAnimInstance, CurrentGroundedLocomotionAnimSet) == 0x000738, "Member 'UDaMiaoLocomotionAnimInstance::CurrentGroundedLocomotionAnimSet' has a wrong offset!");

// Class X6Game.X6CharacterMovementComponent
// 0x0500 (0x14E0 - 0x0FE0)
class UX6CharacterMovementComponent : public UCharacterMovementComponent
{
public:
	FMulticastSparseDelegateProperty_             OnCharacterIsBeingLaunched;                        // 0x0FD8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bEnableUseTerminalFallingVelocity : 1;             // 0x0FD9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FDA[0x2];                                      // 0x0FDA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerminalFallingVelocity;                           // 0x0FDC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationCustom;                         // 0x0FE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableUpdateRegularMovementBase : 1;              // 0x0FE4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FE5[0x3];                                      // 0x0FE5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RegularMovementBaseVelocity;                       // 0x0FE8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1000[0x10];                                    // 0x1000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastDynamicMovementBaseTransform;                  // 0x1010(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CurrentDynamicMovementBaseTransform;               // 0x1070(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             TransformBeforeUpdateMovementBase;                 // 0x10D0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             TransformAfterUpdateMovementBase;                  // 0x1130(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MovementModeCacheNum;                              // 0x1190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1194[0x4];                                     // 0x1194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovementModeCache>             MovementModeCache;                                 // 0x1198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   CurrentMovementModeTag;                            // 0x11A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixTransformRootMotionFreezeSeconds;               // 0x11B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B4[0x109];                                   // 0x11B4(0x0109)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastSparseDelegateProperty_             OnCharacterBlockOtherActor;                        // 0x12BD(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12BE[0x2];                                     // 0x12BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidanceRadius;                                   // 0x12C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceConsiderationRadiusTimeScale;             // 0x12C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RVOYawRate;                                        // 0x12C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAvoidanceVelocityClamp : 1;                    // 0x12CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAvoiding : 1;                                   // 0x12CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12CD[0x3];                                     // 0x12CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTurnInPlaceSpeed;                               // 0x12D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D4[0x4];                                     // 0x12D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TurnInPlaceAngularVelocity;                        // 0x12D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TurningAccelerationInPlace;                        // 0x12F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningDecelerationInPlace;                        // 0x12F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventRotationMovementWhenTurningInPlace;        // 0x12F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F9[0x7];                                     // 0x12F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LowerBoundOfAngleOfTurnInplace;                    // 0x1300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotationOfTurnInplace;                       // 0x1308(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableTurnInplace;                                // 0x1320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1321[0x7];                                     // 0x1321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RemainingTurnInplaceRotator;                       // 0x1328(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1340[0x18];                                    // 0x1340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastSparseDelegateProperty_             OnWalkingNavLinkStart;                             // 0x1358(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1359[0x57];                                    // 0x1359(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClearRootMotionWhenTickEnabled;                   // 0x13B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMulticastStartStopPhase;                          // 0x13B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B2[0x6];                                     // 0x13B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    PendingReplicatedAcceleration;                     // 0x13B8(0x0018)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAnyAcceleration;                               // 0x13D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D1[0x7];                                     // 0x13D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReplicatedVelocity;                                // 0x13D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearVelocityDuringStopPhaseSimulation;           // 0x13F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F1[0xF];                                     // 0x13F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableInertiaVelocityProcess;                     // 0x1400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstFallingFrame;                                // 0x1401(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1402[0x6];                                     // 0x1402(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RedundantVelocity;                                 // 0x1408(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpartSpeedDeceleration;                           // 0x1420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalImpartSpeed;                          // 0x1424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentHorizontalImpartVelocity;                   // 0x1428(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldHorizontalImpartVelocity;                       // 0x1440(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1458[0x20];                                    // 0x1458(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FrozenChracterMovementTag;                         // 0x1478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCharacterHasVelocityStateChanged;                // 0x1480(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1481[0x7];                                     // 0x1481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             GravityDisabledTags;                               // 0x1488(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D8[0x8];                                     // 0x14D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearGravityDisabledTags();
	void ClearMovementModeCache();
	void DisableGravity(class FName Tag);
	void EnableGravity(class FName Tag);
	void FreezeX6CharacterMovement();
	bool GetEnableInertiaVelocityProcess();
	bool IsRootMotionBrake2D();
	bool IsX6CharacterMovementFrozen();
	void K2_ForceUpdateBaseFromFloor();
	void MulticastHasAnyAccelerationChanged(const bool bNewHasAnyAcceleration, const struct FVector& Location);
	void SetBrakeWithRootMotion(const bool bInBrakeWithRootMotion);
	void SetEnableInertiaVelocityProcess(bool bEnable);
	void SetEnableUpdateRegularMovementBase(bool bEnable);
	bool SetMovementModeAtCache(int32 Index_0);
	void SetMovementModeWithTag(EMovementMode NewMovementMode, uint8 NewCustomMode, class FName Tag);
	void SetRootMotionBrakeDistance(const float InBrakeDistance);
	void SetRootMotionBrakeDuration(const float InBrakeDuration);
	bool SetToPrevMovementMode();
	bool SetToTagMovementMode(class FName Tag, int32 Previous);
	void StopActiveTurnInplace();
	void UnfreezeX6CharacterMovement();
	void UpdateRegularMovementBaseVelocity(float DeltaTime);
	void X6_ClearComponentTickDisabledTags();
	void X6_GetComponentTickDisabledTags(TSet<class FName>* OutTags);
	bool X6_SetComponentTickEnabled(bool bEnabled, class FName Tag);

	bool CanTurningInplace() const;
	bool EnableUpdateRegularMovementBase() const;
	bool GetBrakeWithRootMotion() const;
	const struct FTransform GetCurrentDynamicMovementBaseTransform() const;
	const struct FTransform GetLastDynamicMovementBaseTransform() const;
	struct FVector GetRegularMovementBaseVelocity() const;
	float GetRootMotionBrakeDistance() const;
	const struct FTransform GetTransformAfterUpdateMovementBase() const;
	const struct FTransform GetTransformBeforeUpdateMovementBase() const;
	bool IsDisableGravity() const;
	bool IsRegularMovementBaseValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterMovementComponent">();
	}
	static class UX6CharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CharacterMovementComponent>();
	}
};
static_assert(alignof(UX6CharacterMovementComponent) == 0x000010, "Wrong alignment on UX6CharacterMovementComponent");
static_assert(sizeof(UX6CharacterMovementComponent) == 0x0014E0, "Wrong size on UX6CharacterMovementComponent");
static_assert(offsetof(UX6CharacterMovementComponent, OnCharacterIsBeingLaunched) == 0x000FD8, "Member 'UX6CharacterMovementComponent::OnCharacterIsBeingLaunched' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TerminalFallingVelocity) == 0x000FDC, "Member 'UX6CharacterMovementComponent::TerminalFallingVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, BrakingDecelerationCustom) == 0x000FE0, "Member 'UX6CharacterMovementComponent::BrakingDecelerationCustom' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, RegularMovementBaseVelocity) == 0x000FE8, "Member 'UX6CharacterMovementComponent::RegularMovementBaseVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, LastDynamicMovementBaseTransform) == 0x001010, "Member 'UX6CharacterMovementComponent::LastDynamicMovementBaseTransform' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, CurrentDynamicMovementBaseTransform) == 0x001070, "Member 'UX6CharacterMovementComponent::CurrentDynamicMovementBaseTransform' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TransformBeforeUpdateMovementBase) == 0x0010D0, "Member 'UX6CharacterMovementComponent::TransformBeforeUpdateMovementBase' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TransformAfterUpdateMovementBase) == 0x001130, "Member 'UX6CharacterMovementComponent::TransformAfterUpdateMovementBase' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, MovementModeCacheNum) == 0x001190, "Member 'UX6CharacterMovementComponent::MovementModeCacheNum' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, MovementModeCache) == 0x001198, "Member 'UX6CharacterMovementComponent::MovementModeCache' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, CurrentMovementModeTag) == 0x0011A8, "Member 'UX6CharacterMovementComponent::CurrentMovementModeTag' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, FixTransformRootMotionFreezeSeconds) == 0x0011B0, "Member 'UX6CharacterMovementComponent::FixTransformRootMotionFreezeSeconds' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, OnCharacterBlockOtherActor) == 0x0012BD, "Member 'UX6CharacterMovementComponent::OnCharacterBlockOtherActor' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, AvoidanceRadius) == 0x0012C0, "Member 'UX6CharacterMovementComponent::AvoidanceRadius' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, AvoidanceConsiderationRadiusTimeScale) == 0x0012C4, "Member 'UX6CharacterMovementComponent::AvoidanceConsiderationRadiusTimeScale' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, RVOYawRate) == 0x0012C8, "Member 'UX6CharacterMovementComponent::RVOYawRate' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, MaxTurnInPlaceSpeed) == 0x0012D0, "Member 'UX6CharacterMovementComponent::MaxTurnInPlaceSpeed' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TurnInPlaceAngularVelocity) == 0x0012D8, "Member 'UX6CharacterMovementComponent::TurnInPlaceAngularVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TurningAccelerationInPlace) == 0x0012F0, "Member 'UX6CharacterMovementComponent::TurningAccelerationInPlace' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TurningDecelerationInPlace) == 0x0012F4, "Member 'UX6CharacterMovementComponent::TurningDecelerationInPlace' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bPreventRotationMovementWhenTurningInPlace) == 0x0012F8, "Member 'UX6CharacterMovementComponent::bPreventRotationMovementWhenTurningInPlace' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, LowerBoundOfAngleOfTurnInplace) == 0x001300, "Member 'UX6CharacterMovementComponent::LowerBoundOfAngleOfTurnInplace' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, TargetRotationOfTurnInplace) == 0x001308, "Member 'UX6CharacterMovementComponent::TargetRotationOfTurnInplace' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bEnableTurnInplace) == 0x001320, "Member 'UX6CharacterMovementComponent::bEnableTurnInplace' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, RemainingTurnInplaceRotator) == 0x001328, "Member 'UX6CharacterMovementComponent::RemainingTurnInplaceRotator' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, OnWalkingNavLinkStart) == 0x001358, "Member 'UX6CharacterMovementComponent::OnWalkingNavLinkStart' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bClearRootMotionWhenTickEnabled) == 0x0013B0, "Member 'UX6CharacterMovementComponent::bClearRootMotionWhenTickEnabled' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bMulticastStartStopPhase) == 0x0013B1, "Member 'UX6CharacterMovementComponent::bMulticastStartStopPhase' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, PendingReplicatedAcceleration) == 0x0013B8, "Member 'UX6CharacterMovementComponent::PendingReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bHasAnyAcceleration) == 0x0013D0, "Member 'UX6CharacterMovementComponent::bHasAnyAcceleration' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, ReplicatedVelocity) == 0x0013D8, "Member 'UX6CharacterMovementComponent::ReplicatedVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bClearVelocityDuringStopPhaseSimulation) == 0x0013F0, "Member 'UX6CharacterMovementComponent::bClearVelocityDuringStopPhaseSimulation' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bEnableInertiaVelocityProcess) == 0x001400, "Member 'UX6CharacterMovementComponent::bEnableInertiaVelocityProcess' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, bFirstFallingFrame) == 0x001401, "Member 'UX6CharacterMovementComponent::bFirstFallingFrame' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, RedundantVelocity) == 0x001408, "Member 'UX6CharacterMovementComponent::RedundantVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, ImpartSpeedDeceleration) == 0x001420, "Member 'UX6CharacterMovementComponent::ImpartSpeedDeceleration' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, MaxHorizontalImpartSpeed) == 0x001424, "Member 'UX6CharacterMovementComponent::MaxHorizontalImpartSpeed' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, CurrentHorizontalImpartVelocity) == 0x001428, "Member 'UX6CharacterMovementComponent::CurrentHorizontalImpartVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, OldHorizontalImpartVelocity) == 0x001440, "Member 'UX6CharacterMovementComponent::OldHorizontalImpartVelocity' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, FrozenChracterMovementTag) == 0x001478, "Member 'UX6CharacterMovementComponent::FrozenChracterMovementTag' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, OnCharacterHasVelocityStateChanged) == 0x001480, "Member 'UX6CharacterMovementComponent::OnCharacterHasVelocityStateChanged' has a wrong offset!");
static_assert(offsetof(UX6CharacterMovementComponent, GravityDisabledTags) == 0x001488, "Member 'UX6CharacterMovementComponent::GravityDisabledTags' has a wrong offset!");

// Class X6Game.X6CustomizeMovementComponentBase
// 0x0000 (0x14E0 - 0x14E0)
class UX6CustomizeMovementComponentBase : public UX6CharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CustomizeMovementComponentBase">();
	}
	static class UX6CustomizeMovementComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CustomizeMovementComponentBase>();
	}
};
static_assert(alignof(UX6CustomizeMovementComponentBase) == 0x000010, "Wrong alignment on UX6CustomizeMovementComponentBase");
static_assert(sizeof(UX6CustomizeMovementComponentBase) == 0x0014E0, "Wrong size on UX6CustomizeMovementComponentBase");

// Class X6Game.FixedStepSizeMovementComponent
// 0x0050 (0x1530 - 0x14E0)
class UFixedStepSizeMovementComponent final : public UX6CustomizeMovementComponentBase
{
public:
	TMulticastInlineDelegate<void(bool bStartOrEnd, float CurrentStepScale)> OnUpdateStepMovementData; // 0x14E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         WaitIntervalEachStep;                              // 0x14F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepSize;                                          // 0x14F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinStepSizeScale;                                  // 0x14F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxStepSizeScale;                                  // 0x14FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentStepScale;                                  // 0x1500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1504[0x2C];                                    // 0x1504(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedStepSizeMovementComponent">();
	}
	static class UFixedStepSizeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedStepSizeMovementComponent>();
	}
};
static_assert(alignof(UFixedStepSizeMovementComponent) == 0x000010, "Wrong alignment on UFixedStepSizeMovementComponent");
static_assert(sizeof(UFixedStepSizeMovementComponent) == 0x001530, "Wrong size on UFixedStepSizeMovementComponent");
static_assert(offsetof(UFixedStepSizeMovementComponent, OnUpdateStepMovementData) == 0x0014E0, "Member 'UFixedStepSizeMovementComponent::OnUpdateStepMovementData' has a wrong offset!");
static_assert(offsetof(UFixedStepSizeMovementComponent, WaitIntervalEachStep) == 0x0014F0, "Member 'UFixedStepSizeMovementComponent::WaitIntervalEachStep' has a wrong offset!");
static_assert(offsetof(UFixedStepSizeMovementComponent, StepSize) == 0x0014F4, "Member 'UFixedStepSizeMovementComponent::StepSize' has a wrong offset!");
static_assert(offsetof(UFixedStepSizeMovementComponent, MinStepSizeScale) == 0x0014F8, "Member 'UFixedStepSizeMovementComponent::MinStepSizeScale' has a wrong offset!");
static_assert(offsetof(UFixedStepSizeMovementComponent, MaxStepSizeScale) == 0x0014FC, "Member 'UFixedStepSizeMovementComponent::MaxStepSizeScale' has a wrong offset!");
static_assert(offsetof(UFixedStepSizeMovementComponent, CurrentStepScale) == 0x001500, "Member 'UFixedStepSizeMovementComponent::CurrentStepScale' has a wrong offset!");

// Class X6Game.X6CircularListEntry
// 0x0000 (0x0000 - 0x0000)
class IX6CircularListEntry final : public IInterface
{
public:
	void OnEntryReleased();
	void OnItemSelectionChanged(bool bIsSelected);
	void OnListItemObjectSet(class UObject* ListItemObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CircularListEntry">();
	}
	static class IX6CircularListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6CircularListEntry>();
	}
};
static_assert(alignof(IX6CircularListEntry) == 0x000001, "Wrong alignment on IX6CircularListEntry");
static_assert(sizeof(IX6CircularListEntry) == 0x000001, "Wrong size on IX6CircularListEntry");

// Class X6Game.X6CircularListEntryLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6CircularListEntryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* GetListItemObject(TScriptInterface<class IX6CircularListEntry> X6CircularListEntry);
	static class UX6CircularListView* GetOwningListView(TScriptInterface<class IX6CircularListEntry> X6CircularListEntry);
	static bool IsListItemSelected(TScriptInterface<class IX6CircularListEntry> X6CircularListEntry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CircularListEntryLibrary">();
	}
	static class UX6CircularListEntryLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CircularListEntryLibrary>();
	}
};
static_assert(alignof(UX6CircularListEntryLibrary) == 0x000008, "Wrong alignment on UX6CircularListEntryLibrary");
static_assert(sizeof(UX6CircularListEntryLibrary) == 0x000028, "Wrong size on UX6CircularListEntryLibrary");

// Class X6Game.LocomotionRequestInterface
// 0x0000 (0x0000 - 0x0000)
class ILocomotionRequestInterface final : public IInterface
{
public:
	void RequestEnableInterruptAnimation();
	bool RequestTurnInPlaceByAngle(float InAngleToTurn, const TDelegate<void()>& OnComplete, const TDelegate<void()>& OnInterrupt);
	void SetCanInterruptPendingStopState(const bool bCanInterrupt);

	bool CanEverTurnInPlace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionRequestInterface">();
	}
	static class ILocomotionRequestInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILocomotionRequestInterface>();
	}
};
static_assert(alignof(ILocomotionRequestInterface) == 0x000001, "Wrong alignment on ILocomotionRequestInterface");
static_assert(sizeof(ILocomotionRequestInterface) == 0x000001, "Wrong size on ILocomotionRequestInterface");

// Class X6Game.LocomotionRequestObjectBase
// 0x0008 (0x0030 - 0x0028)
class ULocomotionRequestObjectBase final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionRequestObjectBase">();
	}
	static class ULocomotionRequestObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionRequestObjectBase>();
	}
};
static_assert(alignof(ULocomotionRequestObjectBase) == 0x000008, "Wrong alignment on ULocomotionRequestObjectBase");
static_assert(sizeof(ULocomotionRequestObjectBase) == 0x000030, "Wrong size on ULocomotionRequestObjectBase");

// Class X6Game.LookAtLogicHandler
// 0x01C0 (0x01E8 - 0x0028)
class ULookAtLogicHandler final : public UObject
{
public:
	class ULookAtConfigTemplate*                  DA_FocusConfig;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULookAtEventDefTemplate*                DA_FocusEventDef;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtEventRefreshInterval;                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AORefreshInterval;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTurnInPlaceAngle;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x14];                                      // 0x0044(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrawDebugLookAtLocation;                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugLookAtDirection;                         // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugNarrowAimOffsetRange;                    // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSaccade;                                    // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGazeDiversion;                              // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomBlinkRange;                                 // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRuntimeBlink;                               // 0x005E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SaccadeRandomWeight;                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GazeDiversionRandomWeight;                         // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EyeBlinkCoolDownRandomRange;                       // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EyeDetailCoolDownRandomRange;                      // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDetailMaxDistanceRange;                         // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDetailAnimWeightMinRange;                       // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xB4];                                      // 0x0090(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultLookAtDistance;                             // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELookAtEventType                              FaceTowardsLookAtEventType;                        // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x9F];                                     // 0x0149(0x009F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintDeinit();
	void BlueprintInit(class UX6GeneralAnimationDataComponent* InOwnerComponent);
	void BlueprintTick(float DeltaTime);
	void EyeBlinkOnce(bool bRandomBlink, bool bForce);
	struct FVector GetActorLookAtOffset(class AActor* InActor);
	void OnEyeBlinkEnd();
	void OnTurnInPlaceComplete();
	void OnTurnInPlaceInterrupted();
	void PauseLookAt();
	void ResumeLookAt();
	void SetCanOwnerActorDoLookAt(bool bInCanOwnerActorDoLookAt);

	class AActor* GetOwner() const;
	class UX6GeneralAnimationDataComponent* GetOwnerComponent() const;
	bool IsEyeBlinking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtLogicHandler">();
	}
	static class ULookAtLogicHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtLogicHandler>();
	}
};
static_assert(alignof(ULookAtLogicHandler) == 0x000008, "Wrong alignment on ULookAtLogicHandler");
static_assert(sizeof(ULookAtLogicHandler) == 0x0001E8, "Wrong size on ULookAtLogicHandler");
static_assert(offsetof(ULookAtLogicHandler, DA_FocusConfig) == 0x000028, "Member 'ULookAtLogicHandler::DA_FocusConfig' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, DA_FocusEventDef) == 0x000030, "Member 'ULookAtLogicHandler::DA_FocusEventDef' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, LookAtEventRefreshInterval) == 0x000038, "Member 'ULookAtLogicHandler::LookAtEventRefreshInterval' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, AORefreshInterval) == 0x00003C, "Member 'ULookAtLogicHandler::AORefreshInterval' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, TriggerTurnInPlaceAngle) == 0x000040, "Member 'ULookAtLogicHandler::TriggerTurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bDrawDebugLookAtLocation) == 0x000058, "Member 'ULookAtLogicHandler::bDrawDebugLookAtLocation' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bDrawDebugLookAtDirection) == 0x000059, "Member 'ULookAtLogicHandler::bDrawDebugLookAtDirection' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bDrawDebugNarrowAimOffsetRange) == 0x00005A, "Member 'ULookAtLogicHandler::bDrawDebugNarrowAimOffsetRange' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bEnableSaccade) == 0x00005B, "Member 'ULookAtLogicHandler::bEnableSaccade' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bEnableGazeDiversion) == 0x00005C, "Member 'ULookAtLogicHandler::bEnableGazeDiversion' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bRandomBlinkRange) == 0x00005D, "Member 'ULookAtLogicHandler::bRandomBlinkRange' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, bEnableRuntimeBlink) == 0x00005E, "Member 'ULookAtLogicHandler::bEnableRuntimeBlink' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, SaccadeRandomWeight) == 0x000060, "Member 'ULookAtLogicHandler::SaccadeRandomWeight' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, GazeDiversionRandomWeight) == 0x000064, "Member 'ULookAtLogicHandler::GazeDiversionRandomWeight' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, EyeBlinkCoolDownRandomRange) == 0x000068, "Member 'ULookAtLogicHandler::EyeBlinkCoolDownRandomRange' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, EyeDetailCoolDownRandomRange) == 0x000078, "Member 'ULookAtLogicHandler::EyeDetailCoolDownRandomRange' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, EyeDetailMaxDistanceRange) == 0x000088, "Member 'ULookAtLogicHandler::EyeDetailMaxDistanceRange' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, EyeDetailAnimWeightMinRange) == 0x00008C, "Member 'ULookAtLogicHandler::EyeDetailAnimWeightMinRange' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, DefaultLookAtDistance) == 0x000144, "Member 'ULookAtLogicHandler::DefaultLookAtDistance' has a wrong offset!");
static_assert(offsetof(ULookAtLogicHandler, FaceTowardsLookAtEventType) == 0x000148, "Member 'ULookAtLogicHandler::FaceTowardsLookAtEventType' has a wrong offset!");

// Class X6Game.LookAtConfigTemplate
// 0x0060 (0x0090 - 0x0030)
class ULookAtConfigTemplate final : public UPrimaryDataAsset
{
public:
	float                                         AOPitchMin;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOPitchMax;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOYawMin;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOYawMax;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchOffsetDeadZone;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffsetDeadZone;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeYawOffsetScale;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyePitchOffsetScale;                               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeYawOffsetRange;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyePitchOffsetRange;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffsetBlinkTriggerBound;                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchOffsetBlinkTriggerBound;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EyeYawOffsetMapping;                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EyePitchOffsetMapping;                             // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusRadius;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTurnInPlaceAngle;                           // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceMinAngle;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      DebugTraceForObjects;                              // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtConfigTemplate">();
	}
	static class ULookAtConfigTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtConfigTemplate>();
	}
};
static_assert(alignof(ULookAtConfigTemplate) == 0x000008, "Wrong alignment on ULookAtConfigTemplate");
static_assert(sizeof(ULookAtConfigTemplate) == 0x000090, "Wrong size on ULookAtConfigTemplate");
static_assert(offsetof(ULookAtConfigTemplate, AOPitchMin) == 0x000030, "Member 'ULookAtConfigTemplate::AOPitchMin' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, AOPitchMax) == 0x000034, "Member 'ULookAtConfigTemplate::AOPitchMax' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, AOYawMin) == 0x000038, "Member 'ULookAtConfigTemplate::AOYawMin' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, AOYawMax) == 0x00003C, "Member 'ULookAtConfigTemplate::AOYawMax' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, PitchOffsetDeadZone) == 0x000040, "Member 'ULookAtConfigTemplate::PitchOffsetDeadZone' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, YawOffsetDeadZone) == 0x000044, "Member 'ULookAtConfigTemplate::YawOffsetDeadZone' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, EyeYawOffsetScale) == 0x000048, "Member 'ULookAtConfigTemplate::EyeYawOffsetScale' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, EyePitchOffsetScale) == 0x00004C, "Member 'ULookAtConfigTemplate::EyePitchOffsetScale' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, EyeYawOffsetRange) == 0x000050, "Member 'ULookAtConfigTemplate::EyeYawOffsetRange' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, EyePitchOffsetRange) == 0x000054, "Member 'ULookAtConfigTemplate::EyePitchOffsetRange' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, YawOffsetBlinkTriggerBound) == 0x000058, "Member 'ULookAtConfigTemplate::YawOffsetBlinkTriggerBound' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, PitchOffsetBlinkTriggerBound) == 0x00005C, "Member 'ULookAtConfigTemplate::PitchOffsetBlinkTriggerBound' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, EyeYawOffsetMapping) == 0x000060, "Member 'ULookAtConfigTemplate::EyeYawOffsetMapping' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, EyePitchOffsetMapping) == 0x000068, "Member 'ULookAtConfigTemplate::EyePitchOffsetMapping' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, FocusRadius) == 0x000070, "Member 'ULookAtConfigTemplate::FocusRadius' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, TriggerTurnInPlaceAngle) == 0x000074, "Member 'ULookAtConfigTemplate::TriggerTurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, TurnInPlaceMinAngle) == 0x000078, "Member 'ULookAtConfigTemplate::TurnInPlaceMinAngle' has a wrong offset!");
static_assert(offsetof(ULookAtConfigTemplate, DebugTraceForObjects) == 0x000080, "Member 'ULookAtConfigTemplate::DebugTraceForObjects' has a wrong offset!");

// Class X6Game.LookAtEventDefTemplate
// 0x0050 (0x0080 - 0x0030)
class ULookAtEventDefTemplate final : public UPrimaryDataAsset
{
public:
	TMap<ELookAtEventType, struct FLookAtEventInfo> LookAtEventDef;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtEventDefTemplate">();
	}
	static class ULookAtEventDefTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtEventDefTemplate>();
	}
};
static_assert(alignof(ULookAtEventDefTemplate) == 0x000008, "Wrong alignment on ULookAtEventDefTemplate");
static_assert(sizeof(ULookAtEventDefTemplate) == 0x000080, "Wrong size on ULookAtEventDefTemplate");
static_assert(offsetof(ULookAtEventDefTemplate, LookAtEventDef) == 0x000030, "Member 'ULookAtEventDefTemplate::LookAtEventDef' has a wrong offset!");

// Class X6Game.X6ActorComponent
// 0x0000 (0x00A8 - 0x00A8)
class UX6ActorComponent : public UActorComponent
{
public:
	void AttributeChange(const class FString& AttributeName);
	void SetAttributeChangeToSave(bool Change);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ActorComponent">();
	}
	static class UX6ActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ActorComponent>();
	}
};
static_assert(alignof(UX6ActorComponent) == 0x000008, "Wrong alignment on UX6ActorComponent");
static_assert(sizeof(UX6ActorComponent) == 0x0000A8, "Wrong size on UX6ActorComponent");

// Class X6Game.MainCharacterRPCHelperBaseComponent
// 0x0000 (0x00A8 - 0x00A8)
class UMainCharacterRPCHelperBaseComponent final : public UX6ActorComponent
{
public:
	void BP_OnMulticastRemoveLookAtActor(const ELookAtEventType LookAtEventType, class AActor* TargetActor, const bool bClearAll);
	void BP_OnMulticastRemoveLookAtEventsByType(const ELookAtEventType LookAtEventType, const bool bClearAll);
	void BP_OnMulticastRemoveLookAtLocation(const ELookAtEventType LookAtEventType, const bool bClearAll);
	void BP_OnMulticastRequestLookAtActor(const ELookAtEventType LookAtEventType, class AActor* TargetActor, const struct FLookAtRequestParams& Params_0);
	void BP_OnMulticastRequestLookAtLocation(const ELookAtEventType LookAtEventType, const struct FVector& TargetLocation);
	void Multicast_RemoveLookAtActor(const ELookAtEventType LookAtEventType, class AActor* TargetActor, const bool bClearAll);
	void Multicast_RemoveLookAtEventsByType(const ELookAtEventType LookAtEventType, const bool bClearAll);
	void Multicast_RemoveLookAtLocation(const ELookAtEventType LookAtEventType, const bool bClearAll);
	void Multicast_RequestLookAtActor(const ELookAtEventType LookAtEventType, class AActor* TargetActor, const struct FLookAtRequestParams& Params_0);
	void Multicast_RequestLookAtLocation(const ELookAtEventType LookAtEventType, const struct FVector& TargetLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainCharacterRPCHelperBaseComponent">();
	}
	static class UMainCharacterRPCHelperBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainCharacterRPCHelperBaseComponent>();
	}
};
static_assert(alignof(UMainCharacterRPCHelperBaseComponent) == 0x000008, "Wrong alignment on UMainCharacterRPCHelperBaseComponent");
static_assert(sizeof(UMainCharacterRPCHelperBaseComponent) == 0x0000A8, "Wrong size on UMainCharacterRPCHelperBaseComponent");

// Class X6Game.MaskWidget
// 0x0218 (0x03A0 - 0x0188)
class UMaskWidget final : public UWidget
{
public:
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaskWidgetStyle                       WidgetStyle;                                       // 0x0190(0x01D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           BgColorAndOpacity;                                 // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BgColorAndOpacityDelegate;                         // 0x0370(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent; // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddMaskClickClip(const struct FVector2D& Position, const struct FVector2D& Size, class UTexture2D* Mask);
	void EnableMaskClickClip(const int32& ClipIndex, bool Enable);
	bool RemoveMaskClickClip(const int32& ClipIndex);
	void SetBgColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetBgImage(class UTexture2D* Tex, bool bMatchSize);
	void SetBgOpacity(float InOpacity);
	void SetBrushTintColor(const struct FSlateColor& TintColor);
	void SetMaskImage(const int32& ClipIndex, class UTexture2D* Tex);
	void SetMaskPos(const int32& ClipIndex, const struct FVector2D& Pos);
	void SetMaskPosSize(const int32& ClipIndex, const struct FVector4& PosSize);
	void SetMaskPosSizeXYZW(const int32& ClipIndex, const float& X, const float& Y, const float& Z, const float& W);
	void SetMaskPosXY(const int32& ClipIndex, const float& X, const float& Y);
	void SetMaskSize(const int32& ClipIndex, const struct FVector2D& Size);
	void SetMaskSizeXY(const int32& ClipIndex, const float& X, const float& Y);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaskWidget">();
	}
	static class UMaskWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaskWidget>();
	}
};
static_assert(alignof(UMaskWidget) == 0x000010, "Wrong alignment on UMaskWidget");
static_assert(sizeof(UMaskWidget) == 0x0003A0, "Wrong size on UMaskWidget");
static_assert(offsetof(UMaskWidget, WidgetStyle) == 0x000190, "Member 'UMaskWidget::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UMaskWidget, BgColorAndOpacity) == 0x000360, "Member 'UMaskWidget::BgColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UMaskWidget, BgColorAndOpacityDelegate) == 0x000370, "Member 'UMaskWidget::BgColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UMaskWidget, OnMouseButtonDownEvent) == 0x000380, "Member 'UMaskWidget::OnMouseButtonDownEvent' has a wrong offset!");

// Class X6Game.NikkiClothAnimInstance
// 0x0040 (0x0450 - 0x0410)
class UNikkiClothAnimInstance final : public UX6ClothAnimInstance
{
public:
	float                                         ClothBoneFollowAlpha;                              // 0x0408(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NikkiRigLiftLegAlpha;                              // 0x040C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StylizedDressIK;                                   // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NikkiPhysicsAlpha;                                 // 0x0414(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NikkiPhysicsAlphaInternal;                         // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0xC];                                      // 0x041C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateSitHorizontalControlRig;                    // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SitOnGround_RigAlpha;                              // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SitOnChair_RigAlpha;                               // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Sit_RigAlpha;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENikki_HeightFieldMethod                      Sit_Height_Field_Method;                           // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EControlBoneType                              Sit_Excute_Type;                                   // 0x0439(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43A[0x2];                                      // 0x043A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SitOnStool_RigAlpha;                               // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SitBesideObject_RigAlpha;                          // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SitOnGroundUsingChair_RigAlpha;                    // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SitSidewaysOnGround_RigAlpha;                      // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSitRigCurveValue(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NikkiClothAnimInstance">();
	}
	static class UNikkiClothAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNikkiClothAnimInstance>();
	}
};
static_assert(alignof(UNikkiClothAnimInstance) == 0x000010, "Wrong alignment on UNikkiClothAnimInstance");
static_assert(sizeof(UNikkiClothAnimInstance) == 0x000450, "Wrong size on UNikkiClothAnimInstance");
static_assert(offsetof(UNikkiClothAnimInstance, ClothBoneFollowAlpha) == 0x000408, "Member 'UNikkiClothAnimInstance::ClothBoneFollowAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, NikkiRigLiftLegAlpha) == 0x00040C, "Member 'UNikkiClothAnimInstance::NikkiRigLiftLegAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, StylizedDressIK) == 0x000410, "Member 'UNikkiClothAnimInstance::StylizedDressIK' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, NikkiPhysicsAlpha) == 0x000414, "Member 'UNikkiClothAnimInstance::NikkiPhysicsAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, NikkiPhysicsAlphaInternal) == 0x000418, "Member 'UNikkiClothAnimInstance::NikkiPhysicsAlphaInternal' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, bUpdateSitHorizontalControlRig) == 0x000428, "Member 'UNikkiClothAnimInstance::bUpdateSitHorizontalControlRig' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, SitOnGround_RigAlpha) == 0x00042C, "Member 'UNikkiClothAnimInstance::SitOnGround_RigAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, SitOnChair_RigAlpha) == 0x000430, "Member 'UNikkiClothAnimInstance::SitOnChair_RigAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, Sit_RigAlpha) == 0x000434, "Member 'UNikkiClothAnimInstance::Sit_RigAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, Sit_Height_Field_Method) == 0x000438, "Member 'UNikkiClothAnimInstance::Sit_Height_Field_Method' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, Sit_Excute_Type) == 0x000439, "Member 'UNikkiClothAnimInstance::Sit_Excute_Type' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, SitOnStool_RigAlpha) == 0x00043C, "Member 'UNikkiClothAnimInstance::SitOnStool_RigAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, SitBesideObject_RigAlpha) == 0x000440, "Member 'UNikkiClothAnimInstance::SitBesideObject_RigAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, SitOnGroundUsingChair_RigAlpha) == 0x000444, "Member 'UNikkiClothAnimInstance::SitOnGroundUsingChair_RigAlpha' has a wrong offset!");
static_assert(offsetof(UNikkiClothAnimInstance, SitSidewaysOnGround_RigAlpha) == 0x000448, "Member 'UNikkiClothAnimInstance::SitSidewaysOnGround_RigAlpha' has a wrong offset!");

// Class X6Game.NikkiJumpLocomotionAnimInstance
// 0x0010 (0x0500 - 0x04F0)
class UNikkiJumpLocomotionAnimInstance final : public UPlayerLocomotionAnimInstance
{
public:
	struct FJumpAnimationState                    JumpAnimationState;                                // 0x04F0(0x0003)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F3[0x1];                                      // 0x04F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VaultType;                                         // 0x04F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetJumpMainState(ENikkiJumpState InJumpState);
	void SetJumpState_Fall(ENikkiJumpState_Fall InFall);
	void SetJumpState_TakeOff(ENikkiJumpState_TakeOff InTakeOff);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NikkiJumpLocomotionAnimInstance">();
	}
	static class UNikkiJumpLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNikkiJumpLocomotionAnimInstance>();
	}
};
static_assert(alignof(UNikkiJumpLocomotionAnimInstance) == 0x000010, "Wrong alignment on UNikkiJumpLocomotionAnimInstance");
static_assert(sizeof(UNikkiJumpLocomotionAnimInstance) == 0x000500, "Wrong size on UNikkiJumpLocomotionAnimInstance");
static_assert(offsetof(UNikkiJumpLocomotionAnimInstance, JumpAnimationState) == 0x0004F0, "Member 'UNikkiJumpLocomotionAnimInstance::JumpAnimationState' has a wrong offset!");
static_assert(offsetof(UNikkiJumpLocomotionAnimInstance, VaultType) == 0x0004F4, "Member 'UNikkiJumpLocomotionAnimInstance::VaultType' has a wrong offset!");

// Class X6Game.NikkiMovementComponent
// 0x0050 (0x1530 - 0x14E0)
class UNikkiMovementComponent final : public UX6CharacterMovementComponent
{
public:
	TMulticastInlineDelegate<void()>              OnCrouchPreStartDelegate;                          // 0x14E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCrouchPostStartDelegate;                         // 0x14F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCrouchEndDelegate;                               // 0x1500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1510[0x20];                                    // 0x1510(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_CrouchWithEvent(bool bClientSimulation);
	bool K2_IsValidLandingSpot(const struct FVector& CapsuleLocation, const struct FHitResult& Hit);
	bool K2_StepUp(const struct FVector& GravDir, const struct FVector& Delta, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NikkiMovementComponent">();
	}
	static class UNikkiMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNikkiMovementComponent>();
	}
};
static_assert(alignof(UNikkiMovementComponent) == 0x000010, "Wrong alignment on UNikkiMovementComponent");
static_assert(sizeof(UNikkiMovementComponent) == 0x001530, "Wrong size on UNikkiMovementComponent");
static_assert(offsetof(UNikkiMovementComponent, OnCrouchPreStartDelegate) == 0x0014E0, "Member 'UNikkiMovementComponent::OnCrouchPreStartDelegate' has a wrong offset!");
static_assert(offsetof(UNikkiMovementComponent, OnCrouchPostStartDelegate) == 0x0014F0, "Member 'UNikkiMovementComponent::OnCrouchPostStartDelegate' has a wrong offset!");
static_assert(offsetof(UNikkiMovementComponent, OnCrouchEndDelegate) == 0x001500, "Member 'UNikkiMovementComponent::OnCrouchEndDelegate' has a wrong offset!");

// Class X6Game.NPCLocomotionTemplateBase
// 0x03D0 (0x07A0 - 0x03D0)
class UNPCLocomotionTemplateBase final : public UAnimInstance
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x50];                                     // 0x03D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopTurnAngle;                                     // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          StopL0Animation;                                   // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StopL90Animation;                                  // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StopL180Animation;                                 // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopTurnValid;                                    // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCLocomotionAnimSet                  AnimSet;                                           // 0x0450(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x28];                                     // 0x0500(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, ERootMotionMode>            StateRootMotionModeMap;                            // 0x0528(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   LocomotionStateMachineName;                        // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SimpleLocomotionStateMachineName;                  // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TurnInPlaceStateName;                              // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartStateName;                                    // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StopStateName;                                     // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CycleStateName;                                    // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CycleBlendSpaceSampleCount;                        // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x05AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UX6CharacterMovementComponent> OwnerX6CharacterMovement;                    // 0x05B4(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UX6GeneralAnimationDataComponent> OwnerAnimDataComponent;                   // 0x05BC(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSimpleLocomotion;                              // 0x05C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAcceleration;                                  // 0x05C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C6[0x2];                                      // 0x05C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x05C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OrientationAngle;                                  // 0x05CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationAngle;                                 // 0x05D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentStateEnded;                                // 0x05D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D5[0x3];                                      // 0x05D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchSequences>                StopSequences;                                     // 0x05D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0xC];                                      // 0x05E8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNeedMirror;                                       // 0x05F4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TurnInPlaceCachePoseName;                          // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingTurnInPlace;                               // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceAngle;                                  // 0x0604(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStart;                                      // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTurnAngle;                                    // 0x060C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              StartAngleMapOutputRange;                          // 0x0610(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              StartAngleMapInputRange;                           // 0x0620(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CanInterruptStateTriggerName;                      // 0x0630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TurnInPlaceAngleMapOutputRange;                    // 0x0638(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TurnInPlaceAngleMapInputRange;                     // 0x0648(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CycleBlendSpace1DInput;                            // 0x0658(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65C[0x4];                                      // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  CycleSequences;                                    // 0x0660(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bCanInterruptCurrentState;                         // 0x0670(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanInterruptPendingStopState;                     // 0x0671(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopInterrupted;                                  // 0x0672(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnyMontagePlaying;                                // 0x0673(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_674[0x12C];                                    // 0x0674(0x012C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAutomaticRuleStateUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnMirrorIdleTransitionSequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnOutputPoseBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnOutputPoseInitialUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStarFSequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStarL180SequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStarL90SequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopL0SequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopL180SequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopL90SequencePlayerBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopSequencePlayerUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopStateUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnTurnInPlaceStateBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCLocomotionTemplateBase">();
	}
	static class UNPCLocomotionTemplateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCLocomotionTemplateBase>();
	}
};
static_assert(alignof(UNPCLocomotionTemplateBase) == 0x000010, "Wrong alignment on UNPCLocomotionTemplateBase");
static_assert(sizeof(UNPCLocomotionTemplateBase) == 0x0007A0, "Wrong size on UNPCLocomotionTemplateBase");
static_assert(offsetof(UNPCLocomotionTemplateBase, MirrorDataTable) == 0x0003D0, "Member 'UNPCLocomotionTemplateBase::MirrorDataTable' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StopTurnAngle) == 0x000428, "Member 'UNPCLocomotionTemplateBase::StopTurnAngle' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StopL0Animation) == 0x000430, "Member 'UNPCLocomotionTemplateBase::StopL0Animation' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StopL90Animation) == 0x000438, "Member 'UNPCLocomotionTemplateBase::StopL90Animation' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StopL180Animation) == 0x000440, "Member 'UNPCLocomotionTemplateBase::StopL180Animation' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bStopTurnValid) == 0x000448, "Member 'UNPCLocomotionTemplateBase::bStopTurnValid' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, AnimSet) == 0x000450, "Member 'UNPCLocomotionTemplateBase::AnimSet' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StateRootMotionModeMap) == 0x000528, "Member 'UNPCLocomotionTemplateBase::StateRootMotionModeMap' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, LocomotionStateMachineName) == 0x000578, "Member 'UNPCLocomotionTemplateBase::LocomotionStateMachineName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, SimpleLocomotionStateMachineName) == 0x000580, "Member 'UNPCLocomotionTemplateBase::SimpleLocomotionStateMachineName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, TurnInPlaceStateName) == 0x000588, "Member 'UNPCLocomotionTemplateBase::TurnInPlaceStateName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StartStateName) == 0x000590, "Member 'UNPCLocomotionTemplateBase::StartStateName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StopStateName) == 0x000598, "Member 'UNPCLocomotionTemplateBase::StopStateName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, CycleStateName) == 0x0005A0, "Member 'UNPCLocomotionTemplateBase::CycleStateName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, CycleBlendSpaceSampleCount) == 0x0005A8, "Member 'UNPCLocomotionTemplateBase::CycleBlendSpaceSampleCount' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, OwnerActor) == 0x0005AC, "Member 'UNPCLocomotionTemplateBase::OwnerActor' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, OwnerX6CharacterMovement) == 0x0005B4, "Member 'UNPCLocomotionTemplateBase::OwnerX6CharacterMovement' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, OwnerAnimDataComponent) == 0x0005BC, "Member 'UNPCLocomotionTemplateBase::OwnerAnimDataComponent' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bUseSimpleLocomotion) == 0x0005C4, "Member 'UNPCLocomotionTemplateBase::bUseSimpleLocomotion' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bHasAcceleration) == 0x0005C5, "Member 'UNPCLocomotionTemplateBase::bHasAcceleration' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, Speed) == 0x0005C8, "Member 'UNPCLocomotionTemplateBase::Speed' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, OrientationAngle) == 0x0005CC, "Member 'UNPCLocomotionTemplateBase::OrientationAngle' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, AccelerationAngle) == 0x0005D0, "Member 'UNPCLocomotionTemplateBase::AccelerationAngle' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bCurrentStateEnded) == 0x0005D4, "Member 'UNPCLocomotionTemplateBase::bCurrentStateEnded' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StopSequences) == 0x0005D8, "Member 'UNPCLocomotionTemplateBase::StopSequences' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bNeedMirror) == 0x0005F4, "Member 'UNPCLocomotionTemplateBase::bNeedMirror' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, TurnInPlaceCachePoseName) == 0x0005F8, "Member 'UNPCLocomotionTemplateBase::TurnInPlaceCachePoseName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bPendingTurnInPlace) == 0x000600, "Member 'UNPCLocomotionTemplateBase::bPendingTurnInPlace' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, TurnInPlaceAngle) == 0x000604, "Member 'UNPCLocomotionTemplateBase::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bShouldStart) == 0x000608, "Member 'UNPCLocomotionTemplateBase::bShouldStart' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StartTurnAngle) == 0x00060C, "Member 'UNPCLocomotionTemplateBase::StartTurnAngle' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StartAngleMapOutputRange) == 0x000610, "Member 'UNPCLocomotionTemplateBase::StartAngleMapOutputRange' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, StartAngleMapInputRange) == 0x000620, "Member 'UNPCLocomotionTemplateBase::StartAngleMapInputRange' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, CanInterruptStateTriggerName) == 0x000630, "Member 'UNPCLocomotionTemplateBase::CanInterruptStateTriggerName' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, TurnInPlaceAngleMapOutputRange) == 0x000638, "Member 'UNPCLocomotionTemplateBase::TurnInPlaceAngleMapOutputRange' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, TurnInPlaceAngleMapInputRange) == 0x000648, "Member 'UNPCLocomotionTemplateBase::TurnInPlaceAngleMapInputRange' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, CycleBlendSpace1DInput) == 0x000658, "Member 'UNPCLocomotionTemplateBase::CycleBlendSpace1DInput' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, CycleSequences) == 0x000660, "Member 'UNPCLocomotionTemplateBase::CycleSequences' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bCanInterruptCurrentState) == 0x000670, "Member 'UNPCLocomotionTemplateBase::bCanInterruptCurrentState' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bCanInterruptPendingStopState) == 0x000671, "Member 'UNPCLocomotionTemplateBase::bCanInterruptPendingStopState' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bStopInterrupted) == 0x000672, "Member 'UNPCLocomotionTemplateBase::bStopInterrupted' has a wrong offset!");
static_assert(offsetof(UNPCLocomotionTemplateBase, bAnyMontagePlaying) == 0x000673, "Member 'UNPCLocomotionTemplateBase::bAnyMontagePlaying' has a wrong offset!");

// Class X6Game.PerceptionShape_Base
// 0x0000 (0x0028 - 0x0028)
class UPerceptionShape_Base : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerceptionShape_Base">();
	}
	static class UPerceptionShape_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerceptionShape_Base>();
	}
};
static_assert(alignof(UPerceptionShape_Base) == 0x000008, "Wrong alignment on UPerceptionShape_Base");
static_assert(sizeof(UPerceptionShape_Base) == 0x000028, "Wrong size on UPerceptionShape_Base");

// Class X6Game.PerceptionShape_Cone
// 0x0010 (0x0038 - 0x0028)
class UPerceptionShape_Cone final : public UPerceptionShape_Base
{
public:
	float                                         Radius;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HalfDegrees;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LostRadius;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LostHalfDegrees;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerceptionShape_Cone">();
	}
	static class UPerceptionShape_Cone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerceptionShape_Cone>();
	}
};
static_assert(alignof(UPerceptionShape_Cone) == 0x000008, "Wrong alignment on UPerceptionShape_Cone");
static_assert(sizeof(UPerceptionShape_Cone) == 0x000038, "Wrong size on UPerceptionShape_Cone");
static_assert(offsetof(UPerceptionShape_Cone, Radius) == 0x000028, "Member 'UPerceptionShape_Cone::Radius' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Cone, HalfDegrees) == 0x00002C, "Member 'UPerceptionShape_Cone::HalfDegrees' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Cone, LostRadius) == 0x000030, "Member 'UPerceptionShape_Cone::LostRadius' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Cone, LostHalfDegrees) == 0x000034, "Member 'UPerceptionShape_Cone::LostHalfDegrees' has a wrong offset!");

// Class X6Game.PerceptionShape_Sector
// 0x0018 (0x0040 - 0x0028)
class UPerceptionShape_Sector final : public UPerceptionShape_Base
{
public:
	float                                         Radius;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HalfDegrees;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HalfHeight;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LostRadius;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LostHalfDegrees;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LostHalfHeight;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerceptionShape_Sector">();
	}
	static class UPerceptionShape_Sector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerceptionShape_Sector>();
	}
};
static_assert(alignof(UPerceptionShape_Sector) == 0x000008, "Wrong alignment on UPerceptionShape_Sector");
static_assert(sizeof(UPerceptionShape_Sector) == 0x000040, "Wrong size on UPerceptionShape_Sector");
static_assert(offsetof(UPerceptionShape_Sector, Radius) == 0x000028, "Member 'UPerceptionShape_Sector::Radius' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Sector, HalfDegrees) == 0x00002C, "Member 'UPerceptionShape_Sector::HalfDegrees' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Sector, HalfHeight) == 0x000030, "Member 'UPerceptionShape_Sector::HalfHeight' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Sector, LostRadius) == 0x000034, "Member 'UPerceptionShape_Sector::LostRadius' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Sector, LostHalfDegrees) == 0x000038, "Member 'UPerceptionShape_Sector::LostHalfDegrees' has a wrong offset!");
static_assert(offsetof(UPerceptionShape_Sector, LostHalfHeight) == 0x00003C, "Member 'UPerceptionShape_Sector::LostHalfHeight' has a wrong offset!");

// Class X6Game.PlayerJumpPromptLineProcessor
// 0x0240 (0x0268 - 0x0028)
class UPlayerJumpPromptLineProcessor final : public UObject
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Niagara_JumpPromptLine_Standard_Buttom;            // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Niagara_JumpPromptLine_Standard_Middle;            // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Niagara_JumpPromptLine_Standard_Top;               // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Niagara_JumpPromptLandPoint_Legal;                 // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Niagara_JumpPromptLandPoint_Illegal;               // 0x00C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Niagara_JumpPromptLine_RealTime;                   // 0x00F0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugDrawJumpPromptLine;                    // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NiagaraParamName_PathPositions;                    // 0x011C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NiagaraParamName_CurveLength;                      // 0x0124(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultTagName;                                    // 0x012C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMantleMaxHeight;                             // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultTargetVelocityZ;                            // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxSimulationTime;                          // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultMaxSweepLastPostionWhenTraceVerticalSurface; // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           JumpCurveColor_ReachMaxDistance;                   // 0x0144(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           JumpCurveColor_NotReachMaxDistance;                // 0x0154(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAdvanceTime;                                    // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPromptLine_RealTime_AppearSpeed;               // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPromptLine_RealTime_DisappearSpeed;            // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEnableJumpPromptLineFeatureComplete;             // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableJumpPromptLineFeature;                      // 0x0190(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasPlayerStateToHideJumpCurve;                    // 0x0191(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bJumpCurveCanShow;                                 // 0x0192(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_193[0x5];                                      // 0x0193(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             EnableJumpPromptLineFeatureByTagSet;               // 0x0198(0x0050)(NativeAccessSpecifierPrivate)
	class ACharacter*                             OwnerActor;                                        // 0x01E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6RMWalkingComponent*                  MainCharacterRMWalkingComp;                        // 0x01F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6RMInAirComponent*                    MainCharacterRMInAirComp;                          // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        CurJumpCurveLocationTrack;                         // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraComponent_JumpPromptLine_Buttom;            // 0x0210(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraComponent_JumpPromptLine_Middle;            // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraComponent_JumpPromptLine_Top;               // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraComponent_JumpPromptAimPoint;               // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableDrawCurve;                                  // 0x0230(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableDrawCurve_RealTime;                         // 0x0231(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanReleaseToFall;                                 // 0x0232(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_233[0x5];                                      // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         Niagara_JumpPromptLine_Standard_Buttom_Ptr;        // 0x0238(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         Niagara_JumpPromptLine_Standard_Middle_Ptr;        // 0x0240(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         Niagara_JumpPromptLine_Standard_Top_Ptr;           // 0x0248(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         Niagara_JumpPromptLandPoint_Legal_Ptr;             // 0x0250(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         Niagara_JumpPromptLandPoint_Illegal_Ptr;           // 0x0258(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         Niagara_JumpPromptLine_RealTime_Ptr;               // 0x0260(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CanDoMantleInFalling(const struct FVector& CapsuleBaseLocation, const struct FVector& CurrentPlayerInputVector, const struct FVector& CurActorLocation);
	bool CanDrawPredictJumpCurve();
	bool CanDrawRealTimeJumpCurve(float CurrentSpeedXY);
	void DebugDrawPredicJumpCurveLineInWorldSpace(const struct FVector& WorldStartLocation, const TArray<struct FVector>& CurveTrack, const struct FLinearColor& LineColor, float Duration);
	void Deinitialize();
	void DrawPredictJumpCurve(float CosntGravityZ, float DeltaTime);
	void EnableJumpPromptLineFeature(bool bEnable, class FName Tag);
	bool HasPlayerStateToHideJumpCurve();
	bool IsEnableJumpPromptLineFeature();
	bool IsFXAssetLoaded();
	bool IsFXAssetPathNotNull();
	bool IsJumpCurveCanShow();
	void OnInitialize(class ACharacter* Owner, class UX6RMWalkingComponent* X6RMWalkingComponent, class UX6RMInAirComponent* X6RMInAirComponent);
	void SetEnableJumpPromptLineFeature(bool bEnable);
	void SetHasPlayerStateToHideJumpCurve(bool bEnable);
	void SetJumpCurveCanShow(bool bEnable);
	bool TryPointToPointJumping(const struct FVector& SourcePoint, const struct FVector& TargetPoint, struct FVector* OutVelocity, float SteppingSimulationTime, float CosntGravityZ, float MaxSimulationTime, bool EnableDebugDraw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerJumpPromptLineProcessor">();
	}
	static class UPlayerJumpPromptLineProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerJumpPromptLineProcessor>();
	}
};
static_assert(alignof(UPlayerJumpPromptLineProcessor) == 0x000008, "Wrong alignment on UPlayerJumpPromptLineProcessor");
static_assert(sizeof(UPlayerJumpPromptLineProcessor) == 0x000268, "Wrong size on UPlayerJumpPromptLineProcessor");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_Standard_Buttom) == 0x000028, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_Standard_Buttom' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_Standard_Middle) == 0x000050, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_Standard_Middle' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_Standard_Top) == 0x000078, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_Standard_Top' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLandPoint_Legal) == 0x0000A0, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLandPoint_Legal' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLandPoint_Illegal) == 0x0000C8, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLandPoint_Illegal' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_RealTime) == 0x0000F0, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_RealTime' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bEnableDebugDrawJumpPromptLine) == 0x000118, "Member 'UPlayerJumpPromptLineProcessor::bEnableDebugDrawJumpPromptLine' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, NiagaraParamName_PathPositions) == 0x00011C, "Member 'UPlayerJumpPromptLineProcessor::NiagaraParamName_PathPositions' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, NiagaraParamName_CurveLength) == 0x000124, "Member 'UPlayerJumpPromptLineProcessor::NiagaraParamName_CurveLength' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, DefaultTagName) == 0x00012C, "Member 'UPlayerJumpPromptLineProcessor::DefaultTagName' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, PlayerMantleMaxHeight) == 0x000134, "Member 'UPlayerJumpPromptLineProcessor::PlayerMantleMaxHeight' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, DefaultTargetVelocityZ) == 0x000138, "Member 'UPlayerJumpPromptLineProcessor::DefaultTargetVelocityZ' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, DefaultMaxSimulationTime) == 0x00013C, "Member 'UPlayerJumpPromptLineProcessor::DefaultMaxSimulationTime' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, DefaultMaxSweepLastPostionWhenTraceVerticalSurface) == 0x000140, "Member 'UPlayerJumpPromptLineProcessor::DefaultMaxSweepLastPostionWhenTraceVerticalSurface' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, JumpCurveColor_ReachMaxDistance) == 0x000144, "Member 'UPlayerJumpPromptLineProcessor::JumpCurveColor_ReachMaxDistance' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, JumpCurveColor_NotReachMaxDistance) == 0x000154, "Member 'UPlayerJumpPromptLineProcessor::JumpCurveColor_NotReachMaxDistance' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, MinAdvanceTime) == 0x000164, "Member 'UPlayerJumpPromptLineProcessor::MinAdvanceTime' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, JumpPromptLine_RealTime_AppearSpeed) == 0x000168, "Member 'UPlayerJumpPromptLineProcessor::JumpPromptLine_RealTime_AppearSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, JumpPromptLine_RealTime_DisappearSpeed) == 0x00016C, "Member 'UPlayerJumpPromptLineProcessor::JumpPromptLine_RealTime_DisappearSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, OnEnableJumpPromptLineFeatureComplete) == 0x000180, "Member 'UPlayerJumpPromptLineProcessor::OnEnableJumpPromptLineFeatureComplete' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bEnableJumpPromptLineFeature) == 0x000190, "Member 'UPlayerJumpPromptLineProcessor::bEnableJumpPromptLineFeature' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bHasPlayerStateToHideJumpCurve) == 0x000191, "Member 'UPlayerJumpPromptLineProcessor::bHasPlayerStateToHideJumpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bJumpCurveCanShow) == 0x000192, "Member 'UPlayerJumpPromptLineProcessor::bJumpCurveCanShow' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, EnableJumpPromptLineFeatureByTagSet) == 0x000198, "Member 'UPlayerJumpPromptLineProcessor::EnableJumpPromptLineFeatureByTagSet' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, OwnerActor) == 0x0001E8, "Member 'UPlayerJumpPromptLineProcessor::OwnerActor' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, MainCharacterRMWalkingComp) == 0x0001F0, "Member 'UPlayerJumpPromptLineProcessor::MainCharacterRMWalkingComp' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, MainCharacterRMInAirComp) == 0x0001F8, "Member 'UPlayerJumpPromptLineProcessor::MainCharacterRMInAirComp' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, CurJumpCurveLocationTrack) == 0x000200, "Member 'UPlayerJumpPromptLineProcessor::CurJumpCurveLocationTrack' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, NiagaraComponent_JumpPromptLine_Buttom) == 0x000210, "Member 'UPlayerJumpPromptLineProcessor::NiagaraComponent_JumpPromptLine_Buttom' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, NiagaraComponent_JumpPromptLine_Middle) == 0x000218, "Member 'UPlayerJumpPromptLineProcessor::NiagaraComponent_JumpPromptLine_Middle' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, NiagaraComponent_JumpPromptLine_Top) == 0x000220, "Member 'UPlayerJumpPromptLineProcessor::NiagaraComponent_JumpPromptLine_Top' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, NiagaraComponent_JumpPromptAimPoint) == 0x000228, "Member 'UPlayerJumpPromptLineProcessor::NiagaraComponent_JumpPromptAimPoint' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bEnableDrawCurve) == 0x000230, "Member 'UPlayerJumpPromptLineProcessor::bEnableDrawCurve' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bEnableDrawCurve_RealTime) == 0x000231, "Member 'UPlayerJumpPromptLineProcessor::bEnableDrawCurve_RealTime' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, bCanReleaseToFall) == 0x000232, "Member 'UPlayerJumpPromptLineProcessor::bCanReleaseToFall' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_Standard_Buttom_Ptr) == 0x000238, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_Standard_Buttom_Ptr' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_Standard_Middle_Ptr) == 0x000240, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_Standard_Middle_Ptr' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_Standard_Top_Ptr) == 0x000248, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_Standard_Top_Ptr' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLandPoint_Legal_Ptr) == 0x000250, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLandPoint_Legal_Ptr' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLandPoint_Illegal_Ptr) == 0x000258, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLandPoint_Illegal_Ptr' has a wrong offset!");
static_assert(offsetof(UPlayerJumpPromptLineProcessor, Niagara_JumpPromptLine_RealTime_Ptr) == 0x000260, "Member 'UPlayerJumpPromptLineProcessor::Niagara_JumpPromptLine_RealTime_Ptr' has a wrong offset!");

// Class X6Game.PlayerLocomotionLogicProxy
// 0x01A8 (0x01D0 - 0x0028)
class UPlayerLocomotionLogicProxy final : public UObject
{
public:
	class ACharacter*                             CharacterOwner;                                    // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             TurnAroundMoveUpdatedHitResult;                    // 0x0030(0x00F8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FRotator                               LastTargetRotation;                                // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFrameInputContext>             RecentFrameInputContexts;                          // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FFrameInputContext                     CurFrameInputContext;                              // 0x0158(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x60];                                     // 0x0170(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CaculateCurRotationActorInterpSpeed(const struct FRotator& CurrentCameraRotation, const struct FRotator& PreCameraRotation, float CameraRYawClampUpperLimit, float CurveSampleValue, float DeltaSeconds, class UCurveFloat* RotateCurve, class UCurveFloat* RAngleToRYawSpeedRateMappingCurve, float CurrentTurnAroundAngle);
	void GatherCurrentCameraInformation(class AActor* PlayerCameraManager, bool bInputValid);
	struct FFrameInputContext GetCurFrameInputContext();
	float GetMappedSpeed(class UCharacterMovementComponent* CharacterMovementComponent, float LowerSpeedVal, float MiddleSpeedVal, float HighSpeedVal);
	float GetTurnAroundAngle(const struct FVector& InputMovingDirection, const struct FVector& CurrentForwardVector);
	void InitCameraContext(const struct FRotator& CurrentCameraRotation, const struct FRotator& PreCameraRotation, bool bCameraStateChanged, bool bOnNewTargetCameraBlendEnd);
	void InitInputConfigData(float LogicalFramesPerSecond, float PreStartFrames, bool bEnableStartMovingInputCache, float StartMovingInputCacheFrames, bool bEnableMutationCache, float MutationInputCacheFrames, bool bEnableInvalidInput, float InvalidInputFrames, float MutationInputSizeThreshold, float MutationInputDirectionThreshold);
	bool IsEnableMutationCache();
	bool IsNeedStartMovingCache();
	float ProcessBasicOnGroundTurnAroundMovementLogic(class UCharacterMovementComponent* CharacterMovementComponent, struct FRotator* CurrentTargetRotation, const struct FVector& InputMovingDirection, float RotationTargetInterpSpeed, float RotationActorInterpSpeed, float DeltaSeconds);
	bool ProcessInputValueCacheLogic(float DeltaSeconds, bool bIsMoving);
	void RecordCurInputInformation(float CurrentInputValForMoveForward, float CurrentInputValForMoveRight, float PreInputValForMoveForward, float PreInputValForMoveRight);
	void ReplayCameraContext(struct FRotator* CurrentCameraRotation, struct FRotator* PreCameraRotation, bool* bCameraStateChanged, bool* bOnNewTargetCameraBlendEnd);
	void ReplayCurInputInformation(float* PolishInputValForMoveForward, float* PolishInputValForMoveRight, float* PolishPreInputValForMoveForward, float* PolishPreInputValForMoveRight);
	void ResetInputCache();
	struct FRotator SmoothPlayerRotation(struct FRotator* CurrentTargetRotation, const struct FRotator& NewTargetRotation, const struct FRotator& CurActorRotation, float RotationTargetInterpSpeed, float RotationActorInterpSpeed, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLocomotionLogicProxy">();
	}
	static class UPlayerLocomotionLogicProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLocomotionLogicProxy>();
	}
};
static_assert(alignof(UPlayerLocomotionLogicProxy) == 0x000008, "Wrong alignment on UPlayerLocomotionLogicProxy");
static_assert(sizeof(UPlayerLocomotionLogicProxy) == 0x0001D0, "Wrong size on UPlayerLocomotionLogicProxy");
static_assert(offsetof(UPlayerLocomotionLogicProxy, CharacterOwner) == 0x000028, "Member 'UPlayerLocomotionLogicProxy::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionLogicProxy, TurnAroundMoveUpdatedHitResult) == 0x000030, "Member 'UPlayerLocomotionLogicProxy::TurnAroundMoveUpdatedHitResult' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionLogicProxy, LastTargetRotation) == 0x000128, "Member 'UPlayerLocomotionLogicProxy::LastTargetRotation' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionLogicProxy, RecentFrameInputContexts) == 0x000148, "Member 'UPlayerLocomotionLogicProxy::RecentFrameInputContexts' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionLogicProxy, CurFrameInputContext) == 0x000158, "Member 'UPlayerLocomotionLogicProxy::CurFrameInputContext' has a wrong offset!");

// Class X6Game.PlayerShadowDecalProcessor
// 0x02F8 (0x0320 - 0x0028)
class UPlayerShadowDecalProcessor final : public UObject
{
public:
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceCapsuleRadiusOffset;                          // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_CapsuleZOffset;                                  // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_MaxTraceDownHeight;                              // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_MaxJumpHeight;                                   // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                m_ShadowDecalSize;                                 // 0x0040(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            m_Curve_ShadowDecalDistanceMappedToScale2D;        // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_OpacityParamName;                                // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_BlurWeightParamName;                             // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_ScaleParamName;                                  // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_SphereTraceRadius;                               // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_CurrentDecalOpacity;                             // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_TargetShadowHeight;                              // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             m_TargetShadowTranform;                            // 0x0090(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             m_TargetShadowHitsult;                             // 0x00F0(0x00F8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             m_TargetShadowHitsultHight;                        // 0x01E8(0x00F8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsOnWaterSurface;                                 // 0x02E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterHeight;                                       // 0x02E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterHeightTraceMax;                               // 0x02E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WaterTraceProfileName;                             // 0x02EC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterHeightOnHideCubeMesh;                         // 0x02F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnFloorSurface;                                 // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHidePlane;                                  // 0x02F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHideCube;                                   // 0x02FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FB[0x5];                                      // 0x02FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlaneMeshLocationOffset;                           // 0x0300(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LineTraceCount;                                    // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CaculateShadowTargetInfo(class ACharacter* OwnerCharacter, class USkeletalMeshComponent* SkeletalMeshComponent);
	float GetRealCapsultHeight(class ACharacter* OwnerCharacter);
	void InitConfigInformation(float MaxTraceDownHeight, float MaxJumpHeight, const struct FVector& ShadowDecalSize, float SphereTraceRadius, class UCurveFloat* Curve_ShadowDecalDistanceMappedToScale2D);
	void InitShadowDynamicMIParam(class FName OpacityParamName, class FName BlurWeightParamName, class FName ScaleParamName);
	void UpdateDecalMaterialInstanceParam(float DeltaSeconds, class ACharacter* OwnerCharacter, class UMaterialInstanceDynamic* ShadowDynamicMI);
	bool UpdateDrawPlayerShadowDecal(float DeltaSeconds, class ACharacter* OwnerCharacter, class USkeletalMeshComponent* SkeletalMeshComponent, class UDecalComponent* DecalComponent, class USceneComponent* ShadowOnWaterPlaneMeshComp);
	bool UpdateDrawPlayerShadowDecal_Mobile(float DeltaSeconds, class ACharacter* OwnerCharacter, class USkeletalMeshComponent* SkeletalMeshComponent, class USceneComponent* CubeMeshComponent, class USceneComponent* ShadowOnWaterPlaneMeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerShadowDecalProcessor">();
	}
	static class UPlayerShadowDecalProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerShadowDecalProcessor>();
	}
};
static_assert(alignof(UPlayerShadowDecalProcessor) == 0x000010, "Wrong alignment on UPlayerShadowDecalProcessor");
static_assert(sizeof(UPlayerShadowDecalProcessor) == 0x000320, "Wrong size on UPlayerShadowDecalProcessor");
static_assert(offsetof(UPlayerShadowDecalProcessor, DrawDebugType) == 0x000028, "Member 'UPlayerShadowDecalProcessor::DrawDebugType' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, TraceCapsuleRadiusOffset) == 0x00002C, "Member 'UPlayerShadowDecalProcessor::TraceCapsuleRadiusOffset' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_CapsuleZOffset) == 0x000030, "Member 'UPlayerShadowDecalProcessor::m_CapsuleZOffset' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_MaxTraceDownHeight) == 0x000034, "Member 'UPlayerShadowDecalProcessor::m_MaxTraceDownHeight' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_MaxJumpHeight) == 0x000038, "Member 'UPlayerShadowDecalProcessor::m_MaxJumpHeight' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_ShadowDecalSize) == 0x000040, "Member 'UPlayerShadowDecalProcessor::m_ShadowDecalSize' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_Curve_ShadowDecalDistanceMappedToScale2D) == 0x000058, "Member 'UPlayerShadowDecalProcessor::m_Curve_ShadowDecalDistanceMappedToScale2D' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_OpacityParamName) == 0x000060, "Member 'UPlayerShadowDecalProcessor::m_OpacityParamName' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_BlurWeightParamName) == 0x000068, "Member 'UPlayerShadowDecalProcessor::m_BlurWeightParamName' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_ScaleParamName) == 0x000070, "Member 'UPlayerShadowDecalProcessor::m_ScaleParamName' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_SphereTraceRadius) == 0x000078, "Member 'UPlayerShadowDecalProcessor::m_SphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_CurrentDecalOpacity) == 0x00007C, "Member 'UPlayerShadowDecalProcessor::m_CurrentDecalOpacity' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_TargetShadowHeight) == 0x000080, "Member 'UPlayerShadowDecalProcessor::m_TargetShadowHeight' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_TargetShadowTranform) == 0x000090, "Member 'UPlayerShadowDecalProcessor::m_TargetShadowTranform' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_TargetShadowHitsult) == 0x0000F0, "Member 'UPlayerShadowDecalProcessor::m_TargetShadowHitsult' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, m_TargetShadowHitsultHight) == 0x0001E8, "Member 'UPlayerShadowDecalProcessor::m_TargetShadowHitsultHight' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, bIsOnWaterSurface) == 0x0002E0, "Member 'UPlayerShadowDecalProcessor::bIsOnWaterSurface' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, WaterHeight) == 0x0002E4, "Member 'UPlayerShadowDecalProcessor::WaterHeight' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, WaterHeightTraceMax) == 0x0002E8, "Member 'UPlayerShadowDecalProcessor::WaterHeightTraceMax' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, WaterTraceProfileName) == 0x0002EC, "Member 'UPlayerShadowDecalProcessor::WaterTraceProfileName' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, WaterHeightOnHideCubeMesh) == 0x0002F4, "Member 'UPlayerShadowDecalProcessor::WaterHeightOnHideCubeMesh' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, bIsOnFloorSurface) == 0x0002F8, "Member 'UPlayerShadowDecalProcessor::bIsOnFloorSurface' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, bShouldHidePlane) == 0x0002F9, "Member 'UPlayerShadowDecalProcessor::bShouldHidePlane' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, bShouldHideCube) == 0x0002FA, "Member 'UPlayerShadowDecalProcessor::bShouldHideCube' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, PlaneMeshLocationOffset) == 0x000300, "Member 'UPlayerShadowDecalProcessor::PlaneMeshLocationOffset' has a wrong offset!");
static_assert(offsetof(UPlayerShadowDecalProcessor, LineTraceCount) == 0x000318, "Member 'UPlayerShadowDecalProcessor::LineTraceCount' has a wrong offset!");

// Class X6Game.QuadrupedLocomotionAnimInstance
// 0x0020 (0x03F0 - 0x03D0)
class UQuadrupedLocomotionAnimInstance final : public UAnimInstance
{
public:
	float                                         Speed2D;                                           // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration2D;                                    // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x03D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMovementInput;                                 // 0x03D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransToRightFoot;                                 // 0x03D2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransToContractionPose;                           // 0x03D3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThresholdOfTransToContractionPose;                 // 0x03D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  OwnerCharacter;                                    // 0x03D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            OwnerCharacterMovement;                            // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DeterminTransToContractionPose();
	bool DeterminTransToRightFoot();
	void HandleOnMovementInputChanged(bool PrevHasMovementInput, bool NewHasMovementInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadrupedLocomotionAnimInstance">();
	}
	static class UQuadrupedLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuadrupedLocomotionAnimInstance>();
	}
};
static_assert(alignof(UQuadrupedLocomotionAnimInstance) == 0x000010, "Wrong alignment on UQuadrupedLocomotionAnimInstance");
static_assert(sizeof(UQuadrupedLocomotionAnimInstance) == 0x0003F0, "Wrong size on UQuadrupedLocomotionAnimInstance");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, Speed2D) == 0x0003C8, "Member 'UQuadrupedLocomotionAnimInstance::Speed2D' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, Acceleration2D) == 0x0003CC, "Member 'UQuadrupedLocomotionAnimInstance::Acceleration2D' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, bIsMoving) == 0x0003D0, "Member 'UQuadrupedLocomotionAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, bHasMovementInput) == 0x0003D1, "Member 'UQuadrupedLocomotionAnimInstance::bHasMovementInput' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, bTransToRightFoot) == 0x0003D2, "Member 'UQuadrupedLocomotionAnimInstance::bTransToRightFoot' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, bTransToContractionPose) == 0x0003D3, "Member 'UQuadrupedLocomotionAnimInstance::bTransToContractionPose' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, ThresholdOfTransToContractionPose) == 0x0003D4, "Member 'UQuadrupedLocomotionAnimInstance::ThresholdOfTransToContractionPose' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, OwnerCharacter) == 0x0003D8, "Member 'UQuadrupedLocomotionAnimInstance::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UQuadrupedLocomotionAnimInstance, OwnerCharacterMovement) == 0x0003E0, "Member 'UQuadrupedLocomotionAnimInstance::OwnerCharacterMovement' has a wrong offset!");

// Class X6Game.RegularMovementDebugContext
// 0x0008 (0x0030 - 0x0028)
class URegularMovementDebugContext final : public UObject
{
public:
	bool                                          bEnableForceSlowWalk;                              // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEnterSprintGait;                             // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deinitialize();
	void OnInitialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegularMovementDebugContext">();
	}
	static class URegularMovementDebugContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegularMovementDebugContext>();
	}
};
static_assert(alignof(URegularMovementDebugContext) == 0x000008, "Wrong alignment on URegularMovementDebugContext");
static_assert(sizeof(URegularMovementDebugContext) == 0x000030, "Wrong size on URegularMovementDebugContext");
static_assert(offsetof(URegularMovementDebugContext, bEnableForceSlowWalk) == 0x000028, "Member 'URegularMovementDebugContext::bEnableForceSlowWalk' has a wrong offset!");
static_assert(offsetof(URegularMovementDebugContext, bForceEnterSprintGait) == 0x000029, "Member 'URegularMovementDebugContext::bForceEnterSprintGait' has a wrong offset!");

// Class X6Game.RenderTargetBox
// 0x0038 (0x0210 - 0x01D8)
class URenderTargetBox final : public USizeBox
{
public:
	bool                                          ShowChild;                                         // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             ShowChildDelegate;                                 // 0x01DC(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreHittestGrid;                                 // 0x01EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             IgnoreHittestGridDelegate;                         // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x10];                                     // 0x0200(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIgnoreHittestGrid(bool InIgnoreHittestGrid);
	void SetRenderTarget(class UTextureRenderTarget2D* RenderTarget);
	void SetShowChild(bool InShowChild);
	void UpdateRenderTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderTargetBox">();
	}
	static class URenderTargetBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderTargetBox>();
	}
};
static_assert(alignof(URenderTargetBox) == 0x000008, "Wrong alignment on URenderTargetBox");
static_assert(sizeof(URenderTargetBox) == 0x000210, "Wrong size on URenderTargetBox");
static_assert(offsetof(URenderTargetBox, ShowChild) == 0x0001D8, "Member 'URenderTargetBox::ShowChild' has a wrong offset!");
static_assert(offsetof(URenderTargetBox, ShowChildDelegate) == 0x0001DC, "Member 'URenderTargetBox::ShowChildDelegate' has a wrong offset!");
static_assert(offsetof(URenderTargetBox, IgnoreHittestGrid) == 0x0001EC, "Member 'URenderTargetBox::IgnoreHittestGrid' has a wrong offset!");
static_assert(offsetof(URenderTargetBox, IgnoreHittestGridDelegate) == 0x0001F0, "Member 'URenderTargetBox::IgnoreHittestGridDelegate' has a wrong offset!");

// Class X6Game.RenderTargetBoxResourceObject
// 0x0008 (0x0030 - 0x0028)
class URenderTargetBoxResourceObject final : public UObject
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderTargetBoxResourceObject">();
	}
	static class URenderTargetBoxResourceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderTargetBoxResourceObject>();
	}
};
static_assert(alignof(URenderTargetBoxResourceObject) == 0x000008, "Wrong alignment on URenderTargetBoxResourceObject");
static_assert(sizeof(URenderTargetBoxResourceObject) == 0x000030, "Wrong size on URenderTargetBoxResourceObject");
static_assert(offsetof(URenderTargetBoxResourceObject, RenderTarget) == 0x000028, "Member 'URenderTargetBoxResourceObject::RenderTarget' has a wrong offset!");

// Class X6Game.RMBaseLogicProcessor
// 0x02A0 (0x02C8 - 0x0028)
class URMBaseLogicProcessor final : public UObject
{
public:
	struct FRotator                               LastTargetRotation;                                // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRMInputContext                        CurInputContext;                                   // 0x0040(0x00B8)(BlueprintVisible, NativeAccessSpecifierPublic)
	class AActor*                                 CurCameraManager;                                  // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CharacterOwner;                                    // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             TurnAroundMoveUpdatedHitResult;                    // 0x0108(0x00F8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFrameInputContext>             RecentFrameInputContexts;                          // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x78];                                     // 0x0218(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRMCameraContext                       CurPlayerCameraContext;                            // 0x0290(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	float CaculateCurRotationActorInterpSpeed(const struct FRotator& CurrentCameraRotation, const struct FRotator& PreCameraRotation, float CameraRYawClampUpperLimit, float CurveSampleValue, float DeltaSeconds, class UCurveFloat* RotateCurve, class UCurveFloat* RAngleToRYawSpeedRateMappingCurve, float CurrentTurnAroundAngle);
	void Deinitialize();
	void GatherCurrentCameraInformation();
	struct FRMCameraContext GetCameraContext();
	struct FRMInputContext GetInputContext();
	float GetMappedSpeed(float CurrentSpeed2DVal, float LowerSpeedVal, float MiddleSpeedVal, float HighSpeedVal);
	bool GetMostRecentValidInputInfoByValidDuration(float ValidDuration, struct FFrameInputContext* InputContext);
	float GetTurnAroundAngle(const struct FVector& InputMovingDirection, const struct FVector& CurrentForwardVector);
	float GetVariableInputScaleValue(const struct FRMInputConfig& RMInputConfig, bool bIsForwardAxis, float CurrentInputValForMoveForward, float CurrentInputValForMoveRight);
	void InitInputConfigData(float LogicalFramesPerSecond, float PreStartFrames, bool bEnableStartMovingInputCache, float StartMovingInputCacheFrames, bool bEnableMutationCache, float MutationInputCacheFrames, bool bEnableInvalidInput, float InvalidInputFrames, float MutationInputSizeThreshold, float MutationInputDirectionThreshold);
	bool IsEnableMutationCache();
	void IsKeepPolishInputStateOnce();
	bool IsNeedStartMovingCache();
	void KeepPolishInputStateOnce();
	double ObtainingPreciseValueThroughIntegralCalculation(class UCurveFloat* CurCurve, double CurSampleValue, double AdvanceTime, double SamplingInterval);
	void OnInitialize(class AActor* OwnerActor);
	bool PolishInputValue(const struct FRMInputConfig& RMInputConfig, float CurrentInputValForMoveForward, float CurrentInputValForMoveRight);
	float ProcessBasicOnGroundTurnAroundMovementLogic(class UCharacterMovementComponent* CharacterMovementComponent, struct FRotator* CurrentTargetRotation, const struct FVector& InputMovingDirection, float RotationTargetInterpSpeed, float RotationActorInterpSpeed, float DeltaSeconds);
	bool ProcessFollowUpTurnAroundMovementLogic(class UCharacterMovementComponent* CharacterMovementComponent, const struct FVector& InputMovingDirection, float RotationTargetInterpSpeed, float DeltaSeconds);
	void ProcessInputAngularDeadZone(const class UCharacterMovementComponent* CharacterMovementComponent, const struct FRMInputConfig& RMInputConfig, const float DeltaSeconds);
	bool ProcessInputValueCacheLogic(float DeltaSeconds, bool bIsMoving);
	bool ProcessRegularFallingTurnAroundMovementLogic(class UCharacterMovementComponent* CharacterMovementComponent, const struct FVector& InputMovingDirection, float RotationTargetInterpSpeed, float RotationActorInterpSpeed, float DeltaSeconds);
	void RecordCurInputInformation(float CurrentInputValForMoveForward, float CurrentInputValForMoveRight, float PreInputValForMoveForward, float PreInputValForMoveRight);
	void RemapInputAccordingToSwitchWalkMode(class URMProxyTickRecordInterface* TickRecord);
	void ReplayCurInputInformation(float* PolishInputValForMoveForward, float* PolishInputValForMoveRight, float* PolishPreInputValForMoveForward, float* PolishPreInputValForMoveRight);
	void ResetCameraContext();
	void ResetInputCache();
	void ResetInputContext();
	struct FRotator SmoothPlayerRotation(struct FRotator* CurrentTargetRotation, const struct FRotator& NewTargetRotation, const struct FRotator& CurActorRotation, float RotationTargetInterpSpeed, float RotationActorInterpSpeed, float DeltaSeconds);
	struct FRotator SmoothPlayerRotationConstant(const struct FRotator& CurrentRotation, const struct FRotator& TargetRotation, float RotationTargetInterpSpeed, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMBaseLogicProcessor">();
	}
	static class URMBaseLogicProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMBaseLogicProcessor>();
	}
};
static_assert(alignof(URMBaseLogicProcessor) == 0x000008, "Wrong alignment on URMBaseLogicProcessor");
static_assert(sizeof(URMBaseLogicProcessor) == 0x0002C8, "Wrong size on URMBaseLogicProcessor");
static_assert(offsetof(URMBaseLogicProcessor, LastTargetRotation) == 0x000028, "Member 'URMBaseLogicProcessor::LastTargetRotation' has a wrong offset!");
static_assert(offsetof(URMBaseLogicProcessor, CurInputContext) == 0x000040, "Member 'URMBaseLogicProcessor::CurInputContext' has a wrong offset!");
static_assert(offsetof(URMBaseLogicProcessor, CurCameraManager) == 0x0000F8, "Member 'URMBaseLogicProcessor::CurCameraManager' has a wrong offset!");
static_assert(offsetof(URMBaseLogicProcessor, CharacterOwner) == 0x000100, "Member 'URMBaseLogicProcessor::CharacterOwner' has a wrong offset!");
static_assert(offsetof(URMBaseLogicProcessor, TurnAroundMoveUpdatedHitResult) == 0x000108, "Member 'URMBaseLogicProcessor::TurnAroundMoveUpdatedHitResult' has a wrong offset!");
static_assert(offsetof(URMBaseLogicProcessor, RecentFrameInputContexts) == 0x000208, "Member 'URMBaseLogicProcessor::RecentFrameInputContexts' has a wrong offset!");
static_assert(offsetof(URMBaseLogicProcessor, CurPlayerCameraContext) == 0x000290, "Member 'URMBaseLogicProcessor::CurPlayerCameraContext' has a wrong offset!");

// Class X6Game.RMConfigContextInterface
// 0x0000 (0x0028 - 0x0028)
class URMConfigContextInterface : public UObject
{
public:
	void Deinitialize();
	void OnInitialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMConfigContextInterface">();
	}
	static class URMConfigContextInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMConfigContextInterface>();
	}
};
static_assert(alignof(URMConfigContextInterface) == 0x000008, "Wrong alignment on URMConfigContextInterface");
static_assert(sizeof(URMConfigContextInterface) == 0x000028, "Wrong size on URMConfigContextInterface");

// Class X6Game.RMOutputContextInterface
// 0x0060 (0x0088 - 0x0028)
class URMOutputContextInterface : public UObject
{
public:
	bool                                          bIsMoving;                                         // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentInputMovingDirection;                       // 0x0030(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentInputForwardDir;                            // 0x0048(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentInputRightDir;                              // 0x0060(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTurnAroundAngle;                            // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTurnAroundAngularSpeed;                     // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 CurrentMovementMode;                               // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deinitialize();
	void OnInitialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMOutputContextInterface">();
	}
	static class URMOutputContextInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMOutputContextInterface>();
	}
};
static_assert(alignof(URMOutputContextInterface) == 0x000008, "Wrong alignment on URMOutputContextInterface");
static_assert(sizeof(URMOutputContextInterface) == 0x000088, "Wrong size on URMOutputContextInterface");
static_assert(offsetof(URMOutputContextInterface, bIsMoving) == 0x000028, "Member 'URMOutputContextInterface::bIsMoving' has a wrong offset!");
static_assert(offsetof(URMOutputContextInterface, CurrentInputMovingDirection) == 0x000030, "Member 'URMOutputContextInterface::CurrentInputMovingDirection' has a wrong offset!");
static_assert(offsetof(URMOutputContextInterface, CurrentInputForwardDir) == 0x000048, "Member 'URMOutputContextInterface::CurrentInputForwardDir' has a wrong offset!");
static_assert(offsetof(URMOutputContextInterface, CurrentInputRightDir) == 0x000060, "Member 'URMOutputContextInterface::CurrentInputRightDir' has a wrong offset!");
static_assert(offsetof(URMOutputContextInterface, CurrentTurnAroundAngle) == 0x000078, "Member 'URMOutputContextInterface::CurrentTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(URMOutputContextInterface, CurrentTurnAroundAngularSpeed) == 0x00007C, "Member 'URMOutputContextInterface::CurrentTurnAroundAngularSpeed' has a wrong offset!");
static_assert(offsetof(URMOutputContextInterface, CurrentMovementMode) == 0x000080, "Member 'URMOutputContextInterface::CurrentMovementMode' has a wrong offset!");

// Class X6Game.RMBehaviorTreeProxyInterface
// 0x0020 (0x0048 - 0x0028)
class URMBehaviorTreeProxyInterface : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        OuterCompoent;                                     // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            OwnerCharacterMovementComponent;                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Deinitialize();
	void OnInitialize(class UActorComponent* OuterComp, class UCharacterMovementComponent* CharacterMovementComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMBehaviorTreeProxyInterface">();
	}
	static class URMBehaviorTreeProxyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMBehaviorTreeProxyInterface>();
	}
};
static_assert(alignof(URMBehaviorTreeProxyInterface) == 0x000008, "Wrong alignment on URMBehaviorTreeProxyInterface");
static_assert(sizeof(URMBehaviorTreeProxyInterface) == 0x000048, "Wrong size on URMBehaviorTreeProxyInterface");
static_assert(offsetof(URMBehaviorTreeProxyInterface, OuterCompoent) == 0x000038, "Member 'URMBehaviorTreeProxyInterface::OuterCompoent' has a wrong offset!");
static_assert(offsetof(URMBehaviorTreeProxyInterface, OwnerCharacterMovementComponent) == 0x000040, "Member 'URMBehaviorTreeProxyInterface::OwnerCharacterMovementComponent' has a wrong offset!");

// Class X6Game.RMProxyTickRecordInterface
// 0x0048 (0x0070 - 0x0028)
class URMProxyTickRecordInterface : public UObject
{
public:
	float                                         DeltaSeconds;                                      // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMBaseLogicProcessor*                  RMBaseLogicProcessor;                              // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMBehaviorTreeProxyInterface*          CurrentProxy;                                      // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMConfigContextInterface*              ConfigContext;                                     // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMOutputContextInterface*              OutputContext;                                     // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMStateInstructionContext*             StateInstructionContext;                           // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URegularMovementDebugContext*           RMDebugContext;                                    // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseButtonSwitchWalk;                              // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deinitialize();
	class URMConfigContextInterface* GetConfigContext();
	class URMBehaviorTreeProxyInterface* GetCurrentProxy();
	class URegularMovementDebugContext* GetDebugContext();
	class URMOutputContextInterface* GetOutputContext();
	class URMStateInstructionContext* GetStateInstructionContext();
	bool GetUseButtonSwitchWalk();
	void OnInitialize(class AActor* Owner, class URMBaseLogicProcessor* RMLogicProxy, TSubclassOf<class URMOutputContextInterface> RMOutputContextClass, TSubclassOf<class URMStateInstructionContext> RMStateInstructionContextClass, TSubclassOf<class URMConfigContextInterface> RMConfigContextClass, TSubclassOf<class URegularMovementDebugContext> RMDebugContextClass);
	void SetConfigContext(class URMConfigContextInterface* RMConfigContextInterface);
	void SetCurrentProxy(class URMBehaviorTreeProxyInterface* RMProxyInterface);
	void SetOutputContext(class URMOutputContextInterface* RMOutputContextInterface);
	void SetStateInstructionContext(class URMStateInstructionContext* RMStateInstructionContext);
	void SetUseButtonSwitchWalk(bool bNewUseButtonSwitchWalk);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxyTickRecordInterface">();
	}
	static class URMProxyTickRecordInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxyTickRecordInterface>();
	}
};
static_assert(alignof(URMProxyTickRecordInterface) == 0x000008, "Wrong alignment on URMProxyTickRecordInterface");
static_assert(sizeof(URMProxyTickRecordInterface) == 0x000070, "Wrong size on URMProxyTickRecordInterface");
static_assert(offsetof(URMProxyTickRecordInterface, DeltaSeconds) == 0x000028, "Member 'URMProxyTickRecordInterface::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, OwnerActor) == 0x000030, "Member 'URMProxyTickRecordInterface::OwnerActor' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, RMBaseLogicProcessor) == 0x000038, "Member 'URMProxyTickRecordInterface::RMBaseLogicProcessor' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, CurrentProxy) == 0x000040, "Member 'URMProxyTickRecordInterface::CurrentProxy' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, ConfigContext) == 0x000048, "Member 'URMProxyTickRecordInterface::ConfigContext' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, OutputContext) == 0x000050, "Member 'URMProxyTickRecordInterface::OutputContext' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, StateInstructionContext) == 0x000058, "Member 'URMProxyTickRecordInterface::StateInstructionContext' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, RMDebugContext) == 0x000060, "Member 'URMProxyTickRecordInterface::RMDebugContext' has a wrong offset!");
static_assert(offsetof(URMProxyTickRecordInterface, bUseButtonSwitchWalk) == 0x000068, "Member 'URMProxyTickRecordInterface::bUseButtonSwitchWalk' has a wrong offset!");

// Class X6Game.RMStateInstructionContext
// 0x00E0 (0x0108 - 0x0028)
class URMStateInstructionContext final : public UObject
{
public:
	TMap<int32, bool>                             CanDoActionInfoMapper;                             // 0x0028(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, bool>                             HasStatesInfoMapper;                               // 0x0078(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PlayerState_Running_Id;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_Walking_Id;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_Sprinting_Id;                          // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_Moving_Id;                             // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_Glide_Id;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_Jump_Id;                               // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_InAir_Id;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_JumpFloating_Id;                       // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerState_InAirFalling_Id;                       // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_Run_Id;                               // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_Walk_Id;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_Sprint_Id;                            // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_Move_Id;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_Jump_Id;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_JumpFloating_Id;                      // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAction_JumpInAir_Id;                         // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_AddState(int32 StateID);
	bool BP_CanDoAction(int32 ActionId);
	void BP_DoAction(int32 ActionId);
	bool BP_HasState(int32 StateID);
	void BP_RemoveState(int32 StateID);
	void Deinitialize();
	void OnInitialize(class AActor* OwnerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMStateInstructionContext">();
	}
	static class URMStateInstructionContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMStateInstructionContext>();
	}
};
static_assert(alignof(URMStateInstructionContext) == 0x000008, "Wrong alignment on URMStateInstructionContext");
static_assert(sizeof(URMStateInstructionContext) == 0x000108, "Wrong size on URMStateInstructionContext");
static_assert(offsetof(URMStateInstructionContext, CanDoActionInfoMapper) == 0x000028, "Member 'URMStateInstructionContext::CanDoActionInfoMapper' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, HasStatesInfoMapper) == 0x000078, "Member 'URMStateInstructionContext::HasStatesInfoMapper' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_Running_Id) == 0x0000C8, "Member 'URMStateInstructionContext::PlayerState_Running_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_Walking_Id) == 0x0000CC, "Member 'URMStateInstructionContext::PlayerState_Walking_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_Sprinting_Id) == 0x0000D0, "Member 'URMStateInstructionContext::PlayerState_Sprinting_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_Moving_Id) == 0x0000D4, "Member 'URMStateInstructionContext::PlayerState_Moving_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_Glide_Id) == 0x0000D8, "Member 'URMStateInstructionContext::PlayerState_Glide_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_Jump_Id) == 0x0000DC, "Member 'URMStateInstructionContext::PlayerState_Jump_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_InAir_Id) == 0x0000E0, "Member 'URMStateInstructionContext::PlayerState_InAir_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_JumpFloating_Id) == 0x0000E4, "Member 'URMStateInstructionContext::PlayerState_JumpFloating_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerState_InAirFalling_Id) == 0x0000E8, "Member 'URMStateInstructionContext::PlayerState_InAirFalling_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_Run_Id) == 0x0000EC, "Member 'URMStateInstructionContext::PlayerAction_Run_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_Walk_Id) == 0x0000F0, "Member 'URMStateInstructionContext::PlayerAction_Walk_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_Sprint_Id) == 0x0000F4, "Member 'URMStateInstructionContext::PlayerAction_Sprint_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_Move_Id) == 0x0000F8, "Member 'URMStateInstructionContext::PlayerAction_Move_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_Jump_Id) == 0x0000FC, "Member 'URMStateInstructionContext::PlayerAction_Jump_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_JumpFloating_Id) == 0x000100, "Member 'URMStateInstructionContext::PlayerAction_JumpFloating_Id' has a wrong offset!");
static_assert(offsetof(URMStateInstructionContext, PlayerAction_JumpInAir_Id) == 0x000104, "Member 'URMStateInstructionContext::PlayerAction_JumpInAir_Id' has a wrong offset!");

// Class X6Game.RMConfigContext_InAir
// 0x0148 (0x0170 - 0x0028)
class URMConfigContext_InAir final : public URMConfigContextInterface
{
public:
	float                                         DefaultMaxAcceleration;                            // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalGeneralSpeed;                         // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationActorInterpSpeed;                          // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTargetInterpSpeed;                         // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawClampUpperLimit;                          // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RAngleToRYawSpeedRateMappingCurve;                 // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactorFalling;                      // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAnalogWalkSpeed;                                // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSpeedLimit;                                 // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RatioOfInterrupted;                                // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunUpBrakingDecelerationFalling;                   // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableKeepCurrentTrendFeature;                    // 0x005C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeWindowOfResponseJumpInputWhenOffLedge;         // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfCacheJumpInputWhenFalling;                   // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableUseTerminalFallingVelocity;                 // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerminalFallingVelocity;                           // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInfinitelyVariableSpeeds;                   // 0x0070(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpGravity;                                       // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpBrakingDecelerationFalling;                    // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpFallingLateralFriction;                        // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpAirControl;                                    // 0x0084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpRotationActorInterpSpeed;                      // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRotationTargetInterpSpeed;                     // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpMinimumHeightToBeChecked;                      // 0x0094(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateReJumpCountingMode;                       // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfReJumps;                                   // 0x009C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDoubleJumpBeforeApex;                       // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoubleJumpInputCacheDurationBeforeApex;            // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoubleJumpZVelocity;                               // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            JumpGravityCurve;                                  // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MultipleJumpGravityCurve;                          // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MultipleJumpRotationActorInterpSpeed;              // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAutoDoJumpInAirWhenReachingApex;                // 0x00C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallGravity;                                       // 0x00CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallBrakingDecelerationFalling;                    // 0x00D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallFallingLateralFriction;                        // 0x00D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallAirControl;                                    // 0x00D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FallRotationActorInterpSpeed;                      // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallRotationTargetInterpSpeed;                     // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReleaseToFall;                              // 0x00EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReleaseToFall_Gravity;                             // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FallGravityCurve;                                  // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumHeightOfEnteringFloat;                      // 0x0100(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatGravity;                                      // 0x0104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatBrakingDecelerationFalling;                   // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatFallingLateralFriction;                       // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatAirControl;                                   // 0x0110(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FloatRotationActorInterpSpeed;                     // 0x0118(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatRotationTargetInterpSpeed;                    // 0x0120(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalFloatSpeed;                           // 0x0124(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyFloatWhenReachingApex;               // 0x0128(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveOfPassiveWayToTriggerFloating;              // 0x0129(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x2];                                      // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatDuration;                                     // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatInterpDuration;                               // 0x0130(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveMaxZVelocityForFloating;                    // 0x0134(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxZVelocityForFloating;                           // 0x0138(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnterFloatByHoldOrTrigger;                         // 0x013C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateFloatingTimerMode;                        // 0x013D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Current_SpeedToEnterFloatOrJumpValue;              // 0x0140(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseCrashSetting;                                // 0x0144(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x7];                                      // 0x0145(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrashGravity;                                      // 0x014C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CrashGravityCurve;                                 // 0x0150(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashBrakingDecelerationFalling;                   // 0x0158(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashFallingLateralFriction;                       // 0x015C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashAirControl;                                   // 0x0160(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLimitCrashMaxFallingSpeed;                   // 0x0164(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrashMaxFallingSpeed;                              // 0x0168(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetCrashSetting();
	void SetCrashSetting(float inCrashVelocityZ, float inCrashGravity, class UCurveFloat* inCrashGravityCurve, float inCrashBrakingDecelerationFalling, float inCrashFallingLateralFriction, float inCrashAirControl, bool inEnableLimitCrashMaxFallingSpeed, float inCrashMaxFallingSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMConfigContext_InAir">();
	}
	static class URMConfigContext_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMConfigContext_InAir>();
	}
};
static_assert(alignof(URMConfigContext_InAir) == 0x000008, "Wrong alignment on URMConfigContext_InAir");
static_assert(sizeof(URMConfigContext_InAir) == 0x000170, "Wrong size on URMConfigContext_InAir");
static_assert(offsetof(URMConfigContext_InAir, DefaultMaxAcceleration) == 0x000028, "Member 'URMConfigContext_InAir::DefaultMaxAcceleration' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MaxHorizontalGeneralSpeed) == 0x00002C, "Member 'URMConfigContext_InAir::MaxHorizontalGeneralSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, RotationActorInterpSpeed) == 0x000030, "Member 'URMConfigContext_InAir::RotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, RotationTargetInterpSpeed) == 0x000038, "Member 'URMConfigContext_InAir::RotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CameraYawClampUpperLimit) == 0x00003C, "Member 'URMConfigContext_InAir::CameraYawClampUpperLimit' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, RAngleToRYawSpeedRateMappingCurve) == 0x000040, "Member 'URMConfigContext_InAir::RAngleToRYawSpeedRateMappingCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, BrakingFrictionFactorFalling) == 0x000048, "Member 'URMConfigContext_InAir::BrakingFrictionFactorFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MinAnalogWalkSpeed) == 0x00004C, "Member 'URMConfigContext_InAir::MinAnalogWalkSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bEnableSpeedLimit) == 0x000050, "Member 'URMConfigContext_InAir::bEnableSpeedLimit' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, RatioOfInterrupted) == 0x000054, "Member 'URMConfigContext_InAir::RatioOfInterrupted' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, RunUpBrakingDecelerationFalling) == 0x000058, "Member 'URMConfigContext_InAir::RunUpBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bEnableKeepCurrentTrendFeature) == 0x00005C, "Member 'URMConfigContext_InAir::bEnableKeepCurrentTrendFeature' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, TimeWindowOfResponseJumpInputWhenOffLedge) == 0x000060, "Member 'URMConfigContext_InAir::TimeWindowOfResponseJumpInputWhenOffLedge' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, TimeOfCacheJumpInputWhenFalling) == 0x000064, "Member 'URMConfigContext_InAir::TimeOfCacheJumpInputWhenFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bEnableUseTerminalFallingVelocity) == 0x000068, "Member 'URMConfigContext_InAir::bEnableUseTerminalFallingVelocity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, TerminalFallingVelocity) == 0x00006C, "Member 'URMConfigContext_InAir::TerminalFallingVelocity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bEnableInfinitelyVariableSpeeds) == 0x000070, "Member 'URMConfigContext_InAir::bEnableInfinitelyVariableSpeeds' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpGravity) == 0x000074, "Member 'URMConfigContext_InAir::JumpGravity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpZVelocity) == 0x000078, "Member 'URMConfigContext_InAir::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpBrakingDecelerationFalling) == 0x00007C, "Member 'URMConfigContext_InAir::JumpBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpFallingLateralFriction) == 0x000080, "Member 'URMConfigContext_InAir::JumpFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpAirControl) == 0x000084, "Member 'URMConfigContext_InAir::JumpAirControl' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpRotationActorInterpSpeed) == 0x000088, "Member 'URMConfigContext_InAir::JumpRotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpRotationTargetInterpSpeed) == 0x000090, "Member 'URMConfigContext_InAir::JumpRotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpMinimumHeightToBeChecked) == 0x000094, "Member 'URMConfigContext_InAir::JumpMinimumHeightToBeChecked' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bActivateReJumpCountingMode) == 0x000098, "Member 'URMConfigContext_InAir::bActivateReJumpCountingMode' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, NumberOfReJumps) == 0x00009C, "Member 'URMConfigContext_InAir::NumberOfReJumps' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bEnableDoubleJumpBeforeApex) == 0x0000A0, "Member 'URMConfigContext_InAir::bEnableDoubleJumpBeforeApex' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, DoubleJumpInputCacheDurationBeforeApex) == 0x0000A4, "Member 'URMConfigContext_InAir::DoubleJumpInputCacheDurationBeforeApex' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, DoubleJumpZVelocity) == 0x0000A8, "Member 'URMConfigContext_InAir::DoubleJumpZVelocity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, JumpGravityCurve) == 0x0000B0, "Member 'URMConfigContext_InAir::JumpGravityCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MultipleJumpGravityCurve) == 0x0000B8, "Member 'URMConfigContext_InAir::MultipleJumpGravityCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MultipleJumpRotationActorInterpSpeed) == 0x0000C0, "Member 'URMConfigContext_InAir::MultipleJumpRotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CanAutoDoJumpInAirWhenReachingApex) == 0x0000C8, "Member 'URMConfigContext_InAir::CanAutoDoJumpInAirWhenReachingApex' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallGravity) == 0x0000CC, "Member 'URMConfigContext_InAir::FallGravity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallBrakingDecelerationFalling) == 0x0000D0, "Member 'URMConfigContext_InAir::FallBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallFallingLateralFriction) == 0x0000D4, "Member 'URMConfigContext_InAir::FallFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallAirControl) == 0x0000D8, "Member 'URMConfigContext_InAir::FallAirControl' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallRotationActorInterpSpeed) == 0x0000E0, "Member 'URMConfigContext_InAir::FallRotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallRotationTargetInterpSpeed) == 0x0000E8, "Member 'URMConfigContext_InAir::FallRotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bEnableReleaseToFall) == 0x0000EC, "Member 'URMConfigContext_InAir::bEnableReleaseToFall' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, ReleaseToFall_Gravity) == 0x0000F0, "Member 'URMConfigContext_InAir::ReleaseToFall_Gravity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FallGravityCurve) == 0x0000F8, "Member 'URMConfigContext_InAir::FallGravityCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MinimumHeightOfEnteringFloat) == 0x000100, "Member 'URMConfigContext_InAir::MinimumHeightOfEnteringFloat' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatGravity) == 0x000104, "Member 'URMConfigContext_InAir::FloatGravity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatBrakingDecelerationFalling) == 0x000108, "Member 'URMConfigContext_InAir::FloatBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatFallingLateralFriction) == 0x00010C, "Member 'URMConfigContext_InAir::FloatFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatAirControl) == 0x000110, "Member 'URMConfigContext_InAir::FloatAirControl' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatRotationActorInterpSpeed) == 0x000118, "Member 'URMConfigContext_InAir::FloatRotationActorInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatRotationTargetInterpSpeed) == 0x000120, "Member 'URMConfigContext_InAir::FloatRotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MaxHorizontalFloatSpeed) == 0x000124, "Member 'URMConfigContext_InAir::MaxHorizontalFloatSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bAutomaticallyFloatWhenReachingApex) == 0x000128, "Member 'URMConfigContext_InAir::bAutomaticallyFloatWhenReachingApex' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bActiveOfPassiveWayToTriggerFloating) == 0x000129, "Member 'URMConfigContext_InAir::bActiveOfPassiveWayToTriggerFloating' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatDuration) == 0x00012C, "Member 'URMConfigContext_InAir::FloatDuration' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, FloatInterpDuration) == 0x000130, "Member 'URMConfigContext_InAir::FloatInterpDuration' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bActiveMaxZVelocityForFloating) == 0x000134, "Member 'URMConfigContext_InAir::bActiveMaxZVelocityForFloating' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, MaxZVelocityForFloating) == 0x000138, "Member 'URMConfigContext_InAir::MaxZVelocityForFloating' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, EnterFloatByHoldOrTrigger) == 0x00013C, "Member 'URMConfigContext_InAir::EnterFloatByHoldOrTrigger' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, bActivateFloatingTimerMode) == 0x00013D, "Member 'URMConfigContext_InAir::bActivateFloatingTimerMode' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, Current_SpeedToEnterFloatOrJumpValue) == 0x000140, "Member 'URMConfigContext_InAir::Current_SpeedToEnterFloatOrJumpValue' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CanUseCrashSetting) == 0x000144, "Member 'URMConfigContext_InAir::CanUseCrashSetting' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CrashGravity) == 0x00014C, "Member 'URMConfigContext_InAir::CrashGravity' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CrashGravityCurve) == 0x000150, "Member 'URMConfigContext_InAir::CrashGravityCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CrashBrakingDecelerationFalling) == 0x000158, "Member 'URMConfigContext_InAir::CrashBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CrashFallingLateralFriction) == 0x00015C, "Member 'URMConfigContext_InAir::CrashFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CrashAirControl) == 0x000160, "Member 'URMConfigContext_InAir::CrashAirControl' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, EnableLimitCrashMaxFallingSpeed) == 0x000164, "Member 'URMConfigContext_InAir::EnableLimitCrashMaxFallingSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_InAir, CrashMaxFallingSpeed) == 0x000168, "Member 'URMConfigContext_InAir::CrashMaxFallingSpeed' has a wrong offset!");

// Class X6Game.RMConfigContext_OnGround
// 0x00E0 (0x0108 - 0x0028)
class URMConfigContext_OnGround final : public URMConfigContextInterface
{
public:
	float                                         WalkSpeedVal;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedVal;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeedVal;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundRotationTargetInterpSpeed;                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactorWalking;                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactorFalling;                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRYawClampUpperLimit;                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotationRateCurve;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RAngleToRYawSpeedRateMappingCurve;                 // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNormalSprintOperation;                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchSprintOperationMode;                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchWalkOperationMode;                          // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRunOperation;                               // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWalkOperation;                              // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMovementCurve;                              // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MovementCurve;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGetMovementCurveDataByAllowedGaitSampling;   // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMultiCurve*                            SlopeMoveCurve;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlopeMoveCurve_SprintMaxSpeedFactor_Name;          // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlopeMoveCurve_GeneralMaxSpeedFactor_Name;         // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlopeMoveCurve_MaxAccelerationSlopeFactor_Name;    // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlopeMoveCurve_BrakingDecelerationWalkingSlopeFactor_Name; // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAISlopeFactor;                              // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerInputMinAnalogWalkSpeed;                      // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxAcceleration;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultBrakingDecelerationWalking;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultGroundFriction;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSpeedSegment;                               // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Input_Walk_Mid;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Input_Jog_Lower;                                   // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Input_Jog_Upper;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInfinitelyVariableSpeeds;                   // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniformRotationInplaceSpeed;                       // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningAccelerationInPlace;                        // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningDecelerationInPlace;                        // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompensateSpeedWhenWalkingOffLedge;                // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaxAcceleration;                          // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideMaxAccelerationVal;                        // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBrakingDecelerationWalking;               // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideBrakingDecelerationWalkingVal;             // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideGroundFriction;                           // 0x0100(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideGroundFrictionVal;                         // 0x0104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMConfigContext_OnGround">();
	}
	static class URMConfigContext_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMConfigContext_OnGround>();
	}
};
static_assert(alignof(URMConfigContext_OnGround) == 0x000008, "Wrong alignment on URMConfigContext_OnGround");
static_assert(sizeof(URMConfigContext_OnGround) == 0x000108, "Wrong size on URMConfigContext_OnGround");
static_assert(offsetof(URMConfigContext_OnGround, WalkSpeedVal) == 0x000028, "Member 'URMConfigContext_OnGround::WalkSpeedVal' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, RunSpeedVal) == 0x00002C, "Member 'URMConfigContext_OnGround::RunSpeedVal' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, SprintSpeedVal) == 0x000030, "Member 'URMConfigContext_OnGround::SprintSpeedVal' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, GroundRotationTargetInterpSpeed) == 0x000034, "Member 'URMConfigContext_OnGround::GroundRotationTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, BrakingFrictionFactorWalking) == 0x000038, "Member 'URMConfigContext_OnGround::BrakingFrictionFactorWalking' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, BrakingFrictionFactorFalling) == 0x00003C, "Member 'URMConfigContext_OnGround::BrakingFrictionFactorFalling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, CameraRYawClampUpperLimit) == 0x000040, "Member 'URMConfigContext_OnGround::CameraRYawClampUpperLimit' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, RotationRateCurve) == 0x000048, "Member 'URMConfigContext_OnGround::RotationRateCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, RAngleToRYawSpeedRateMappingCurve) == 0x000050, "Member 'URMConfigContext_OnGround::RAngleToRYawSpeedRateMappingCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableNormalSprintOperation) == 0x000058, "Member 'URMConfigContext_OnGround::bEnableNormalSprintOperation' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bSwitchSprintOperationMode) == 0x000059, "Member 'URMConfigContext_OnGround::bSwitchSprintOperationMode' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bSwitchWalkOperationMode) == 0x00005A, "Member 'URMConfigContext_OnGround::bSwitchWalkOperationMode' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableRunOperation) == 0x00005B, "Member 'URMConfigContext_OnGround::bEnableRunOperation' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableWalkOperation) == 0x00005C, "Member 'URMConfigContext_OnGround::bEnableWalkOperation' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableMovementCurve) == 0x00005D, "Member 'URMConfigContext_OnGround::bEnableMovementCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, MovementCurve) == 0x000060, "Member 'URMConfigContext_OnGround::MovementCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, EnableGetMovementCurveDataByAllowedGaitSampling) == 0x000068, "Member 'URMConfigContext_OnGround::EnableGetMovementCurveDataByAllowedGaitSampling' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, SlopeMoveCurve) == 0x000070, "Member 'URMConfigContext_OnGround::SlopeMoveCurve' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, SlopeMoveCurve_SprintMaxSpeedFactor_Name) == 0x000078, "Member 'URMConfigContext_OnGround::SlopeMoveCurve_SprintMaxSpeedFactor_Name' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, SlopeMoveCurve_GeneralMaxSpeedFactor_Name) == 0x000088, "Member 'URMConfigContext_OnGround::SlopeMoveCurve_GeneralMaxSpeedFactor_Name' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, SlopeMoveCurve_MaxAccelerationSlopeFactor_Name) == 0x000098, "Member 'URMConfigContext_OnGround::SlopeMoveCurve_MaxAccelerationSlopeFactor_Name' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, SlopeMoveCurve_BrakingDecelerationWalkingSlopeFactor_Name) == 0x0000A8, "Member 'URMConfigContext_OnGround::SlopeMoveCurve_BrakingDecelerationWalkingSlopeFactor_Name' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableAISlopeFactor) == 0x0000B8, "Member 'URMConfigContext_OnGround::bEnableAISlopeFactor' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, LowerInputMinAnalogWalkSpeed) == 0x0000BC, "Member 'URMConfigContext_OnGround::LowerInputMinAnalogWalkSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, DefaultMaxAcceleration) == 0x0000C0, "Member 'URMConfigContext_OnGround::DefaultMaxAcceleration' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, DefaultBrakingDecelerationWalking) == 0x0000C4, "Member 'URMConfigContext_OnGround::DefaultBrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, DefaultGroundFriction) == 0x0000C8, "Member 'URMConfigContext_OnGround::DefaultGroundFriction' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableSpeedSegment) == 0x0000CC, "Member 'URMConfigContext_OnGround::bEnableSpeedSegment' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, Input_Walk_Mid) == 0x0000D0, "Member 'URMConfigContext_OnGround::Input_Walk_Mid' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, Input_Jog_Lower) == 0x0000D4, "Member 'URMConfigContext_OnGround::Input_Jog_Lower' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, Input_Jog_Upper) == 0x0000D8, "Member 'URMConfigContext_OnGround::Input_Jog_Upper' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bEnableInfinitelyVariableSpeeds) == 0x0000DC, "Member 'URMConfigContext_OnGround::bEnableInfinitelyVariableSpeeds' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, UniformRotationInplaceSpeed) == 0x0000E0, "Member 'URMConfigContext_OnGround::UniformRotationInplaceSpeed' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, TurningAccelerationInPlace) == 0x0000E4, "Member 'URMConfigContext_OnGround::TurningAccelerationInPlace' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, TurningDecelerationInPlace) == 0x0000E8, "Member 'URMConfigContext_OnGround::TurningDecelerationInPlace' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, CompensateSpeedWhenWalkingOffLedge) == 0x0000EC, "Member 'URMConfigContext_OnGround::CompensateSpeedWhenWalkingOffLedge' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bOverrideMaxAcceleration) == 0x0000F0, "Member 'URMConfigContext_OnGround::bOverrideMaxAcceleration' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, OverrideMaxAccelerationVal) == 0x0000F4, "Member 'URMConfigContext_OnGround::OverrideMaxAccelerationVal' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bOverrideBrakingDecelerationWalking) == 0x0000F8, "Member 'URMConfigContext_OnGround::bOverrideBrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, OverrideBrakingDecelerationWalkingVal) == 0x0000FC, "Member 'URMConfigContext_OnGround::OverrideBrakingDecelerationWalkingVal' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, bOverrideGroundFriction) == 0x000100, "Member 'URMConfigContext_OnGround::bOverrideGroundFriction' has a wrong offset!");
static_assert(offsetof(URMConfigContext_OnGround, OverrideGroundFrictionVal) == 0x000104, "Member 'URMConfigContext_OnGround::OverrideGroundFrictionVal' has a wrong offset!");

// Class X6Game.RMInputActionProcessor
// 0x0000 (0x0028 - 0x0028)
class URMInputActionProcessor : public UObject
{
public:
	void Deinitialize();
	void OnInitialize(class URMProxyTickRecordInterface* TickRecord);
	void OnInputActionProcessorSwitch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMInputActionProcessor">();
	}
	static class URMInputActionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMInputActionProcessor>();
	}
};
static_assert(alignof(URMInputActionProcessor) == 0x000008, "Wrong alignment on URMInputActionProcessor");
static_assert(sizeof(URMInputActionProcessor) == 0x000028, "Wrong size on URMInputActionProcessor");

// Class X6Game.RMInputActionProcessor_InAir
// 0x0028 (0x0050 - 0x0028)
class URMInputActionProcessor_InAir final : public URMInputActionProcessor
{
public:
	TWeakObjectPtr<class URMPTickRecord_InAir>    TickRecord_InAir;                                  // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URMOutputContext_InAir>  OutputContext_InAir;                               // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URMConfigContext_InAir>  ConfigContext_InAir;                               // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMStateMachineContext_InAir*           StateMachineContext;                               // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URMStateMachineContext_InAir> StateMachineContextClass;                        // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanCrash(bool bForce, bool NeedToDoAction);
	bool CanFloat(bool bForce);
	bool CanJump(bool bForce, bool NeedToDoAction);
	bool DoCrash(bool bForce);
	bool DoFall(bool bForce);
	bool DoFloat(bool bForce);
	bool DoJump(bool bForce, ERegularJumpMode NewRegularJumpMode);
	bool DoLand(bool bForce);
	bool DoReleaseToFall();
	bool EnterFloatByJumpApex();
	class URMStateMachineContext_InAir* GetStateMachineContext();
	bool Handle_DetermineActionSlotJumpIsAvailable();
	void OnReachedJumpApex();
	void ProcessActionAndState(float DeltaTime);
	void ProcessRequestedJumpActions();
	void SetStateMachineContext(class URMStateMachineContext_InAir* inStateMachineContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMInputActionProcessor_InAir">();
	}
	static class URMInputActionProcessor_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMInputActionProcessor_InAir>();
	}
};
static_assert(alignof(URMInputActionProcessor_InAir) == 0x000008, "Wrong alignment on URMInputActionProcessor_InAir");
static_assert(sizeof(URMInputActionProcessor_InAir) == 0x000050, "Wrong size on URMInputActionProcessor_InAir");
static_assert(offsetof(URMInputActionProcessor_InAir, TickRecord_InAir) == 0x000028, "Member 'URMInputActionProcessor_InAir::TickRecord_InAir' has a wrong offset!");
static_assert(offsetof(URMInputActionProcessor_InAir, OutputContext_InAir) == 0x000030, "Member 'URMInputActionProcessor_InAir::OutputContext_InAir' has a wrong offset!");
static_assert(offsetof(URMInputActionProcessor_InAir, ConfigContext_InAir) == 0x000038, "Member 'URMInputActionProcessor_InAir::ConfigContext_InAir' has a wrong offset!");
static_assert(offsetof(URMInputActionProcessor_InAir, StateMachineContext) == 0x000040, "Member 'URMInputActionProcessor_InAir::StateMachineContext' has a wrong offset!");
static_assert(offsetof(URMInputActionProcessor_InAir, StateMachineContextClass) == 0x000048, "Member 'URMInputActionProcessor_InAir::StateMachineContextClass' has a wrong offset!");

// Class X6Game.RMOutputContext_InAir
// 0x0078 (0x0100 - 0x0088)
class URMOutputContext_InAir final : public URMOutputContextInterface
{
public:
	ERegularFloatingJumpStage                     PreviousFloatingJumpState;                         // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularFloatingJumpStage                     CurrentFloatingJumpStage;                          // 0x0089(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularJumpMode                              PreviousJumpMode;                                  // 0x008A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularJumpMode                              CurrentJumpMode;                                   // 0x008B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentActualGait;                                 // 0x008C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurVelocityMappedSpeed;                            // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpingInAir;                                     // 0x0094(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreemptionAttribute_TargetInterpSpeed_Override;    // 0x0098(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreemptionAttribute_MaxWalkSpeed_Override;         // 0x009C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurNormalJumpCount;                                // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAfterJumpingOnGround;                             // 0x00A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAfterJumpingInAir;                                // 0x00A5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogicRequireJump;                                 // 0x00A6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLogicOperateInFallStage;                         // 0x00A7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTimeWindowOfCacheDoubleJumpInput;               // 0x00A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTimeWindowOfResponseJumpInputWhenOffLedge;      // 0x00A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTimeWindowOfCacheJumpInput;                     // 0x00AA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurTimeDurationOfCacheJumpInput;                   // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitPercherchWhenInFloatingState_GravityScale;     // 0x00B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayerHasState_WaitingCinematic;             // 0x00B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDecelerateFallSpeedInFloatStage;               // 0x00B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentFloatTargetSpeed;                           // 0x00B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRunUpFeature;                               // 0x00BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunUpMaxHorizontalSpped;                           // 0x00C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingTrendMaxWalkSpeed;                          // 0x00C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentAccumlateTime_InMovementModeFalling;        // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurInputActionJumpValue;                           // 0x00CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurInputActionFloatValue;                          // 0x00CD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurInputActionRejumpValue;                         // 0x00CE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurInputActionJumpPressTime;                       // 0x00D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurInputActionJumpReleaseTime;                     // 0x00D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInhibitJumpInputByAbleTask;                       // 0x00D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInPlayerSkillMoveState;                           // 0x00D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularPlaySkillMovementType                 PlayerSkillMovementChangeMode;                     // 0x00DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB[0x1];                                       // 0x00DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideJumpGravityScale;                          // 0x00DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFallGravityScale;                          // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFloatGravityScale;                         // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCrashGravityScale;                         // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFloatDuration;                              // 0x00EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCrashDuration;                              // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentJumpDuration;                               // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFallDuration;                               // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetOverrideGravityScale();
	float GetStageDuration(ERegularFloatingJumpStage InStage);
	void ResetOverrideGravityScale();
	void ResetStageDuration();
	void SetOverrideGravityScale(float GravityScale, ERegularFloatingJumpStage InStage);
	void SetStageDuration(ERegularFloatingJumpStage InStage, float inDuration);
	void UpdateStateDuration(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMOutputContext_InAir">();
	}
	static class URMOutputContext_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMOutputContext_InAir>();
	}
};
static_assert(alignof(URMOutputContext_InAir) == 0x000008, "Wrong alignment on URMOutputContext_InAir");
static_assert(sizeof(URMOutputContext_InAir) == 0x000100, "Wrong size on URMOutputContext_InAir");
static_assert(offsetof(URMOutputContext_InAir, PreviousFloatingJumpState) == 0x000088, "Member 'URMOutputContext_InAir::PreviousFloatingJumpState' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentFloatingJumpStage) == 0x000089, "Member 'URMOutputContext_InAir::CurrentFloatingJumpStage' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, PreviousJumpMode) == 0x00008A, "Member 'URMOutputContext_InAir::PreviousJumpMode' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentJumpMode) == 0x00008B, "Member 'URMOutputContext_InAir::CurrentJumpMode' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentActualGait) == 0x00008C, "Member 'URMOutputContext_InAir::CurrentActualGait' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurVelocityMappedSpeed) == 0x000090, "Member 'URMOutputContext_InAir::CurVelocityMappedSpeed' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bJumpingInAir) == 0x000094, "Member 'URMOutputContext_InAir::bJumpingInAir' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, PreemptionAttribute_TargetInterpSpeed_Override) == 0x000098, "Member 'URMOutputContext_InAir::PreemptionAttribute_TargetInterpSpeed_Override' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, PreemptionAttribute_MaxWalkSpeed_Override) == 0x00009C, "Member 'URMOutputContext_InAir::PreemptionAttribute_MaxWalkSpeed_Override' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurNormalJumpCount) == 0x0000A0, "Member 'URMOutputContext_InAir::CurNormalJumpCount' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bAfterJumpingOnGround) == 0x0000A4, "Member 'URMOutputContext_InAir::bAfterJumpingOnGround' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bAfterJumpingInAir) == 0x0000A5, "Member 'URMOutputContext_InAir::bAfterJumpingInAir' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bLogicRequireJump) == 0x0000A6, "Member 'URMOutputContext_InAir::bLogicRequireJump' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, IsLogicOperateInFallStage) == 0x0000A7, "Member 'URMOutputContext_InAir::IsLogicOperateInFallStage' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bInTimeWindowOfCacheDoubleJumpInput) == 0x0000A8, "Member 'URMOutputContext_InAir::bInTimeWindowOfCacheDoubleJumpInput' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bInTimeWindowOfResponseJumpInputWhenOffLedge) == 0x0000A9, "Member 'URMOutputContext_InAir::bInTimeWindowOfResponseJumpInputWhenOffLedge' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bInTimeWindowOfCacheJumpInput) == 0x0000AA, "Member 'URMOutputContext_InAir::bInTimeWindowOfCacheJumpInput' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurTimeDurationOfCacheJumpInput) == 0x0000AC, "Member 'URMOutputContext_InAir::CurTimeDurationOfCacheJumpInput' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, ExitPercherchWhenInFloatingState_GravityScale) == 0x0000B0, "Member 'URMOutputContext_InAir::ExitPercherchWhenInFloatingState_GravityScale' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bLocalPlayerHasState_WaitingCinematic) == 0x0000B4, "Member 'URMOutputContext_InAir::bLocalPlayerHasState_WaitingCinematic' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bCanDecelerateFallSpeedInFloatStage) == 0x0000B5, "Member 'URMOutputContext_InAir::bCanDecelerateFallSpeedInFloatStage' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentFloatTargetSpeed) == 0x0000B8, "Member 'URMOutputContext_InAir::CurrentFloatTargetSpeed' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bEnableRunUpFeature) == 0x0000BC, "Member 'URMOutputContext_InAir::bEnableRunUpFeature' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, RunUpMaxHorizontalSpped) == 0x0000C0, "Member 'URMOutputContext_InAir::RunUpMaxHorizontalSpped' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, WalkingTrendMaxWalkSpeed) == 0x0000C4, "Member 'URMOutputContext_InAir::WalkingTrendMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentAccumlateTime_InMovementModeFalling) == 0x0000C8, "Member 'URMOutputContext_InAir::CurrentAccumlateTime_InMovementModeFalling' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurInputActionJumpValue) == 0x0000CC, "Member 'URMOutputContext_InAir::CurInputActionJumpValue' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurInputActionFloatValue) == 0x0000CD, "Member 'URMOutputContext_InAir::CurInputActionFloatValue' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurInputActionRejumpValue) == 0x0000CE, "Member 'URMOutputContext_InAir::CurInputActionRejumpValue' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurInputActionJumpPressTime) == 0x0000D0, "Member 'URMOutputContext_InAir::CurInputActionJumpPressTime' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurInputActionJumpReleaseTime) == 0x0000D4, "Member 'URMOutputContext_InAir::CurInputActionJumpReleaseTime' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bInhibitJumpInputByAbleTask) == 0x0000D8, "Member 'URMOutputContext_InAir::bInhibitJumpInputByAbleTask' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, bInPlayerSkillMoveState) == 0x0000D9, "Member 'URMOutputContext_InAir::bInPlayerSkillMoveState' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, PlayerSkillMovementChangeMode) == 0x0000DA, "Member 'URMOutputContext_InAir::PlayerSkillMovementChangeMode' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, OverrideJumpGravityScale) == 0x0000DC, "Member 'URMOutputContext_InAir::OverrideJumpGravityScale' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, OverrideFallGravityScale) == 0x0000E0, "Member 'URMOutputContext_InAir::OverrideFallGravityScale' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, OverrideFloatGravityScale) == 0x0000E4, "Member 'URMOutputContext_InAir::OverrideFloatGravityScale' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, OverrideCrashGravityScale) == 0x0000E8, "Member 'URMOutputContext_InAir::OverrideCrashGravityScale' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentFloatDuration) == 0x0000EC, "Member 'URMOutputContext_InAir::CurrentFloatDuration' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentCrashDuration) == 0x0000F0, "Member 'URMOutputContext_InAir::CurrentCrashDuration' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentJumpDuration) == 0x0000F4, "Member 'URMOutputContext_InAir::CurrentJumpDuration' has a wrong offset!");
static_assert(offsetof(URMOutputContext_InAir, CurrentFallDuration) == 0x0000F8, "Member 'URMOutputContext_InAir::CurrentFallDuration' has a wrong offset!");

// Class X6Game.RMOutputContext_OnGround
// 0x0068 (0x00F0 - 0x0088)
class URMOutputContext_OnGround final : public URMOutputContextInterface
{
public:
	float                                         CurStartMovingTurnAroundAngle;                     // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentAllowedGait;                                // 0x008C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        LastAllowedGait;                                   // 0x008D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentActualGait;                                 // 0x008E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInplaceTurnAroundBehavior;                  // 0x008F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurInplaceTurnAroundAngle;                         // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurAITurnAroundAngle;                              // 0x0094(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMaxInput;                                    // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x57];                                      // 0x0099(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSwitchToNewAllowedGait(ERegularLocomotionType NewAllowedGait);
	void TryToSwitchSprintGait(bool bEnterSprint);
	void TryToSwitchWalkOrRunGait(bool bWalkOrRun);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMOutputContext_OnGround">();
	}
	static class URMOutputContext_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMOutputContext_OnGround>();
	}
};
static_assert(alignof(URMOutputContext_OnGround) == 0x000008, "Wrong alignment on URMOutputContext_OnGround");
static_assert(sizeof(URMOutputContext_OnGround) == 0x0000F0, "Wrong size on URMOutputContext_OnGround");
static_assert(offsetof(URMOutputContext_OnGround, CurStartMovingTurnAroundAngle) == 0x000088, "Member 'URMOutputContext_OnGround::CurStartMovingTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, CurrentAllowedGait) == 0x00008C, "Member 'URMOutputContext_OnGround::CurrentAllowedGait' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, LastAllowedGait) == 0x00008D, "Member 'URMOutputContext_OnGround::LastAllowedGait' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, CurrentActualGait) == 0x00008E, "Member 'URMOutputContext_OnGround::CurrentActualGait' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, bEnableInplaceTurnAroundBehavior) == 0x00008F, "Member 'URMOutputContext_OnGround::bEnableInplaceTurnAroundBehavior' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, CurInplaceTurnAroundAngle) == 0x000090, "Member 'URMOutputContext_OnGround::CurInplaceTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, CurAITurnAroundAngle) == 0x000094, "Member 'URMOutputContext_OnGround::CurAITurnAroundAngle' has a wrong offset!");
static_assert(offsetof(URMOutputContext_OnGround, bForceMaxInput) == 0x000098, "Member 'URMOutputContext_OnGround::bForceMaxInput' has a wrong offset!");

// Class X6Game.RMProxy_PlayerControl_InAir
// 0x0000 (0x0048 - 0x0048)
class URMProxy_PlayerControl_InAir final : public URMBehaviorTreeProxyInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxy_PlayerControl_InAir">();
	}
	static class URMProxy_PlayerControl_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxy_PlayerControl_InAir>();
	}
};
static_assert(alignof(URMProxy_PlayerControl_InAir) == 0x000008, "Wrong alignment on URMProxy_PlayerControl_InAir");
static_assert(sizeof(URMProxy_PlayerControl_InAir) == 0x000048, "Wrong size on URMProxy_PlayerControl_InAir");

// Class X6Game.RMProxy_PlayerControl_OnGround
// 0x0000 (0x0048 - 0x0048)
class URMProxy_PlayerControl_OnGround final : public URMBehaviorTreeProxyInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxy_PlayerControl_OnGround">();
	}
	static class URMProxy_PlayerControl_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxy_PlayerControl_OnGround>();
	}
};
static_assert(alignof(URMProxy_PlayerControl_OnGround) == 0x000008, "Wrong alignment on URMProxy_PlayerControl_OnGround");
static_assert(sizeof(URMProxy_PlayerControl_OnGround) == 0x000048, "Wrong size on URMProxy_PlayerControl_OnGround");

// Class X6Game.RMProxy_PlayerDrivedByAI_OnGround
// 0x0000 (0x0048 - 0x0048)
class URMProxy_PlayerDrivedByAI_OnGround final : public URMBehaviorTreeProxyInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxy_PlayerDrivedByAI_OnGround">();
	}
	static class URMProxy_PlayerDrivedByAI_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxy_PlayerDrivedByAI_OnGround>();
	}
};
static_assert(alignof(URMProxy_PlayerDrivedByAI_OnGround) == 0x000008, "Wrong alignment on URMProxy_PlayerDrivedByAI_OnGround");
static_assert(sizeof(URMProxy_PlayerDrivedByAI_OnGround) == 0x000048, "Wrong size on URMProxy_PlayerDrivedByAI_OnGround");

// Class X6Game.RMProxy_RemoteSimulated_InAir
// 0x0000 (0x0048 - 0x0048)
class URMProxy_RemoteSimulated_InAir final : public URMBehaviorTreeProxyInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxy_RemoteSimulated_InAir">();
	}
	static class URMProxy_RemoteSimulated_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxy_RemoteSimulated_InAir>();
	}
};
static_assert(alignof(URMProxy_RemoteSimulated_InAir) == 0x000008, "Wrong alignment on URMProxy_RemoteSimulated_InAir");
static_assert(sizeof(URMProxy_RemoteSimulated_InAir) == 0x000048, "Wrong size on URMProxy_RemoteSimulated_InAir");

// Class X6Game.RMProxy_RemoteSimulated_OnGround
// 0x0000 (0x0048 - 0x0048)
class URMProxy_RemoteSimulated_OnGround final : public URMBehaviorTreeProxyInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxy_RemoteSimulated_OnGround">();
	}
	static class URMProxy_RemoteSimulated_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxy_RemoteSimulated_OnGround>();
	}
};
static_assert(alignof(URMProxy_RemoteSimulated_OnGround) == 0x000008, "Wrong alignment on URMProxy_RemoteSimulated_OnGround");
static_assert(sizeof(URMProxy_RemoteSimulated_OnGround) == 0x000048, "Wrong size on URMProxy_RemoteSimulated_OnGround");

// Class X6Game.RMProxy_Simplified_OnGround
// 0x0000 (0x0048 - 0x0048)
class URMProxy_Simplified_OnGround final : public URMBehaviorTreeProxyInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMProxy_Simplified_OnGround">();
	}
	static class URMProxy_Simplified_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMProxy_Simplified_OnGround>();
	}
};
static_assert(alignof(URMProxy_Simplified_OnGround) == 0x000008, "Wrong alignment on URMProxy_Simplified_OnGround");
static_assert(sizeof(URMProxy_Simplified_OnGround) == 0x000048, "Wrong size on URMProxy_Simplified_OnGround");

// Class X6Game.RMPTickRecord_InAir
// 0x0050 (0x00C0 - 0x0070)
class URMPTickRecord_InAir final : public URMProxyTickRecordInterface
{
public:
	TWeakObjectPtr<class UX6RMWalkingComponent>   RMWalkingComponent;                                // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMOutputContext_InAir*                 OutputContext_InAir;                               // 0x0078(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMConfigContext_InAir*                 ConfigContext_InAir;                               // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasJumpAbility;                                   // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFloatAbility;                                  // 0x0089(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UCharacterMovementComponent> OwnerCharacterMovementComponent;               // 0x008C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UX6NikkiCPPTickHelperComponent> PlayerCPPTickHelperComponent;               // 0x0094(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentHeight;                                     // 0x009C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanAutoDoFloatWhenReachingApex();
	bool CanAutoDoJumpInAirWhenReachingApex();
	bool CanReleaseToFall();
	void CheckCanDecelerateFallSpeedInFloatStage();
	void ClearAccumulateDurationOfCacheDoubleJumpInput();
	void ClearAccumulateDurationOfCacheJumpInput();
	void ClearAccumulateDurationOfResponseJumpInputWhenOffLedgeTimer();
	void ClearJumpCount();
	void ClearTimerHandle(const struct FTimerHandle& TimerHandle);
	class UCharacterMovementComponent* GetCharacterMovementComponent();
	void HandleOn_KeepCurrentTrendFeature();
	void HandleOn_ProcessMovementParamsChangeWhenPlayingSkill();
	void HandleOn_UpdateAttributesByGeneralConfig();
	void HandleOn_UpdateAttributesByStageChange();
	void HandleOn_UpdateBrakingFrictionFactorValue();
	void HandleOn_UpdateRunUpDecelerationInFloatStage();
	bool HasFloatAbility();
	bool HasJumpAbility();
	void InitAccumlateTime_InMovementModeFalling();
	bool IsApex();
	bool IsBeforeApex();
	bool IsInCrashStage();
	bool IsInFallStage();
	bool IsInFloatStage();
	bool IsInJumpStage();
	bool IsOnLand();
	bool IsUseDoubleJumpZVelocity();
	void ResetInputAction_Jump();
	void ResetOverrideGravityScale();
	void ResetOwnerJumpStateConfig();
	void SetOverrideGravityScale(float NewGravityScale, ERegularFloatingJumpStage JumpStage);
	void SetRegularJumpMode(ERegularJumpMode NewRegularJumpMode);
	struct FTimerHandle SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
	void StartAccumulateDurationOfCacheDoubleJumpInput();
	void StartAccumulateDurationOfCacheJumpInput();
	void StartAccumulateDurationOfResponseJumpInputWhenOffLedgeTimer();
	void StopAccumulateTime_InMovementModeFalling();
	void UpdateAccumulateTime_InMovementModeFalling(float DeltaTime);
	void UpdateDebugInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMPTickRecord_InAir">();
	}
	static class URMPTickRecord_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMPTickRecord_InAir>();
	}
};
static_assert(alignof(URMPTickRecord_InAir) == 0x000008, "Wrong alignment on URMPTickRecord_InAir");
static_assert(sizeof(URMPTickRecord_InAir) == 0x0000C0, "Wrong size on URMPTickRecord_InAir");
static_assert(offsetof(URMPTickRecord_InAir, RMWalkingComponent) == 0x000070, "Member 'URMPTickRecord_InAir::RMWalkingComponent' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, OutputContext_InAir) == 0x000078, "Member 'URMPTickRecord_InAir::OutputContext_InAir' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, ConfigContext_InAir) == 0x000080, "Member 'URMPTickRecord_InAir::ConfigContext_InAir' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, bHasJumpAbility) == 0x000088, "Member 'URMPTickRecord_InAir::bHasJumpAbility' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, bHasFloatAbility) == 0x000089, "Member 'URMPTickRecord_InAir::bHasFloatAbility' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, OwnerCharacterMovementComponent) == 0x00008C, "Member 'URMPTickRecord_InAir::OwnerCharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, PlayerCPPTickHelperComponent) == 0x000094, "Member 'URMPTickRecord_InAir::PlayerCPPTickHelperComponent' has a wrong offset!");
static_assert(offsetof(URMPTickRecord_InAir, CurrentHeight) == 0x00009C, "Member 'URMPTickRecord_InAir::CurrentHeight' has a wrong offset!");

// Class X6Game.RMPTickRecord_OnGround
// 0x0010 (0x0080 - 0x0070)
class URMPTickRecord_OnGround final : public URMProxyTickRecordInterface
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanChangeCurDesiredGaitToNewGait(ERegularLocomotionType Gait);
	bool HasSprintAbility();
	void SwitchRequiringSprintOperation(bool InputBoolValue);
	void SwitchRequiringWalkOperation(bool InputBoolValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMPTickRecord_OnGround">();
	}
	static class URMPTickRecord_OnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMPTickRecord_OnGround>();
	}
};
static_assert(alignof(URMPTickRecord_OnGround) == 0x000008, "Wrong alignment on URMPTickRecord_OnGround");
static_assert(sizeof(URMPTickRecord_OnGround) == 0x000080, "Wrong size on URMPTickRecord_OnGround");

// Class X6Game.RMStateMachineContext_InAir
// 0x0040 (0x0068 - 0x0028)
class URMStateMachineContext_InAir final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentFloatInterpDuration;                        // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x1C];                                      // 0x004C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ChangeJumpStage(ERegularFloatingJumpStage NewStage, bool bForceUpdate);
	void BP_Handle_StageChanged(ERegularFloatingJumpStage PreviousStage, ERegularFloatingJumpStage NewStage);
	void BP_OnEnterCrash();
	void BP_OnEnterFall();
	void BP_OnEnterFloat();
	void BP_OnEnterJump();
	void BP_OnEnterOnLand();
	void BP_OnExitCrash();
	void BP_OnExitFall();
	void BP_OnExitFloat();
	void BP_OnExitJump();
	void BP_OnExitOnLand();
	bool CanCrash();
	bool CanDoFloat(bool bForce);
	bool CanJump(bool bForce, bool NeedToDoAction);
	bool CanMultipleJump(ERegularJumpMode NewRegularJumpMode, bool NeedToDoAction);
	void ChangeJumpStage(ERegularFloatingJumpStage NewStage, bool bForceUpdate);
	void Clear_Timer_CheckPerchWhenInFloatingStage();
	void Deinitialize();
	void DoCrash();
	bool DoFall(bool bForce);
	bool DoFloat(bool bForce);
	bool DoJump(bool bForce, ERegularJumpMode NewRegularJumpMode);
	void DoLand();
	bool DoMultipleJump(bool bForce, ERegularJumpMode NewRegularJumpMode);
	bool DoReleaseToFall();
	void Handle_CheckPerchWhenInFloatingState();
	bool Handle_DetermineActionSlotJumpIsAvailable();
	bool HasFloatAbility();
	bool HasJumpAbility();
	void OnCheckPerchWhenInFloatingStage();
	void OnEnterCrash();
	void OnEnterFall();
	void OnEnterFloat();
	void OnEnterJump();
	void OnEnterOnLand();
	void OnExitCrash();
	void OnExitFall();
	void OnExitFloat();
	void OnExitJump();
	void OnExitOnLand();
	void OnInitialize(class URMProxyTickRecordInterface* TickRecord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RMStateMachineContext_InAir">();
	}
	static class URMStateMachineContext_InAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<URMStateMachineContext_InAir>();
	}
};
static_assert(alignof(URMStateMachineContext_InAir) == 0x000008, "Wrong alignment on URMStateMachineContext_InAir");
static_assert(sizeof(URMStateMachineContext_InAir) == 0x000068, "Wrong size on URMStateMachineContext_InAir");
static_assert(offsetof(URMStateMachineContext_InAir, CurrentFloatInterpDuration) == 0x000048, "Member 'URMStateMachineContext_InAir::CurrentFloatInterpDuration' has a wrong offset!");

// Class X6Game.X6AssetUserData_KeepTexture
// 0x0000 (0x0028 - 0x0028)
class UX6AssetUserData_KeepTexture final : public UAssetUserData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AssetUserData_KeepTexture">();
	}
	static class UX6AssetUserData_KeepTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AssetUserData_KeepTexture>();
	}
};
static_assert(alignof(UX6AssetUserData_KeepTexture) == 0x000008, "Wrong alignment on UX6AssetUserData_KeepTexture");
static_assert(sizeof(UX6AssetUserData_KeepTexture) == 0x000028, "Wrong size on UX6AssetUserData_KeepTexture");

// Class X6Game.ScreenShotManager
// 0x0068 (0x0098 - 0x0030)
class UScreenShotManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnScreenshotCaptured;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(const struct FVector2D& ScreenSize)> OnViewportResizedDel;                        // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             LastCapturedScreenShot;                            // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIRequestedX;                                      // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UIRequestedY;                                      // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoCalCropArea;                                   // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CropAreaStartPos;                                  // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CropAreaWidth;                                     // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CropAreaHeight;                                    // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindDelegateToViewportResized();
	void ClearCachedScreenShot();
	void DoHighResShot(const class FString& Cmd);
	void DoShot(bool bShowUI);
	void UnbindDelegateFromViewportResized();

	class UTexture2D* GetLastCapturedScreenShot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenShotManager">();
	}
	static class UScreenShotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenShotManager>();
	}
};
static_assert(alignof(UScreenShotManager) == 0x000008, "Wrong alignment on UScreenShotManager");
static_assert(sizeof(UScreenShotManager) == 0x000098, "Wrong size on UScreenShotManager");
static_assert(offsetof(UScreenShotManager, OnScreenshotCaptured) == 0x000038, "Member 'UScreenShotManager::OnScreenshotCaptured' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, OnViewportResizedDel) == 0x000048, "Member 'UScreenShotManager::OnViewportResizedDel' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, LastCapturedScreenShot) == 0x000058, "Member 'UScreenShotManager::LastCapturedScreenShot' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, UIRequestedX) == 0x000068, "Member 'UScreenShotManager::UIRequestedX' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, UIRequestedY) == 0x00006C, "Member 'UScreenShotManager::UIRequestedY' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, AutoCalCropArea) == 0x000070, "Member 'UScreenShotManager::AutoCalCropArea' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, CropAreaStartPos) == 0x000078, "Member 'UScreenShotManager::CropAreaStartPos' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, CropAreaWidth) == 0x000088, "Member 'UScreenShotManager::CropAreaWidth' has a wrong offset!");
static_assert(offsetof(UScreenShotManager, CropAreaHeight) == 0x00008C, "Member 'UScreenShotManager::CropAreaHeight' has a wrong offset!");

// Class X6Game.StimuliManager
// 0x0130 (0x0158 - 0x0028)
class UStimuliManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int64 Identifier, const struct FVector& SourceLocation, class AActor* OwnerActor, int32 StimuliTag, const TArray<class AActor*>& SenseActors, bool IsPending)> OnSenseStimuli; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int64 Identifier, int32 StimuliTag, class AActor* OwnerActor)> OnStimuliSourceRemoved; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStimuliSourceSet>              StimuliSourceArray;                                // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0xF0];                                      // 0x0068(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStimuliSensor(int64 Identifier, class AActor* OwnerActor, float SenseRadius, float SenseHalfAngle);
	void AddStimuliSource(int64 Identifier, class AActor* Owner, const struct FVector& InitLocation, const struct FStimuliSource& StimuliSource);
	void RemoveAllStimuliSource(int64 Identifier);
	void RemoveMultiStimuliSource(int64 Identifier, const TArray<int32>& StimuliTags);
	void RemoveStimuliSensor(int64 Identifier);
	void RemoveStimuliSource(int64 Identifier, int32 StimuliTag);

	bool FindStimuliSource(int64 Identifier, int32 StimuliTag, struct FStimuliSource* OutSource) const;
	bool HasStimuliSourceSet(int64 Identifier) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StimuliManager">();
	}
	static class UStimuliManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStimuliManager>();
	}
};
static_assert(alignof(UStimuliManager) == 0x000008, "Wrong alignment on UStimuliManager");
static_assert(sizeof(UStimuliManager) == 0x000158, "Wrong size on UStimuliManager");
static_assert(offsetof(UStimuliManager, OnSenseStimuli) == 0x000030, "Member 'UStimuliManager::OnSenseStimuli' has a wrong offset!");
static_assert(offsetof(UStimuliManager, OnStimuliSourceRemoved) == 0x000040, "Member 'UStimuliManager::OnStimuliSourceRemoved' has a wrong offset!");
static_assert(offsetof(UStimuliManager, StimuliSourceArray) == 0x000058, "Member 'UStimuliManager::StimuliSourceArray' has a wrong offset!");

// Class X6Game.StimuliPreprocessSystem
// 0x0070 (0x0098 - 0x0028)
class UStimuliPreprocessSystem final : public UObject
{
public:
	TMulticastInlineDelegate<void(int64 Identifier, const struct FVector& SourceLocation, class AActor* OwnerActor, int32 StimuliTag, class AActor* SenseActor, const TArray<int32>& RuleIDs)> OnPreprocessorSenseStimuli; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStimuliManager*                        StimuliManager;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FStimuliPreprocessor> PreprocessorMap;                                // 0x0048(0x0050)(NativeAccessSpecifierPrivate)

public:
	void OnActorDestroy(class AActor* DestroyedActor);
	void OnSenseStimuli(int64 Identifier, const struct FVector& SourceLocation, class AActor* SourceActor, int32 StimuliTag, const TArray<class AActor*>& SenseActors, bool IsPendingRemove);
	void OnStimuliSourceSetRemoved(int64 Identifier, int32 StimuliTag, class AActor* OwnerActor);
	void RegisterPreprocessorRule(class AActor* OwnerActor, const struct FStimuliPreprocessorRule& Rule);
	void UnregisterPreprocessorRule(class AActor* OwnerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StimuliPreprocessSystem">();
	}
	static class UStimuliPreprocessSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStimuliPreprocessSystem>();
	}
};
static_assert(alignof(UStimuliPreprocessSystem) == 0x000008, "Wrong alignment on UStimuliPreprocessSystem");
static_assert(sizeof(UStimuliPreprocessSystem) == 0x000098, "Wrong size on UStimuliPreprocessSystem");
static_assert(offsetof(UStimuliPreprocessSystem, OnPreprocessorSenseStimuli) == 0x000028, "Member 'UStimuliPreprocessSystem::OnPreprocessorSenseStimuli' has a wrong offset!");
static_assert(offsetof(UStimuliPreprocessSystem, StimuliManager) == 0x000038, "Member 'UStimuliPreprocessSystem::StimuliManager' has a wrong offset!");
static_assert(offsetof(UStimuliPreprocessSystem, PreprocessorMap) == 0x000048, "Member 'UStimuliPreprocessSystem::PreprocessorMap' has a wrong offset!");

// Class X6Game.TargetSwitchCommand
// 0x0028 (0x0050 - 0x0028)
class UTargetSwitchCommand : public UObject
{
public:
	ETargetSwitchMode                             TargetSwitchMode;                                  // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BaseRotation;                                      // 0x0030(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSwitchCommand">();
	}
	static class UTargetSwitchCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSwitchCommand>();
	}
};
static_assert(alignof(UTargetSwitchCommand) == 0x000008, "Wrong alignment on UTargetSwitchCommand");
static_assert(sizeof(UTargetSwitchCommand) == 0x000050, "Wrong size on UTargetSwitchCommand");
static_assert(offsetof(UTargetSwitchCommand, TargetSwitchMode) == 0x000028, "Member 'UTargetSwitchCommand::TargetSwitchMode' has a wrong offset!");
static_assert(offsetof(UTargetSwitchCommand, Priority) == 0x00002C, "Member 'UTargetSwitchCommand::Priority' has a wrong offset!");
static_assert(offsetof(UTargetSwitchCommand, BaseRotation) == 0x000030, "Member 'UTargetSwitchCommand::BaseRotation' has a wrong offset!");

// Class X6Game.TargetSwitchCommand_PlaySkill
// 0x0010 (0x0060 - 0x0050)
class UTargetSwitchCommand_PlaySkill final : public UTargetSwitchCommand
{
public:
	TArray<class AActor*>                         PendingTargets;                                    // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSwitchCommand_PlaySkill">();
	}
	static class UTargetSwitchCommand_PlaySkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSwitchCommand_PlaySkill>();
	}
};
static_assert(alignof(UTargetSwitchCommand_PlaySkill) == 0x000008, "Wrong alignment on UTargetSwitchCommand_PlaySkill");
static_assert(sizeof(UTargetSwitchCommand_PlaySkill) == 0x000060, "Wrong size on UTargetSwitchCommand_PlaySkill");
static_assert(offsetof(UTargetSwitchCommand_PlaySkill, PendingTargets) == 0x000050, "Member 'UTargetSwitchCommand_PlaySkill::PendingTargets' has a wrong offset!");

// Class X6Game.TargetSwitchCommand_ActiveTryLocking
// 0x0020 (0x0070 - 0x0050)
class UTargetSwitchCommand_ActiveTryLocking final : public UTargetSwitchCommand
{
public:
	struct FVector                                TapLocation;                                       // 0x0050(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETouchIndex                                   FingerIndex;                                       // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interval;                                          // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSwitchCommand_ActiveTryLocking">();
	}
	static class UTargetSwitchCommand_ActiveTryLocking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSwitchCommand_ActiveTryLocking>();
	}
};
static_assert(alignof(UTargetSwitchCommand_ActiveTryLocking) == 0x000008, "Wrong alignment on UTargetSwitchCommand_ActiveTryLocking");
static_assert(sizeof(UTargetSwitchCommand_ActiveTryLocking) == 0x000070, "Wrong size on UTargetSwitchCommand_ActiveTryLocking");
static_assert(offsetof(UTargetSwitchCommand_ActiveTryLocking, TapLocation) == 0x000050, "Member 'UTargetSwitchCommand_ActiveTryLocking::TapLocation' has a wrong offset!");
static_assert(offsetof(UTargetSwitchCommand_ActiveTryLocking, FingerIndex) == 0x000068, "Member 'UTargetSwitchCommand_ActiveTryLocking::FingerIndex' has a wrong offset!");
static_assert(offsetof(UTargetSwitchCommand_ActiveTryLocking, Interval) == 0x00006C, "Member 'UTargetSwitchCommand_ActiveTryLocking::Interval' has a wrong offset!");

// Class X6Game.TargetSwitchCommand_Attacked
// 0x0008 (0x0058 - 0x0050)
class UTargetSwitchCommand_Attacked final : public UTargetSwitchCommand
{
public:
	class AActor*                                 Attacker;                                          // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSwitchCommand_Attacked">();
	}
	static class UTargetSwitchCommand_Attacked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSwitchCommand_Attacked>();
	}
};
static_assert(alignof(UTargetSwitchCommand_Attacked) == 0x000008, "Wrong alignment on UTargetSwitchCommand_Attacked");
static_assert(sizeof(UTargetSwitchCommand_Attacked) == 0x000058, "Wrong size on UTargetSwitchCommand_Attacked");
static_assert(offsetof(UTargetSwitchCommand_Attacked, Attacker) == 0x000050, "Member 'UTargetSwitchCommand_Attacked::Attacker' has a wrong offset!");

// Class X6Game.TargetSwitchCommand_Death
// 0x0000 (0x0050 - 0x0050)
class UTargetSwitchCommand_Death final : public UTargetSwitchCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSwitchCommand_Death">();
	}
	static class UTargetSwitchCommand_Death* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSwitchCommand_Death>();
	}
};
static_assert(alignof(UTargetSwitchCommand_Death) == 0x000008, "Wrong alignment on UTargetSwitchCommand_Death");
static_assert(sizeof(UTargetSwitchCommand_Death) == 0x000050, "Wrong size on UTargetSwitchCommand_Death");

// Class X6Game.TargetSystemComponent
// 0x0208 (0x02B0 - 0x00A8)
class UTargetSystemComponent final : public UActorComponent
{
public:
	float                                         MinimumDistanceToEnable;                           // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     TargetableActors;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetableCollisionChannel;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldControlRotation;                            // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLookInput;                                  // 0x00BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedInViewport;                                   // 0x00BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF[0x1];                                       // 0x00BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartRotatingThreshold;                            // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDrawLockedOnEffect;                         // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawLockedOnWidgetOrNiagaraEffect;                // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                LockedOnWidgetClass;                               // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetSpace                                  LockedOnWidgetSpaceType;                           // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockedOnWidgetDrawSize;                            // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockedOnWidgetWorldScale;                          // 0x00D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockedOnWidgetRelativeLocation;                    // 0x00F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LockedOnNiagaraTemplate;                           // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockedOnNiagaraRelativeLocation;                   // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LockedOnNiagaraRelativeRotation;                   // 0x0128(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      NiagaraParamMap;                                   // 0x0140(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPriorityRadius;                                 // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPriorityRadius;                                 // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPriorityAngle;                                  // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPriorityAngle;                                  // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeAttackedSwitchCoolDown;                          // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustPitchBasedOnDistanceToTarget;               // 0x01A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchDistanceCoefficient;                          // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchDistanceOffset;                               // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMin;                                          // 0x01B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStickyTarget;                               // 0x01BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisMultiplier;                                    // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickyRotationThreshold;                           // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* TargetActor)> OnTargetLockedOff;                     // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* TargetActor)> OnTargetLockedOn;                      // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* TargetActor, const struct FRotator& ControlRotation)> OnTargetSetRotation; // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 CharacterReference;                                // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      PlayerController;                                  // 0x0200(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LockedOnTargetActor;                               // 0x0208(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AActor>                  PendingLockedOnTargetAttacker;                     // 0x0210(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETargetSwitchMode, class UTargetSwitchCommand*> CachedCommands;                             // 0x0240(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* CustomFilterTargets(const TArray<class AActor*>& Actors);
	void ExcuteTargetSwitchCommand(class UTargetSwitchCommand* TargetSwitchCommand);
	struct FVector GetCurrentCharacterInputVector();
	class UTargetSwitchCommand* GetSwitchTargetCommandByType(ETargetSwitchMode TargetSwitchMode);
	bool GetTargetLockedStatus();
	bool IsEnableTargetLocking();
	void TargetActor();
	void TargetActorWithAxisInput(float AxisValue);
	class AActor* TargetFilterByPriorityRuleAndRotation(const TArray<class AActor*>& Actors, const struct FRotator& CurrentRotation, bool needInArea);
	class AActor* TargetFilterByPriorityRuleAndRotation_Override(const TArray<class AActor*>& Actors, const struct FRotator& CurrentRotation, bool needInArea);
	void TargetLockOff();

	class AActor* GetLockedOnTargetActor() const;
	bool IsLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSystemComponent">();
	}
	static class UTargetSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSystemComponent>();
	}
};
static_assert(alignof(UTargetSystemComponent) == 0x000008, "Wrong alignment on UTargetSystemComponent");
static_assert(sizeof(UTargetSystemComponent) == 0x0002B0, "Wrong size on UTargetSystemComponent");
static_assert(offsetof(UTargetSystemComponent, MinimumDistanceToEnable) == 0x0000A8, "Member 'UTargetSystemComponent::MinimumDistanceToEnable' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, TargetableActors) == 0x0000B0, "Member 'UTargetSystemComponent::TargetableActors' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, TargetableCollisionChannel) == 0x0000B8, "Member 'UTargetSystemComponent::TargetableCollisionChannel' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bShouldControlRotation) == 0x0000BC, "Member 'UTargetSystemComponent::bShouldControlRotation' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bIgnoreLookInput) == 0x0000BD, "Member 'UTargetSystemComponent::bIgnoreLookInput' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bNeedInViewport) == 0x0000BE, "Member 'UTargetSystemComponent::bNeedInViewport' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, StartRotatingThreshold) == 0x0000C0, "Member 'UTargetSystemComponent::StartRotatingThreshold' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bShouldDrawLockedOnEffect) == 0x0000C4, "Member 'UTargetSystemComponent::bShouldDrawLockedOnEffect' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bDrawLockedOnWidgetOrNiagaraEffect) == 0x0000C5, "Member 'UTargetSystemComponent::bDrawLockedOnWidgetOrNiagaraEffect' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnWidgetClass) == 0x0000C8, "Member 'UTargetSystemComponent::LockedOnWidgetClass' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnWidgetSpaceType) == 0x0000D0, "Member 'UTargetSystemComponent::LockedOnWidgetSpaceType' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnWidgetDrawSize) == 0x0000D4, "Member 'UTargetSystemComponent::LockedOnWidgetDrawSize' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnWidgetWorldScale) == 0x0000D8, "Member 'UTargetSystemComponent::LockedOnWidgetWorldScale' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnWidgetRelativeLocation) == 0x0000F0, "Member 'UTargetSystemComponent::LockedOnWidgetRelativeLocation' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnNiagaraTemplate) == 0x000108, "Member 'UTargetSystemComponent::LockedOnNiagaraTemplate' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnNiagaraRelativeLocation) == 0x000110, "Member 'UTargetSystemComponent::LockedOnNiagaraRelativeLocation' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnNiagaraRelativeRotation) == 0x000128, "Member 'UTargetSystemComponent::LockedOnNiagaraRelativeRotation' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, NiagaraParamMap) == 0x000140, "Member 'UTargetSystemComponent::NiagaraParamMap' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bAutoDestroy) == 0x000190, "Member 'UTargetSystemComponent::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, MinPriorityRadius) == 0x000194, "Member 'UTargetSystemComponent::MinPriorityRadius' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, MaxPriorityRadius) == 0x000198, "Member 'UTargetSystemComponent::MaxPriorityRadius' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, MinPriorityAngle) == 0x00019C, "Member 'UTargetSystemComponent::MinPriorityAngle' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, MaxPriorityAngle) == 0x0001A0, "Member 'UTargetSystemComponent::MaxPriorityAngle' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, BeAttackedSwitchCoolDown) == 0x0001A4, "Member 'UTargetSystemComponent::BeAttackedSwitchCoolDown' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bAdjustPitchBasedOnDistanceToTarget) == 0x0001A8, "Member 'UTargetSystemComponent::bAdjustPitchBasedOnDistanceToTarget' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, PitchDistanceCoefficient) == 0x0001AC, "Member 'UTargetSystemComponent::PitchDistanceCoefficient' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, PitchDistanceOffset) == 0x0001B0, "Member 'UTargetSystemComponent::PitchDistanceOffset' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, PitchMin) == 0x0001B4, "Member 'UTargetSystemComponent::PitchMin' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, PitchMax) == 0x0001B8, "Member 'UTargetSystemComponent::PitchMax' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bEnableStickyTarget) == 0x0001BC, "Member 'UTargetSystemComponent::bEnableStickyTarget' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, AxisMultiplier) == 0x0001C0, "Member 'UTargetSystemComponent::AxisMultiplier' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, StickyRotationThreshold) == 0x0001C4, "Member 'UTargetSystemComponent::StickyRotationThreshold' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, OnTargetLockedOff) == 0x0001C8, "Member 'UTargetSystemComponent::OnTargetLockedOff' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, OnTargetLockedOn) == 0x0001D8, "Member 'UTargetSystemComponent::OnTargetLockedOn' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, OnTargetSetRotation) == 0x0001E8, "Member 'UTargetSystemComponent::OnTargetSetRotation' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, CharacterReference) == 0x0001F8, "Member 'UTargetSystemComponent::CharacterReference' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, PlayerController) == 0x000200, "Member 'UTargetSystemComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, LockedOnTargetActor) == 0x000208, "Member 'UTargetSystemComponent::LockedOnTargetActor' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, PendingLockedOnTargetAttacker) == 0x000210, "Member 'UTargetSystemComponent::PendingLockedOnTargetAttacker' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, CachedCommands) == 0x000240, "Member 'UTargetSystemComponent::CachedCommands' has a wrong offset!");

// Class X6Game.TargetSystemTargetableInterface
// 0x0000 (0x0000 - 0x0000)
class ITargetSystemTargetableInterface final : public IInterface
{
public:
	class FName GetLockedOnMeshSocket() const;
	bool IsTargetable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSystemTargetableInterface">();
	}
	static class ITargetSystemTargetableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITargetSystemTargetableInterface>();
	}
};
static_assert(alignof(ITargetSystemTargetableInterface) == 0x000001, "Wrong alignment on ITargetSystemTargetableInterface");
static_assert(sizeof(ITargetSystemTargetableInterface) == 0x000001, "Wrong size on ITargetSystemTargetableInterface");

// Class X6Game.UX6BoxCollisionComponent
// 0x0000 (0x0600 - 0x0600)
class UUX6BoxCollisionComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UX6BoxCollisionComponent">();
	}
	static class UUX6BoxCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUX6BoxCollisionComponent>();
	}
};
static_assert(alignof(UUX6BoxCollisionComponent) == 0x000010, "Wrong alignment on UUX6BoxCollisionComponent");
static_assert(sizeof(UUX6BoxCollisionComponent) == 0x000600, "Wrong size on UUX6BoxCollisionComponent");

// Class X6Game.WaterVoxelContainer
// 0x0190 (0x0538 - 0x03A8)
class AWaterVoxelContainer final : public AActor
{
public:
	uint8                                         Pad_3A8[0x180];                                    // 0x03A8(0x0180)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6FBoxesRenderingComp*                 BoxesRenderingComp;                                // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnableDrawing : 1;                                // 0x0530(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCompAndDelegate(class USceneComponent* Component, TDelegate<void(bool IsInWater)> OnWaterActorsChanged);
	void CollectAndDrawLeafBoxes();
	void DrawLeafBoxes(class UObject* targetUObject, float LifeTime, bool bDrawComplicated);
	void ImportBigWorldWaterVoxelFromDT();
	void ImportOtherLevelWaterVoxelFromDT(class FString* LevelName);
	void ImportWaterVoxelFromDTByWorldID(class FString* worldId, TDelegate<void(bool IsAdd)> InOnAssetLoaded);
	bool IsEnteredWater(const struct FVector& Point);
	void RemoveCompAndDelegate(class USceneComponent* Component);
	void SetEnableDebugDraw(bool bEnable);
	void SetNotDrawLeafBoxes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterVoxelContainer">();
	}
	static class AWaterVoxelContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterVoxelContainer>();
	}
};
static_assert(alignof(AWaterVoxelContainer) == 0x000008, "Wrong alignment on AWaterVoxelContainer");
static_assert(sizeof(AWaterVoxelContainer) == 0x000538, "Wrong size on AWaterVoxelContainer");
static_assert(offsetof(AWaterVoxelContainer, BoxesRenderingComp) == 0x000528, "Member 'AWaterVoxelContainer::BoxesRenderingComp' has a wrong offset!");

// Class X6Game.X6AbilityModifierBase
// 0x0000 (0x0028 - 0x0028)
class UX6AbilityModifierBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityModifierBase">();
	}
	static class UX6AbilityModifierBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityModifierBase>();
	}
};
static_assert(alignof(UX6AbilityModifierBase) == 0x000008, "Wrong alignment on UX6AbilityModifierBase");
static_assert(sizeof(UX6AbilityModifierBase) == 0x000028, "Wrong size on UX6AbilityModifierBase");

// Class X6Game.X6AbilityTask_ChargeUp
// 0x0048 (0x00C8 - 0x0080)
class UX6AbilityTask_ChargeUp final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float CurTime)> OnChargeUpFinish;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float CurTime)> OnChargeUpFailed;                                  // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float CurTime)> OnChargeUpPhaseComplete;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_ChargeUp* ChargeUpProxy(class UGameplayAbility* OwningAbility, float Duration);

	void OnReleaseCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_ChargeUp">();
	}
	static class UX6AbilityTask_ChargeUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_ChargeUp>();
	}
};
static_assert(alignof(UX6AbilityTask_ChargeUp) == 0x000008, "Wrong alignment on UX6AbilityTask_ChargeUp");
static_assert(sizeof(UX6AbilityTask_ChargeUp) == 0x0000C8, "Wrong size on UX6AbilityTask_ChargeUp");
static_assert(offsetof(UX6AbilityTask_ChargeUp, OnChargeUpFinish) == 0x000080, "Member 'UX6AbilityTask_ChargeUp::OnChargeUpFinish' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ChargeUp, OnChargeUpFailed) == 0x000090, "Member 'UX6AbilityTask_ChargeUp::OnChargeUpFailed' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ChargeUp, OnChargeUpPhaseComplete) == 0x0000A0, "Member 'UX6AbilityTask_ChargeUp::OnChargeUpPhaseComplete' has a wrong offset!");

// Class X6Game.X6AbilityTask_PerformTargeting
// 0x0020 (0x00A0 - 0x0080)
class UX6AbilityTask_PerformTargeting final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FHitResult>& ResultData)> OnTargetReady;       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_PerformTargeting* X6PerformTargetingRequest(class UGameplayAbility* OwningAbility, class UTargetingPreset* InTargetingPreset, bool bAllowAsync);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_PerformTargeting">();
	}
	static class UX6AbilityTask_PerformTargeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_PerformTargeting>();
	}
};
static_assert(alignof(UX6AbilityTask_PerformTargeting) == 0x000008, "Wrong alignment on UX6AbilityTask_PerformTargeting");
static_assert(sizeof(UX6AbilityTask_PerformTargeting) == 0x0000A0, "Wrong size on UX6AbilityTask_PerformTargeting");
static_assert(offsetof(UX6AbilityTask_PerformTargeting, OnTargetReady) == 0x000080, "Member 'UX6AbilityTask_PerformTargeting::OnTargetReady' has a wrong offset!");

// Class X6Game.X6AbilityTask_PlayMontageForMeshAndWaitForEvent
// 0x00C0 (0x0140 - 0x0080)
class UX6AbilityTask_PlayMontageForMeshAndWaitForEvent final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class FName NotifyName)> OnCompleted;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnBlendOut;                               // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnInterrupted;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnCancelled;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyBegin;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyEnd;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 mesh;                                              // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x00F4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideBlendOutTimeForCancelAbility;              // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverrideBlendOutTimeForStopWhenEndAbility;         // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x2C];                                     // 0x010C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMirror;                                           // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_PlayMontageForMeshAndWaitForEvent* PlayMontageForMeshAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class USkeletalMeshComponent* mesh_0, class UAnimMontage* MontageToPlay_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0, float OverrideBlendOutTimeForCancelAbility_0, float OverrideBlendOutTimeForStopWhenEndAbility_0, bool bMirror_0);

	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_PlayMontageForMeshAndWaitForEvent">();
	}
	static class UX6AbilityTask_PlayMontageForMeshAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_PlayMontageForMeshAndWaitForEvent>();
	}
};
static_assert(alignof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent) == 0x000008, "Wrong alignment on UX6AbilityTask_PlayMontageForMeshAndWaitForEvent");
static_assert(sizeof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent) == 0x000140, "Wrong size on UX6AbilityTask_PlayMontageForMeshAndWaitForEvent");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OnCompleted) == 0x000080, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OnBlendOut) == 0x000090, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OnInterrupted) == 0x0000A0, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OnCancelled) == 0x0000B0, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OnNotifyBegin) == 0x0000C0, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OnNotifyEnd) == 0x0000D0, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OnNotifyEnd' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, mesh) == 0x0000E0, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::mesh' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, MontageToPlay) == 0x0000E8, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, Rate) == 0x0000F0, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, StartSection) == 0x0000F4, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, AnimRootMotionTranslationScale) == 0x0000FC, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, bStopWhenAbilityEnds) == 0x000100, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OverrideBlendOutTimeForCancelAbility) == 0x000104, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OverrideBlendOutTimeForCancelAbility' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, OverrideBlendOutTimeForStopWhenEndAbility) == 0x000108, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::OverrideBlendOutTimeForStopWhenEndAbility' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageForMeshAndWaitForEvent, bMirror) == 0x000138, "Member 'UX6AbilityTask_PlayMontageForMeshAndWaitForEvent::bMirror' has a wrong offset!");

// Class X6Game.X6AbilityTask_SpawnBullet
// 0x0028 (0x00A8 - 0x0080)
class UX6AbilityTask_SpawnBullet final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPrimaryDataAsset*                      TriggerData;                                       // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsModifyHitDirection;                              // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UX6AbilityTask_SpawnBullet* SpawnBulletProxy(class UGameplayAbility* OwningAbility, class UPrimaryDataAsset* TriggerData_0, bool IsModifyHitDirection_0, class AActor* TargetActor_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_SpawnBullet">();
	}
	static class UX6AbilityTask_SpawnBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_SpawnBullet>();
	}
};
static_assert(alignof(UX6AbilityTask_SpawnBullet) == 0x000008, "Wrong alignment on UX6AbilityTask_SpawnBullet");
static_assert(sizeof(UX6AbilityTask_SpawnBullet) == 0x0000A8, "Wrong size on UX6AbilityTask_SpawnBullet");
static_assert(offsetof(UX6AbilityTask_SpawnBullet, OnCompleted) == 0x000080, "Member 'UX6AbilityTask_SpawnBullet::OnCompleted' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_SpawnBullet, TriggerData) == 0x000090, "Member 'UX6AbilityTask_SpawnBullet::TriggerData' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_SpawnBullet, IsModifyHitDirection) == 0x000098, "Member 'UX6AbilityTask_SpawnBullet::IsModifyHitDirection' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_SpawnBullet, TargetActor) == 0x0000A0, "Member 'UX6AbilityTask_SpawnBullet::TargetActor' has a wrong offset!");

// Class X6Game.X6AbilityTask_WaitAccelChange
// 0x0020 (0x00A0 - 0x0080)
class UX6AbilityTask_WaitAccelChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnAccelChange;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_WaitAccelChange* X6WaitAccelChange(class UGameplayAbility* OwningAbility, bool bChangeToZero);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_WaitAccelChange">();
	}
	static class UX6AbilityTask_WaitAccelChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_WaitAccelChange>();
	}
};
static_assert(alignof(UX6AbilityTask_WaitAccelChange) == 0x000008, "Wrong alignment on UX6AbilityTask_WaitAccelChange");
static_assert(sizeof(UX6AbilityTask_WaitAccelChange) == 0x0000A0, "Wrong size on UX6AbilityTask_WaitAccelChange");
static_assert(offsetof(UX6AbilityTask_WaitAccelChange, OnAccelChange) == 0x000080, "Member 'UX6AbilityTask_WaitAccelChange::OnAccelChange' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_WaitAccelChange, CachedMovementComponent) == 0x000090, "Member 'UX6AbilityTask_WaitAccelChange::CachedMovementComponent' has a wrong offset!");

// Class X6Game.X6Actor
// 0x0090 (0x0438 - 0x03A8)
class AX6Actor : public AActor
{
public:
	bool                                          IsGround;                                          // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UX6EditInLinePropertyBase*>      EditInLinePropertyArray;                           // 0x03B0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           X6Tags;                                            // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x68];                                     // 0x03D0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostServerInit(bool bServer);
	void PostSpawnerGroupSpawned();
	void ServerInit(bool bServer);
	void X6_AddTag(const TArray<class FName>& NewX6Tags);
	void X6_ClearAndInvalidateTimerHandle(const struct FTimerHandle& Handle);
	void X6_ClearTimer(class UObject* Object, const class FString& FunctionName);
	void X6_ClearTimerDelegate(TDelegate<void()> Delegate);
	void X6_ClearTimerHandle(const struct FTimerHandle& Handle);
	void X6_DeleteTag(const class FString& strTag);
	bool X6_GetActorHiddenFlags(TSet<int32>* OutFlags);
	TArray<class FName> X6_GetTag();
	float X6_GetTimerElapsedTime(class UObject* Object, const class FString& FunctionName);
	float X6_GetTimerElapsedTimeDelegate(TDelegate<void()> Delegate);
	float X6_GetTimerElapsedTimeDelegateEachTrigger(TDelegate<void()> Delegate);
	float X6_GetTimerElapsedTimeEachTrigger(class UObject* Object, const class FString& FunctionName);
	float X6_GetTimerElapsedTimeHandle(const struct FTimerHandle& Handle);
	float X6_GetTimerElapsedTimeHandleEachTrigger(const struct FTimerHandle& Handle);
	float X6_GetTimerRemainingTime(class UObject* Object, const class FString& FunctionName);
	float X6_GetTimerRemainingTimeDelegate(TDelegate<void()> Delegate);
	float X6_GetTimerRemainingTimeHandle(const struct FTimerHandle& Handle);
	bool X6_HasSimulatePhysicsComponent();
	bool X6_HasTag(const class FString& strTag);
	bool X6_IsTimerActive(class UObject* Object, const class FString& FunctionName);
	bool X6_IsTimerActiveDelegate(TDelegate<void()> Delegate);
	bool X6_IsTimerActiveHandle(const struct FTimerHandle& Handle);
	bool X6_IsTimerPaused(class UObject* Object, const class FString& FunctionName);
	bool X6_IsTimerPausedDelegate(TDelegate<void()> Delegate);
	bool X6_IsTimerPausedHandle(const struct FTimerHandle& Handle);
	bool X6_IsValidTimerHandle(const struct FTimerHandle& Handle);
	void X6_PauseTimer(class UObject* Object, const class FString& FunctionName);
	void X6_PauseTimerDelegate(TDelegate<void()> Delegate);
	void X6_PauseTimerHandle(const struct FTimerHandle& Handle);
	void X6_RequireActorFade(bool bFadeIn, int32 FadeOutHiddenFlag, bool bInView);
	bool X6_SetActorHiddenInGame(bool bNewHidden, int32 Flag, bool bClearFlag);
	struct FTimerHandle X6_SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
	struct FTimerHandle X6_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
	void X6_SimulatePhysicsDisable();
	void X6_SimulatePhysicsEnable();
	bool X6_TimerExists(class UObject* Object, const class FString& FunctionName);
	bool X6_TimerExistsDelegate(TDelegate<void()> Delegate);
	bool X6_TimerExistsHandle(const struct FTimerHandle& Handle);
	void X6_UnPauseTimer(class UObject* Object, const class FString& FunctionName);
	void X6_UnPauseTimerDelegate(TDelegate<void()> Delegate);
	void X6_UnPauseTimerHandle(const struct FTimerHandle& Handle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6Actor">();
	}
	static class AX6Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6Actor>();
	}
};
static_assert(alignof(AX6Actor) == 0x000008, "Wrong alignment on AX6Actor");
static_assert(sizeof(AX6Actor) == 0x000438, "Wrong size on AX6Actor");
static_assert(offsetof(AX6Actor, IsGround) == 0x0003A8, "Member 'AX6Actor::IsGround' has a wrong offset!");
static_assert(offsetof(AX6Actor, EditInLinePropertyArray) == 0x0003B0, "Member 'AX6Actor::EditInLinePropertyArray' has a wrong offset!");
static_assert(offsetof(AX6Actor, X6Tags) == 0x0003C0, "Member 'AX6Actor::X6Tags' has a wrong offset!");

// Class X6Game.X6ActorWithTag
// 0x0028 (0x0460 - 0x0438)
class AX6ActorWithTag : public AX6Actor
{
public:
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  StaticGameplayTags;                                // 0x0440(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ActorWithTag">();
	}
	static class AX6ActorWithTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6ActorWithTag>();
	}
};
static_assert(alignof(AX6ActorWithTag) == 0x000008, "Wrong alignment on AX6ActorWithTag");
static_assert(sizeof(AX6ActorWithTag) == 0x000460, "Wrong size on AX6ActorWithTag");
static_assert(offsetof(AX6ActorWithTag, StaticGameplayTags) == 0x000440, "Member 'AX6ActorWithTag::StaticGameplayTags' has a wrong offset!");

// Class X6Game.X6AdjustmentBlendWarpComponent
// 0x0030 (0x00D8 - 0x00A8)
class UX6AdjustmentBlendWarpComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ACharacter>              CharacterOwner;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class USkeletalMeshComponent>  CacheMeshComp;                                     // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMotionModifier_AdjustmentBlendWarp*> Modifiers;                                    // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FMotionWarpingTarget>           WarpTargets;                                       // 0x00C8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddOrUpdateWarpTarget(const struct FMotionWarpingTarget& WarpTarget);
	int32 RemoveWarpTarget(class FName WarpTargetName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AdjustmentBlendWarpComponent">();
	}
	static class UX6AdjustmentBlendWarpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AdjustmentBlendWarpComponent>();
	}
};
static_assert(alignof(UX6AdjustmentBlendWarpComponent) == 0x000008, "Wrong alignment on UX6AdjustmentBlendWarpComponent");
static_assert(sizeof(UX6AdjustmentBlendWarpComponent) == 0x0000D8, "Wrong size on UX6AdjustmentBlendWarpComponent");
static_assert(offsetof(UX6AdjustmentBlendWarpComponent, CharacterOwner) == 0x0000A8, "Member 'UX6AdjustmentBlendWarpComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UX6AdjustmentBlendWarpComponent, CacheMeshComp) == 0x0000B0, "Member 'UX6AdjustmentBlendWarpComponent::CacheMeshComp' has a wrong offset!");
static_assert(offsetof(UX6AdjustmentBlendWarpComponent, Modifiers) == 0x0000B8, "Member 'UX6AdjustmentBlendWarpComponent::Modifiers' has a wrong offset!");
static_assert(offsetof(UX6AdjustmentBlendWarpComponent, WarpTargets) == 0x0000C8, "Member 'UX6AdjustmentBlendWarpComponent::WarpTargets' has a wrong offset!");

// Class X6Game.X6AIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6AIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AdjustLocationWhenOverlap(class AActor* OwnerActor, class UCapsuleComponent* CapsuleComponet);
	static void CachedOrResetCapsuleCompLocation(class AActor* OwnerActor, class UCapsuleComponent* CapsuleComponet, bool bResetData, bool* IsRootComponent, float* Radius, float* HalfHeight, TMap<int64, float>* ChildComponentRelativeZMap);
	static void DisableActorRelatedTicks(class AActor* Actor, class UClass* IgnoreClass, TArray<class UObject*>* OutDisabledUObjects);
	static void EnableUObjectsTick(const TArray<class UObject*>& UObjects);
	static bool FindWalkableFloorInTargetSurround(class ACharacter* FollowTargetCharacter, class ACharacter* OwnerCharacter, struct FVector* OutWlakablePoint, bool bDetectDirectLand, float DirectLandDownTraceDis, float SecondTraceDeltaDistance, float HorizontalDistance, float DownDistance, int32 WaterCollionChannel);
	static float GetActorCollisionHalfHeight(class AActor* Actor);
	static float GetActorCollisionRadius(class AActor* Actor);
	static struct FVector GetActorNavLocation(const class AActor* Actor);
	static float GetDistToActorWithoutRadius(class AActor* ActorA, class AActor* ActorB, const bool OnXYPlane);
	static class UBehaviorTree* GetRootBehaviorTree(class AAIController* Controller);
	static float GetSignedAngleBetweenVector(const struct FVector& A, const struct FVector& B);
	static int32 InsertSteeringPointToPath(class UX6NavigationPathPoints* PathPoints, const struct FVector& Orientation, float MaxSteeringAngle, float StartSteeringDistance, float* OutYaw);
	static struct FVector InvalidLocation();
	static struct FRotator InvalidRotation();
	static bool IsActorInRange(class AActor* TestActor, const struct FVector& OriginPoint, const float Radius);
	static bool IsActorMovingOnGround(class AActor* Actor);
	static bool IsAgentFollowingAPath(class APawn* Agent);
	static bool IsNoneBBKeySelector(const struct FBlackboardKeySelector& InBBKeySelector);
	static bool IsPointInActorCone(const struct FVector& TestPoint, class AActor* Actor, const float ConeHalfAngle, const float ConeAngleOffset, const bool OnXYPlane);
	static bool IsPointInActorRange(class AActor* Actor, const struct FVector& TestPoint, const float Radius, const float HalfAngle, const float AngleOffset);
	static bool IsPointInActorRange2D(class AActor* Actor, const struct FVector& TestPoint, const float Radius, const float HalfAngle, const float AngleOffset);
	static bool LineSphereIntersection(const struct FVector& CircleCenter, float Radius, const struct FVector& LineStart, const struct FVector& LineEnd);
	static class UX6NavigationPathPoints* MakeNavigationPathPoints(const TArray<struct FVector>& PointLocations);
	static void PathPointsSineInterp(class UX6NavigationPathPoints* PathPoints, const class AActor* PathOwner, const int32 OneCycleSampleNum, const float AmplitudeMin, const float AmplitudeMax, const float FrequencyMin, const float FrequencyMax);
	static void SetPreciseReachThreshold(class AAIController* Controller, float AgentRadiusMultiplier, float AgentHalfHeightMultiplier);
	static void ShowAIGameplayDebugger(class UObject* WorldContextObject, bool bIsShow, class AActor* InTargetActor, TArray<int32>* EnableFeaturesArray);
	static bool SmoothPathByConstantRadius(class AActor* PathOwner, TArray<struct FVector>* InOutPath, float Radius, float InterpStep, bool bDrawDebug, float DrawTime);
	static void StopAIMovementAndResetVelocity(class AAIController* AIController);
	static struct FRotator SubsteppingQInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed, float TimeStep);
	static struct FVector SubsteppingVInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float TimeStep);
	static void TestFloorDist(const class AActor* TestActor, ETraceTypeQuery TraceType, float LineDistance, struct FFindFloorResult* OutFindFloorResult);
	static bool TryAdjustPathEndPoint(class UX6NavigationPathPoints* PathPoints, class AActor* PathOwner, const struct FVector& DesiredLocation, float AcceptanceMinDistanceSq, float AcceptanceMaxDistanceSq, const TArray<class AActor*>& ActorsToIgnore);
	static bool VisibilityClippingPathPoints(class APawn* OwnerActor, class UX6NavigationPathPoints* PathPoints, EVisibilityClipMode ClipMode, float ClipScreenSize, int32 IterationCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AIBlueprintLibrary">();
	}
	static class UX6AIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AIBlueprintLibrary>();
	}
};
static_assert(alignof(UX6AIBlueprintLibrary) == 0x000008, "Wrong alignment on UX6AIBlueprintLibrary");
static_assert(sizeof(UX6AIBlueprintLibrary) == 0x000028, "Wrong size on UX6AIBlueprintLibrary");

// Class X6Game.X6AIController
// 0x0078 (0x05B0 - 0x0538)
class AX6AIController final : public APaperAIController
{
public:
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          PitchDependOnFocusActor;                           // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FVector& CurrentToward, const struct FVector& MoveSegmentPoint)> OnAIFocusMoveRotationUpdate; // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& SuggestNavmeshLocation)> OnAgentGetOutOfNavmesh; // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNavMovementComponent*                  MovementComp;                                      // 0x0568(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          PendingStartBehaviorTree;                          // 0x0570(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x38];                                     // 0x0578(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetGetOutOfNavmeshThreshold(int32 threshold);

	void ClearMaxPitchAngle();
	EPathFollowingRequestResult FlyToActor(const class AActor* Goal, float AcceptanceRadius, bool bStopOnOverlap, int32 UserFlag);
	EPathFollowingRequestResult FlyToLocation(const struct FVector& dest, float AcceptanceRadius, bool bStopOnOverlap, int32 UserFlag);
	float GetAccelerationRotateSpeed();
	class UAIPerceptionComponent* GetPerceptionComponent();
	EPathFollowingRequestResult MoveToLocationWithFlag(const struct FVector& dest, int32 UserFlag, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPath);
	EPathFollowingRequestResult MoveToLocationWithPath(const struct FVector& dest, const TArray<struct FVector>& PathPoints, int32 UserFlag, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPaths);
	void OnForceRepath();
	void OnGetServerPath(int64 InRequestID, class UX6NavigationPathPoints* PathPoints);
	void PauseBehaviorTree(const class FString& Reason);
	void ReportMoveOutOfNavmesh();
	void ResumeBehaviorTree(const class FString& Reason);
	void SetAccelerationRotateSpeed(float InAccelerationRotateSpeed);
	void SetMaxPitchAngle(float ControlDepressionAngle, float ControlElevationAngle);
	void SetUseServerPathFinding(bool InUseServerPathFinding);
	void StopBehaviorTree(const class FString& Reason);
	EPathFollowingRequestResult X6FollowSpecifiedPath(class UX6NavigationPathPoints* PathPoints, float AcceptanceRadius, bool bStopOnOverlap, int32 UserFlag, bool bCanStrafe);
	EPathFollowingRequestResult X6MoveToActor(class AActor* Goal, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, int32 UserFlag, bool bDirectMoveIfPossible, const struct FDirectMoveParams& DirectMoveChecker, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPath);
	EPathFollowingRequestResult X6MoveToLocation(const struct FVector& dest, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, int32 UserFlag, bool bDirectMoveIfPossible, const struct FDirectMoveParams& DirectMoveChecker, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPaths, const struct FRotator& FinalRotation);
	bool X6RunBehaviorTree(class UBehaviorTree* BTAsset);

	bool CanDirectMoveToLocation(const struct FVector& dest, const struct FDirectMoveParams& DirectMoveChecker, EX6DirectMoveCheckMode CheckMode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AIController">();
	}
	static class AX6AIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6AIController>();
	}
};
static_assert(alignof(AX6AIController) == 0x000008, "Wrong alignment on AX6AIController");
static_assert(sizeof(AX6AIController) == 0x0005B0, "Wrong size on AX6AIController");
static_assert(offsetof(AX6AIController, PitchDependOnFocusActor) == 0x000540, "Member 'AX6AIController::PitchDependOnFocusActor' has a wrong offset!");
static_assert(offsetof(AX6AIController, OnAIFocusMoveRotationUpdate) == 0x000548, "Member 'AX6AIController::OnAIFocusMoveRotationUpdate' has a wrong offset!");
static_assert(offsetof(AX6AIController, OnAgentGetOutOfNavmesh) == 0x000558, "Member 'AX6AIController::OnAgentGetOutOfNavmesh' has a wrong offset!");
static_assert(offsetof(AX6AIController, MovementComp) == 0x000568, "Member 'AX6AIController::MovementComp' has a wrong offset!");
static_assert(offsetof(AX6AIController, PendingStartBehaviorTree) == 0x000570, "Member 'AX6AIController::PendingStartBehaviorTree' has a wrong offset!");

// Class X6Game.X6AimNS_AllSocketTimedNiagara
// 0x0000 (0x0078 - 0x0078)
class UX6AimNS_AllSocketTimedNiagara final : public UAnimNotifyState_TimedNiagaraEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AimNS_AllSocketTimedNiagara">();
	}
	static class UX6AimNS_AllSocketTimedNiagara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AimNS_AllSocketTimedNiagara>();
	}
};
static_assert(alignof(UX6AimNS_AllSocketTimedNiagara) == 0x000008, "Wrong alignment on UX6AimNS_AllSocketTimedNiagara");
static_assert(sizeof(UX6AimNS_AllSocketTimedNiagara) == 0x000078, "Wrong size on UX6AimNS_AllSocketTimedNiagara");

// Class X6Game.X6AIPerceptionComponent
// 0x0060 (0x01F8 - 0x0198)
class UX6AIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	uint8                                         Pad_198[0x50];                                     // 0x0198(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UX6AISenseModifier*>             Modifier;                                          // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddModifier(TSubclassOf<class UAISense> SenseClass, class UX6AISenseModifier* ToAddModifier);
	void AddSenseConfig(class UAISenseConfig* SenseConfig);
	void RemoveAllSenseConfigs();
	void SetSenseEnabledSafe(TSubclassOf<class UAISense> SenseClass, const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AIPerceptionComponent">();
	}
	static class UX6AIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AIPerceptionComponent>();
	}
};
static_assert(alignof(UX6AIPerceptionComponent) == 0x000008, "Wrong alignment on UX6AIPerceptionComponent");
static_assert(sizeof(UX6AIPerceptionComponent) == 0x0001F8, "Wrong size on UX6AIPerceptionComponent");
static_assert(offsetof(UX6AIPerceptionComponent, Modifier) == 0x0001E8, "Member 'UX6AIPerceptionComponent::Modifier' has a wrong offset!");

// Class X6Game.X6AIPerformanceSetting
// 0x0018 (0x0050 - 0x0038)
class UX6AIPerformanceSetting final : public UDeveloperSettings
{
public:
	float                                         TotalBudgetTime;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConsumeTimeInfo>               FunctionBudgetTime;                                // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AIPerformanceSetting">();
	}
	static class UX6AIPerformanceSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AIPerformanceSetting>();
	}
};
static_assert(alignof(UX6AIPerformanceSetting) == 0x000008, "Wrong alignment on UX6AIPerformanceSetting");
static_assert(sizeof(UX6AIPerformanceSetting) == 0x000050, "Wrong size on UX6AIPerformanceSetting");
static_assert(offsetof(UX6AIPerformanceSetting, TotalBudgetTime) == 0x000038, "Member 'UX6AIPerformanceSetting::TotalBudgetTime' has a wrong offset!");
static_assert(offsetof(UX6AIPerformanceSetting, FunctionBudgetTime) == 0x000040, "Member 'UX6AIPerformanceSetting::FunctionBudgetTime' has a wrong offset!");

// Class X6Game.X6AIPerformanceManager
// 0x0038 (0x0060 - 0x0028)
class UX6AIPerformanceManager final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFunctionBudgetInMicroseconds(const class FName& InFunctionName);
	void RegisterUnImportantFunctionDelegate(const TDelegate<void()>& ExecuteDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AIPerformanceManager">();
	}
	static class UX6AIPerformanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AIPerformanceManager>();
	}
};
static_assert(alignof(UX6AIPerformanceManager) == 0x000008, "Wrong alignment on UX6AIPerformanceManager");
static_assert(sizeof(UX6AIPerformanceManager) == 0x000060, "Wrong size on UX6AIPerformanceManager");

// Class X6Game.X6AISenseConfig_Sight
// 0x0030 (0x0078 - 0x0048)
class UX6AISenseConfig_Sight final : public UAISenseConfig
{
public:
	int32                                         FilterFlag;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UX6AISense_Sight>           Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPerceptionShape_Base*                  Shape;                                             // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 OutRangeDebugColor;                                // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool NeedLineTrace();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AISenseConfig_Sight">();
	}
	static class UX6AISenseConfig_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AISenseConfig_Sight>();
	}
};
static_assert(alignof(UX6AISenseConfig_Sight) == 0x000008, "Wrong alignment on UX6AISenseConfig_Sight");
static_assert(sizeof(UX6AISenseConfig_Sight) == 0x000078, "Wrong size on UX6AISenseConfig_Sight");
static_assert(offsetof(UX6AISenseConfig_Sight, FilterFlag) == 0x000048, "Member 'UX6AISenseConfig_Sight::FilterFlag' has a wrong offset!");
static_assert(offsetof(UX6AISenseConfig_Sight, Implementation) == 0x000050, "Member 'UX6AISenseConfig_Sight::Implementation' has a wrong offset!");
static_assert(offsetof(UX6AISenseConfig_Sight, Shape) == 0x000058, "Member 'UX6AISenseConfig_Sight::Shape' has a wrong offset!");
static_assert(offsetof(UX6AISenseConfig_Sight, SocketName) == 0x000060, "Member 'UX6AISenseConfig_Sight::SocketName' has a wrong offset!");
static_assert(offsetof(UX6AISenseConfig_Sight, Tag) == 0x000068, "Member 'UX6AISenseConfig_Sight::Tag' has a wrong offset!");
static_assert(offsetof(UX6AISenseConfig_Sight, OutRangeDebugColor) == 0x000070, "Member 'UX6AISenseConfig_Sight::OutRangeDebugColor' has a wrong offset!");

// Class X6Game.X6AISenseModifier
// 0x0070 (0x0098 - 0x0028)
class UX6AISenseModifier final : public UObject
{
public:
	double                                        AddTimeStamp;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESenseShapeProperty, float>              PropertyModifierMap;                               // 0x0040(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          ModifierIsValid;                                   // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AISenseModifier">();
	}
	static class UX6AISenseModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AISenseModifier>();
	}
};
static_assert(alignof(UX6AISenseModifier) == 0x000008, "Wrong alignment on UX6AISenseModifier");
static_assert(sizeof(UX6AISenseModifier) == 0x000098, "Wrong size on UX6AISenseModifier");
static_assert(offsetof(UX6AISenseModifier, AddTimeStamp) == 0x000028, "Member 'UX6AISenseModifier::AddTimeStamp' has a wrong offset!");
static_assert(offsetof(UX6AISenseModifier, Priority) == 0x000030, "Member 'UX6AISenseModifier::Priority' has a wrong offset!");
static_assert(offsetof(UX6AISenseModifier, Tag) == 0x000034, "Member 'UX6AISenseModifier::Tag' has a wrong offset!");
static_assert(offsetof(UX6AISenseModifier, PropertyModifierMap) == 0x000040, "Member 'UX6AISenseModifier::PropertyModifierMap' has a wrong offset!");
static_assert(offsetof(UX6AISenseModifier, ModifierIsValid) == 0x000090, "Member 'UX6AISenseModifier::ModifierIsValid' has a wrong offset!");

// Class X6Game.X6AISense_Sight
// 0x00F8 (0x0170 - 0x0078)
class UX6AISense_Sight final : public UAISense
{
public:
	uint8                                         Pad_78[0xC8];                                      // 0x0078(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EquipSightFactor;                                  // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTracesPerTick;                                  // 0x0144(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinQueriesPerTimeSliceCheck;                       // 0x0148(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxTimeSlicePerTick;                               // 0x0150(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighImportanceQueryDistanceThreshold;              // 0x0158(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxQueryImportance;                                // 0x0160(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightLimitQueryImportance;                         // 0x0164(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInterestedTarget(const class AActor* ListenerActor, class AActor* TargetActor, class UX6AISenseConfig_Sight* Config);
	bool ReportStimulus(const class AActor* ListenerActor, class AActor* TargetActor, class UX6AISenseConfig_Sight* Config, EX6AISenseSightResultType ResultType, bool bLastResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AISense_Sight">();
	}
	static class UX6AISense_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AISense_Sight>();
	}
};
static_assert(alignof(UX6AISense_Sight) == 0x000008, "Wrong alignment on UX6AISense_Sight");
static_assert(sizeof(UX6AISense_Sight) == 0x000170, "Wrong size on UX6AISense_Sight");
static_assert(offsetof(UX6AISense_Sight, EquipSightFactor) == 0x000140, "Member 'UX6AISense_Sight::EquipSightFactor' has a wrong offset!");
static_assert(offsetof(UX6AISense_Sight, MaxTracesPerTick) == 0x000144, "Member 'UX6AISense_Sight::MaxTracesPerTick' has a wrong offset!");
static_assert(offsetof(UX6AISense_Sight, MinQueriesPerTimeSliceCheck) == 0x000148, "Member 'UX6AISense_Sight::MinQueriesPerTimeSliceCheck' has a wrong offset!");
static_assert(offsetof(UX6AISense_Sight, MaxTimeSlicePerTick) == 0x000150, "Member 'UX6AISense_Sight::MaxTimeSlicePerTick' has a wrong offset!");
static_assert(offsetof(UX6AISense_Sight, HighImportanceQueryDistanceThreshold) == 0x000158, "Member 'UX6AISense_Sight::HighImportanceQueryDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UX6AISense_Sight, MaxQueryImportance) == 0x000160, "Member 'UX6AISense_Sight::MaxQueryImportance' has a wrong offset!");
static_assert(offsetof(UX6AISense_Sight, SightLimitQueryImportance) == 0x000164, "Member 'UX6AISense_Sight::SightLimitQueryImportance' has a wrong offset!");

// Class X6Game.X6AIStimuliSourceComponent
// 0x0028 (0x00E8 - 0x00C0)
class UX6AIStimuliSourceComponent final : public UAIPerceptionStimuliSourceComponent
{
public:
	class FString                                 SamplePointKey;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FX6AISightTargetSample>         SamplePoints;                                      // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         threshold;                                         // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetSocketPos(const class FName& SocketName, struct FVector* OutPos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AIStimuliSourceComponent">();
	}
	static class UX6AIStimuliSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AIStimuliSourceComponent>();
	}
};
static_assert(alignof(UX6AIStimuliSourceComponent) == 0x000008, "Wrong alignment on UX6AIStimuliSourceComponent");
static_assert(sizeof(UX6AIStimuliSourceComponent) == 0x0000E8, "Wrong size on UX6AIStimuliSourceComponent");
static_assert(offsetof(UX6AIStimuliSourceComponent, SamplePointKey) == 0x0000C0, "Member 'UX6AIStimuliSourceComponent::SamplePointKey' has a wrong offset!");
static_assert(offsetof(UX6AIStimuliSourceComponent, SamplePoints) == 0x0000D0, "Member 'UX6AIStimuliSourceComponent::SamplePoints' has a wrong offset!");
static_assert(offsetof(UX6AIStimuliSourceComponent, threshold) == 0x0000E0, "Member 'UX6AIStimuliSourceComponent::threshold' has a wrong offset!");

// Class X6Game.X6AISubsystem
// 0x0018 (0x0048 - 0x0030)
class UX6AISubsystem final : public UGameInstanceSubsystem
{
public:
	class UStimuliManager*                        StimuliManager;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStimuliPreprocessSystem*               StimuliPreprocessSystem;                           // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6AIPerformanceManager*                AIPerformanceManager;                              // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AISubsystem">();
	}
	static class UX6AISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AISubsystem>();
	}
};
static_assert(alignof(UX6AISubsystem) == 0x000008, "Wrong alignment on UX6AISubsystem");
static_assert(sizeof(UX6AISubsystem) == 0x000048, "Wrong size on UX6AISubsystem");
static_assert(offsetof(UX6AISubsystem, StimuliManager) == 0x000030, "Member 'UX6AISubsystem::StimuliManager' has a wrong offset!");
static_assert(offsetof(UX6AISubsystem, StimuliPreprocessSystem) == 0x000038, "Member 'UX6AISubsystem::StimuliPreprocessSystem' has a wrong offset!");
static_assert(offsetof(UX6AISubsystem, AIPerformanceManager) == 0x000040, "Member 'UX6AISubsystem::AIPerformanceManager' has a wrong offset!");

// Class X6Game.X6AnimInstanceWithTag
// 0x0020 (0x03F0 - 0x03D0)
#pragma pack(push, 0x1)
class alignas(0x10) UX6AnimInstanceWithTag : public UAnimInstance
{
public:
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x03C8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimInstanceWithTag">();
	}
	static class UX6AnimInstanceWithTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimInstanceWithTag>();
	}
};
#pragma pack(pop)
static_assert(alignof(UX6AnimInstanceWithTag) == 0x000010, "Wrong alignment on UX6AnimInstanceWithTag");
static_assert(sizeof(UX6AnimInstanceWithTag) == 0x0003F0, "Wrong size on UX6AnimInstanceWithTag");
static_assert(offsetof(UX6AnimInstanceWithTag, GameplayTagPropertyMap) == 0x0003C8, "Member 'UX6AnimInstanceWithTag::GameplayTagPropertyMap' has a wrong offset!");

// Class X6Game.X6AnimNotifyState_AllSocketTrail
// 0x0000 (0x0058 - 0x0058)
class UX6AnimNotifyState_AllSocketTrail final : public UAnimNotifyState_Trail
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimNotifyState_AllSocketTrail">();
	}
	static class UX6AnimNotifyState_AllSocketTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimNotifyState_AllSocketTrail>();
	}
};
static_assert(alignof(UX6AnimNotifyState_AllSocketTrail) == 0x000008, "Wrong alignment on UX6AnimNotifyState_AllSocketTrail");
static_assert(sizeof(UX6AnimNotifyState_AllSocketTrail) == 0x000058, "Wrong size on UX6AnimNotifyState_AllSocketTrail");

// Class X6Game.X6AnimNotifyState_ComboWithCache
// 0x0018 (0x00B8 - 0x00A0)
class UX6AnimNotifyState_ComboWithCache final : public UAnimNotifyState_Sections
{
public:
	TArray<class UComboInputData*>                InputData;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bInactivateWhenNotifyEnd : 1;                      // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimNotifyState_ComboWithCache">();
	}
	static class UX6AnimNotifyState_ComboWithCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimNotifyState_ComboWithCache>();
	}
};
static_assert(alignof(UX6AnimNotifyState_ComboWithCache) == 0x000008, "Wrong alignment on UX6AnimNotifyState_ComboWithCache");
static_assert(sizeof(UX6AnimNotifyState_ComboWithCache) == 0x0000B8, "Wrong size on UX6AnimNotifyState_ComboWithCache");
static_assert(offsetof(UX6AnimNotifyState_ComboWithCache, InputData) == 0x0000A0, "Member 'UX6AnimNotifyState_ComboWithCache::InputData' has a wrong offset!");

// Class X6Game.AsyncActionLoadSoftObjPath
// 0x0078 (0x00A8 - 0x0030)
class UAsyncActionLoadSoftObjPath final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const TArray<class UObject*>& Loaded)> Completed;                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedAssets;                                      // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncActionLoadSoftObjPath* AsyncLoadPrimaryAsset(class UObject* WorldContextObject, const TArray<struct FSoftObjectPath>& InAssetsToLoad, bool InForceLoadBPClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionLoadSoftObjPath">();
	}
	static class UAsyncActionLoadSoftObjPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionLoadSoftObjPath>();
	}
};
static_assert(alignof(UAsyncActionLoadSoftObjPath) == 0x000008, "Wrong alignment on UAsyncActionLoadSoftObjPath");
static_assert(sizeof(UAsyncActionLoadSoftObjPath) == 0x0000A8, "Wrong size on UAsyncActionLoadSoftObjPath");
static_assert(offsetof(UAsyncActionLoadSoftObjPath, Completed) == 0x000030, "Member 'UAsyncActionLoadSoftObjPath::Completed' has a wrong offset!");
static_assert(offsetof(UAsyncActionLoadSoftObjPath, LoadedAssets) == 0x000088, "Member 'UAsyncActionLoadSoftObjPath::LoadedAssets' has a wrong offset!");

// Class X6Game.X6AssetManager
// 0x0000 (0x06B0 - 0x06B0)
class UX6AssetManager final : public UPaperAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AssetManager">();
	}
	static class UX6AssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AssetManager>();
	}
};
static_assert(alignof(UX6AssetManager) == 0x000008, "Wrong alignment on UX6AssetManager");
static_assert(sizeof(UX6AssetManager) == 0x0006B0, "Wrong size on UX6AssetManager");

// Class X6Game.X6AssetUserDataBase
// 0x0000 (0x0028 - 0x0028)
class UX6AssetUserDataBase : public UAssetUserData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AssetUserDataBase">();
	}
	static class UX6AssetUserDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AssetUserDataBase>();
	}
};
static_assert(alignof(UX6AssetUserDataBase) == 0x000008, "Wrong alignment on UX6AssetUserDataBase");
static_assert(sizeof(UX6AssetUserDataBase) == 0x000028, "Wrong size on UX6AssetUserDataBase");

// Class X6Game.X6ClothesAssetExtraData
// 0x0000 (0x0028 - 0x0028)
class UX6ClothesAssetExtraData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ClothesAssetExtraData">();
	}
	static class UX6ClothesAssetExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ClothesAssetExtraData>();
	}
};
static_assert(alignof(UX6ClothesAssetExtraData) == 0x000008, "Wrong alignment on UX6ClothesAssetExtraData");
static_assert(sizeof(UX6ClothesAssetExtraData) == 0x000028, "Wrong size on UX6ClothesAssetExtraData");

// Class X6Game.X6MakeUpMaterialData
// 0x0000 (0x0028 - 0x0028)
class UX6MakeUpMaterialData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6MakeUpMaterialData">();
	}
	static class UX6MakeUpMaterialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6MakeUpMaterialData>();
	}
};
static_assert(alignof(UX6MakeUpMaterialData) == 0x000008, "Wrong alignment on UX6MakeUpMaterialData");
static_assert(sizeof(UX6MakeUpMaterialData) == 0x000028, "Wrong size on UX6MakeUpMaterialData");

// Class X6Game.X6HoldItemDetailData
// 0x0000 (0x0028 - 0x0028)
class UX6HoldItemDetailData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HoldItemDetailData">();
	}
	static class UX6HoldItemDetailData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HoldItemDetailData>();
	}
};
static_assert(alignof(UX6HoldItemDetailData) == 0x000008, "Wrong alignment on UX6HoldItemDetailData");
static_assert(sizeof(UX6HoldItemDetailData) == 0x000028, "Wrong size on UX6HoldItemDetailData");

// Class X6Game.X6DlgBreathData
// 0x0000 (0x0028 - 0x0028)
class UX6DlgBreathData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6DlgBreathData">();
	}
	static class UX6DlgBreathData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6DlgBreathData>();
	}
};
static_assert(alignof(UX6DlgBreathData) == 0x000008, "Wrong alignment on UX6DlgBreathData");
static_assert(sizeof(UX6DlgBreathData) == 0x000028, "Wrong size on UX6DlgBreathData");

// Class X6Game.X6ClothesTypeData
// 0x0000 (0x0028 - 0x0028)
class UX6ClothesTypeData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ClothesTypeData">();
	}
	static class UX6ClothesTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ClothesTypeData>();
	}
};
static_assert(alignof(UX6ClothesTypeData) == 0x000008, "Wrong alignment on UX6ClothesTypeData");
static_assert(sizeof(UX6ClothesTypeData) == 0x000028, "Wrong size on UX6ClothesTypeData");

// Class X6Game.X6ClothesDecalData
// 0x0000 (0x0028 - 0x0028)
class UX6ClothesDecalData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ClothesDecalData">();
	}
	static class UX6ClothesDecalData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ClothesDecalData>();
	}
};
static_assert(alignof(UX6ClothesDecalData) == 0x000008, "Wrong alignment on UX6ClothesDecalData");
static_assert(sizeof(UX6ClothesDecalData) == 0x000028, "Wrong size on UX6ClothesDecalData");

// Class X6Game.X6ClothesTranslucentAndMaskedMatMobileSwitchData
// 0x0000 (0x0028 - 0x0028)
class UX6ClothesTranslucentAndMaskedMatMobileSwitchData final : public UX6AssetUserDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ClothesTranslucentAndMaskedMatMobileSwitchData">();
	}
	static class UX6ClothesTranslucentAndMaskedMatMobileSwitchData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ClothesTranslucentAndMaskedMatMobileSwitchData>();
	}
};
static_assert(alignof(UX6ClothesTranslucentAndMaskedMatMobileSwitchData) == 0x000008, "Wrong alignment on UX6ClothesTranslucentAndMaskedMatMobileSwitchData");
static_assert(sizeof(UX6ClothesTranslucentAndMaskedMatMobileSwitchData) == 0x000028, "Wrong size on UX6ClothesTranslucentAndMaskedMatMobileSwitchData");

// Class X6Game.X6TileView
// 0x0790 (0x1470 - 0x0CE0)
class UX6TileView final : public UTileView
{
public:
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x0CE0(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasMask;                                          // 0x1450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1451[0x3];                                     // 0x1451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopMaskParameterName;                              // 0x1454(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomMaskParameterName;                           // 0x145C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1464[0xC];                                     // 0x1464(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAnItem();
	void BP_NavigateToItemIndex(const int32& ItemIndex);
	void BP_OnTileItemValueChanged(const int32& Index_0);
	void BP_ScrollItemIndexIntoView(const int32& ItemIndex);
	void BP_SetItemSelectionByIndex(const int32& Index_0, bool bSelected);
	void BP_SetSelectedItemByIndex(const int32& Index_0);
	void BP_SetTileItemCount(const int32& Count);
	int32 GetLineOrientationItemNums();
	float GetScrollVelocity();
	void RemoveItemByIndex(const int32& Index_0);

	int32 BP_GetSelectedIndex() const;
	bool BP_GetSelectedItemsViaIndex(TArray<int32>* Items) const;
	bool BP_IsItemVisibleByIndex(const int32& Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TileView">();
	}
	static class UX6TileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TileView>();
	}
};
static_assert(alignof(UX6TileView) == 0x000010, "Wrong alignment on UX6TileView");
static_assert(sizeof(UX6TileView) == 0x001470, "Wrong size on UX6TileView");
static_assert(offsetof(UX6TileView, WidgetBarStyle) == 0x000CE0, "Member 'UX6TileView::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UX6TileView, bHasMask) == 0x001450, "Member 'UX6TileView::bHasMask' has a wrong offset!");
static_assert(offsetof(UX6TileView, TopMaskParameterName) == 0x001454, "Member 'UX6TileView::TopMaskParameterName' has a wrong offset!");
static_assert(offsetof(UX6TileView, BottomMaskParameterName) == 0x00145C, "Member 'UX6TileView::BottomMaskParameterName' has a wrong offset!");

// Class X6Game.X6AsyncCollisionTraceSubSystem
// 0x00A0 (0x00D0 - 0x0030)
class UX6AsyncCollisionTraceSubSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AsyncCollisionTraceSubSystem">();
	}
	static class UX6AsyncCollisionTraceSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AsyncCollisionTraceSubSystem>();
	}
};
static_assert(alignof(UX6AsyncCollisionTraceSubSystem) == 0x000008, "Wrong alignment on UX6AsyncCollisionTraceSubSystem");
static_assert(sizeof(UX6AsyncCollisionTraceSubSystem) == 0x0000D0, "Wrong size on UX6AsyncCollisionTraceSubSystem");

// Class X6Game.X6AsyncCollisionTraceBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6AsyncCollisionTraceBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AsyncBoxOverlapActors(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback);
	static bool AsyncCapsuleOverlapActors(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback);
	static bool AsyncLineTraceByChannel(EX6AsyncTraceType InTraceType, class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel InTraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TDelegate<void(bool bIsHit, const TArray<struct FHitResult>& HitResults, uint32 CustomFlag)> DelegateCallback, int32 CustomFlag);
	static bool AsyncOverlapActorsCustomizeChannel(class UObject* WorldContextObject, const class UShapeComponent* shapeComp, ECollisionResponse AllChannelsResponse, const TMap<ECollisionChannel, ECollisionResponse>& TraceChannels, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, const TArray<class UClass*>& ActorsClassFilter, TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback);
	static bool AsyncSphereOverlapActors(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TDelegate<void(bool bIsOverlap, const TArray<class AActor*>& OverlapActors)> DelegateCallback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AsyncCollisionTraceBlueprintLibrary">();
	}
	static class UX6AsyncCollisionTraceBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AsyncCollisionTraceBlueprintLibrary>();
	}
};
static_assert(alignof(UX6AsyncCollisionTraceBlueprintLibrary) == 0x000008, "Wrong alignment on UX6AsyncCollisionTraceBlueprintLibrary");
static_assert(sizeof(UX6AsyncCollisionTraceBlueprintLibrary) == 0x000028, "Wrong size on UX6AsyncCollisionTraceBlueprintLibrary");

// Class X6Game.X6NavigationSubSystem
// 0x0220 (0x0250 - 0x0030)
class alignas(0x10) UX6NavigationSubSystem final : public UGameInstanceSubsystem
{
public:
	TMap<int64, class UX6SplineRoad*>             RoadUIDToRoadDataMapping;                          // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x58];                                      // 0x0080(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SegmentSampleStep;                                 // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SegmentStepsMinDistanceSq;                         // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RoadOffsetClampMin;                                // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RoadOffsetClampMax;                                // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SampleNumPerSegment;                               // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x164];                                     // 0x00EC(0x0164)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRoad(class UX6SplineRoad* Road);
	void AddRoadNodesToPathV2(TArray<struct FVector>* PathPoints, TArray<int32>* OffMeshIdxs, const TMap<int32, int64>& SplineNodes, bool DebugDraw, float DebugDrawDuration);
	void DrawNavLink(class UWorld* InWorld, TArray<struct FNavigationLink>* NavLinks, const struct FLinearColor& Color, float Time);
	void DrawNavMesh(class UWorld* InWorld, TArray<struct FVector>* Tiles, const struct FLinearColor& Color, float Time);
	void GetNavigationRegionFilterFlags(int32* OutIncludeFlags, int32* OutExcludeFlags, const struct FVector& StartLocation, const struct FVector& GoalLocation);
	void RemoveAllRoad();
	void RemoveRoad(int64 RoadID);
	void SetRoadOffsetClamp(float ClampMin, float ClampMax);
	void SetSegmentSampleStep(const float NewStep);
	void SetSegmentStepsMinDistance(float Distance);

	class UX6SplineRoad* GetOwnerRoad(int64 NodeUID) const;
	int64 GetOwnerRoadUID(int64 NodeUID) const;
	float GetSegmentSampleStep() const;
	float GetSegmentStepsMinDistanceSq() const;
	bool HasRoadNode(int64 NodeUID) const;
	class UX6NavigationPathPoints* MakeNavigationPathPoints(const TArray<struct FVector>& PointLocations, const TMap<int32, int64>& NavLinkMark, const TMap<int32, int64>& RoadNodeMark) const;
	class UX6NavigationPathPoints* MakePureNavigationPathPoints(const TArray<struct FVector>& PointLocations) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NavigationSubSystem">();
	}
	static class UX6NavigationSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NavigationSubSystem>();
	}
};
static_assert(alignof(UX6NavigationSubSystem) == 0x000010, "Wrong alignment on UX6NavigationSubSystem");
static_assert(sizeof(UX6NavigationSubSystem) == 0x000250, "Wrong size on UX6NavigationSubSystem");
static_assert(offsetof(UX6NavigationSubSystem, RoadUIDToRoadDataMapping) == 0x000030, "Member 'UX6NavigationSubSystem::RoadUIDToRoadDataMapping' has a wrong offset!");
static_assert(offsetof(UX6NavigationSubSystem, SegmentSampleStep) == 0x0000D8, "Member 'UX6NavigationSubSystem::SegmentSampleStep' has a wrong offset!");
static_assert(offsetof(UX6NavigationSubSystem, SegmentStepsMinDistanceSq) == 0x0000DC, "Member 'UX6NavigationSubSystem::SegmentStepsMinDistanceSq' has a wrong offset!");
static_assert(offsetof(UX6NavigationSubSystem, RoadOffsetClampMin) == 0x0000E0, "Member 'UX6NavigationSubSystem::RoadOffsetClampMin' has a wrong offset!");
static_assert(offsetof(UX6NavigationSubSystem, RoadOffsetClampMax) == 0x0000E4, "Member 'UX6NavigationSubSystem::RoadOffsetClampMax' has a wrong offset!");
static_assert(offsetof(UX6NavigationSubSystem, SampleNumPerSegment) == 0x0000E8, "Member 'UX6NavigationSubSystem::SampleNumPerSegment' has a wrong offset!");

// Class X6Game.X6AvatarSubsystem
// 0x0058 (0x0088 - 0x0030)
class UX6AvatarSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AvatarSubsystem">();
	}
	static class UX6AvatarSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AvatarSubsystem>();
	}
};
static_assert(alignof(UX6AvatarSubsystem) == 0x000008, "Wrong alignment on UX6AvatarSubsystem");
static_assert(sizeof(UX6AvatarSubsystem) == 0x000088, "Wrong size on UX6AvatarSubsystem");

// Class X6Game.AvatarComponent
// 0x0028 (0x00D0 - 0x00A8)
class UAvatarComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnCharacterGenAssetSetUp;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             AvatarConfig;                                      // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AvatarTag;                                         // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CopySkeletalMeshFromActor(class AActor* Template);
	void SetAvatarTag(const class FString& Tag);
	void SetSkeletalMeshFromMapping(const TMap<class FName, class USkeletalMesh*>& PartToMeshMapping, class USkeletalMeshComponent* MainSkeletal);
	void SetupAvatarByDataConfig(class USkeletalMeshComponent* MainMeshComp, int32 SuitId, const TMap<class FName, struct FClothMeshSetting>& PartToClothMeshMapping);
	void SetupAvatarByRuntime(const class FString& NewTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvatarComponent">();
	}
	static class UAvatarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvatarComponent>();
	}
};
static_assert(alignof(UAvatarComponent) == 0x000008, "Wrong alignment on UAvatarComponent");
static_assert(sizeof(UAvatarComponent) == 0x0000D0, "Wrong size on UAvatarComponent");
static_assert(offsetof(UAvatarComponent, OnCharacterGenAssetSetUp) == 0x0000A8, "Member 'UAvatarComponent::OnCharacterGenAssetSetUp' has a wrong offset!");
static_assert(offsetof(UAvatarComponent, AvatarConfig) == 0x0000B8, "Member 'UAvatarComponent::AvatarConfig' has a wrong offset!");
static_assert(offsetof(UAvatarComponent, AvatarTag) == 0x0000C0, "Member 'UAvatarComponent::AvatarTag' has a wrong offset!");

// Class X6Game.X6VehicleSkeletalMeshComponent
// 0x0000 (0x12D0 - 0x12D0)
class UX6VehicleSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bEnableIgnoreMoveThreshold;                        // 0x12C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C9[0x7];                                     // 0x12C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6VehicleSkeletalMeshComponent">();
	}
	static class UX6VehicleSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6VehicleSkeletalMeshComponent>();
	}
};
static_assert(alignof(UX6VehicleSkeletalMeshComponent) == 0x000010, "Wrong alignment on UX6VehicleSkeletalMeshComponent");
static_assert(sizeof(UX6VehicleSkeletalMeshComponent) == 0x0012D0, "Wrong size on UX6VehicleSkeletalMeshComponent");
static_assert(offsetof(UX6VehicleSkeletalMeshComponent, bEnableIgnoreMoveThreshold) == 0x0012C8, "Member 'UX6VehicleSkeletalMeshComponent::bEnableIgnoreMoveThreshold' has a wrong offset!");

// Class X6Game.X6AvatarPreviewSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UX6AvatarPreviewSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* Actor);
	void OnGenAssetActorDestory(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AvatarPreviewSubsystem">();
	}
	static class UX6AvatarPreviewSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AvatarPreviewSubsystem>();
	}
};
static_assert(alignof(UX6AvatarPreviewSubsystem) == 0x000008, "Wrong alignment on UX6AvatarPreviewSubsystem");
static_assert(sizeof(UX6AvatarPreviewSubsystem) == 0x0000A0, "Wrong size on UX6AvatarPreviewSubsystem");

// Class X6Game.X6AvatarPreviewComponent
// 0x0018 (0x00C0 - 0x00A8)
class UX6AvatarPreviewComponent final : public UActorComponent
{
public:
	bool                                          bApplyHighHeelHeight;                              // 0x00A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HighHeel_Ankle_Angle;                              // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighHeel_Toe_Angle;                                // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighHeel_Height;                                   // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterGenAsset*                     CurrentGenAsset;                                   // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWithCharacterGenAsset(class UCharacterGenAsset* inCharacterGenAsset);
	void SetAvatarTag(int32 AvatarTagValue);
	void SetAvatarTagByName(const class FString& EnumDisplayName);
	void TestHiddenPart(int32 AvatarTagValue);
	void TestHighHeel(int32 AvatarTagValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AvatarPreviewComponent">();
	}
	static class UX6AvatarPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AvatarPreviewComponent>();
	}
};
static_assert(alignof(UX6AvatarPreviewComponent) == 0x000008, "Wrong alignment on UX6AvatarPreviewComponent");
static_assert(sizeof(UX6AvatarPreviewComponent) == 0x0000C0, "Wrong size on UX6AvatarPreviewComponent");
static_assert(offsetof(UX6AvatarPreviewComponent, bApplyHighHeelHeight) == 0x0000A8, "Member 'UX6AvatarPreviewComponent::bApplyHighHeelHeight' has a wrong offset!");
static_assert(offsetof(UX6AvatarPreviewComponent, HighHeel_Ankle_Angle) == 0x0000AC, "Member 'UX6AvatarPreviewComponent::HighHeel_Ankle_Angle' has a wrong offset!");
static_assert(offsetof(UX6AvatarPreviewComponent, HighHeel_Toe_Angle) == 0x0000B0, "Member 'UX6AvatarPreviewComponent::HighHeel_Toe_Angle' has a wrong offset!");
static_assert(offsetof(UX6AvatarPreviewComponent, HighHeel_Height) == 0x0000B4, "Member 'UX6AvatarPreviewComponent::HighHeel_Height' has a wrong offset!");
static_assert(offsetof(UX6AvatarPreviewComponent, CurrentGenAsset) == 0x0000B8, "Member 'UX6AvatarPreviewComponent::CurrentGenAsset' has a wrong offset!");

// Class X6Game.X6TargetingSelectionTask_ChargeUpBase
// 0x0088 (0x00B0 - 0x0028)
class UX6TargetingSelectionTask_ChargeUpBase : public UTargetingTask
{
public:
	float                                         SlopeDegree;                                       // 0x0028(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BulletTransform;                                   // 0x0030(0x0060)(BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DebugDraw;                                         // 0x0090(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      SlopeTraceObjectTypes;                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddHitResult(const struct FTargetingRequestHandle& TargetingHandle, const struct FHitResult& HitResult) const;
	bool AddSingleTargetComponentForPriority(const struct FTargetingRequestHandle& TargetingHandle, class UPrimitiveComponent* InTargetComponent) const;
	bool AddTargetActor(const struct FTargetingRequestHandle& TargetingHandle, class AActor* InTargetActor) const;
	bool AddTargetComponent(const struct FTargetingRequestHandle& TargetingHandle, class UPrimitiveComponent* InTargetComponent) const;
	bool K2_CanSelect(const struct FTargetingRequestHandle& TargetingHandle, const struct FTargetingSourceContext& SourceContext) const;
	bool K2_IsExistForwardTargets(const class AActor* SourceActor, const struct FVector& InHalfSize, const struct FVector& InOffset) const;
	bool K2_IsResultsExistTargetActorOrComponent(const struct FTargetingRequestHandle& TargetingHandle, class AActor* InTargetActor, class UPrimitiveComponent* InTargetComponent) const;
	void SelectTargets(const struct FTargetingRequestHandle& TargetingHandle, const struct FTargetingSourceContext& SourceContext) const;
	void UpdateSelectingTransformInfo(const class AActor* SourceActor, const class FName& SocketName, const float DepthLength, const struct FVector& Offset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingSelectionTask_ChargeUpBase">();
	}
	static class UX6TargetingSelectionTask_ChargeUpBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingSelectionTask_ChargeUpBase>();
	}
};
static_assert(alignof(UX6TargetingSelectionTask_ChargeUpBase) == 0x000010, "Wrong alignment on UX6TargetingSelectionTask_ChargeUpBase");
static_assert(sizeof(UX6TargetingSelectionTask_ChargeUpBase) == 0x0000B0, "Wrong size on UX6TargetingSelectionTask_ChargeUpBase");
static_assert(offsetof(UX6TargetingSelectionTask_ChargeUpBase, SlopeDegree) == 0x000028, "Member 'UX6TargetingSelectionTask_ChargeUpBase::SlopeDegree' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_ChargeUpBase, BulletTransform) == 0x000030, "Member 'UX6TargetingSelectionTask_ChargeUpBase::BulletTransform' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_ChargeUpBase, DebugDraw) == 0x000090, "Member 'UX6TargetingSelectionTask_ChargeUpBase::DebugDraw' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_ChargeUpBase, SlopeTraceObjectTypes) == 0x000098, "Member 'UX6TargetingSelectionTask_ChargeUpBase::SlopeTraceObjectTypes' has a wrong offset!");

// Class X6Game.CinePawnSettings
// 0x0168 (0x01A0 - 0x0038)
class UCinePawnSettings final : public UDeveloperSettings
{
public:
	class FString                                 SuitExcelRelativePath;                             // 0x0038(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SuitSheetName;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MinorTypeExcelRelativePath;                        // 0x0058(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MinorTypeSheetName;                                // 0x0068(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShoesTypeExcelRelativePath;                        // 0x0078(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShoesTypeSheetName;                                // 0x0088(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemExcelRelativePath;                             // 0x0098(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemSheetName;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemExtraExcelRelativePath;                        // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemExtraSheetName;                                // 0x00C8(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              AvatarConfig;                                      // 0x00D8(0x0028)(Edit, Config, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUserDefinedEnum>        HiddenPartEnum;                                    // 0x0100(0x0028)(Edit, Config, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UUserDefinedEnum>        AvatarTagEnum;                                     // 0x0128(0x0028)(Edit, Config, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CharacterList;                                     // 0x0150(0x0028)(Edit, Config, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFont>                   NPCNameFont;                                       // 0x0178(0x0028)(Edit, Config, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinePawnSettings">();
	}
	static class UCinePawnSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinePawnSettings>();
	}
};
static_assert(alignof(UCinePawnSettings) == 0x000008, "Wrong alignment on UCinePawnSettings");
static_assert(sizeof(UCinePawnSettings) == 0x0001A0, "Wrong size on UCinePawnSettings");
static_assert(offsetof(UCinePawnSettings, SuitExcelRelativePath) == 0x000038, "Member 'UCinePawnSettings::SuitExcelRelativePath' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, SuitSheetName) == 0x000048, "Member 'UCinePawnSettings::SuitSheetName' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, MinorTypeExcelRelativePath) == 0x000058, "Member 'UCinePawnSettings::MinorTypeExcelRelativePath' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, MinorTypeSheetName) == 0x000068, "Member 'UCinePawnSettings::MinorTypeSheetName' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, ShoesTypeExcelRelativePath) == 0x000078, "Member 'UCinePawnSettings::ShoesTypeExcelRelativePath' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, ShoesTypeSheetName) == 0x000088, "Member 'UCinePawnSettings::ShoesTypeSheetName' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, ItemExcelRelativePath) == 0x000098, "Member 'UCinePawnSettings::ItemExcelRelativePath' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, ItemSheetName) == 0x0000A8, "Member 'UCinePawnSettings::ItemSheetName' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, ItemExtraExcelRelativePath) == 0x0000B8, "Member 'UCinePawnSettings::ItemExtraExcelRelativePath' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, ItemExtraSheetName) == 0x0000C8, "Member 'UCinePawnSettings::ItemExtraSheetName' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, AvatarConfig) == 0x0000D8, "Member 'UCinePawnSettings::AvatarConfig' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, HiddenPartEnum) == 0x000100, "Member 'UCinePawnSettings::HiddenPartEnum' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, AvatarTagEnum) == 0x000128, "Member 'UCinePawnSettings::AvatarTagEnum' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, CharacterList) == 0x000150, "Member 'UCinePawnSettings::CharacterList' has a wrong offset!");
static_assert(offsetof(UCinePawnSettings, NPCNameFont) == 0x000178, "Member 'UCinePawnSettings::NPCNameFont' has a wrong offset!");

// Class X6Game.X6BasePuzzleManager
// 0x0058 (0x0490 - 0x0438)
class AX6BasePuzzleManager final : public AX6Actor
{
public:
	FMulticastSparseDelegateProperty_             AllActorTypePropertiesBeginPlayCompleted;          // 0x0438(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           AllActorTypeProperties;                            // 0x0440(0x0050)(NativeAccessSpecifierPrivate)

public:
	void HandleActorTypePropertiesBeginPlayCompleted();
	void HandleCheckPropertiesBeginPlayCompleted(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BasePuzzleManager">();
	}
	static class AX6BasePuzzleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6BasePuzzleManager>();
	}
};
static_assert(alignof(AX6BasePuzzleManager) == 0x000008, "Wrong alignment on AX6BasePuzzleManager");
static_assert(sizeof(AX6BasePuzzleManager) == 0x000490, "Wrong size on AX6BasePuzzleManager");
static_assert(offsetof(AX6BasePuzzleManager, AllActorTypePropertiesBeginPlayCompleted) == 0x000438, "Member 'AX6BasePuzzleManager::AllActorTypePropertiesBeginPlayCompleted' has a wrong offset!");
static_assert(offsetof(AX6BasePuzzleManager, AllActorTypeProperties) == 0x000440, "Member 'AX6BasePuzzleManager::AllActorTypeProperties' has a wrong offset!");

// Class X6Game.X6NavigationRegionInterface
// 0x0000 (0x0000 - 0x0000)
class IX6NavigationRegionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NavigationRegionInterface">();
	}
	static class IX6NavigationRegionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6NavigationRegionInterface>();
	}
};
static_assert(alignof(IX6NavigationRegionInterface) == 0x000001, "Wrong alignment on IX6NavigationRegionInterface");
static_assert(sizeof(IX6NavigationRegionInterface) == 0x000001, "Wrong size on IX6NavigationRegionInterface");

// Class X6Game.X6BaseSplineTrackComponent
// 0x00C0 (0x0780 - 0x06C0)
class UX6BaseSplineTrackComponent final : public USplineComponent
{
public:
	ETrackBehaviourType                           BehaviourType;                                     // 0x06B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivation;                                   // 0x06B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInitializationMode                           InitializationMode;                                // 0x06BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BB[0x1];                                      // 0x06BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitializationSplineInputKey;                      // 0x06BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitializationSplineIndex;                         // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitMovingForward;                                 // 0x06C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetDefaultSpeedByMoveTime;                        // 0x06C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C6[0x2];                                      // 0x06C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultSpeed;                                      // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMoveTime;                                   // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultBlendOutTime;                               // 0x06D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTrackSegmentOverride>     SegmentOverrides;                                  // 0x06D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bOverrideSegmentsBackward;                         // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0x7];                                      // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTrackSegmentOverride>     SegmentOverridesBackward;                          // 0x0730(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BaseSplineTrackComponent">();
	}
	static class UX6BaseSplineTrackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BaseSplineTrackComponent>();
	}
};
static_assert(alignof(UX6BaseSplineTrackComponent) == 0x000010, "Wrong alignment on UX6BaseSplineTrackComponent");
static_assert(sizeof(UX6BaseSplineTrackComponent) == 0x000780, "Wrong size on UX6BaseSplineTrackComponent");
static_assert(offsetof(UX6BaseSplineTrackComponent, BehaviourType) == 0x0006B8, "Member 'UX6BaseSplineTrackComponent::BehaviourType' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, bAutoActivation) == 0x0006B9, "Member 'UX6BaseSplineTrackComponent::bAutoActivation' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, InitializationMode) == 0x0006BA, "Member 'UX6BaseSplineTrackComponent::InitializationMode' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, InitializationSplineInputKey) == 0x0006BC, "Member 'UX6BaseSplineTrackComponent::InitializationSplineInputKey' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, InitializationSplineIndex) == 0x0006C0, "Member 'UX6BaseSplineTrackComponent::InitializationSplineIndex' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, InitMovingForward) == 0x0006C4, "Member 'UX6BaseSplineTrackComponent::InitMovingForward' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, bSetDefaultSpeedByMoveTime) == 0x0006C5, "Member 'UX6BaseSplineTrackComponent::bSetDefaultSpeedByMoveTime' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, DefaultSpeed) == 0x0006C8, "Member 'UX6BaseSplineTrackComponent::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, DefaultMoveTime) == 0x0006CC, "Member 'UX6BaseSplineTrackComponent::DefaultMoveTime' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, DefaultBlendOutTime) == 0x0006D0, "Member 'UX6BaseSplineTrackComponent::DefaultBlendOutTime' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, SegmentOverrides) == 0x0006D8, "Member 'UX6BaseSplineTrackComponent::SegmentOverrides' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, bOverrideSegmentsBackward) == 0x000728, "Member 'UX6BaseSplineTrackComponent::bOverrideSegmentsBackward' has a wrong offset!");
static_assert(offsetof(UX6BaseSplineTrackComponent, SegmentOverridesBackward) == 0x000730, "Member 'UX6BaseSplineTrackComponent::SegmentOverridesBackward' has a wrong offset!");

// Class X6Game.X6BaseVolume
// 0x0000 (0x03E0 - 0x03E0)
class AX6BaseVolume : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BaseVolume">();
	}
	static class AX6BaseVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6BaseVolume>();
	}
};
static_assert(alignof(AX6BaseVolume) == 0x000008, "Wrong alignment on AX6BaseVolume");
static_assert(sizeof(AX6BaseVolume) == 0x0003E0, "Wrong size on AX6BaseVolume");

// Class X6Game.X6CharacterBase
// 0x0120 (0x08B0 - 0x0790)
class AX6CharacterBase : public ACharacter
{
public:
	FMulticastSparseDelegateProperty_             OnX6CharacterPossessed;                            // 0x0788(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnX6CharacterUnPossessed;                          // 0x0789(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnX6CharacterWalkingOffLedge;                      // 0x078A(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnX6CharacterMoveBlockedBy;                        // 0x078B(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnX6CharacterFalling;                              // 0x078C(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnX6CharacterBaseChange;                           // 0x078D(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnX6SimulateCharacterFirstRepMovement;             // 0x078E(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78F[0x1];                                      // 0x078F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           X6Tags;                                            // 0x0790(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bUseDynamicCreateWalkLogicComponent;               // 0x07A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A1[0x7];                                      // 0x07A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UX6RMWalkingComponent>      WalkLogicComponent;                                // 0x07A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDynamicCreateInAirLogicComponent;              // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UX6RMInAirComponent>        InAirLogicComponent;                               // 0x07B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatedCharacterHasRepMovement;                 // 0x07C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C1[0x5F];                                     // 0x07C1(0x005F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSimulatedReplicateMovement;                       // 0x0820(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSimulatedReplicateAttachment;                     // 0x0821(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLocalBaseIfUnresolved;                         // 0x0822(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_823[0x5];                                      // 0x0823(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6MovementBaseInfo                    X6ReplicatedMovementBase;                          // 0x0828(0x0040)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FX6BasedMovementStateInfo              X6ReplicatedBasedMovementState;                    // 0x0868(0x0040)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A8[0x8];                                      // 0x08A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_X6ReplicatedBasedMovementState();
	void OnRep_X6ReplicatedMovementBase();
	void PostSpawnerGroupSpawned();
	void ReceiveMovementFromServer(const struct FX6ReplicatedMovement& InReplicatedMovement);
	void ServerInit(bool bServer);
	void SetLocalRole(ENetRole InRole);
	void SetSimulatedReplicateMovement(const bool bInSimulatedReplicateMovement, const bool bRefreshReplication);
	void X6_AddTag(const TArray<class FName>& NewX6Tags);
	void X6_ClearAndInvalidateTimerHandle(struct FTimerHandle& Handle);
	void X6_ClearTimer(class UObject* Object, const class FString& FunctionName);
	void X6_ClearTimerDelegate(TDelegate<void()> Delegate);
	void X6_ClearTimerHandle(const struct FTimerHandle& Handle);
	void X6_DeleteTag(const class FString& strTag);
	bool X6_GetActorHiddenFlags(TSet<int32>* OutFlags);
	TArray<class FName> X6_GetTag();
	float X6_GetTimerElapsedTime(class UObject* Object, const class FString& FunctionName);
	float X6_GetTimerElapsedTimeDelegate(TDelegate<void()> Delegate);
	float X6_GetTimerElapsedTimeDelegateEachTrigger(TDelegate<void()> Delegate);
	float X6_GetTimerElapsedTimeEachTrigger(class UObject* Object, const class FString& FunctionName);
	float X6_GetTimerElapsedTimeHandle(const struct FTimerHandle& Handle);
	float X6_GetTimerElapsedTimeHandleEachTrigger(const struct FTimerHandle& Handle);
	float X6_GetTimerRemainingTime(class UObject* Object, const class FString& FunctionName);
	float X6_GetTimerRemainingTimeDelegate(TDelegate<void()> Delegate);
	float X6_GetTimerRemainingTimeHandle(const struct FTimerHandle& Handle);
	bool X6_HasTag(const class FString& strTag);
	bool X6_IsTimerActive(class UObject* Object, const class FString& FunctionName);
	bool X6_IsTimerActiveDelegate(TDelegate<void()> Delegate);
	bool X6_IsTimerActiveHandle(const struct FTimerHandle& Handle);
	bool X6_IsTimerPaused(class UObject* Object, const class FString& FunctionName);
	bool X6_IsTimerPausedDelegate(TDelegate<void()> Delegate);
	bool X6_IsTimerPausedHandle(const struct FTimerHandle& Handle);
	bool X6_IsValidTimerHandle(const struct FTimerHandle& Handle);
	void X6_PauseTimer(class UObject* Object, const class FString& FunctionName);
	void X6_PauseTimerDelegate(TDelegate<void()> Delegate);
	void X6_PauseTimerHandle(const struct FTimerHandle& Handle);
	void X6_RequireActorFade(bool bFadeIn, int32 FadeOutHiddenFlag, bool bInView);
	bool X6_SetActorHiddenInGame(bool bNewHidden, int32 Flag, bool bClearFlag);
	struct FTimerHandle X6_SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
	struct FTimerHandle X6_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
	bool X6_TimerExists(class UObject* Object, const class FString& FunctionName);
	bool X6_TimerExistsDelegate(TDelegate<void()> Delegate);
	bool X6_TimerExistsHandle(const struct FTimerHandle& Handle);
	void X6_UnPauseTimer(class UObject* Object, const class FString& FunctionName);
	void X6_UnPauseTimerDelegate(TDelegate<void()> Delegate);
	void X6_UnPauseTimerHandle(const struct FTimerHandle& Handle);

	struct FVector GetMoveGoalOffsetInternal(const class AActor* MovingActor) const;
	bool IsSimulatedReplicateAttachment() const;
	bool IsSimulatedReplicateMovement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterBase">();
	}
	static class AX6CharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CharacterBase>();
	}
};
static_assert(alignof(AX6CharacterBase) == 0x000010, "Wrong alignment on AX6CharacterBase");
static_assert(sizeof(AX6CharacterBase) == 0x0008B0, "Wrong size on AX6CharacterBase");
static_assert(offsetof(AX6CharacterBase, OnX6CharacterPossessed) == 0x000788, "Member 'AX6CharacterBase::OnX6CharacterPossessed' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, OnX6CharacterUnPossessed) == 0x000789, "Member 'AX6CharacterBase::OnX6CharacterUnPossessed' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, OnX6CharacterWalkingOffLedge) == 0x00078A, "Member 'AX6CharacterBase::OnX6CharacterWalkingOffLedge' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, OnX6CharacterMoveBlockedBy) == 0x00078B, "Member 'AX6CharacterBase::OnX6CharacterMoveBlockedBy' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, OnX6CharacterFalling) == 0x00078C, "Member 'AX6CharacterBase::OnX6CharacterFalling' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, OnX6CharacterBaseChange) == 0x00078D, "Member 'AX6CharacterBase::OnX6CharacterBaseChange' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, OnX6SimulateCharacterFirstRepMovement) == 0x00078E, "Member 'AX6CharacterBase::OnX6SimulateCharacterFirstRepMovement' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, X6Tags) == 0x000790, "Member 'AX6CharacterBase::X6Tags' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, bUseDynamicCreateWalkLogicComponent) == 0x0007A0, "Member 'AX6CharacterBase::bUseDynamicCreateWalkLogicComponent' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, WalkLogicComponent) == 0x0007A8, "Member 'AX6CharacterBase::WalkLogicComponent' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, bUseDynamicCreateInAirLogicComponent) == 0x0007B0, "Member 'AX6CharacterBase::bUseDynamicCreateInAirLogicComponent' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, InAirLogicComponent) == 0x0007B8, "Member 'AX6CharacterBase::InAirLogicComponent' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, bSimulatedCharacterHasRepMovement) == 0x0007C0, "Member 'AX6CharacterBase::bSimulatedCharacterHasRepMovement' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, bSimulatedReplicateMovement) == 0x000820, "Member 'AX6CharacterBase::bSimulatedReplicateMovement' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, bSimulatedReplicateAttachment) == 0x000821, "Member 'AX6CharacterBase::bSimulatedReplicateAttachment' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, bUseLocalBaseIfUnresolved) == 0x000822, "Member 'AX6CharacterBase::bUseLocalBaseIfUnresolved' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, X6ReplicatedMovementBase) == 0x000828, "Member 'AX6CharacterBase::X6ReplicatedMovementBase' has a wrong offset!");
static_assert(offsetof(AX6CharacterBase, X6ReplicatedBasedMovementState) == 0x000868, "Member 'AX6CharacterBase::X6ReplicatedBasedMovementState' has a wrong offset!");

// Class X6Game.X6CharacterWithAbilities
// 0x0020 (0x08D0 - 0x08B0)
#pragma pack(push, 0x1)
class alignas(0x10) AX6CharacterWithAbilities : public AX6CharacterBase
{
public:
	uint8                                         Pad_8B0[0x10];                                     // 0x08B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilitySystemComponent*              AbilitySystemComponent;                            // 0x08C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_SetReplicatePriority(int32 NewReplicatePriority);
	void K2_SetShouldForceReplicateProperty(bool bReplicate);

	class UX6AbilitySystemComponent* GetX6AbilitySystemComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterWithAbilities">();
	}
	static class AX6CharacterWithAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CharacterWithAbilities>();
	}
};
#pragma pack(pop)
static_assert(alignof(AX6CharacterWithAbilities) == 0x000010, "Wrong alignment on AX6CharacterWithAbilities");
static_assert(sizeof(AX6CharacterWithAbilities) == 0x0008D0, "Wrong size on AX6CharacterWithAbilities");
static_assert(offsetof(AX6CharacterWithAbilities, AbilitySystemComponent) == 0x0008C0, "Member 'AX6CharacterWithAbilities::AbilitySystemComponent' has a wrong offset!");

// Class X6Game.X6NikkiPawn
// 0x0010 (0x08E0 - 0x08D0)
class AX6NikkiPawn final : public AX6CharacterWithAbilities
{
public:
	bool                                          bCarryItem;                                        // 0x08C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNikkiMovementComponent*                NikkiMoveComp;                                     // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D8[0x8];                                      // 0x08D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 Client_GetCameraState();
	bool IsCarryItem();
	bool IsEnableFootIK();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NikkiPawn">();
	}
	static class AX6NikkiPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6NikkiPawn>();
	}
};
static_assert(alignof(AX6NikkiPawn) == 0x000010, "Wrong alignment on AX6NikkiPawn");
static_assert(sizeof(AX6NikkiPawn) == 0x0008E0, "Wrong size on AX6NikkiPawn");
static_assert(offsetof(AX6NikkiPawn, bCarryItem) == 0x0008C8, "Member 'AX6NikkiPawn::bCarryItem' has a wrong offset!");
static_assert(offsetof(AX6NikkiPawn, NikkiMoveComp) == 0x0008D0, "Member 'AX6NikkiPawn::NikkiMoveComp' has a wrong offset!");

// Class X6Game.X6BasicMoveableComponent
// 0x00C0 (0x0168 - 0x00A8)
class UX6BasicMoveableComponent final : public UX6ActorComponent
{
public:
	struct FRMInputContext                        CurRMInputContext;                                 // 0x00A8(0x00B8)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FVector GatherCurrentInputDirection(class AActor* ReferenceActor, float ForwardInputValue, float RightInputValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BasicMoveableComponent">();
	}
	static class UX6BasicMoveableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BasicMoveableComponent>();
	}
};
static_assert(alignof(UX6BasicMoveableComponent) == 0x000008, "Wrong alignment on UX6BasicMoveableComponent");
static_assert(sizeof(UX6BasicMoveableComponent) == 0x000168, "Wrong size on UX6BasicMoveableComponent");
static_assert(offsetof(UX6BasicMoveableComponent, CurRMInputContext) == 0x0000A8, "Member 'UX6BasicMoveableComponent::CurRMInputContext' has a wrong offset!");
static_assert(offsetof(UX6BasicMoveableComponent, CharacterMovementComponent) == 0x000160, "Member 'UX6BasicMoveableComponent::CharacterMovementComponent' has a wrong offset!");

// Class X6Game.X6BasicRegularMovementComponent
// 0x0038 (0x00E0 - 0x00A8)
class UX6BasicRegularMovementComponent : public UX6ActorComponent
{
public:
	uint8                                         bEnableMovementBlockedBy : 1;                      // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	FMulticastSparseDelegateProperty_             OnRegularMovementBlockedBy;                        // 0x00A9(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x26];                                      // 0x00AA(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            OwnerCharacterMovementComponent;                   // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             Character;                                         // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float CalculateMovementBlockedByHeight(const struct FHitResult& HitResult, float BoundaryFromLowToHigh, float EnterBlockAngle);
	void CheckExitMovementBlockedByState(float DeltaSeconds, float ExitBlockAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BasicRegularMovementComponent">();
	}
	static class UX6BasicRegularMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BasicRegularMovementComponent>();
	}
};
static_assert(alignof(UX6BasicRegularMovementComponent) == 0x000008, "Wrong alignment on UX6BasicRegularMovementComponent");
static_assert(sizeof(UX6BasicRegularMovementComponent) == 0x0000E0, "Wrong size on UX6BasicRegularMovementComponent");
static_assert(offsetof(UX6BasicRegularMovementComponent, OnRegularMovementBlockedBy) == 0x0000A9, "Member 'UX6BasicRegularMovementComponent::OnRegularMovementBlockedBy' has a wrong offset!");
static_assert(offsetof(UX6BasicRegularMovementComponent, OwnerCharacterMovementComponent) == 0x0000D0, "Member 'UX6BasicRegularMovementComponent::OwnerCharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UX6BasicRegularMovementComponent, Character) == 0x0000D8, "Member 'UX6BasicRegularMovementComponent::Character' has a wrong offset!");

// Class X6Game.X6NiagaraEffectParam
// 0x0008 (0x0030 - 0x0028)
class UX6NiagaraEffectParam : public UObject
{
public:
	class FName                                   ParameterName;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NiagaraEffectParam">();
	}
	static class UX6NiagaraEffectParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NiagaraEffectParam>();
	}
};
static_assert(alignof(UX6NiagaraEffectParam) == 0x000008, "Wrong alignment on UX6NiagaraEffectParam");
static_assert(sizeof(UX6NiagaraEffectParam) == 0x000030, "Wrong size on UX6NiagaraEffectParam");
static_assert(offsetof(UX6NiagaraEffectParam, ParameterName) == 0x000028, "Member 'UX6NiagaraEffectParam::ParameterName' has a wrong offset!");

// Class X6Game.X6NiagaraEffectParamFloat
// 0x0008 (0x0038 - 0x0030)
class UX6NiagaraEffectParamFloat final : public UX6NiagaraEffectParam
{
public:
	float                                         Value;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NiagaraEffectParamFloat">();
	}
	static class UX6NiagaraEffectParamFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NiagaraEffectParamFloat>();
	}
};
static_assert(alignof(UX6NiagaraEffectParamFloat) == 0x000008, "Wrong alignment on UX6NiagaraEffectParamFloat");
static_assert(sizeof(UX6NiagaraEffectParamFloat) == 0x000038, "Wrong size on UX6NiagaraEffectParamFloat");
static_assert(offsetof(UX6NiagaraEffectParamFloat, Value) == 0x000030, "Member 'UX6NiagaraEffectParamFloat::Value' has a wrong offset!");

// Class X6Game.X6CarrierDataContext
// 0x0000 (0x0028 - 0x0028)
class UX6CarrierDataContext : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CarrierDataContext">();
	}
	static class UX6CarrierDataContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CarrierDataContext>();
	}
};
static_assert(alignof(UX6CarrierDataContext) == 0x000008, "Wrong alignment on UX6CarrierDataContext");
static_assert(sizeof(UX6CarrierDataContext) == 0x000028, "Wrong size on UX6CarrierDataContext");

// Class X6Game.X6BikeDataContext
// 0x00B8 (0x00E0 - 0x0028)
class UX6BikeDataContext final : public UX6CarrierDataContext
{
public:
	uint8                                         BP_CycleStateL1;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeStartRidingType;                            // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeSpotTurnType;                               // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeRidingType;                                 // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeBrakeType;                                  // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeStartJumpType;                              // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeJumpEndType;                                // 0x002E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeDebarkationType;                            // 0x002F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeCyclingInAirType;                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_BikeEnterBikeType;                              // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BP_PreBikeCyclingTypeL1;                           // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBikeIdleLeft;                                     // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSlopeAngle;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeSteerValue;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikePitchOffset;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeYawOffset;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeBodyLeanAngle;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerYAxisInput;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBikeAutoEnter;                                    // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BikeRootMOffset;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeForerakeInput;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeHeelInput;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerAttachedToBike;                             // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBikeSwitchIdle;                                   // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerGestureValue;                                // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeRotationScale;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMoveModeV8;                                 // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BikeSpeedValue;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLaunchedInAir;                                    // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectlyFall;                                     // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LHandLockPosition;                                 // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LHandLockRotation;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RHandLockPosition;                                 // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RHandLockRotation;                                 // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HandIKAlpha;                                       // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHandLockPositionL;                          // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHandLockPositionR;                          // 0x00DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHandLockRotateL;                            // 0x00DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHandLockRotateR;                            // 0x00DF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BikeDataContext">();
	}
	static class UX6BikeDataContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BikeDataContext>();
	}
};
static_assert(alignof(UX6BikeDataContext) == 0x000008, "Wrong alignment on UX6BikeDataContext");
static_assert(sizeof(UX6BikeDataContext) == 0x0000E0, "Wrong size on UX6BikeDataContext");
static_assert(offsetof(UX6BikeDataContext, BP_CycleStateL1) == 0x000028, "Member 'UX6BikeDataContext::BP_CycleStateL1' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeStartRidingType) == 0x000029, "Member 'UX6BikeDataContext::BP_BikeStartRidingType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeSpotTurnType) == 0x00002A, "Member 'UX6BikeDataContext::BP_BikeSpotTurnType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeRidingType) == 0x00002B, "Member 'UX6BikeDataContext::BP_BikeRidingType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeBrakeType) == 0x00002C, "Member 'UX6BikeDataContext::BP_BikeBrakeType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeStartJumpType) == 0x00002D, "Member 'UX6BikeDataContext::BP_BikeStartJumpType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeJumpEndType) == 0x00002E, "Member 'UX6BikeDataContext::BP_BikeJumpEndType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeDebarkationType) == 0x00002F, "Member 'UX6BikeDataContext::BP_BikeDebarkationType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeCyclingInAirType) == 0x000030, "Member 'UX6BikeDataContext::BP_BikeCyclingInAirType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_BikeEnterBikeType) == 0x000031, "Member 'UX6BikeDataContext::BP_BikeEnterBikeType' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BP_PreBikeCyclingTypeL1) == 0x000032, "Member 'UX6BikeDataContext::BP_PreBikeCyclingTypeL1' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bBikeIdleLeft) == 0x000033, "Member 'UX6BikeDataContext::bBikeIdleLeft' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, CurrentSlopeAngle) == 0x000034, "Member 'UX6BikeDataContext::CurrentSlopeAngle' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeSteerValue) == 0x000038, "Member 'UX6BikeDataContext::BikeSteerValue' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikePitchOffset) == 0x00003C, "Member 'UX6BikeDataContext::BikePitchOffset' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeYawOffset) == 0x000040, "Member 'UX6BikeDataContext::BikeYawOffset' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeBodyLeanAngle) == 0x000044, "Member 'UX6BikeDataContext::BikeBodyLeanAngle' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, PlayerYAxisInput) == 0x000048, "Member 'UX6BikeDataContext::PlayerYAxisInput' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bBikeAutoEnter) == 0x00004C, "Member 'UX6BikeDataContext::bBikeAutoEnter' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeRootMOffset) == 0x000050, "Member 'UX6BikeDataContext::BikeRootMOffset' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeForerakeInput) == 0x000054, "Member 'UX6BikeDataContext::BikeForerakeInput' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeHeelInput) == 0x000058, "Member 'UX6BikeDataContext::BikeHeelInput' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bPlayerAttachedToBike) == 0x00005C, "Member 'UX6BikeDataContext::bPlayerAttachedToBike' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bBikeSwitchIdle) == 0x00005D, "Member 'UX6BikeDataContext::bBikeSwitchIdle' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, PlayerGestureValue) == 0x000060, "Member 'UX6BikeDataContext::PlayerGestureValue' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeRotationScale) == 0x000064, "Member 'UX6BikeDataContext::BikeRotationScale' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bEnableMoveModeV8) == 0x000068, "Member 'UX6BikeDataContext::bEnableMoveModeV8' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, BikeSpeedValue) == 0x00006C, "Member 'UX6BikeDataContext::BikeSpeedValue' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bLaunchedInAir) == 0x000070, "Member 'UX6BikeDataContext::bLaunchedInAir' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bDirectlyFall) == 0x000071, "Member 'UX6BikeDataContext::bDirectlyFall' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, LHandLockPosition) == 0x000078, "Member 'UX6BikeDataContext::LHandLockPosition' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, LHandLockRotation) == 0x000090, "Member 'UX6BikeDataContext::LHandLockRotation' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, RHandLockPosition) == 0x0000A8, "Member 'UX6BikeDataContext::RHandLockPosition' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, RHandLockRotation) == 0x0000C0, "Member 'UX6BikeDataContext::RHandLockRotation' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, HandIKAlpha) == 0x0000D8, "Member 'UX6BikeDataContext::HandIKAlpha' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bEnableHandLockPositionL) == 0x0000DC, "Member 'UX6BikeDataContext::bEnableHandLockPositionL' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bEnableHandLockPositionR) == 0x0000DD, "Member 'UX6BikeDataContext::bEnableHandLockPositionR' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bEnableHandLockRotateL) == 0x0000DE, "Member 'UX6BikeDataContext::bEnableHandLockRotateL' has a wrong offset!");
static_assert(offsetof(UX6BikeDataContext, bEnableHandLockRotateR) == 0x0000DF, "Member 'UX6BikeDataContext::bEnableHandLockRotateR' has a wrong offset!");

// Class X6Game.X6MultiPlayerSubSystem
// 0x0198 (0x01C8 - 0x0030)
class UX6MultiPlayerSubSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xF8];                                      // 0x0030(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int64, class AActor*>                    SpawnerIDActorMap;                                 // 0x0128(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class AActor*, int64>                    ActorSpawnerIDMap;                                 // 0x0178(0x0050)(NativeAccessSpecifierPrivate)

public:
	void GetAssetPath(const int32 InGuid, struct FSoftObjectPath* OutPath);
	void RegisterSimulatedActor(int32 EntityID, class AActor* NewSimulatedActor);
	void RegisterSpawner(const int64 SpawnerID, class AActor* Actor);
	void UnregisterSimulatedActor(int32 EntityID);
	void UnregisterSpawner(const int64 SpawnerID, class AActor* Actor);

	int32 GetAssetGuid(const struct FSoftObjectPath& InPath) const;
	class FString GetAssetPathString(const int32 InGuid) const;
	int32 GetPathStringGuid(const class FString& InPathString) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6MultiPlayerSubSystem">();
	}
	static class UX6MultiPlayerSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6MultiPlayerSubSystem>();
	}
};
static_assert(alignof(UX6MultiPlayerSubSystem) == 0x000008, "Wrong alignment on UX6MultiPlayerSubSystem");
static_assert(sizeof(UX6MultiPlayerSubSystem) == 0x0001C8, "Wrong size on UX6MultiPlayerSubSystem");
static_assert(offsetof(UX6MultiPlayerSubSystem, SpawnerIDActorMap) == 0x000128, "Member 'UX6MultiPlayerSubSystem::SpawnerIDActorMap' has a wrong offset!");
static_assert(offsetof(UX6MultiPlayerSubSystem, ActorSpawnerIDMap) == 0x000178, "Member 'UX6MultiPlayerSubSystem::ActorSpawnerIDMap' has a wrong offset!");

// Class X6Game.X6CarrierBaseProcessor
// 0x0000 (0x0028 - 0x0028)
class UX6CarrierBaseProcessor : public UObject
{
public:
	void DeInit();
	void Init();
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CarrierBaseProcessor">();
	}
	static class UX6CarrierBaseProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CarrierBaseProcessor>();
	}
};
static_assert(alignof(UX6CarrierBaseProcessor) == 0x000008, "Wrong alignment on UX6CarrierBaseProcessor");
static_assert(sizeof(UX6CarrierBaseProcessor) == 0x000028, "Wrong size on UX6CarrierBaseProcessor");

// Class X6Game.X6BikePosturalCorrectionProcessor
// 0x03F8 (0x0420 - 0x0028)
class UX6BikePosturalCorrectionProcessor final : public UX6CarrierBaseProcessor
{
public:
	TWeakObjectPtr<class USkeletalMeshComponent>  BikeMeshComponent;                                 // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UChaosWheeledVehicleMovementComponent> BikeMovementComponent;               // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  BikeActor;                                         // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RawPlayerSteer;                                    // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BikeWheelRotationAngle;                            // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BikeSpeedForWheelRotation;                         // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationRelativeToFloor;                           // 0x0050(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                VelocityRelativeToFloor;                           // 0x0068(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastFrameSpeed;                                    // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBikeInAir;                                        // 0x0084(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DrivingCom;                                        // 0x0088(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAccelerateSlope;                               // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationAngleVelocity;                             // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlopeAngle;                                        // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IsTurnInPlace;                                     // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         FloorNormalIgnoreActors;                           // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x2F0];                                     // 0x00C0(0x02F0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTilt;                                           // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltCorrectionMultiplier;                          // 0x03B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x03B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRollThrottle;                              // 0x03BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAirMinSpeedThresholdToStraighten;                // 0x03C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedThresholdToMaxStraighten;                     // 0x03C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackSpeedThresholdToMaxStraighten;                 // 0x03C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteerStraightenMultiplier;                         // 0x03CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StraightenMultiplier;                              // 0x03D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAirStraightenMultiplier;                         // 0x03D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationThresholdToMaxXOffset;                 // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         COMXMaxFrontOffset;                                // 0x03DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         COMXMaxRearOffset;                                 // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedThresholdToMaxZOffset;                        // 0x03E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         COMZMaxOffset;                                     // 0x03E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeSpeedResedeScale;                              // 0x03EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBikeSpeedForWheelRotation;                      // 0x03F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeWheelRadius;                                   // 0x03F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopThreshold;                                     // 0x03F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerateAdditionalSlopeValue;                    // 0x03FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundWheelRotationVelocityScale;                  // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHeight;                                     // 0x0404(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDeltaWidth;                                   // 0x0408(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDeltaHeight;                                  // 0x040C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               FloorNormalTraceChannel;                           // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTurnWithRoll;                               // 0x0411(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_412[0x2];                                      // 0x0412(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRollAngleInTurn;                                // 0x0414(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceInterpSpeed;                            // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_CacheRuntimeVariables();
	void BP_SetBikeData();
	void CheckBikeInAirState();
	void COMAdjustment(float DeltaSeconds);
	void RecoverVerticality();
	void SetUseAccelerateSlopeCalculate(bool bUseAccelerate);
	void TiltLimit();
	void UpdateBikeOnSlopeAngle(float DeltaSeconds);
	float UpdateBikeWheelInAirAngle(float DeltaSeconds);
	void UpdateBikeWheelOnGroundAngle(float DeltaSeconds);
	void UpdateBikeWheelRotationAngle(float DeltaSeconds);
	void UpdateFloorNormal(float DeltaSeconds);
	void UpdateRelativeRotation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BikePosturalCorrectionProcessor">();
	}
	static class UX6BikePosturalCorrectionProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BikePosturalCorrectionProcessor>();
	}
};
static_assert(alignof(UX6BikePosturalCorrectionProcessor) == 0x000008, "Wrong alignment on UX6BikePosturalCorrectionProcessor");
static_assert(sizeof(UX6BikePosturalCorrectionProcessor) == 0x000420, "Wrong size on UX6BikePosturalCorrectionProcessor");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeMeshComponent) == 0x000028, "Member 'UX6BikePosturalCorrectionProcessor::BikeMeshComponent' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeMovementComponent) == 0x000030, "Member 'UX6BikePosturalCorrectionProcessor::BikeMovementComponent' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeActor) == 0x000038, "Member 'UX6BikePosturalCorrectionProcessor::BikeActor' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, RawPlayerSteer) == 0x000040, "Member 'UX6BikePosturalCorrectionProcessor::RawPlayerSteer' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeWheelRotationAngle) == 0x000044, "Member 'UX6BikePosturalCorrectionProcessor::BikeWheelRotationAngle' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeSpeedForWheelRotation) == 0x000048, "Member 'UX6BikePosturalCorrectionProcessor::BikeSpeedForWheelRotation' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, RotationRelativeToFloor) == 0x000050, "Member 'UX6BikePosturalCorrectionProcessor::RotationRelativeToFloor' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, VelocityRelativeToFloor) == 0x000068, "Member 'UX6BikePosturalCorrectionProcessor::VelocityRelativeToFloor' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, LastFrameSpeed) == 0x000080, "Member 'UX6BikePosturalCorrectionProcessor::LastFrameSpeed' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, bBikeInAir) == 0x000084, "Member 'UX6BikePosturalCorrectionProcessor::bBikeInAir' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, DrivingCom) == 0x000088, "Member 'UX6BikePosturalCorrectionProcessor::DrivingCom' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, bUseAccelerateSlope) == 0x0000A0, "Member 'UX6BikePosturalCorrectionProcessor::bUseAccelerateSlope' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, RotationAngleVelocity) == 0x0000A4, "Member 'UX6BikePosturalCorrectionProcessor::RotationAngleVelocity' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, SlopeAngle) == 0x0000A8, "Member 'UX6BikePosturalCorrectionProcessor::SlopeAngle' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, IsTurnInPlace) == 0x0000AC, "Member 'UX6BikePosturalCorrectionProcessor::IsTurnInPlace' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, FloorNormalIgnoreActors) == 0x0000B0, "Member 'UX6BikePosturalCorrectionProcessor::FloorNormalIgnoreActors' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, MaxTilt) == 0x0003B0, "Member 'UX6BikePosturalCorrectionProcessor::MaxTilt' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, TiltCorrectionMultiplier) == 0x0003B4, "Member 'UX6BikePosturalCorrectionProcessor::TiltCorrectionMultiplier' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, MaxPitch) == 0x0003B8, "Member 'UX6BikePosturalCorrectionProcessor::MaxPitch' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, VerticalRollThrottle) == 0x0003BC, "Member 'UX6BikePosturalCorrectionProcessor::VerticalRollThrottle' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, InAirMinSpeedThresholdToStraighten) == 0x0003C0, "Member 'UX6BikePosturalCorrectionProcessor::InAirMinSpeedThresholdToStraighten' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, SpeedThresholdToMaxStraighten) == 0x0003C4, "Member 'UX6BikePosturalCorrectionProcessor::SpeedThresholdToMaxStraighten' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BackSpeedThresholdToMaxStraighten) == 0x0003C8, "Member 'UX6BikePosturalCorrectionProcessor::BackSpeedThresholdToMaxStraighten' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, SteerStraightenMultiplier) == 0x0003CC, "Member 'UX6BikePosturalCorrectionProcessor::SteerStraightenMultiplier' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, StraightenMultiplier) == 0x0003D0, "Member 'UX6BikePosturalCorrectionProcessor::StraightenMultiplier' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, InAirStraightenMultiplier) == 0x0003D4, "Member 'UX6BikePosturalCorrectionProcessor::InAirStraightenMultiplier' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, AccelerationThresholdToMaxXOffset) == 0x0003D8, "Member 'UX6BikePosturalCorrectionProcessor::AccelerationThresholdToMaxXOffset' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, COMXMaxFrontOffset) == 0x0003DC, "Member 'UX6BikePosturalCorrectionProcessor::COMXMaxFrontOffset' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, COMXMaxRearOffset) == 0x0003E0, "Member 'UX6BikePosturalCorrectionProcessor::COMXMaxRearOffset' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, SpeedThresholdToMaxZOffset) == 0x0003E4, "Member 'UX6BikePosturalCorrectionProcessor::SpeedThresholdToMaxZOffset' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, COMZMaxOffset) == 0x0003E8, "Member 'UX6BikePosturalCorrectionProcessor::COMZMaxOffset' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeSpeedResedeScale) == 0x0003EC, "Member 'UX6BikePosturalCorrectionProcessor::BikeSpeedResedeScale' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, MinBikeSpeedForWheelRotation) == 0x0003F0, "Member 'UX6BikePosturalCorrectionProcessor::MinBikeSpeedForWheelRotation' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, BikeWheelRadius) == 0x0003F4, "Member 'UX6BikePosturalCorrectionProcessor::BikeWheelRadius' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, StopThreshold) == 0x0003F8, "Member 'UX6BikePosturalCorrectionProcessor::StopThreshold' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, AccelerateAdditionalSlopeValue) == 0x0003FC, "Member 'UX6BikePosturalCorrectionProcessor::AccelerateAdditionalSlopeValue' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, GroundWheelRotationVelocityScale) == 0x000400, "Member 'UX6BikePosturalCorrectionProcessor::GroundWheelRotationVelocityScale' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, CapsuleHeight) == 0x000404, "Member 'UX6BikePosturalCorrectionProcessor::CapsuleHeight' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, TraceDeltaWidth) == 0x000408, "Member 'UX6BikePosturalCorrectionProcessor::TraceDeltaWidth' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, TraceDeltaHeight) == 0x00040C, "Member 'UX6BikePosturalCorrectionProcessor::TraceDeltaHeight' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, FloorNormalTraceChannel) == 0x000410, "Member 'UX6BikePosturalCorrectionProcessor::FloorNormalTraceChannel' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, bEnableTurnWithRoll) == 0x000411, "Member 'UX6BikePosturalCorrectionProcessor::bEnableTurnWithRoll' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, MaxRollAngleInTurn) == 0x000414, "Member 'UX6BikePosturalCorrectionProcessor::MaxRollAngleInTurn' has a wrong offset!");
static_assert(offsetof(UX6BikePosturalCorrectionProcessor, TurnInPlaceInterpSpeed) == 0x000418, "Member 'UX6BikePosturalCorrectionProcessor::TurnInPlaceInterpSpeed' has a wrong offset!");

// Class X6Game.X6NikkiGroundAnimInstance
// 0x0010 (0x0600 - 0x05F0)
class UX6NikkiGroundAnimInstance final : public UNikkiGroundAnimInstance
{
public:
	bool                                          bMovementBlocked;                                  // 0x05F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelativeBlockedByHeight;                           // 0x05F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NikkiGroundAnimInstance">();
	}
	static class UX6NikkiGroundAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NikkiGroundAnimInstance>();
	}
};
static_assert(alignof(UX6NikkiGroundAnimInstance) == 0x000010, "Wrong alignment on UX6NikkiGroundAnimInstance");
static_assert(sizeof(UX6NikkiGroundAnimInstance) == 0x000600, "Wrong size on UX6NikkiGroundAnimInstance");
static_assert(offsetof(UX6NikkiGroundAnimInstance, bMovementBlocked) == 0x0005F0, "Member 'UX6NikkiGroundAnimInstance::bMovementBlocked' has a wrong offset!");
static_assert(offsetof(UX6NikkiGroundAnimInstance, RelativeBlockedByHeight) == 0x0005F4, "Member 'UX6NikkiGroundAnimInstance::RelativeBlockedByHeight' has a wrong offset!");

// Class X6Game.ClickNotification
// 0x0020 (0x0048 - 0x0028)
class UClickNotification final : public UObject
{
public:
	TDelegate<void()>                             OnClickedOutSide;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClickNotification">();
	}
	static class UClickNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClickNotification>();
	}
};
static_assert(alignof(UClickNotification) == 0x000008, "Wrong alignment on UClickNotification");
static_assert(sizeof(UClickNotification) == 0x000048, "Wrong size on UClickNotification");
static_assert(offsetof(UClickNotification, OnClickedOutSide) == 0x000028, "Member 'UClickNotification::OnClickedOutSide' has a wrong offset!");

// Class X6Game.X6GetActiveAudioComponentOpertion
// 0x0010 (0x0038 - 0x0028)
class UX6GetActiveAudioComponentOpertion final : public UObject
{
public:
	TDelegate<void(const TArray<class UAudioComponent*>& OutActiveAudioComponents)> OnCompleted;     // 0x0028(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Activate(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GetActiveAudioComponentOpertion">();
	}
	static class UX6GetActiveAudioComponentOpertion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GetActiveAudioComponentOpertion>();
	}
};
static_assert(alignof(UX6GetActiveAudioComponentOpertion) == 0x000008, "Wrong alignment on UX6GetActiveAudioComponentOpertion");
static_assert(sizeof(UX6GetActiveAudioComponentOpertion) == 0x000038, "Wrong size on UX6GetActiveAudioComponentOpertion");
static_assert(offsetof(UX6GetActiveAudioComponentOpertion, OnCompleted) == 0x000028, "Member 'UX6GetActiveAudioComponentOpertion::OnCompleted' has a wrong offset!");

// Class X6Game.X6ObstacleInterface
// 0x0000 (0x0000 - 0x0000)
class IX6ObstacleInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ObstacleInterface">();
	}
	static class IX6ObstacleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6ObstacleInterface>();
	}
};
static_assert(alignof(IX6ObstacleInterface) == 0x000001, "Wrong alignment on IX6ObstacleInterface");
static_assert(sizeof(IX6ObstacleInterface) == 0x000001, "Wrong size on IX6ObstacleInterface");

// Class X6Game.X6BlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6BlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActorFaceTowardsActor(class AActor* InActor, class AActor* TargetActor, const bool bTurnInPlace, const bool bLookAt, const struct FLookAtParams& LookAtParam, const TDelegate<void()>& OnComplete, const TDelegate<void()>& OnInterrupt);
	static void ActorFaceTowardsLocation(class AActor* InActor, const struct FVector& TargetLocation, const bool bTurnInPlace, const bool bLookAt, const struct FLookAtParams& LookAtParam, const TDelegate<void()>& OnComplete, const TDelegate<void()>& OnInterrupt);
	static void ActorFaceTowardsRotation(class AActor* InActor, const struct FRotator& TargetRotation, const bool bTurnInPlace, const bool bLookAt, const struct FLookAtParams& LookAtParam, const TDelegate<void()>& OnComplete, const TDelegate<void()>& OnInterrupt);
	static void AddEffectOutlineOnActor(class AActor* InActor);
	static void AddViewSlaveLocation(const struct FVector& SlaveLocation, float BoostFactor, bool bOverrideLocation, float Duration);
	static void ApplyLevelTransform(class ULevelStreaming* loadLevels, const struct FTransform& Transform);
	static void AsyncGetFoliageGeometryInfosInCircleRange(class UObject* WorldContextObject, const struct FVector& Center, const double Radius, TDelegate<void(const TArray<struct FFoliageGeometryInfo>& OutFoliageGeometryInfos)> OnFoliageGeometryInfoReady);
	static float CalculateBesselCurve(const struct FVector& StartPoint, const struct FVector& ControllerPoint1, const struct FVector& ControllerPoint2, const struct FVector& EndPoint, int32 NumPoints, TArray<struct FVector>* OutPoints);
	static bool CheckActorHasBegunPlay(class AActor* Actor);
	static bool CheckBulletConditionCanTraceStartToEnd(class UObject* InWorldContextObject, const struct FVector& Start, const struct FVector& End, const float Radius, const struct FVector& HalfSize, const struct FRotator& Orientation, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, bool bIgnoreSelf, bool bPenetrate, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CheckIsInWater(const class UObject* InWorldContextObject, const struct FVector& CheckLocation, float TraceLength, float MinWaterLengthTolerance, bool bOneLayerWaterCheck);
	static struct FTransform ClearAnimInstanceRootMotionMovementParams(class UAnimInstance* AnimInstance);
	static void ClearCurrentRootMotionSource(class UCharacterMovementComponent* CharacterMovementComponent);
	static void ClearGameViewportForceCursorType(class UObject* InWorldContextObject);
	static void ClearMeshComponentOverrideMaterials(class UMeshComponent* InMeshComponent);
	static void ClearStreamingPauseRenderingDelegate();
	static void ClearTransformUpdatedEvent(class AActor* Target);
	static void ClipboardCopy(const class FString& CopyText);
	static void ClipboardPaste(class FString* OutPasteText);
	static void ComponentSweepMulti(TArray<struct FHitResult>* OutHits, TArray<float>* PenetrationDepth, class UPrimitiveComponent* PrimComp, const struct FVector& Start, const struct FVector& End, const struct FQuat& Quat);
	static struct FVector ComputeGroundMovementDelta(const struct FVector& Delta, const struct FHitResult& RampHit, const bool bHitFromLineTrace);
	static bool ConvertFileNameToObjectPath(const class FString& Filename, class FString* PackageName);
	static bool CopyFile(const class FString& SourcePath, const class FString& DestPath);
	static void CrashTest();
	static struct FGuid CreateGuid();
	static class UMediaTexture* CreateMediaTexture(class UObject* Outer_0);
	static class FText CreateTextFromBuffer(const class FString& BufferStr);
	static class UTexture2DDynamic* CreateTexture2DFromImageFile(const class FString& ImageFileName);
	static class UTexture2D* CreateTexture2DFromWidget(class UWidget* Widget, const struct FVector2D& DrawSize, bool bWriteContentInGammaSpace);
	static bool DeleteDirectory(const class FString& InDirPath, bool RequireExists, bool Tree);
	static void DestroyActorRecusively(class AActor* ActorToDestroy);
	static bool DoesAnimHasNotifyOrNotifyState(class UAnimSequence* InAnimationSequence, TSubclassOf<class UObject> InNotifyOrNotifyStateClass);
	static void DrawCylinderWithFOV(const class UObject* WorldContextObject, const struct FTransform& QueryTransform, float Height, float Radius, float FOV, int32 Segments, const struct FColor& Color, float LifeTime, uint8 DepthPriority, float Thickness, float YawOffset);
	static bool FindAssetsInMemory(const TArray<class FString>& InAssetPaths, TArray<class UObject*>* OutObjects);
	static struct FMovieSceneObjectBindingID FindBindingIDByName(class UMovieSceneSequence* Sequence, const class FString& Name_0, EMovieSceneObjectBindingSpace Space);
	static bool FindPackagesInDirectory(TArray<class FString>* OutPackages, const class FString& RootDir);
	static void FlushWorldComposition(const class UObject* WorldContextObject);
	static void ForceRefreshCurrentLanguage();
	static void ForceTickAnimationWithNoneDeltaTime(class USkeletalMeshComponent* InSkeletalMeshComponent);
	static void ForceTickAnimOnlyWithNoneDeltaTime(class USkeletalMeshComponent* InSkeletalMeshComponent);
	static void GameViewportFadeIn(class UObject* WorldContextObject, float BlackDuration, float FadeInDuration, bool bShouldDisableInput);
	static void GameViewportFadeOut(class UObject* WorldContextObject, float FadeOutDuration, bool bShouldDisableInput);
	static bool GameViewportFadeOutAndFadeIn(class UObject* WorldContextObject, float FadeOutDuration, float BlackDuration, float FadeInDuration, bool bShouldDisableInput, bool bForceFade, const TDelegate<void()>& _FadeOutEndEvent, const TDelegate<void()>& _FadeBlackEndEvent, const TDelegate<void()>& _FadeInEndEvent, bool bStopFadeWhenPause, const struct FLinearColor& InFadeColor);
	static bool GameViewportHasFocus();
	static TArray<class AActor*> GetActorByX6Tag(class UObject* WorldContextObject, const class FString& Tag);
	static void GetAddressPing(const class FString& TargetAddress, TDelegate<void(float Result)> Callback);
	static class ADonNavigationManagerUnbound* GetAirPathfindingMng(const class UObject* WorldContextObject);
	static class UAssetUserData* GetAssetUserDataOfClass(class UObject* InObject, TSubclassOf<class UAssetUserData> InUserDataClass);
	static int32 GetBatteryLevel();
	static class FString GetBinaryVersion();
	static struct FVector GetBoneComponentLocation(class USkeletalMeshComponent* MeshComponent, class FName BoneName);
	static struct FQuat GetBoneComponentQuaternion(class USkeletalMeshComponent* MeshComponent, class FName BoneName);
	static struct FVector GetBoneWorldLocation(class USkeletalMeshComponent* MeshComponent, class FName BoneName);
	static class FString GetBuildVersionDesc();
	static void GetCodesFromKey(const struct FKey& InKey, int64* OutKeyCode, int64* OutCharCode);
	static float GetComputeSlopeDegree(const class UObject* InWorldContextObject, const TArray<EObjectTypeQuery>& ObjectTypes, const struct FVector& ForwardVector, const struct FVector& Start, const float DepthLength, EDrawDebugTrace DrawDebugType);
	static struct FRotator GetComputeSlopeRotation(const class UObject* InWorldContextObject, const TArray<EObjectTypeQuery>& ObjectTypes, struct FTransform* CheckPointTransform, const float InFloorAngle, const float DepthLength, EDrawDebugTrace DrawDebugType);
	static int64 GetCurrentTotalMillisecond();
	static bool GetFileNames(const class FString& InDirPath, TArray<class FString>* OutFileNames);
	static float GetFPS();
	static int32 GetFrameOfMarkedFrame(class ULevelSequence* Sequence, const class FString& Label);
	static class UWidget* GetKeyBoardFocusedWidget(class UUserWidget* InScopeWidget);
	static struct FKey GetKeyFromCodes(const int64 KeyCode, const int64 CharCode);
	static double GetLastUserInteractionDeltaTime(bool bIgnoreMotionInput);
	static struct FKey GetLeftMouseButtonKey();
	static class FString GetLevel(class AActor* Actor);
	static struct FVector GetLevelOffset(class AActor* InActor);
	static class AX6PlayerCameraManager* GetLocalPlayerCameraManager(class UObject* WorldContextObject);
	static class USkeletalMeshComponent* GetMainSkeletalComponent(class AActor* InActor);
	static class UPrimitiveComponent* GetMostPriorityHitComponent(const class AActor* InTargetActor);
	static float GetNavMeshTileSize(const class UObject* WorldContextObject);
	static TArray<struct FNikkiAroundMeshInfo> GetNikkiAroundBound(class ACharacter* InNikki);
	static struct FVector GetNikkiMeshForwardVector(class ACharacter* InNikki, bool bIgnoreZAxis);
	static class AX6NikkiPlayerController* GetNikkiPlayerController(const class UObject* WorldContextObject);
	static void GetNotifyStartAndEndTime(const struct FAnimNotifyEvent& InQueryNotify, float* OutStartTime, float* OutEndTime);
	static double GetObjectsMemoryUsage(const TArray<class UObject*>& Objects);
	static double GetPlatformMilliseconds();
	static struct FVector2f GetPointerPosition(int32 PointerIndex);
	static class FString GetProjectVersion();
	static bool GetSafePaddingLeftRightSymmetric();
	static bool GetSafePaddingTopBottomSymmetric();
	static struct FVector4f GetSafeZonePaddingMaxValue();
	static struct FVector4f GetSafeZonePaddingOriginalValue();
	static void GetSequenceFloatCurveKeys(class UAnimSequence* AnimationSequence, class FName CurveName, TArray<float>* Times, TArray<float>* KeyData);
	static bool GetSequencerTransfromTrackBoxs(class UMovieSceneSequence* InSequence, class UMovieSceneSequencePlayer* InPlayer, const struct FTransform& InTransform, TArray<struct FBox>* OutBoxArray);
	static float GetSingleAnimCurrentTime(class USkeletalMeshComponent* MeshComp);
	static struct FVector GetSkeletalMeshForwardVector(class USkeletalMeshComponent* InSkeletalMeshComponent, bool bIgnoreZAxis);
	static struct FTransform GetSocketComponentSpaceTransformByTime(class USkeletalMeshComponent* SkeletalMeshComp, class UAnimSequence* AnimSequence, class FName SocketName, float Time);
	static void GetStringArrayFromFile(const class FString& Filename, TArray<class FString>* Content);
	static bool GetStringFromFile(const class FString& Filename, class FString* Content);
	static int64 GetStringHash(const class FString& Str);
	static class FString GetStringMD5(const class FString& Str);
	static TArray<class FString> GetStructFieldsArray(class UStruct* Struct);
	static class UWidget* GetSubWidgetByGuideTag(class UUserWidget* InWidget, class FName InGuideTag);
	static const TMap<class FName, class UWidget*> GetSubWidgetWithGuideTag(class UUserWidget* InWidget);
	static int32 GetSupportedAgentIndex(class AActor* Actor);
	static void GetTargetCanFilterAndPriority(const class UPrimitiveComponent* Component, bool* bCanFilter, int32* PriorityValue);
	static void GetTargetFilterHitComponents(const class AActor* InTargetActor, TArray<class UPrimitiveComponent*>* X6CombatHitComponents);
	static void GetVelocityAndPredictPath_CustomArc(class UObject* WorldContextObject, struct FVector* OutLaunchVelocity, TArray<struct FVector>* OutPathPositions, const struct FVector& StartPos, const struct FVector& EndPos, float SimFrequency, float MaxSimTime, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float OverrideGravityZ, float ArcParam);
	static class UWidget* GetWidgetByGuideTag(class UObject* WorldContextObject, class FName InGuideTag);
	static class UUserWidget* GetWidgetInViewport(class UObject* InWidget, TArray<class UWidget*>* OutHierarchyWidgets);
	static class UX6GameInstance* GetX6GameInstance(const class UObject* WorldContextObject);
	static class AX6PlayerControllerBase* GetX6PlayerController(const class UObject* WorldContextObject);
	static bool HasRootMotion(class UAnimSequenceBase* AnimSequenceBase);
	static bool IsActorPlayingGivenAnimation(class AActor* ActorObject, const TArray<struct FSoftObjectPath>& AnimationSoftRefs);
	static bool IsAnyGamePadConnected();
	static bool IsInViewport(class UObject* WorldContextObject, class AActor* Actor);
	static bool IsLoadingScreenFinished();
	static bool IsLocalPlayerController(class AActor* Actor);
	static bool IsMontageSlotActivated(class UAnimInstance* AnimInstance, const class FName& SlotNodeName, const bool bCheckPlaying);
	static bool IsPlayerEyeBlinking(class AActor* InPlayerActor);
	static bool IsPlayingInEditor();
	static bool IsPointInsideBoxComponent(const struct FVector& Point, class UBoxComponent* BoxComponent);
	static bool IsPSOPrecompiling();
	static bool IsThisApplicationForeground();
	static bool IsWidgetChildOf(class UWidget* Widget, class UWidget* PossibleParent);
	static bool IsWidgetRealVisible(class UWidget* InWidget);
	static bool IsWithEditor();
	static bool IsWorldPositionInViewport(class UObject* WorldContextObject, const struct FVector& Position, bool bPlayerViewportRelative);
	static bool LineBoxIntersection(const struct FBox& Box, const struct FVector& Start, const struct FVector& End, const struct FVector& Direction);
	static void LoadAndActivateGameFeaturePlugin(const class FString& InGameFeaturePluginName);
	static void LoadPropertiesFromConfig(class UObject* obj, const class FString& Filename, int32 Instance_ID);
	static void MarkAsGarbageByObject(const class UObject* InObject);
	static void MarkAsGarbageByPath(const class FString& InPackagePath);
	static int32 MatchesTagDepth(const struct FGameplayTag& TagOne, const struct FGameplayTag& TagTwo);
	static int32 NumPSOPrecompilesRemaining();
	static bool PaperDynamicLinkAnimClassLayers(class USkeletalMeshComponent* SKMeshComp, TSubclassOf<class UAnimInstance> NewLinkAnimClass);
	static bool PaperDynamicSetAnimInstanceClass(class USkeletalMeshComponent* SKMeshComp, TSubclassOf<class UAnimInstance> NewAnimClass);
	static void PlayerActorCancelLookAtActor(ELookAtEventType InEventType, class AActor* InPlayerActor, class AActor* InTargetActor, const bool bClearAll, const bool bNeedNetSync);
	static void PlayerActorCancelLookAtLocation(ELookAtEventType InEventType, class AActor* InPlayerActor, const bool bClearAll, const bool bNeedNetSync);
	static void PlayerActorCancleLookAtEventsByType(ELookAtEventType InEventType, class AActor* InPlayerActor, const bool bClearAll, const bool bNeedNetSync);
	static void PlayerActorLookAtActor(ELookAtEventType InEventType, class AActor* InPlayerActor, class AActor* InTargetActor, const bool bNeedTriggerTurn, const float OverrideTriggerTurnAngle, const bool bNeedNetSync);
	static void PlayerActorLookAtActorWithParams(ELookAtEventType InEventType, class AActor* InPlayerActor, class AActor* InTargetActor, const struct FLookAtRequestParams& LookAtRequestParams, const bool bNeedNetSync);
	static void PlayerActorLookAtLocation(ELookAtEventType InEventType, class AActor* InPlayerActor, const struct FVector& InTargetLocation, const bool bNeedTriggerTurn, const float OverrideTriggerTurnAngle, const bool bNeedNetSync);
	static void PlayerActorLookAtLocationWithParams(ELookAtEventType InEventType, class AActor* InPlayerActor, const struct FVector& InTargetLocation, const struct FLookAtRequestParams& LookAtRequestParams, const bool bNeedNetSync);
	static void PlayerActorPauseLookAt(class AActor* InPlayerActor);
	static void PlayerActorResumeLookAt(class AActor* InPlayerActor);
	static void PlayerEyeBlinkOnce(class AActor* InPlayerActor, bool bRandomBlink, bool bForce);
	static void PlayerMoveToLocationAfterFlushLevelStreaming(class UObject* WorldContextObject, const struct FVector& InLocation);
	static void PrestreamTextures(class AActor* Actor, float Seconds, bool bEnableStreaming, int32 CinematicTextureGroups);
	static bool RegisterAndAddComponent(class AActor* Actor, class UActorComponent* NewComponent, EAttachmentRule AttachmentRules, class FName InSocketName);
	static class UClickNotification* RegisterClickNotification(class UWidget* InWidget);
	static int64 RegisterGameViewportActivationChangedEvent(const class UObject* WorldContextObject, const TDelegate<void(bool bActivated)>& Callback);
	static int64 RegisterViewportFocusChangingEvent(TDelegate<void(bool IsFocused, bool IsInFocusPath)> Callback);
	static void ReleaseAllPointerCapture();
	static void RemoveEffectOutlineOnActor(class AActor* InActor);
	static bool RemoveTransformUpdatedEvent(class AActor* Target, int64 Handle);
	static void ReplaceVisibleTextWidgetsToKey(class UObject* InWorldContextObject);
	static struct FGameplayTag RequestGameplayTag(class FName Name_0);
	static void ResetAdvancedCameraRotation(const class UObject* WorldContextObject);
	static void ResizeRenderTarget(class UTextureRenderTarget2D* RenderTarget, int32 Width, int32 Height);
	static void ReTargetActorTickToLevel(class ULevel* InLevel, class AActor* InActor);
	static void SavePropertiesToConfig(class UObject* obj, const class FString& Filename, int32 Instance_ID);
	static bool SaveRenderTargetToFile(class UTextureRenderTarget2D* rt, const class FString& fileDestination, const bool bWithAlpha);
	static bool SaveStringToFile(const class FString& String, const class FString& Filename);
	static bool SearchBulletConditionPathTargetResults(class UObject* InWorldContextObject, const struct FVector& Start, const struct FVector& End, const float Radius, const struct FVector& HalfSize, bool bPenetrateMonster, const struct FRotator& Orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void SearchFilterConditionAreaTargetResults(class UObject* InWorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool SegmentIntersection2D(const struct FVector& SegmentStartA, const struct FVector& SegmentEndA, const struct FVector& SegmentStartB, const struct FVector& SegmentEndB, struct FVector* IntersectionPoint);
	static void SetActorRootComponent(class AActor* InActor, class USceneComponent* InComponent);
	static void SetEnableAnimMontageRootRotion(class UAnimInstance* AnimInstace, class UAnimMontage* AnimMontage, bool bEnable);
	static void SetGameUIFocusBrushEnable(bool bEnable);
	static void SetGameViewportForceCursorType(class UObject* InWorldContextObject, EMouseCursor InForceCursorType);
	static void SetLoadingScreenScale(float DPIScale);
	static void SetLoadingScreenWidget(class UUserWidget* InUserWidget, float MinimumLoadingScreenDisplayTime, bool bWaitForManualStop, bool bAllowEngineTick);
	static void SetMouthShapeLanguage(const class FString& InCulture);
	static void SetPlayerActorLookAtLookAtSelectHighestScore(class AActor* InPlayerActor);
	static void SetPlayerActorLookAtSelectLatestWithEventType(class AActor* InPlayerActor, ELookAtEventType InEventType);
	static void SetSafePaddingSymmetric(bool bLeftRightSymmetric, bool bTopBottomSymmetric);
	static void SetSafeZonePaddingMaxValue(float maxValX, float maxValY, float maxValZ, float maxValW);
	static void SetSingleAnimPosition(class USkeletalMeshComponent* MeshComp, float Time);
	static void SetSkipUpdateAnimation(class UAnimInstance* LinkedAnimInstace, bool IsSkipAnimationUpdate);
	static int64 SetTransformUpdatedEvent(class AActor* Target, TDelegate<void(class USceneComponent* UpdatedComponent, int32 UpdateTransformFlags, ETeleportType Teleport)> Callback);
	static void SetWidgetNavigationEnable(bool bEnabled);
	static void StopLoadingScreen();
	static void SwitchTranslucentOrMaskedMaterails(class AActor* InActor, bool bInTranslucent);
	static bool TestPathSync(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static void UnloadGameFeaturePlugin(const class FString& InGameFeaturePluginName);
	static void UnregisterClickNotification(class UClickNotification* ClickNotification);
	static bool UnregisterGameViewportActivationChangedEvent(const class UObject* WorldContextObject, int64 Handle);
	static bool UnregisterViewportFocusChangingEvent(int64 Handle);
	static void UpdateHiddenParts(class USkeletalMeshComponent* InMainSkMeshComp, const bool bIncludeMainSM);
	static void UpdateTextureRenderTargetResource(class UTextureRenderTarget2D* rt, bool bClearRenderTarget);
	static void UpdateTextureResource(class UTextureRenderTarget2D* rt);
	static void X6AsyncLoadAssetClassViaSoftObjectPath(class UObject* WorldContextObject, const struct FSoftObjectPath& AssetClassPath, TDelegate<void(TSubclassOf<class UObject> Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo);
	static void X6AsyncLoadAssetViaSoftObjectRef(class UObject* WorldContextObject, TSoftObjectPtr<class UObject> Asset, TDelegate<void(class UObject* Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo);
	static ETraceTypeQuery X6ConvertToTraceType(ECollisionChannel CollisionChannel);
	static int32 X6GetArrayFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, TArray<class FString>* Result, bool bNeedReload);
	static bool X6GetBoolFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static int32 X6GetIntFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static struct FRotator X6GetRotatorFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static class FString X6GetStringFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static struct FVector X6GetVectorFromConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool bNeedReload);
	static struct FSlateBrush X6MakeBrushFromTexture(class UObject* AssetObject, int32 Width, int32 Height);
	static void X6SetBoolToConfig(const class FString& Session, const class FString& Key, const class FString& Path, bool Value);
	static void X6SetIntToConfig(const class FString& Session, const class FString& Key, const class FString& Path, int32 Value);
	static void X6SetStringToConfig(const class FString& Session, const class FString& Key, const class FString& Path, const class FString& Value);
	static class AActor* X6SpawnActor(class UObject* WorldContextObject, class UClass* SpawnClass, const struct FVector& SpawnPosition, const struct FRotator& SpawnRotation, bool bAddToSoloLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BlueprintLibrary">();
	}
	static class UX6BlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BlueprintLibrary>();
	}
};
static_assert(alignof(UX6BlueprintLibrary) == 0x000008, "Wrong alignment on UX6BlueprintLibrary");
static_assert(sizeof(UX6BlueprintLibrary) == 0x000028, "Wrong size on UX6BlueprintLibrary");

// Class X6Game.X6CombatCameraSynchronizerBase
// 0x0010 (0x01E0 - 0x01D0)
class UX6CombatCameraSynchronizerBase : public UCameraOrientationSynchronizer
{
public:
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableCombatSynchronize(bool bEnable);
	void SetCombatSyncSettingValue(bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatCameraSynchronizerBase">();
	}
	static class UX6CombatCameraSynchronizerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatCameraSynchronizerBase>();
	}
};
static_assert(alignof(UX6CombatCameraSynchronizerBase) == 0x000010, "Wrong alignment on UX6CombatCameraSynchronizerBase");
static_assert(sizeof(UX6CombatCameraSynchronizerBase) == 0x0001E0, "Wrong size on UX6CombatCameraSynchronizerBase");

// Class X6Game.X6PlayerControllerBase
// 0x0030 (0x09C0 - 0x0990)
class AX6PlayerControllerBase : public APlayerController
{
public:
	TSubclassOf<class UX6UtcPlayerInputComponent> UtcInputComponentClass;                            // 0x0990(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_998[0x28];                                     // 0x0998(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTouchInputEnable(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PlayerControllerBase">();
	}
	static class AX6PlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6PlayerControllerBase>();
	}
};
static_assert(alignof(AX6PlayerControllerBase) == 0x000008, "Wrong alignment on AX6PlayerControllerBase");
static_assert(sizeof(AX6PlayerControllerBase) == 0x0009C0, "Wrong size on AX6PlayerControllerBase");
static_assert(offsetof(AX6PlayerControllerBase, UtcInputComponentClass) == 0x000990, "Member 'AX6PlayerControllerBase::UtcInputComponentClass' has a wrong offset!");

// Class X6Game.X6NikkiPlayerController
// 0x0010 (0x09D0 - 0x09C0)
class AX6NikkiPlayerController final : public AX6PlayerControllerBase
{
public:
	bool                                          bCreatePlayerCameraManager;                        // 0x09C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C1[0x7];                                      // 0x09C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ControlPawn;                                       // 0x09C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetControlPawn(class APawn* InPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NikkiPlayerController">();
	}
	static class AX6NikkiPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6NikkiPlayerController>();
	}
};
static_assert(alignof(AX6NikkiPlayerController) == 0x000008, "Wrong alignment on AX6NikkiPlayerController");
static_assert(sizeof(AX6NikkiPlayerController) == 0x0009D0, "Wrong size on AX6NikkiPlayerController");
static_assert(offsetof(AX6NikkiPlayerController, bCreatePlayerCameraManager) == 0x0009C0, "Member 'AX6NikkiPlayerController::bCreatePlayerCameraManager' has a wrong offset!");
static_assert(offsetof(AX6NikkiPlayerController, ControlPawn) == 0x0009C8, "Member 'AX6NikkiPlayerController::ControlPawn' has a wrong offset!");

// Class X6Game.X6BossCameraSynchronizer
// 0x0020 (0x0200 - 0x01E0)
class UX6BossCameraSynchronizer final : public UX6CombatCameraSynchronizerBase
{
public:
	uint8                                         Pad_1E0[0x4];                                      // 0x01E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaYawFromDireToBoss;                            // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStaticTargetPitchSync;                      // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticWorldPitchValue;                             // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationPitchSyncAngularSpeedCurve;                // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FRotator BlueprintGetYawSyncTargetRotation();
	void ClearRotateTargetBoss();
	void SetRotateTargetBoss(class AActor* BossCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BossCameraSynchronizer">();
	}
	static class UX6BossCameraSynchronizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BossCameraSynchronizer>();
	}
};
static_assert(alignof(UX6BossCameraSynchronizer) == 0x000010, "Wrong alignment on UX6BossCameraSynchronizer");
static_assert(sizeof(UX6BossCameraSynchronizer) == 0x000200, "Wrong size on UX6BossCameraSynchronizer");
static_assert(offsetof(UX6BossCameraSynchronizer, DeltaYawFromDireToBoss) == 0x0001E4, "Member 'UX6BossCameraSynchronizer::DeltaYawFromDireToBoss' has a wrong offset!");
static_assert(offsetof(UX6BossCameraSynchronizer, bEnableStaticTargetPitchSync) == 0x0001E8, "Member 'UX6BossCameraSynchronizer::bEnableStaticTargetPitchSync' has a wrong offset!");
static_assert(offsetof(UX6BossCameraSynchronizer, StaticWorldPitchValue) == 0x0001EC, "Member 'UX6BossCameraSynchronizer::StaticWorldPitchValue' has a wrong offset!");
static_assert(offsetof(UX6BossCameraSynchronizer, RotationPitchSyncAngularSpeedCurve) == 0x0001F0, "Member 'UX6BossCameraSynchronizer::RotationPitchSyncAngularSpeedCurve' has a wrong offset!");

// Class X6Game.X6BTDecorator_BlueprintBase
// 0x0000 (0x00A0 - 0x00A0)
class UX6BTDecorator_BlueprintBase final : public UBTDecorator_BlueprintBase
{
public:
	void K2_OnInstanceDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTDecorator_BlueprintBase">();
	}
	static class UX6BTDecorator_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTDecorator_BlueprintBase>();
	}
};
static_assert(alignof(UX6BTDecorator_BlueprintBase) == 0x000008, "Wrong alignment on UX6BTDecorator_BlueprintBase");
static_assert(sizeof(UX6BTDecorator_BlueprintBase) == 0x0000A0, "Wrong size on UX6BTDecorator_BlueprintBase");

// Class X6Game.X6NigaraBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6NigaraBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetNiagaraUserBoolParam(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, bool* OutValue);
	static bool GetNiagaraUserFloatParam(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, float* OutValue);
	static bool GetNiagaraUserInt32Param(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, int32* OutValue);
	static bool GetNiagaraUserLinearColorParam(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, struct FLinearColor* OutValue);
	static bool GetNiagaraUserObjectParam(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, class UObject** OutValue);
	static bool GetNiagaraUserVector2Param(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, struct FVector2D* OutValue);
	static bool GetNiagaraUserVector3Param(class UNiagaraSystem* InNiagaraSystem, class FName InUserParamName, struct FVector* OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NigaraBlueprintLibrary">();
	}
	static class UX6NigaraBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NigaraBlueprintLibrary>();
	}
};
static_assert(alignof(UX6NigaraBlueprintLibrary) == 0x000008, "Wrong alignment on UX6NigaraBlueprintLibrary");
static_assert(sizeof(UX6NigaraBlueprintLibrary) == 0x000028, "Wrong size on UX6NigaraBlueprintLibrary");

// Class X6Game.X6BTDecorator_IsInRange
// 0x0058 (0x00C0 - 0x0068)
class UX6BTDecorator_IsInRange final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 Origin;                                            // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 End;                                               // 0x0090(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         Distance;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bXYDistance : 1;                                   // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bExcludeActorRadius : 1;                           // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTDecorator_IsInRange">();
	}
	static class UX6BTDecorator_IsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTDecorator_IsInRange>();
	}
};
static_assert(alignof(UX6BTDecorator_IsInRange) == 0x000008, "Wrong alignment on UX6BTDecorator_IsInRange");
static_assert(sizeof(UX6BTDecorator_IsInRange) == 0x0000C0, "Wrong size on UX6BTDecorator_IsInRange");
static_assert(offsetof(UX6BTDecorator_IsInRange, Origin) == 0x000068, "Member 'UX6BTDecorator_IsInRange::Origin' has a wrong offset!");
static_assert(offsetof(UX6BTDecorator_IsInRange, End) == 0x000090, "Member 'UX6BTDecorator_IsInRange::End' has a wrong offset!");
static_assert(offsetof(UX6BTDecorator_IsInRange, Distance) == 0x0000B8, "Member 'UX6BTDecorator_IsInRange::Distance' has a wrong offset!");

// Class X6Game.X6BTService_BlueprintBase
// 0x0000 (0x0098 - 0x0098)
class UX6BTService_BlueprintBase final : public UBTService_BlueprintBase
{
public:
	void K2_OnInstanceDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTService_BlueprintBase">();
	}
	static class UX6BTService_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTService_BlueprintBase>();
	}
};
static_assert(alignof(UX6BTService_BlueprintBase) == 0x000008, "Wrong alignment on UX6BTService_BlueprintBase");
static_assert(sizeof(UX6BTService_BlueprintBase) == 0x000098, "Wrong size on UX6BTService_BlueprintBase");

// Class X6Game.X6ObjectOctreeRenderingComp
// 0x0010 (0x05D0 - 0x05C0)
class UX6ObjectOctreeRenderingComp final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ObjectOctreeRenderingComp">();
	}
	static class UX6ObjectOctreeRenderingComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ObjectOctreeRenderingComp>();
	}
};
static_assert(alignof(UX6ObjectOctreeRenderingComp) == 0x000010, "Wrong alignment on UX6ObjectOctreeRenderingComp");
static_assert(sizeof(UX6ObjectOctreeRenderingComp) == 0x0005D0, "Wrong size on UX6ObjectOctreeRenderingComp");

// Class X6Game.X6BTTask_BlueprintBase
// 0x0008 (0x00B0 - 0x00A8)
class UX6BTTask_BlueprintBase final : public UBTTask_BlueprintBase
{
public:
	uint8                                         bObserveBlackboard : 1;                            // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCustomizeDescription : 1;                         // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnInstanceDestroyed();
	void OnBlackboardKeyValueChange(const class UBlackboardComponent* Blackboard, class FName KeyName);

	class FString K2_GetCustomDescription(const class FString& InDescripttion) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTTask_BlueprintBase">();
	}
	static class UX6BTTask_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTTask_BlueprintBase>();
	}
};
static_assert(alignof(UX6BTTask_BlueprintBase) == 0x000008, "Wrong alignment on UX6BTTask_BlueprintBase");
static_assert(sizeof(UX6BTTask_BlueprintBase) == 0x0000B0, "Wrong size on UX6BTTask_BlueprintBase");

// Class X6Game.X6BTTask_PlayBlackboardAnimation
// 0x0080 (0x00F0 - 0x0070)
class UX6BTTask_PlayBlackboardAnimation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 Animation;                                         // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class FName                                   SlotNodeName;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreAbort : 1;                                  // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumPlayTime;                                   // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 MyOwnerComp;                                       // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimInstance*                          AnimInstance;                                      // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTTask_PlayBlackboardAnimation">();
	}
	static class UX6BTTask_PlayBlackboardAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTTask_PlayBlackboardAnimation>();
	}
};
static_assert(alignof(UX6BTTask_PlayBlackboardAnimation) == 0x000008, "Wrong alignment on UX6BTTask_PlayBlackboardAnimation");
static_assert(sizeof(UX6BTTask_PlayBlackboardAnimation) == 0x0000F0, "Wrong size on UX6BTTask_PlayBlackboardAnimation");
static_assert(offsetof(UX6BTTask_PlayBlackboardAnimation, Animation) == 0x000070, "Member 'UX6BTTask_PlayBlackboardAnimation::Animation' has a wrong offset!");
static_assert(offsetof(UX6BTTask_PlayBlackboardAnimation, SlotNodeName) == 0x000098, "Member 'UX6BTTask_PlayBlackboardAnimation::SlotNodeName' has a wrong offset!");
static_assert(offsetof(UX6BTTask_PlayBlackboardAnimation, MinimumPlayTime) == 0x0000A4, "Member 'UX6BTTask_PlayBlackboardAnimation::MinimumPlayTime' has a wrong offset!");
static_assert(offsetof(UX6BTTask_PlayBlackboardAnimation, MyOwnerComp) == 0x0000A8, "Member 'UX6BTTask_PlayBlackboardAnimation::MyOwnerComp' has a wrong offset!");
static_assert(offsetof(UX6BTTask_PlayBlackboardAnimation, AnimInstance) == 0x0000B0, "Member 'UX6BTTask_PlayBlackboardAnimation::AnimInstance' has a wrong offset!");

// Class X6Game.X6PlayerCameraManager
// 0x01D0 (0x7450 - 0x7280)
class AX6PlayerCameraManager final : public AX6PlayerCameraManagerBase
{
public:
	struct FCameraModifiersWrap                   ModifierObjects;                                   // 0x7280(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
	class UDataTable*                             DTCameraStateTransitionRule;                       // 0x72B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DTCameraStatePriority;                             // 0x72C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C8[0x58];                                    // 0x72C8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ECameraState NewCameraState)> OnCameraStateChanged;                // 0x7320(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bDissolveEnable : 1;                               // 0x7330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7331[0x7];                                     // 0x7331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCameraModifierSpecHandle>      ActivateModifiers;                                 // 0x7338(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCameraModifierEffectSpec>      CameraModifiers_External;                          // 0x7348(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             ModifiersConfig;                                   // 0x7358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UCameraModifiersDetailData*> ModifiersList;                            // 0x7360(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_73B0[0x50];                                    // 0x73B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     RadiusBlurMaterial;                                // 0x7400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RadiusBlurVectorParamName;                         // 0x7408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RadiusBlurVectorParamValue;                        // 0x7410(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               RadiusBlurMID;                                     // 0x7420(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams)> OnCameraCutBeginDelegate; // 0x7428(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams)> OnCameraCutEndDelegate; // 0x7438(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7448[0x8];                                     // 0x7448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FCameraModifierSpecHandle ApplyCameraModifierEffectByKey(const class FString& Key);
	void ApplyRadiusBlurToPostProcessSettings(const float InOffset, const float InRadius, const float InHardness, const float InSwitchDir, struct FPostProcessSettings* InOutPostProcessSettings, const float InBlendWeight);
	void BlendToViewTargetWithParam(ECameraState CurrentCameraState, class AActor* CurrentTarget, ECameraState NewCameraState, class AActor* NewTarget, const struct FViewTargetTransitionParams& TransitionParams, bool bOverrideTransitionParams);
	bool CheckIsBlendingToOtherTarget();
	TArray<struct FDebugCameraModifierStackInfo> DEBUG_GetCameraModifierStackInfo();
	struct FDebugCameraReviseParam DEBUG_GetCameraTransformParam();
	void FixLastViewTargetOfLevelSequence();
	float GetOutOfFrustumValue(const struct FVector& TargetWorldLoc, float InRangeMultiper);
	bool K2_ApplyCameraModifierEffectByKey(const class FString& Key);
	void K2_ChangeCameraStateTo(ECameraState NewCameraState, class AActor* NewTarget);
	void K2_OnCameraModifierEffectToSelf(const struct FCameraModifierSpecHandle& ActiveHandle);
	void K2_PopAndSwitchToLastCameraState(bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	void K2_PushAndSwitchToCameraState(ECameraState NewCameraState, class AActor* NewTarget, bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	void K2_PushCameraState(ECameraState NewCameraState, class AActor* NewTarget);
	void K2_SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void K2_SwitchToCameraState(ECameraState NewCameraState, class AActor* NewTarget);
	void OnAssignViewTarget(class AActor* NewTarget);
	void OnSetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void RemoveCameraModifierEffectByHandle(int32 HandleID);
	void RemoveCameraState(ECameraState CameraStateToRemove, class AActor* TargetToRemove, bool BlendToTop, bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	void ResetCameraExitConditions();
	void SetKeepCameraCutRotationWhenBlendOut(const bool bInKeepCameraCutRotationWhenBlendOut);
	void SetResetCameraCutRotationWhenJumpOut(const bool bInResetCameraCutRotationWhenJumpCut);
	void SetViewTargetInSequence(class UObject* WorldContextObject, class AActor* CameraActor, bool DoCollisionTest, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing);

	bool CheckCameraTransitionEnable(ECameraState SourceCameraState, ECameraState TargetCameraState) const;
	class AActor* GetCurViewTarget() const;
	struct FRotator GetDesiredTargetRotation() const;
	struct FCameraTransitionConfig GetTransitionConfig(const ECameraState SourceCameraState, const ECameraState TargetCameraState) const;
	bool IsPossessedByLevelSequence(const bool bIgnoreViewTargetDifference) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PlayerCameraManager">();
	}
	static class AX6PlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6PlayerCameraManager>();
	}
};
static_assert(alignof(AX6PlayerCameraManager) == 0x000010, "Wrong alignment on AX6PlayerCameraManager");
static_assert(sizeof(AX6PlayerCameraManager) == 0x007450, "Wrong size on AX6PlayerCameraManager");
static_assert(offsetof(AX6PlayerCameraManager, ModifierObjects) == 0x007280, "Member 'AX6PlayerCameraManager::ModifierObjects' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, DTCameraStateTransitionRule) == 0x0072B8, "Member 'AX6PlayerCameraManager::DTCameraStateTransitionRule' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, DTCameraStatePriority) == 0x0072C0, "Member 'AX6PlayerCameraManager::DTCameraStatePriority' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, OnCameraStateChanged) == 0x007320, "Member 'AX6PlayerCameraManager::OnCameraStateChanged' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, ActivateModifiers) == 0x007338, "Member 'AX6PlayerCameraManager::ActivateModifiers' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, CameraModifiers_External) == 0x007348, "Member 'AX6PlayerCameraManager::CameraModifiers_External' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, ModifiersConfig) == 0x007358, "Member 'AX6PlayerCameraManager::ModifiersConfig' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, ModifiersList) == 0x007360, "Member 'AX6PlayerCameraManager::ModifiersList' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, RadiusBlurMaterial) == 0x007400, "Member 'AX6PlayerCameraManager::RadiusBlurMaterial' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, RadiusBlurVectorParamName) == 0x007408, "Member 'AX6PlayerCameraManager::RadiusBlurVectorParamName' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, RadiusBlurVectorParamValue) == 0x007410, "Member 'AX6PlayerCameraManager::RadiusBlurVectorParamValue' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, RadiusBlurMID) == 0x007420, "Member 'AX6PlayerCameraManager::RadiusBlurMID' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, OnCameraCutBeginDelegate) == 0x007428, "Member 'AX6PlayerCameraManager::OnCameraCutBeginDelegate' has a wrong offset!");
static_assert(offsetof(AX6PlayerCameraManager, OnCameraCutEndDelegate) == 0x007438, "Member 'AX6PlayerCameraManager::OnCameraCutEndDelegate' has a wrong offset!");

// Class X6Game.BTDaMiaoAvoidanceContext
// 0x0058 (0x0080 - 0x0028)
class UBTDaMiaoAvoidanceContext final : public UObject
{
public:
	TMap<int64, class AX6CharacterBase*>          CustomMoveCharacters;                              // 0x0028(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	float                                         CheckMoveTime;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespMultiPlayer;                                  // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDaMiaoAvoidanceContext">();
	}
	static class UBTDaMiaoAvoidanceContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDaMiaoAvoidanceContext>();
	}
};
static_assert(alignof(UBTDaMiaoAvoidanceContext) == 0x000008, "Wrong alignment on UBTDaMiaoAvoidanceContext");
static_assert(sizeof(UBTDaMiaoAvoidanceContext) == 0x000080, "Wrong size on UBTDaMiaoAvoidanceContext");
static_assert(offsetof(UBTDaMiaoAvoidanceContext, CustomMoveCharacters) == 0x000028, "Member 'UBTDaMiaoAvoidanceContext::CustomMoveCharacters' has a wrong offset!");
static_assert(offsetof(UBTDaMiaoAvoidanceContext, CheckMoveTime) == 0x000078, "Member 'UBTDaMiaoAvoidanceContext::CheckMoveTime' has a wrong offset!");
static_assert(offsetof(UBTDaMiaoAvoidanceContext, bRespMultiPlayer) == 0x00007C, "Member 'UBTDaMiaoAvoidanceContext::bRespMultiPlayer' has a wrong offset!");

// Class X6Game.X6BTDecorator_CheckDaMiaoAvoidance
// 0x0030 (0x0098 - 0x0068)
class UX6BTDecorator_CheckDaMiaoAvoidance final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 AvoidanceContextKey;                               // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	class UBTDaMiaoAvoidanceContext*              CachedAvoidanceContext;                            // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTDecorator_CheckDaMiaoAvoidance">();
	}
	static class UX6BTDecorator_CheckDaMiaoAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTDecorator_CheckDaMiaoAvoidance>();
	}
};
static_assert(alignof(UX6BTDecorator_CheckDaMiaoAvoidance) == 0x000008, "Wrong alignment on UX6BTDecorator_CheckDaMiaoAvoidance");
static_assert(sizeof(UX6BTDecorator_CheckDaMiaoAvoidance) == 0x000098, "Wrong size on UX6BTDecorator_CheckDaMiaoAvoidance");
static_assert(offsetof(UX6BTDecorator_CheckDaMiaoAvoidance, AvoidanceContextKey) == 0x000068, "Member 'UX6BTDecorator_CheckDaMiaoAvoidance::AvoidanceContextKey' has a wrong offset!");
static_assert(offsetof(UX6BTDecorator_CheckDaMiaoAvoidance, CachedAvoidanceContext) == 0x000090, "Member 'UX6BTDecorator_CheckDaMiaoAvoidance::CachedAvoidanceContext' has a wrong offset!");

// Class X6Game.X6PathfindingSetting
// 0x0008 (0x0040 - 0x0038)
class UX6PathfindingSetting final : public UDeveloperSettings
{
public:
	ECollisionChannel                             DefaultAirPathfindingCollisionChannel;             // 0x0038(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PathfindingSetting">();
	}
	static class UX6PathfindingSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PathfindingSetting>();
	}
};
static_assert(alignof(UX6PathfindingSetting) == 0x000008, "Wrong alignment on UX6PathfindingSetting");
static_assert(sizeof(UX6PathfindingSetting) == 0x000040, "Wrong size on UX6PathfindingSetting");
static_assert(offsetof(UX6PathfindingSetting, DefaultAirPathfindingCollisionChannel) == 0x000038, "Member 'UX6PathfindingSetting::DefaultAirPathfindingCollisionChannel' has a wrong offset!");

// Class X6Game.X6BTTask_DaMiaoAvoidance
// 0x00B8 (0x0128 - 0x0070)
class UX6BTTask_DaMiaoAvoidance final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 AvoidanceContextKey;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ForwardAnimationKey;                               // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BackwardAnimationKey;                              // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBTDaMiaoAvoidanceContext*              CachedAvoidanceContext;                            // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTreeComponent*                 MyOwnerComp;                                       // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           CachedForwardMontage;                              // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           CachedBackwardMontage;                             // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayAnimationFinished(class FName NotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BTTask_DaMiaoAvoidance">();
	}
	static class UX6BTTask_DaMiaoAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BTTask_DaMiaoAvoidance>();
	}
};
static_assert(alignof(UX6BTTask_DaMiaoAvoidance) == 0x000008, "Wrong alignment on UX6BTTask_DaMiaoAvoidance");
static_assert(sizeof(UX6BTTask_DaMiaoAvoidance) == 0x000128, "Wrong size on UX6BTTask_DaMiaoAvoidance");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, AvoidanceContextKey) == 0x000070, "Member 'UX6BTTask_DaMiaoAvoidance::AvoidanceContextKey' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, ForwardAnimationKey) == 0x000098, "Member 'UX6BTTask_DaMiaoAvoidance::ForwardAnimationKey' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, BackwardAnimationKey) == 0x0000C0, "Member 'UX6BTTask_DaMiaoAvoidance::BackwardAnimationKey' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, SlotNodeName) == 0x0000E8, "Member 'UX6BTTask_DaMiaoAvoidance::SlotNodeName' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, CachedAvoidanceContext) == 0x0000F0, "Member 'UX6BTTask_DaMiaoAvoidance::CachedAvoidanceContext' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, MyOwnerComp) == 0x000108, "Member 'UX6BTTask_DaMiaoAvoidance::MyOwnerComp' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, CachedForwardMontage) == 0x000110, "Member 'UX6BTTask_DaMiaoAvoidance::CachedForwardMontage' has a wrong offset!");
static_assert(offsetof(UX6BTTask_DaMiaoAvoidance, CachedBackwardMontage) == 0x000118, "Member 'UX6BTTask_DaMiaoAvoidance::CachedBackwardMontage' has a wrong offset!");

// Class X6Game.X6BuffDataAsset
// 0x0010 (0x0040 - 0x0030)
class UX6BuffDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<class UX6BuffEffectModifier*>          BuffEffectModifier;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BuffDataAsset">();
	}
	static class UX6BuffDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BuffDataAsset>();
	}
};
static_assert(alignof(UX6BuffDataAsset) == 0x000008, "Wrong alignment on UX6BuffDataAsset");
static_assert(sizeof(UX6BuffDataAsset) == 0x000040, "Wrong size on UX6BuffDataAsset");
static_assert(offsetof(UX6BuffDataAsset, BuffEffectModifier) == 0x000030, "Member 'UX6BuffDataAsset::BuffEffectModifier' has a wrong offset!");

// Class X6Game.X6Object
// 0x0000 (0x0028 - 0x0028)
class UX6Object final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6Object">();
	}
	static class UX6Object* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6Object>();
	}
};
static_assert(alignof(UX6Object) == 0x000008, "Wrong alignment on UX6Object");
static_assert(sizeof(UX6Object) == 0x000028, "Wrong size on UX6Object");

// Class X6Game.X6BuffEffectModifier
// 0x0000 (0x0028 - 0x0028)
class UX6BuffEffectModifier final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BuffEffectModifier">();
	}
	static class UX6BuffEffectModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BuffEffectModifier>();
	}
};
static_assert(alignof(UX6BuffEffectModifier) == 0x000008, "Wrong alignment on UX6BuffEffectModifier");
static_assert(sizeof(UX6BuffEffectModifier) == 0x000028, "Wrong size on UX6BuffEffectModifier");

// Class X6Game.X6BulletActorBase
// 0x0098 (0x04D0 - 0x0438)
class AX6BulletActorBase final : public AX6Actor
{
public:
	class AActor*                                 CasterActor;                                       // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6BulletDataAsset*                     BulletDataAsset;                                   // 0x0440(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TargetComponent;                                   // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0450(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0458(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextLocation;                                      // 0x0470(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestroyHitImpactPoint;                             // 0x0488(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlockingDestroy;                                // 0x04A0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6BulletDestroyType                          DestroyType;                                       // 0x04A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A2[0x2];                                      // 0x04A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccumulateSeconds;                                 // 0x04A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPendingDestroy;                                 // 0x04A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UX6BulletSimpleBasicModifier*>   BulletModifiers;                                   // 0x04B0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UX6BulletMovementBasicModifier*         BulletMovementModifier;                            // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x04C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitData(class AActor* InCasterActor, class UX6BulletDataAsset* InBulletDataAsset, class USceneComponent* InTargetComponent, class AActor* InTargetActor);
	void K2_ClearTargetIfHit(class AActor* HitActor);
	void K2_DestroyModifiers();
	void K2_DoDelayDestroy();
	void K2_DoPendingDestroy(bool bHitDamage, class AActor* HitActor, const struct FVector& InDestroyHitImpactPoint);
	void K2_OnDestroyBlocked(bool bHitDamage, const class AActor* HitActor, const struct FVector& InDestroyHitImpactPoint, const class UX6BulletSimpleBasicModifier* SourceModifier);
	void K2_SetIsBlockingDestroy(bool bBlock);
	void OnAsyncLoadComplete();

	float K2_GetAccumulateSeconds() const;
	EX6BulletDestroyType K2_GetBulletDestroyType(const class AActor* HitActor, bool bHitDamage) const;
	class AActor* K2_GetTargetActor() const;
	bool K2_IsDestroyFromHit() const;
	bool K2_IsPendingDestroy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletActorBase">();
	}
	static class AX6BulletActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6BulletActorBase>();
	}
};
static_assert(alignof(AX6BulletActorBase) == 0x000008, "Wrong alignment on AX6BulletActorBase");
static_assert(sizeof(AX6BulletActorBase) == 0x0004D0, "Wrong size on AX6BulletActorBase");
static_assert(offsetof(AX6BulletActorBase, CasterActor) == 0x000438, "Member 'AX6BulletActorBase::CasterActor' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, BulletDataAsset) == 0x000440, "Member 'AX6BulletActorBase::BulletDataAsset' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, TargetComponent) == 0x000448, "Member 'AX6BulletActorBase::TargetComponent' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, TargetActor) == 0x000450, "Member 'AX6BulletActorBase::TargetActor' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, Velocity) == 0x000458, "Member 'AX6BulletActorBase::Velocity' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, NextLocation) == 0x000470, "Member 'AX6BulletActorBase::NextLocation' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, DestroyHitImpactPoint) == 0x000488, "Member 'AX6BulletActorBase::DestroyHitImpactPoint' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, bIsBlockingDestroy) == 0x0004A0, "Member 'AX6BulletActorBase::bIsBlockingDestroy' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, DestroyType) == 0x0004A1, "Member 'AX6BulletActorBase::DestroyType' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, AccumulateSeconds) == 0x0004A4, "Member 'AX6BulletActorBase::AccumulateSeconds' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, bIsPendingDestroy) == 0x0004A8, "Member 'AX6BulletActorBase::bIsPendingDestroy' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, BulletModifiers) == 0x0004B0, "Member 'AX6BulletActorBase::BulletModifiers' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, BulletMovementModifier) == 0x0004C0, "Member 'AX6BulletActorBase::BulletMovementModifier' has a wrong offset!");
static_assert(offsetof(AX6BulletActorBase, Duration) == 0x0004C8, "Member 'AX6BulletActorBase::Duration' has a wrong offset!");

// Class X6Game.X6BulletBase
// 0x0008 (0x0440 - 0x0438)
class AX6BulletBase final : public AX6Actor
{
public:
	EX6BulletClass                                BulletClass;                                       // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletBase">();
	}
	static class AX6BulletBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6BulletBase>();
	}
};
static_assert(alignof(AX6BulletBase) == 0x000008, "Wrong alignment on AX6BulletBase");
static_assert(sizeof(AX6BulletBase) == 0x000440, "Wrong size on AX6BulletBase");
static_assert(offsetof(AX6BulletBase, BulletClass) == 0x000438, "Member 'AX6BulletBase::BulletClass' has a wrong offset!");

// Class X6Game.X6BulletModifier
// 0x0018 (0x0040 - 0x0028)
class UX6BulletModifier : public UObject
{
public:
	bool                                          bActive;                                           // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AX6BulletActorBase*                     OwnerActor;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6BulletDataAsset*                     BulletDataAsset;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Destroy();
	void Init(class AX6BulletActorBase* InOwnerActor, class UX6BulletDataAsset* InBulletDataAsset);
	void OnAsyncLoadComplete();
	void SetActive(bool Inactive);
	void Tick(float DeltaSeconds);

	bool IsActive() const;
	void K2_Destroy() const;
	void K2_Init() const;
	void K2_OnAsyncLoadComplete() const;
	void K2_Tick(float DeltaSeconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletModifier">();
	}
	static class UX6BulletModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletModifier>();
	}
};
static_assert(alignof(UX6BulletModifier) == 0x000008, "Wrong alignment on UX6BulletModifier");
static_assert(sizeof(UX6BulletModifier) == 0x000040, "Wrong size on UX6BulletModifier");
static_assert(offsetof(UX6BulletModifier, bActive) == 0x000028, "Member 'UX6BulletModifier::bActive' has a wrong offset!");
static_assert(offsetof(UX6BulletModifier, OwnerActor) == 0x000030, "Member 'UX6BulletModifier::OwnerActor' has a wrong offset!");
static_assert(offsetof(UX6BulletModifier, BulletDataAsset) == 0x000038, "Member 'UX6BulletModifier::BulletDataAsset' has a wrong offset!");

// Class X6Game.X6RecycableObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IX6RecycableObjectInterface final : public IInterface
{
public:
	void OnPop();
	void OnPreCreated();
	void OnPush();
	bool RejectRecycle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RecycableObjectInterface">();
	}
	static class IX6RecycableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6RecycableObjectInterface>();
	}
};
static_assert(alignof(IX6RecycableObjectInterface) == 0x000001, "Wrong alignment on IX6RecycableObjectInterface");
static_assert(sizeof(IX6RecycableObjectInterface) == 0x000001, "Wrong size on IX6RecycableObjectInterface");

// Class X6Game.X6BulletMovementBasicModifier
// 0x0018 (0x0058 - 0x0040)
class UX6BulletMovementBasicModifier : public UX6BulletModifier
{
public:
	float                                         BaseSpeed;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCurve;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDrawDebugTrace                               DebugMoveDraw;                                     // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float K2_GetSpeedRateValue(float AccumulateSeconds) const;
	void K2_TickLineMove(float DeltaSeconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletMovementBasicModifier">();
	}
	static class UX6BulletMovementBasicModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletMovementBasicModifier>();
	}
};
static_assert(alignof(UX6BulletMovementBasicModifier) == 0x000008, "Wrong alignment on UX6BulletMovementBasicModifier");
static_assert(sizeof(UX6BulletMovementBasicModifier) == 0x000058, "Wrong size on UX6BulletMovementBasicModifier");
static_assert(offsetof(UX6BulletMovementBasicModifier, BaseSpeed) == 0x000040, "Member 'UX6BulletMovementBasicModifier::BaseSpeed' has a wrong offset!");
static_assert(offsetof(UX6BulletMovementBasicModifier, SpeedCurve) == 0x000048, "Member 'UX6BulletMovementBasicModifier::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UX6BulletMovementBasicModifier, DebugMoveDraw) == 0x000050, "Member 'UX6BulletMovementBasicModifier::DebugMoveDraw' has a wrong offset!");

// Class X6Game.X6BulletCloseToFloorMovementModifier
// 0x0020 (0x0078 - 0x0058)
class UX6BulletCloseToFloorMovementModifier : public UX6BulletMovementBasicModifier
{
public:
	float                                         Radius;                                            // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallAngle;                                         // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorAngle;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToLevelOffset;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      FloorTraceObjectTypes;                             // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void K2_TickCloseToFloorMove(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletCloseToFloorMovementModifier">();
	}
	static class UX6BulletCloseToFloorMovementModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletCloseToFloorMovementModifier>();
	}
};
static_assert(alignof(UX6BulletCloseToFloorMovementModifier) == 0x000008, "Wrong alignment on UX6BulletCloseToFloorMovementModifier");
static_assert(sizeof(UX6BulletCloseToFloorMovementModifier) == 0x000078, "Wrong size on UX6BulletCloseToFloorMovementModifier");
static_assert(offsetof(UX6BulletCloseToFloorMovementModifier, Radius) == 0x000058, "Member 'UX6BulletCloseToFloorMovementModifier::Radius' has a wrong offset!");
static_assert(offsetof(UX6BulletCloseToFloorMovementModifier, WallAngle) == 0x00005C, "Member 'UX6BulletCloseToFloorMovementModifier::WallAngle' has a wrong offset!");
static_assert(offsetof(UX6BulletCloseToFloorMovementModifier, FloorAngle) == 0x000060, "Member 'UX6BulletCloseToFloorMovementModifier::FloorAngle' has a wrong offset!");
static_assert(offsetof(UX6BulletCloseToFloorMovementModifier, ToLevelOffset) == 0x000064, "Member 'UX6BulletCloseToFloorMovementModifier::ToLevelOffset' has a wrong offset!");
static_assert(offsetof(UX6BulletCloseToFloorMovementModifier, FloorTraceObjectTypes) == 0x000068, "Member 'UX6BulletCloseToFloorMovementModifier::FloorTraceObjectTypes' has a wrong offset!");

// Class X6Game.X6BulletSimpleBasicModifier
// 0x0000 (0x0040 - 0x0040)
class UX6BulletSimpleBasicModifier : public UX6BulletModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletSimpleBasicModifier">();
	}
	static class UX6BulletSimpleBasicModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletSimpleBasicModifier>();
	}
};
static_assert(alignof(UX6BulletSimpleBasicModifier) == 0x000008, "Wrong alignment on UX6BulletSimpleBasicModifier");
static_assert(sizeof(UX6BulletSimpleBasicModifier) == 0x000040, "Wrong size on UX6BulletSimpleBasicModifier");

// Class X6Game.X6BulletShapeTraceModifier
// 0x0090 (0x00D0 - 0x0040)
class UX6BulletShapeTraceModifier : public UX6BulletSimpleBasicModifier
{
public:
	struct FVector                                OffsetLocation;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPenetrate;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TraceObjectTypes;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DebugDraw;                                         // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DebugTraceColor;                                   // 0x0074(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DebugTraceHitColor;                                // 0x0084(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6BulletShapeTraceContext             BulletTraceContext;                                // 0x0098(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ExtraIgnoreActors;                                 // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	bool CanShapeTrace();
	void K2_AddExtraIgnoreActor(class AActor* IgnoreActor);
	void K2_SetDebugInfo(EDrawDebugTrace InDebugDraw, const struct FLinearColor& InDebugTraceColor, const struct FLinearColor& InDebugTraceHitColor);

	struct FVector GetEndLocation() const;
	TArray<class AActor*> GetIgnoreActors() const;
	struct FVector GetStartLocation() const;
	void K2_ProcessHitResults(const struct FVector& StartLocation, const struct FVector& EndLocation, const TArray<struct FHitResult>& HitResults) const;
	void K2_SwapTraceCorrection(const struct FVector& SwapLocation) const;
	bool K2_TraceByObjects(const struct FVector& StartLocation, const struct FVector& EndLocation, const TArray<EObjectTypeQuery>& ObjectTypes, EDrawDebugTrace DrawDebugType, const TArray<class AActor*>& IgnoreActors, const struct FX6BulletShapeTraceContext& InTraceContext, TArray<struct FHitResult>* HitResults) const;
	void SwapTraceCorrection(const struct FVector& SwapLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletShapeTraceModifier">();
	}
	static class UX6BulletShapeTraceModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletShapeTraceModifier>();
	}
};
static_assert(alignof(UX6BulletShapeTraceModifier) == 0x000008, "Wrong alignment on UX6BulletShapeTraceModifier");
static_assert(sizeof(UX6BulletShapeTraceModifier) == 0x0000D0, "Wrong size on UX6BulletShapeTraceModifier");
static_assert(offsetof(UX6BulletShapeTraceModifier, OffsetLocation) == 0x000040, "Member 'UX6BulletShapeTraceModifier::OffsetLocation' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, bPenetrate) == 0x000058, "Member 'UX6BulletShapeTraceModifier::bPenetrate' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, TraceObjectTypes) == 0x000060, "Member 'UX6BulletShapeTraceModifier::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, DebugDraw) == 0x000070, "Member 'UX6BulletShapeTraceModifier::DebugDraw' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, DebugTraceColor) == 0x000074, "Member 'UX6BulletShapeTraceModifier::DebugTraceColor' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, DebugTraceHitColor) == 0x000084, "Member 'UX6BulletShapeTraceModifier::DebugTraceHitColor' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, BulletTraceContext) == 0x000098, "Member 'UX6BulletShapeTraceModifier::BulletTraceContext' has a wrong offset!");
static_assert(offsetof(UX6BulletShapeTraceModifier, ExtraIgnoreActors) == 0x0000C0, "Member 'UX6BulletShapeTraceModifier::ExtraIgnoreActors' has a wrong offset!");

// Class X6Game.X6BulletCollisionModifier
// 0x0008 (0x00D8 - 0x00D0)
class UX6BulletCollisionModifier final : public UX6BulletShapeTraceModifier
{
public:
	EObjectTypeQuery                              TraceType_SkillReceiver;                           // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayEffectiveTime;                                // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool K2_IsCollisionDestroy(class AActor* HitActor, const struct FHitResult& HitResult, bool bTriggerSkillReceiver, const class UAbilitySystemComponent* AbilitySystemComponent) const;
	bool K2_ShouldDestroyByActor(class AActor* HitActor, const struct FHitResult& HitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletCollisionModifier">();
	}
	static class UX6BulletCollisionModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletCollisionModifier>();
	}
};
static_assert(alignof(UX6BulletCollisionModifier) == 0x000008, "Wrong alignment on UX6BulletCollisionModifier");
static_assert(sizeof(UX6BulletCollisionModifier) == 0x0000D8, "Wrong size on UX6BulletCollisionModifier");
static_assert(offsetof(UX6BulletCollisionModifier, TraceType_SkillReceiver) == 0x0000D0, "Member 'UX6BulletCollisionModifier::TraceType_SkillReceiver' has a wrong offset!");
static_assert(offsetof(UX6BulletCollisionModifier, DelayEffectiveTime) == 0x0000D4, "Member 'UX6BulletCollisionModifier::DelayEffectiveTime' has a wrong offset!");

// Class X6Game.X6BulletDataAsset
// 0x0080 (0x00B0 - 0x0030)
class UX6BulletDataAsset final : public UPrimaryDataAsset
{
public:
	int32                                         ID;                                                // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetLocation;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotator;                                     // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayEffectDestroyTime;                            // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TraceEffect;                                       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DestroyEffectByHit;                                // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DestroyEffectByNormalEnd;                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6BulletMovementBasicModifier*         BulletMovementModifier;                            // 0x0090(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepInitRoll;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UX6BulletSimpleBasicModifier*>   BulletModifies;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletDataAsset">();
	}
	static class UX6BulletDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletDataAsset>();
	}
};
static_assert(alignof(UX6BulletDataAsset) == 0x000008, "Wrong alignment on UX6BulletDataAsset");
static_assert(sizeof(UX6BulletDataAsset) == 0x0000B0, "Wrong size on UX6BulletDataAsset");
static_assert(offsetof(UX6BulletDataAsset, ID) == 0x000030, "Member 'UX6BulletDataAsset::ID' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, Socket) == 0x000034, "Member 'UX6BulletDataAsset::Socket' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, OffsetLocation) == 0x000040, "Member 'UX6BulletDataAsset::OffsetLocation' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, OffsetRotator) == 0x000058, "Member 'UX6BulletDataAsset::OffsetRotator' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, Duration) == 0x000070, "Member 'UX6BulletDataAsset::Duration' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, DelayEffectDestroyTime) == 0x000074, "Member 'UX6BulletDataAsset::DelayEffectDestroyTime' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, TraceEffect) == 0x000078, "Member 'UX6BulletDataAsset::TraceEffect' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, DestroyEffectByHit) == 0x000080, "Member 'UX6BulletDataAsset::DestroyEffectByHit' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, DestroyEffectByNormalEnd) == 0x000088, "Member 'UX6BulletDataAsset::DestroyEffectByNormalEnd' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, BulletMovementModifier) == 0x000090, "Member 'UX6BulletDataAsset::BulletMovementModifier' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, bKeepInitRoll) == 0x000098, "Member 'UX6BulletDataAsset::bKeepInitRoll' has a wrong offset!");
static_assert(offsetof(UX6BulletDataAsset, BulletModifies) == 0x0000A0, "Member 'UX6BulletDataAsset::BulletModifies' has a wrong offset!");

// Class X6Game.X6RadialSlider
// 0x08F8 (0x0A80 - 0x0188)
class UX6RadialSlider final : public UWidget
{
public:
	float                                         Value;                                             // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueDelegate;                                     // 0x018C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomDefaultValue;                            // 0x019C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomDefaultValue;                                // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SliderRange;                                       // 0x01A8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<float>                                 ValueTags;                                         // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SliderHandleStartAngle;                            // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderHandleEndAngle;                              // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularOffset;                                     // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6RadialSliderStyle                   WidgetStyle;                                       // 0x0250(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SliderRadius;                                      // 0x09C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SliderBarColor;                                    // 0x09C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SliderProgressColor;                               // 0x09D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SliderHandleColor;                                 // 0x09E4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Locked;                                            // 0x09F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MouseUsesStep;                                     // 0x09F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresControllerLock;                            // 0x09F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F7[0x1];                                      // 0x09F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepSize;                                          // 0x09F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x09FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9FD[0x3];                                      // 0x09FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMouseCaptureBegin;                               // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMouseCaptureEnd;                                 // 0x0A10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnControllerCaptureBegin;                          // 0x0A20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnControllerCaptureEnd;                            // 0x0A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnValueChanged;                                    // 0x0A40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnThumbPressed;                                    // 0x0A50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnThumbHovered;                                    // 0x0A60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A70[0x10];                                     // 0x0A70(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAngularOffset(float InValue);
	void SetCustomDefaultValue(float InValue);
	void SetLocked(bool InValue);
	void SetSliderBarColor(const struct FLinearColor& InValue);
	void SetSliderHandleColor(const struct FLinearColor& InValue);
	void SetSliderHandleEndAngle(float InValue);
	void SetSliderHandleStartAngle(float InValue);
	void SetSliderProgressColor(const struct FLinearColor& InValue);
	void SetSliderRadius(float InValue);
	void SetSliderRange(const struct FRuntimeFloatCurve& InSliderRange);
	void SetStepSize(float InValue);
	void SetValue(float InValue);
	void SetValueTags(const TArray<float>& InValueTags);

	float GetCustomDefaultValue() const;
	float GetNormalizedSliderHandlePosition() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RadialSlider">();
	}
	static class UX6RadialSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6RadialSlider>();
	}
};
static_assert(alignof(UX6RadialSlider) == 0x000010, "Wrong alignment on UX6RadialSlider");
static_assert(sizeof(UX6RadialSlider) == 0x000A80, "Wrong size on UX6RadialSlider");
static_assert(offsetof(UX6RadialSlider, Value) == 0x000188, "Member 'UX6RadialSlider::Value' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, ValueDelegate) == 0x00018C, "Member 'UX6RadialSlider::ValueDelegate' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, bUseCustomDefaultValue) == 0x00019C, "Member 'UX6RadialSlider::bUseCustomDefaultValue' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, CustomDefaultValue) == 0x0001A0, "Member 'UX6RadialSlider::CustomDefaultValue' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderRange) == 0x0001A8, "Member 'UX6RadialSlider::SliderRange' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, ValueTags) == 0x000230, "Member 'UX6RadialSlider::ValueTags' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderHandleStartAngle) == 0x000240, "Member 'UX6RadialSlider::SliderHandleStartAngle' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderHandleEndAngle) == 0x000244, "Member 'UX6RadialSlider::SliderHandleEndAngle' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, AngularOffset) == 0x000248, "Member 'UX6RadialSlider::AngularOffset' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, WidgetStyle) == 0x000250, "Member 'UX6RadialSlider::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderRadius) == 0x0009C0, "Member 'UX6RadialSlider::SliderRadius' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderBarColor) == 0x0009C4, "Member 'UX6RadialSlider::SliderBarColor' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderProgressColor) == 0x0009D4, "Member 'UX6RadialSlider::SliderProgressColor' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, SliderHandleColor) == 0x0009E4, "Member 'UX6RadialSlider::SliderHandleColor' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, Locked) == 0x0009F4, "Member 'UX6RadialSlider::Locked' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, MouseUsesStep) == 0x0009F5, "Member 'UX6RadialSlider::MouseUsesStep' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, RequiresControllerLock) == 0x0009F6, "Member 'UX6RadialSlider::RequiresControllerLock' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, StepSize) == 0x0009F8, "Member 'UX6RadialSlider::StepSize' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, IsFocusable) == 0x0009FC, "Member 'UX6RadialSlider::IsFocusable' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnMouseCaptureBegin) == 0x000A00, "Member 'UX6RadialSlider::OnMouseCaptureBegin' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnMouseCaptureEnd) == 0x000A10, "Member 'UX6RadialSlider::OnMouseCaptureEnd' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnControllerCaptureBegin) == 0x000A20, "Member 'UX6RadialSlider::OnControllerCaptureBegin' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnControllerCaptureEnd) == 0x000A30, "Member 'UX6RadialSlider::OnControllerCaptureEnd' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnValueChanged) == 0x000A40, "Member 'UX6RadialSlider::OnValueChanged' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnThumbPressed) == 0x000A50, "Member 'UX6RadialSlider::OnThumbPressed' has a wrong offset!");
static_assert(offsetof(UX6RadialSlider, OnThumbHovered) == 0x000A60, "Member 'UX6RadialSlider::OnThumbHovered' has a wrong offset!");

// Class X6Game.X6BulletEffectWindZoneModifier
// 0x0060 (0x00A0 - 0x0040)
class UX6BulletEffectWindZoneModifier final : public UX6BulletSimpleBasicModifier
{
public:
	EObjectTypeQuery                              TraceTypeWater;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceWaterHeight;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         WaterParticle01;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         WaterParticle02;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         WaterParticleEnd;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseColorValue;                                     // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseColor;                                         // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHitWater;                                       // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShapeArc;                                         // 0x0066(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastLocation;                                      // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDrawDebugTrace                               DebugDrawType;                                     // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x1F];                                      // 0x0081(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetCacheCasterActor(class AActor* InCasterActor);
	void K2_StopWaterParticle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletEffectWindZoneModifier">();
	}
	static class UX6BulletEffectWindZoneModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletEffectWindZoneModifier>();
	}
};
static_assert(alignof(UX6BulletEffectWindZoneModifier) == 0x000008, "Wrong alignment on UX6BulletEffectWindZoneModifier");
static_assert(sizeof(UX6BulletEffectWindZoneModifier) == 0x0000A0, "Wrong size on UX6BulletEffectWindZoneModifier");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, TraceTypeWater) == 0x000040, "Member 'UX6BulletEffectWindZoneModifier::TraceTypeWater' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, TraceWaterHeight) == 0x000044, "Member 'UX6BulletEffectWindZoneModifier::TraceWaterHeight' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, WaterParticle01) == 0x000048, "Member 'UX6BulletEffectWindZoneModifier::WaterParticle01' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, WaterParticle02) == 0x000050, "Member 'UX6BulletEffectWindZoneModifier::WaterParticle02' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, WaterParticleEnd) == 0x000058, "Member 'UX6BulletEffectWindZoneModifier::WaterParticleEnd' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, UseColorValue) == 0x000060, "Member 'UX6BulletEffectWindZoneModifier::UseColorValue' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, bUseColor) == 0x000064, "Member 'UX6BulletEffectWindZoneModifier::bUseColor' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, bIsHitWater) == 0x000065, "Member 'UX6BulletEffectWindZoneModifier::bIsHitWater' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, bShapeArc) == 0x000066, "Member 'UX6BulletEffectWindZoneModifier::bShapeArc' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, LastLocation) == 0x000068, "Member 'UX6BulletEffectWindZoneModifier::LastLocation' has a wrong offset!");
static_assert(offsetof(UX6BulletEffectWindZoneModifier, DebugDrawType) == 0x000080, "Member 'UX6BulletEffectWindZoneModifier::DebugDrawType' has a wrong offset!");

// Class X6Game.X6BulletFilterTargetingPresetModifier
// 0x0060 (0x00A0 - 0x0040)
class UX6BulletFilterTargetingPresetModifier final : public UX6BulletSimpleBasicModifier
{
public:
	bool                                          bLoopTargetingPreset;                              // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetingSourceContext                TargetingSourceContext;                            // 0x0048(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckObstacle;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetingPreset*                       TargetingPreset;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void K2_ExecuteTargetingRequest();
	void K2_ProcessHitResults(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletFilterTargetingPresetModifier">();
	}
	static class UX6BulletFilterTargetingPresetModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletFilterTargetingPresetModifier>();
	}
};
static_assert(alignof(UX6BulletFilterTargetingPresetModifier) == 0x000008, "Wrong alignment on UX6BulletFilterTargetingPresetModifier");
static_assert(sizeof(UX6BulletFilterTargetingPresetModifier) == 0x0000A0, "Wrong size on UX6BulletFilterTargetingPresetModifier");
static_assert(offsetof(UX6BulletFilterTargetingPresetModifier, bLoopTargetingPreset) == 0x000040, "Member 'UX6BulletFilterTargetingPresetModifier::bLoopTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6BulletFilterTargetingPresetModifier, TargetingSourceContext) == 0x000048, "Member 'UX6BulletFilterTargetingPresetModifier::TargetingSourceContext' has a wrong offset!");
static_assert(offsetof(UX6BulletFilterTargetingPresetModifier, bCheckObstacle) == 0x000090, "Member 'UX6BulletFilterTargetingPresetModifier::bCheckObstacle' has a wrong offset!");
static_assert(offsetof(UX6BulletFilterTargetingPresetModifier, TargetingPreset) == 0x000098, "Member 'UX6BulletFilterTargetingPresetModifier::TargetingPreset' has a wrong offset!");

// Class X6Game.X6TargetingSortTask_Base
// 0x0010 (0x0038 - 0x0028)
class UX6TargetingSortTask_Base : public UTargetingTask
{
public:
	uint8                                         bAscending : 1;                                    // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x002C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefScore;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingSortTask_Base">();
	}
	static class UX6TargetingSortTask_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingSortTask_Base>();
	}
};
static_assert(alignof(UX6TargetingSortTask_Base) == 0x000008, "Wrong alignment on UX6TargetingSortTask_Base");
static_assert(sizeof(UX6TargetingSortTask_Base) == 0x000038, "Wrong size on UX6TargetingSortTask_Base");
static_assert(offsetof(UX6TargetingSortTask_Base, Weight) == 0x00002C, "Member 'UX6TargetingSortTask_Base::Weight' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_Base, RefScore) == 0x000030, "Member 'UX6TargetingSortTask_Base::RefScore' has a wrong offset!");

// Class X6Game.X6SimpleTargetingSortTask
// 0x0000 (0x0038 - 0x0038)
class UX6SimpleTargetingSortTask final : public UX6TargetingSortTask_Base
{
public:
	float BP_GetScoreForTarget(const struct FTargetingRequestHandle& TargetingHandle, const struct FTargetingDefaultResultData& TargetData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SimpleTargetingSortTask">();
	}
	static class UX6SimpleTargetingSortTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SimpleTargetingSortTask>();
	}
};
static_assert(alignof(UX6SimpleTargetingSortTask) == 0x000008, "Wrong alignment on UX6SimpleTargetingSortTask");
static_assert(sizeof(UX6SimpleTargetingSortTask) == 0x000038, "Wrong size on UX6SimpleTargetingSortTask");

// Class X6Game.X6BulletFloorAndTargetOptionMovementModifier
// 0x0008 (0x0080 - 0x0078)
class UX6BulletFloorAndTargetOptionMovementModifier final : public UX6BulletCloseToFloorMovementModifier
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletFloorAndTargetOptionMovementModifier">();
	}
	static class UX6BulletFloorAndTargetOptionMovementModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletFloorAndTargetOptionMovementModifier>();
	}
};
static_assert(alignof(UX6BulletFloorAndTargetOptionMovementModifier) == 0x000008, "Wrong alignment on UX6BulletFloorAndTargetOptionMovementModifier");
static_assert(sizeof(UX6BulletFloorAndTargetOptionMovementModifier) == 0x000080, "Wrong size on UX6BulletFloorAndTargetOptionMovementModifier");

// Class X6Game.X6BulletFollowTargetMovementModifier
// 0x0060 (0x00D8 - 0x0078)
class UX6BulletFollowTargetMovementModifier final : public UX6BulletCloseToFloorMovementModifier
{
public:
	float                                         RemainFollowTime;                                  // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AccumulateCanRotator;                              // 0x0080(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasTarget;                                        // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultStepSecond;                                 // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FollowRefreshInterval;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FollowTargetRotator;                               // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FollowCanRotator;                                  // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletFollowTargetMovementModifier">();
	}
	static class UX6BulletFollowTargetMovementModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletFollowTargetMovementModifier>();
	}
};
static_assert(alignof(UX6BulletFollowTargetMovementModifier) == 0x000008, "Wrong alignment on UX6BulletFollowTargetMovementModifier");
static_assert(sizeof(UX6BulletFollowTargetMovementModifier) == 0x0000D8, "Wrong size on UX6BulletFollowTargetMovementModifier");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, RemainFollowTime) == 0x000078, "Member 'UX6BulletFollowTargetMovementModifier::RemainFollowTime' has a wrong offset!");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, AccumulateCanRotator) == 0x000080, "Member 'UX6BulletFollowTargetMovementModifier::AccumulateCanRotator' has a wrong offset!");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, bHasTarget) == 0x000098, "Member 'UX6BulletFollowTargetMovementModifier::bHasTarget' has a wrong offset!");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, DefaultStepSecond) == 0x00009C, "Member 'UX6BulletFollowTargetMovementModifier::DefaultStepSecond' has a wrong offset!");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, FollowRefreshInterval) == 0x0000A0, "Member 'UX6BulletFollowTargetMovementModifier::FollowRefreshInterval' has a wrong offset!");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, FollowTargetRotator) == 0x0000A8, "Member 'UX6BulletFollowTargetMovementModifier::FollowTargetRotator' has a wrong offset!");
static_assert(offsetof(UX6BulletFollowTargetMovementModifier, FollowCanRotator) == 0x0000C0, "Member 'UX6BulletFollowTargetMovementModifier::FollowCanRotator' has a wrong offset!");

// Class X6Game.X6RMInAirComponent
// 0x00E8 (0x01C8 - 0x00E0)
class UX6RMInAirComponent final : public UX6BasicRegularMovementComponent
{
public:
	struct FX6RMInAirComponentPostPhysicsTickFunction PostPhysicsTickFunction;                       // 0x00E0(0x0038)(NativeAccessSpecifierPublic)
	TSubclassOf<class URMBaseLogicProcessor>      RMBaseLogicProcessorClass;                         // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMConfigContext_InAir>     RMConfigContextClass;                              // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMStateInstructionContext> StateInstructionContextClass;                      // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMPTickRecord_InAir>       RMProxyTickRecordClass;                            // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMOutputContext_InAir>     RMOutputContextClass;                              // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMBehaviorTreeProxyInterface> RMBehaviorTreeProxyClass;                       // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URegularMovementDebugContext> RMDebugContextClass;                             // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMInputActionProcessor_InAir> InputActionProcessorClass;                      // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMPTickRecord_InAir*                   CurRMProxyTickRecord;                              // 0x0158(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMBaseLogicProcessor*                  CurRMBaseLogicProcessor;                           // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMBehaviorTreeProxyInterface*          CurRMProxy_InAir;                                  // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMInputActionProcessor_InAir*          InputActionProcessor;                              // 0x0170(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERegularFloatingJumpStage                     ReplicatedFloatingJumpStage;                       // 0x0178(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FX6RMInAirReplicatedMovementData       ReplicatedMovementData;                            // 0x0180(0x0020)(NoDestructor, NativeAccessSpecifierPrivate)
	ERegularJumpMode                              NP_ReplicatedJumpMode;                             // 0x01A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    NP_ReplicatedInputMovingDirection;                 // 0x01A8(0x0018)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NP_ReplicatedTurnAroundAngleToInt;                 // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_PostUpdateRegularMovementBehavior(float DeltaSeconds);
	void Blueprint_PreUpdateRegularMovementBehavior(float DeltaSeconds);
	void DeinitRegularMovementBehaviorProxy();
	class URMBaseLogicProcessor* GetCurRMBaseLogicProcessor();
	void InitRegularMovementBehaviorProxy();
	void InitRMBaseLogicProcessor(class URMBaseLogicProcessor* RMBaseLogicProcessor);
	bool IsValidReplicatedMovingDirection();
	void MulticastRPC_ChangeJumpStage(ERegularFloatingJumpStage NewStage, bool bForceUpdate);
	void MulticastRPC_ForceUpdateReplicatedMovementData();
	void OnRep_FloatingJumpStage();
	void OnRep_MovementData_InputMovingDirection();
	void OnRep_MovementData_ReplicatedJumpMode();
	void OnRep_MovementData_TurnAroundAngle();
	void ReceivePostPhysicsTick(float DeltaTime);
	void ResetInputActionProcessor(TSubclassOf<class URMInputActionProcessor_InAir> inInputActionProcessorClass);
	void SetPostPhysicsTickFunctionEnable(bool bEnable);
	void UpdateDynamicMovementSettings(bool bForceUpdate);
	void UpdateReplicatedMovementData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RMInAirComponent">();
	}
	static class UX6RMInAirComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6RMInAirComponent>();
	}
};
static_assert(alignof(UX6RMInAirComponent) == 0x000008, "Wrong alignment on UX6RMInAirComponent");
static_assert(sizeof(UX6RMInAirComponent) == 0x0001C8, "Wrong size on UX6RMInAirComponent");
static_assert(offsetof(UX6RMInAirComponent, PostPhysicsTickFunction) == 0x0000E0, "Member 'UX6RMInAirComponent::PostPhysicsTickFunction' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, RMBaseLogicProcessorClass) == 0x000118, "Member 'UX6RMInAirComponent::RMBaseLogicProcessorClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, RMConfigContextClass) == 0x000120, "Member 'UX6RMInAirComponent::RMConfigContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, StateInstructionContextClass) == 0x000128, "Member 'UX6RMInAirComponent::StateInstructionContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, RMProxyTickRecordClass) == 0x000130, "Member 'UX6RMInAirComponent::RMProxyTickRecordClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, RMOutputContextClass) == 0x000138, "Member 'UX6RMInAirComponent::RMOutputContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, RMBehaviorTreeProxyClass) == 0x000140, "Member 'UX6RMInAirComponent::RMBehaviorTreeProxyClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, RMDebugContextClass) == 0x000148, "Member 'UX6RMInAirComponent::RMDebugContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, InputActionProcessorClass) == 0x000150, "Member 'UX6RMInAirComponent::InputActionProcessorClass' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, CurRMProxyTickRecord) == 0x000158, "Member 'UX6RMInAirComponent::CurRMProxyTickRecord' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, CurRMBaseLogicProcessor) == 0x000160, "Member 'UX6RMInAirComponent::CurRMBaseLogicProcessor' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, CurRMProxy_InAir) == 0x000168, "Member 'UX6RMInAirComponent::CurRMProxy_InAir' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, InputActionProcessor) == 0x000170, "Member 'UX6RMInAirComponent::InputActionProcessor' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, ReplicatedFloatingJumpStage) == 0x000178, "Member 'UX6RMInAirComponent::ReplicatedFloatingJumpStage' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, ReplicatedMovementData) == 0x000180, "Member 'UX6RMInAirComponent::ReplicatedMovementData' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, NP_ReplicatedJumpMode) == 0x0001A0, "Member 'UX6RMInAirComponent::NP_ReplicatedJumpMode' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, NP_ReplicatedInputMovingDirection) == 0x0001A8, "Member 'UX6RMInAirComponent::NP_ReplicatedInputMovingDirection' has a wrong offset!");
static_assert(offsetof(UX6RMInAirComponent, NP_ReplicatedTurnAroundAngleToInt) == 0x0001C0, "Member 'UX6RMInAirComponent::NP_ReplicatedTurnAroundAngleToInt' has a wrong offset!");

// Class X6Game.X6BulletHitDamageModifier
// 0x0008 (0x00D8 - 0x00D0)
class UX6BulletHitDamageModifier final : public UX6BulletShapeTraceModifier
{
public:
	float                                         HitDestroyExtraDistance;                           // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsHitDestroyExtraTrace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletHitDamageModifier">();
	}
	static class UX6BulletHitDamageModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletHitDamageModifier>();
	}
};
static_assert(alignof(UX6BulletHitDamageModifier) == 0x000008, "Wrong alignment on UX6BulletHitDamageModifier");
static_assert(sizeof(UX6BulletHitDamageModifier) == 0x0000D8, "Wrong size on UX6BulletHitDamageModifier");
static_assert(offsetof(UX6BulletHitDamageModifier, HitDestroyExtraDistance) == 0x0000D0, "Member 'UX6BulletHitDamageModifier::HitDestroyExtraDistance' has a wrong offset!");

// Class X6Game.X6BulletLineMovementModifier
// 0x0000 (0x0058 - 0x0058)
class UX6BulletLineMovementModifier final : public UX6BulletMovementBasicModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletLineMovementModifier">();
	}
	static class UX6BulletLineMovementModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletLineMovementModifier>();
	}
};
static_assert(alignof(UX6BulletLineMovementModifier) == 0x000008, "Wrong alignment on UX6BulletLineMovementModifier");
static_assert(sizeof(UX6BulletLineMovementModifier) == 0x000058, "Wrong size on UX6BulletLineMovementModifier");

// Class X6Game.X6PushBoxMovementComponent
// 0x02D8 (0x0460 - 0x0188)
class alignas(0x10) UX6PushBoxMovementComponent final : public UPawnMovementComponent
{
public:
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0188(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bPositionCorrected : 1;                            // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoxDropDownTrackResult>        CacheCheckDropDownTrackResults;                    // 0x01A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBoxDropDownTrackResult                CacheCenterResult;                                 // 0x01B0(0x0108)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               LineTraceCheckVisibleChannel;                      // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    MovementBase;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x168];                                    // 0x02C8(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningBoost;                                      // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxExtentZ;                                        // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxMaxStepHeight;                                  // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorCheckMinHeight;                               // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorCheckMaxHeight;                               // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoxPushPower;                                      // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovedByPhysics;                                   // 0x0458(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropDown;                                         // 0x0459(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveBlock;                                        // 0x045A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45B[0x5];                                      // 0x045B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PushBoxMovementComponent">();
	}
	static class UX6PushBoxMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PushBoxMovementComponent>();
	}
};
static_assert(alignof(UX6PushBoxMovementComponent) == 0x000010, "Wrong alignment on UX6PushBoxMovementComponent");
static_assert(sizeof(UX6PushBoxMovementComponent) == 0x000460, "Wrong size on UX6PushBoxMovementComponent");
static_assert(offsetof(UX6PushBoxMovementComponent, IgnoreActors) == 0x000188, "Member 'UX6PushBoxMovementComponent::IgnoreActors' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, CacheCheckDropDownTrackResults) == 0x0001A0, "Member 'UX6PushBoxMovementComponent::CacheCheckDropDownTrackResults' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, CacheCenterResult) == 0x0001B0, "Member 'UX6PushBoxMovementComponent::CacheCenterResult' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, LineTraceCheckVisibleChannel) == 0x0002B8, "Member 'UX6PushBoxMovementComponent::LineTraceCheckVisibleChannel' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, MovementBase) == 0x0002C0, "Member 'UX6PushBoxMovementComponent::MovementBase' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, MaxSpeed) == 0x000430, "Member 'UX6PushBoxMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, Acceleration) == 0x000434, "Member 'UX6PushBoxMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, Deceleration) == 0x000438, "Member 'UX6PushBoxMovementComponent::Deceleration' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, TurningBoost) == 0x00043C, "Member 'UX6PushBoxMovementComponent::TurningBoost' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, BoxExtentZ) == 0x000440, "Member 'UX6PushBoxMovementComponent::BoxExtentZ' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, RotateSpeed) == 0x000444, "Member 'UX6PushBoxMovementComponent::RotateSpeed' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, BoxMaxStepHeight) == 0x000448, "Member 'UX6PushBoxMovementComponent::BoxMaxStepHeight' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, FloorCheckMinHeight) == 0x00044C, "Member 'UX6PushBoxMovementComponent::FloorCheckMinHeight' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, FloorCheckMaxHeight) == 0x000450, "Member 'UX6PushBoxMovementComponent::FloorCheckMaxHeight' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, BoxPushPower) == 0x000454, "Member 'UX6PushBoxMovementComponent::BoxPushPower' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, bMovedByPhysics) == 0x000458, "Member 'UX6PushBoxMovementComponent::bMovedByPhysics' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, bDropDown) == 0x000459, "Member 'UX6PushBoxMovementComponent::bDropDown' has a wrong offset!");
static_assert(offsetof(UX6PushBoxMovementComponent, bMoveBlock) == 0x00045A, "Member 'UX6PushBoxMovementComponent::bMoveBlock' has a wrong offset!");

// Class X6Game.X6BulletWindComponent
// 0x0060 (0x0108 - 0x00A8)
class UX6BulletWindComponent final : public UActorComponent
{
public:
	EObjectTypeQuery                              TraceTypeWater;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceWaterHeight;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         WaterParticle01;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         WaterParticle02;                                   // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         WaterParticleEnd;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseColorValue;                                     // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseColor;                                         // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHitWater;                                       // 0x00CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShapeArc;                                         // 0x00CE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastLocation;                                      // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDrawDebugTrace                               DebugDrawType;                                     // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x1F];                                      // 0x00E9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCacheCasterActor(class AActor* InCasterActor);
	void StopWaterParticle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BulletWindComponent">();
	}
	static class UX6BulletWindComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BulletWindComponent>();
	}
};
static_assert(alignof(UX6BulletWindComponent) == 0x000008, "Wrong alignment on UX6BulletWindComponent");
static_assert(sizeof(UX6BulletWindComponent) == 0x000108, "Wrong size on UX6BulletWindComponent");
static_assert(offsetof(UX6BulletWindComponent, TraceTypeWater) == 0x0000A8, "Member 'UX6BulletWindComponent::TraceTypeWater' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, TraceWaterHeight) == 0x0000AC, "Member 'UX6BulletWindComponent::TraceWaterHeight' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, WaterParticle01) == 0x0000B0, "Member 'UX6BulletWindComponent::WaterParticle01' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, WaterParticle02) == 0x0000B8, "Member 'UX6BulletWindComponent::WaterParticle02' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, WaterParticleEnd) == 0x0000C0, "Member 'UX6BulletWindComponent::WaterParticleEnd' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, UseColorValue) == 0x0000C8, "Member 'UX6BulletWindComponent::UseColorValue' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, bUseColor) == 0x0000CC, "Member 'UX6BulletWindComponent::bUseColor' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, bIsHitWater) == 0x0000CD, "Member 'UX6BulletWindComponent::bIsHitWater' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, bShapeArc) == 0x0000CE, "Member 'UX6BulletWindComponent::bShapeArc' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, LastLocation) == 0x0000D0, "Member 'UX6BulletWindComponent::LastLocation' has a wrong offset!");
static_assert(offsetof(UX6BulletWindComponent, DebugDrawType) == 0x0000E8, "Member 'UX6BulletWindComponent::DebugDrawType' has a wrong offset!");

// Class X6Game.X6BuoyancyEffectComponent
// 0x0230 (0x02D8 - 0x00A8)
class UX6BuoyancyEffectComponent final : public UActorComponent
{
public:
	bool                                          CanSimulateFlowOnWater;                            // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleFlowSpeed;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateFlowSpeedTime;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSimulateBuoyancyInWater;                        // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialConfigDensity;                              // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentActorDensity;                               // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatingOnWaterHeightPercent;                      // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseProgramEquationToEnterWater;                    // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResistanceCoefficient;                             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMaxBuoyancyAngle;                               // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngularRotationPeriod;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMaxBuoyancyAngle;                             // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAngularRotationPeriod;                        // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReferenceDisturbanceRotator;                       // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CanDisturbanceAngle;                               // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAutoCheckedByWater;                           // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x1DE];                                     // 0x00FA(0x01DE)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveUpdateActorLocation(bool bActive);
	void BPDoEnterWaterEffect();
	void DoProgramEnterWaterEffect();
	EActorBuoyancyState GetActorBuoyancyState();
	float GetActorCurrentDensity();
	bool IsActorFloatingOnWaterSurface();
	void OnActorBeginEnterWater(float WaterDensity, float WaterSurfaceHeight, const struct FVector& CurrentVelocity);
	void OnActorLeftWater();
	void OnUpdateActorLocationFinished();
	void OnWaterDensityUdpated(float CurrentDensity);
	void OnWaterSurfaceHightUdpated(float currentHgithInWorldCoordinate);
	void OnWaterUpdateIceState(bool bEnterOrExitIce);
	void SetActorCanSimulateBuoyancy(bool CanSimulate);
	void SetupWaterParameter(class AActor* WaterActor, ESimulateWaterFlowType WaterFlowType, class USplineComponent* SimulateFlowSpline, TArray<struct FSimulateWaterFlowKeyPoint>* TrackKeyPoints);
	void UpdateActorDensity(float NewDensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6BuoyancyEffectComponent">();
	}
	static class UX6BuoyancyEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6BuoyancyEffectComponent>();
	}
};
static_assert(alignof(UX6BuoyancyEffectComponent) == 0x000008, "Wrong alignment on UX6BuoyancyEffectComponent");
static_assert(sizeof(UX6BuoyancyEffectComponent) == 0x0002D8, "Wrong size on UX6BuoyancyEffectComponent");
static_assert(offsetof(UX6BuoyancyEffectComponent, CanSimulateFlowOnWater) == 0x0000A8, "Member 'UX6BuoyancyEffectComponent::CanSimulateFlowOnWater' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, ScaleFlowSpeed) == 0x0000AC, "Member 'UX6BuoyancyEffectComponent::ScaleFlowSpeed' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, UpdateFlowSpeedTime) == 0x0000B4, "Member 'UX6BuoyancyEffectComponent::UpdateFlowSpeedTime' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, CanSimulateBuoyancyInWater) == 0x0000B8, "Member 'UX6BuoyancyEffectComponent::CanSimulateBuoyancyInWater' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, InitialConfigDensity) == 0x0000BC, "Member 'UX6BuoyancyEffectComponent::InitialConfigDensity' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, CurrentActorDensity) == 0x0000C0, "Member 'UX6BuoyancyEffectComponent::CurrentActorDensity' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, FloatingOnWaterHeightPercent) == 0x0000C4, "Member 'UX6BuoyancyEffectComponent::FloatingOnWaterHeightPercent' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, UseProgramEquationToEnterWater) == 0x0000C8, "Member 'UX6BuoyancyEffectComponent::UseProgramEquationToEnterWater' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, ResistanceCoefficient) == 0x0000CC, "Member 'UX6BuoyancyEffectComponent::ResistanceCoefficient' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, YawMaxBuoyancyAngle) == 0x0000D0, "Member 'UX6BuoyancyEffectComponent::YawMaxBuoyancyAngle' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, YawAngularRotationPeriod) == 0x0000D4, "Member 'UX6BuoyancyEffectComponent::YawAngularRotationPeriod' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, PitchMaxBuoyancyAngle) == 0x0000D8, "Member 'UX6BuoyancyEffectComponent::PitchMaxBuoyancyAngle' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, PitchAngularRotationPeriod) == 0x0000DC, "Member 'UX6BuoyancyEffectComponent::PitchAngularRotationPeriod' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, ReferenceDisturbanceRotator) == 0x0000E0, "Member 'UX6BuoyancyEffectComponent::ReferenceDisturbanceRotator' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, CanDisturbanceAngle) == 0x0000F8, "Member 'UX6BuoyancyEffectComponent::CanDisturbanceAngle' has a wrong offset!");
static_assert(offsetof(UX6BuoyancyEffectComponent, CanBeAutoCheckedByWater) == 0x0000F9, "Member 'UX6BuoyancyEffectComponent::CanBeAutoCheckedByWater' has a wrong offset!");

// Class X6Game.X6SequencerBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6SequencerBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddBindingWithNamesAndActors(class ALevelSequenceActor* InLSActor, TMap<class FString, class AActor*>* InActorsAndNames);
	static void CinematicActorLookAtActor(ELookAtEventType InEventType, class AActor* InPlayerActor, class AActor* InTargetActor, const struct FLookAtRequestParams& Params_0);
	static void CinematicActorLookAtLocation(ELookAtEventType InEventType, class AActor* InPlayerActor, const struct FVector& InTargetLocation, const struct FLookAtRequestParams& Params_0);
	static void GetAllSections(const class UMovieSceneSequence* MovieSceneSequence, TArray<class UMovieSceneSection*>* OutSections);
	static void GetAllTracks(const class UMovieSceneSequence* MovieSceneSequence, TArray<class UMovieSceneTrack*>* OutTracks);
	static void GetCastNamesInLevelSequenceByTag(const class ALevelSequenceActor* InLSActor, class FName InTag, TArray<class FString>* OutNames);
	static TArray<struct FX6TrackContent> GetMasterTrackContents(const class ULevelSequence* LevelSequence, TSubclassOf<class UMovieSceneTrack> TrackClass);
	static bool HasTrack(const class ALevelSequenceActor* LevelSequenceActor, class AActor* Actor, TSubclassOf<class UMovieSceneTrack> TrackClass);
	static int32 PreLoadLevelSequence(class ULevelSequence* LevelSequence);
	static void RemoveCinematicActorLookAt(ELookAtEventType InEventType, class AActor* InPlayerActor, class AActor* LookAtTargetActor);
	static void SetPreAnimatedPreviewCameraRotation(const struct FRotator& InRotation);
	static void SetSectionIsActiveByNetPolicy(class UMovieSceneSequence* MovieSceneSequence, EMovieSceneNetPolicy MovieSceneNetPolicy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SequencerBlueprintLibrary">();
	}
	static class UX6SequencerBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SequencerBlueprintLibrary>();
	}
};
static_assert(alignof(UX6SequencerBlueprintLibrary) == 0x000008, "Wrong alignment on UX6SequencerBlueprintLibrary");
static_assert(sizeof(UX6SequencerBlueprintLibrary) == 0x000028, "Wrong size on UX6SequencerBlueprintLibrary");

// Class X6Game.X6CameraBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6CameraBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddActorCustomDissolveSocket(class AActor* InActor, class FName InSocketName, bool bSpecifyDissolveCondition, const struct FDissolveCondition& InDissolveCondition);
	static int32 ApplyCameraModifierByKey(const class UObject* WorldContextObject, const class FString& ConfigKey);
	static void BlendBackToFollow(const class UObject* WorldContextObject, const struct FViewTargetTransitionParams& CameraBlendParams);
	static void BlendBackToViewTarget(const class UObject* WorldContextObject, const struct FViewTargetTransitionParams& TransitionParams);
	static class UCameraComponent* CameraComponentFromActor(const class AActor* InActor);
	static struct FVOscillator CastVOscillatorToOffsetZero(const struct FVOscillator& InVOscillator);
	static void ChangeCameraState(const class UObject* WorldContextObject, float LerpDataSpeed, const struct FVector& SocketOffset, const struct FVector& TargetOffset, float Armlength, const struct FRotator& Rotation);
	static bool CheckActorIsInScreen(class AActor* TargetActor);
	static bool CheckAndMoveCurrentCameraToLocation(class UObject* CurrentWorld, float SettingPitch, float SettingYaw, float SettingArmLength, float AngleTolerance, float ArmLengthTolerance, float InterpSpeed);
	static bool CheckBoundingBoxAndCenterIsInScreen(class UObject* WorldContextObject, const struct FVector& BoundingBoxCenter, const struct FVector& BoundingBoxExtend);
	static bool CheckBoundingBoxIsInScreen(class UObject* WorldContextObject, const struct FVector& BoundingBoxCenter, const struct FVector& BoundingBoxExtend);
	static bool CheckCameraPossessedByLevelSequence(class UObject* WorldContextObject);
	static bool DoesActorImplementCameraMode(class AActor* TargetActor);
	static bool FindMostOpenSpaceRotation(const class UObject* WorldContextObject, const struct FTransform& RelativeTrans, struct FRotator* OutDeltaRot);
	static class UCameraModifier* FindOrAddModifierByClass(const class UObject* WorldContextObject, const TSubclassOf<class UCameraModifier> ModifierClass);
	static void ForceUpdateCamera(class UObject* TargetObject);
	static struct FVector2D GetActorScreenLocation(class AActor* TargetActor, class APlayerController* Controller);
	static class UAdvancedCamera* GetAdvancedCameraComponent(const class UObject* WorldContextObject);
	static struct FVector2D GetGameScreenSize(class UObject* WorldContextObject);
	static float GetRotateTimeWithAngleSpeed(float AngleSpeed, const struct FRotator& StartRotation, const struct FRotator& EndRotation);
	static class AX6PlayerCameraManager* GetX6PlayerCameraManager(const class UObject* WorldContextObject);
	static bool IsActorLevelSequenceCameraCut(const class AActor* InActor);
	static void PopAndSwitchToLastCameraState(class UObject* WorldContextObject, bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	static void PushAndSwitchToCameraState(class UObject* WorldContextObject, ECameraState NewCameraState, class AActor* NewTarget, bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	static int32 PushCustomRotationRangeConfigForActor(class AActor* InActor, const struct FRotator& OriginRotation, float MinYaw, float MaxYaw, float MinPitch, float MaxPitch, bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	static void RecalculateCameraTransformIgnoreLag(class AActor* ViewTarget);
	static void RemoveActorCustomDissolveSocket(class AActor* InActor, class FName InSocketName);
	static void RemoveCameraConfigForActor(class AActor* InActor, int32 IndexToRemove);
	static void RemoveCameraModifierEffectByHandle(const class UObject* WorldContextObject, int32 Handle);
	static void RemoveCameraState(class UObject* WorldContextObject, const ECameraState CameraStateToRemove, class AActor* TargetToRemove, bool bBlendToTop, bool bOverrideTransitionParams, const struct FViewTargetTransitionParams& TransitionParams);
	static void ResetAdvancedCameraRotation(const class UObject* WorldContextObject);
	static void ResetArmLengthAndRotation(class UObject* CurrentWorld);
	static void ResetFollowCamera(const class UObject* WorldContextObject);
	static void ResetToDefaultRelativeRotation(class AActor* ViewTarget, bool bApplyImmediate);
	static struct FRotator RotatorClamp(const struct FRotator& Rotator);
	static void SetActorCameraDesireRotation(const class AActor* InActor, const struct FRotator& NewDesireRotation, const bool Teleport);
	static void SetActorCameraRotationLookAtTrackActor(const class AActor* InActor, const class AActor* ActorToTrack, const struct FVector& RelativeOffset, const bool bApplyImmediately);
	static void SetActorDissolveByMesh(class AActor* InActor, const bool bDissolveByMesh, int32 Reason);
	static void SetActorDissolveEnable(class AActor* InActor, const bool bEnable, const bool bClearCurrentEffect);
	static void SetActorDissolveEnableByReason(class AActor* InActor, const bool bEnable, int32 Reason, const bool bClearCurrentEffect);
	static void SetCameraDrawDebug(class UObject* WorldContextObject, bool bDebugEnable, float DrawDebugTime);
	static void SetCamerarInputEnable(const class UObject* WorldContextObject, bool bInputEnable);
	static void SetCameraViewPointWithBlend(const class UObject* WorldContextObject, const struct FMinimalViewInfo& ViewInfo, const struct FViewTargetTransitionParams& TransitionParams);
	static void SetCharacterFollowCameraRotation(class AActor* Actor, const struct FRotator& NewDesireRotation, bool Teleport);
	static void SetDesireRotation(const class UObject* WorldContextObject, const struct FRotator& NewDesireRotation, bool Teleport);
	static void SetDissolveEnable(const class UObject* WorldContextObject, bool Dissolve);
	static void SetGlobalDissolveEnable(const class UObject* WorldContextObject, bool Dissolve);
	static void SetPassiveDesiredRotation(const class UObject* WorldContextObject, const struct FRotator& NewDesireRotation, float AngularSpeed, EViewTargetBlendFunction BlendFunction, float BlendExp);
	static void SetViewTargetAngularSpeed(class AActor* NewViewTarget, float AngularSpeed, float BlendExp, EViewTargetBlendFunction BlendFunction);
	static void SetViewTargetInSequence(class UObject* WorldContextObject, class AActor* CameraActor, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing);
	static void SetViewTargetLineSpeed(class AActor* NewViewTarget, float LineSpeed, float BlendExp, EViewTargetBlendFunction BlendFunction);
	static void SetViewTargetTeleport(class AActor* NewTarget);
	static void SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing, class UCurveFloat* InBlendCurve);
	static void SetViewTargetWithParabolaPath(class AActor* Target, const struct FViewTargetCurveTransitionParams& TransitionParams, float FrontViewAngleScope, float MinHeight, float MaxHeight, float SimFrequency, bool HeightTakePrecedence);
	static void StartCustomizeCameraShake(class UObject* WorldContextObject, float Duration, float BlendInTime, float BlendOutTime, const struct FROscillator& ROscillator, const struct FVOscillator& VOscillator, const struct FFOscillator& Oscillator);
	static void SwitchToCameraState(class UObject* WorldContextObject, ECameraState NewCameraState, class AActor* NewTarget);
	static struct FVector2D WorldLocation2Screen(const struct FVector& WorldLocaion, class APlayerController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CameraBlueprintLibrary">();
	}
	static class UX6CameraBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CameraBlueprintLibrary>();
	}
};
static_assert(alignof(UX6CameraBlueprintLibrary) == 0x000008, "Wrong alignment on UX6CameraBlueprintLibrary");
static_assert(sizeof(UX6CameraBlueprintLibrary) == 0x000028, "Wrong size on UX6CameraBlueprintLibrary");

// Class X6Game.X6CameraComponent
// 0x0000 (0x2D10 - 0x2D10)
class UX6CameraComponent final : public UAdvancedCamera
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CameraComponent">();
	}
	static class UX6CameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CameraComponent>();
	}
};
static_assert(alignof(UX6CameraComponent) == 0x000010, "Wrong alignment on UX6CameraComponent");
static_assert(sizeof(UX6CameraComponent) == 0x002D10, "Wrong size on UX6CameraComponent");

// Class X6Game.X6TargetingFilter_AlwaysAiming
// 0x0020 (0x0048 - 0x0028)
class UX6TargetingFilter_AlwaysAiming final : public UTargetingFilterTask_BasicFilterTemplate
{
public:
	struct FGameplayTagContainer                  TargetGameplayTags;                                // 0x0028(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingFilter_AlwaysAiming">();
	}
	static class UX6TargetingFilter_AlwaysAiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingFilter_AlwaysAiming>();
	}
};
static_assert(alignof(UX6TargetingFilter_AlwaysAiming) == 0x000008, "Wrong alignment on UX6TargetingFilter_AlwaysAiming");
static_assert(sizeof(UX6TargetingFilter_AlwaysAiming) == 0x000048, "Wrong size on UX6TargetingFilter_AlwaysAiming");
static_assert(offsetof(UX6TargetingFilter_AlwaysAiming, TargetGameplayTags) == 0x000028, "Member 'UX6TargetingFilter_AlwaysAiming::TargetGameplayTags' has a wrong offset!");

// Class X6Game.X6CameraSpringArmComponent
// 0x0160 (0x0490 - 0x0330)
class UX6CameraSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bUseScreenBorderClamp;                             // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BorderClampArmlengthScale;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BorderClampMaxDistance;                            // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x5C];                                     // 0x0344(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitDesiredBlendInTime;                             // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitDesiredBlendOutTime;                            // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendOutCurve;                                     // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x4];                                      // 0x03B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainTime;                                        // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendExp;                                          // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0xCC];                                     // 0x03C4(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCollisionIgnoreActor(class AActor* InActor);
	void ClearCollisionIgnoreActors();
	void RemoveCollisionIgnoreActor(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CameraSpringArmComponent">();
	}
	static class UX6CameraSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CameraSpringArmComponent>();
	}
};
static_assert(alignof(UX6CameraSpringArmComponent) == 0x000010, "Wrong alignment on UX6CameraSpringArmComponent");
static_assert(sizeof(UX6CameraSpringArmComponent) == 0x000490, "Wrong size on UX6CameraSpringArmComponent");
static_assert(offsetof(UX6CameraSpringArmComponent, bUseScreenBorderClamp) == 0x000330, "Member 'UX6CameraSpringArmComponent::bUseScreenBorderClamp' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, BorderClampArmlengthScale) == 0x000338, "Member 'UX6CameraSpringArmComponent::BorderClampArmlengthScale' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, BorderClampMaxDistance) == 0x000340, "Member 'UX6CameraSpringArmComponent::BorderClampMaxDistance' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, HitDesiredBlendInTime) == 0x0003A0, "Member 'UX6CameraSpringArmComponent::HitDesiredBlendInTime' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, HitDesiredBlendOutTime) == 0x0003A8, "Member 'UX6CameraSpringArmComponent::HitDesiredBlendOutTime' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, BlendOutCurve) == 0x0003B0, "Member 'UX6CameraSpringArmComponent::BlendOutCurve' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, RemainTime) == 0x0003BC, "Member 'UX6CameraSpringArmComponent::RemainTime' has a wrong offset!");
static_assert(offsetof(UX6CameraSpringArmComponent, BlendExp) == 0x0003C0, "Member 'UX6CameraSpringArmComponent::BlendExp' has a wrong offset!");

// Class X6Game.X6CameraVolume
// 0x0000 (0x03E0 - 0x03E0)
class AX6CameraVolume final : public AX6BaseVolume
{
public:
	struct FBoxSphereBounds GetShapeBounds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CameraVolume">();
	}
	static class AX6CameraVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CameraVolume>();
	}
};
static_assert(alignof(AX6CameraVolume) == 0x000008, "Wrong alignment on AX6CameraVolume");
static_assert(sizeof(AX6CameraVolume) == 0x0003E0, "Wrong size on AX6CameraVolume");

// Class X6Game.X6SpawnOnViewSubsystem
// 0x0220 (0x0250 - 0x0030)
class UX6SpawnOnViewSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x220];                                     // 0x0030(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCacheEntity(int64 EntityID, int64 SpawnerID, int64 GroupID, struct FVector* SpawnLocation, double SpawnDistSqr);
	void AddSpawner(class AActor* Actor, int64 SpawnerID, int64 EntityID, class FName Cat);
	void CheckEntitySpawnOnView(TArray<int64>* NeedSpawnEntities);
	void ClearManagedEntityAndSpawners();
	void ForceRemoveCahceEntity(int64 EntityID);
	void GetSpawnSystemStatistics(int64* SpawnerNum, int64* SkippedNum);
	void RemoveSpawner(class AActor* Actor, class FName Cat);
	void ResetSpawnerGroup(int64 GroupID, TArray<int64>* SpawnerIDS);
	void SetSystemParams(int32 OnScreenLimitHiddenFlag, float NearSpawnerDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SpawnOnViewSubsystem">();
	}
	static class UX6SpawnOnViewSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SpawnOnViewSubsystem>();
	}
};
static_assert(alignof(UX6SpawnOnViewSubsystem) == 0x000008, "Wrong alignment on UX6SpawnOnViewSubsystem");
static_assert(sizeof(UX6SpawnOnViewSubsystem) == 0x000250, "Wrong size on UX6SpawnOnViewSubsystem");

// Class X6Game.X6CarrierCharacterBase
// 0x0000 (0x08B0 - 0x08B0)
class AX6CarrierCharacterBase : public AX6CharacterBase
{
public:
	void GetMoveGoalReachTestInternal(const class AActor* MovingActor, const struct FVector& MoveOffset, struct FVector* GoalOffset, float* GoalRadius, float* GoalHalfHeight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CarrierCharacterBase">();
	}
	static class AX6CarrierCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CarrierCharacterBase>();
	}
};
static_assert(alignof(AX6CarrierCharacterBase) == 0x000010, "Wrong alignment on AX6CarrierCharacterBase");
static_assert(sizeof(AX6CarrierCharacterBase) == 0x0008B0, "Wrong size on AX6CarrierCharacterBase");

// Class X6Game.X6RootMotionModifier_SkewWarpWithMirror
// 0x0000 (0x02D0 - 0x02D0)
class UX6RootMotionModifier_SkewWarpWithMirror final : public URootMotionModifier_SkewWarp
{
public:
	static class UX6RootMotionModifier_SkewWarpWithMirror* AddRootMotionModifierSkewWarpWithMirror(class UMotionWarpingComponent* InMotionWarpingComp, const class UAnimSequenceBase* InAnimation, float InStartTime, float InEndTime, class FName InWarpTargetName, EWarpPointAnimProvider InWarpPointAnimProvider, const struct FTransform& InWarpPointAnimTransform, class FName InWarpPointAnimBoneName, bool bInWarpTranslation, bool bInIgnoreZAxis, bool bInWarpRotation, EMotionWarpRotationType InRotationType, EMotionWarpRotationMethod InRotationMethod, float InWarpRotationTimeMultiplier, float InWarpMaxRotationRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RootMotionModifier_SkewWarpWithMirror">();
	}
	static class UX6RootMotionModifier_SkewWarpWithMirror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6RootMotionModifier_SkewWarpWithMirror>();
	}
};
static_assert(alignof(UX6RootMotionModifier_SkewWarpWithMirror) == 0x000010, "Wrong alignment on UX6RootMotionModifier_SkewWarpWithMirror");
static_assert(sizeof(UX6RootMotionModifier_SkewWarpWithMirror) == 0x0002D0, "Wrong size on UX6RootMotionModifier_SkewWarpWithMirror");

// Class X6Game.X6CarrierCharacter
// 0x0000 (0x08B0 - 0x08B0)
class AX6CarrierCharacter final : public AX6CarrierCharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CarrierCharacter">();
	}
	static class AX6CarrierCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CarrierCharacter>();
	}
};
static_assert(alignof(AX6CarrierCharacter) == 0x000010, "Wrong alignment on AX6CarrierCharacter");
static_assert(sizeof(AX6CarrierCharacter) == 0x0008B0, "Wrong size on AX6CarrierCharacter");

// Class X6Game.X6CarrierMovementComponent
// 0x0000 (0x14E0 - 0x14E0)
class UX6CarrierMovementComponent final : public UX6CharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CarrierMovementComponent">();
	}
	static class UX6CarrierMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CarrierMovementComponent>();
	}
};
static_assert(alignof(UX6CarrierMovementComponent) == 0x000010, "Wrong alignment on UX6CarrierMovementComponent");
static_assert(sizeof(UX6CarrierMovementComponent) == 0x0014E0, "Wrong size on UX6CarrierMovementComponent");

// Class X6Game.X6T2NpcActorBase
// 0x0000 (0x0438 - 0x0438)
class AX6T2NpcActorBase final : public AX6Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6T2NpcActorBase">();
	}
	static class AX6T2NpcActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6T2NpcActorBase>();
	}
};
static_assert(alignof(AX6T2NpcActorBase) == 0x000008, "Wrong alignment on AX6T2NpcActorBase");
static_assert(sizeof(AX6T2NpcActorBase) == 0x000438, "Wrong size on AX6T2NpcActorBase");

// Class X6Game.X6CharacterLightBase
// 0x0010 (0x03B8 - 0x03A8)
class AX6CharacterLightBase : public AActor
{
public:
	class USpringArmComponent*                    SpringArmComponent;                                // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULightComponent*                        LightComponent;                                    // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterLightBase">();
	}
	static class AX6CharacterLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CharacterLightBase>();
	}
};
static_assert(alignof(AX6CharacterLightBase) == 0x000008, "Wrong alignment on AX6CharacterLightBase");
static_assert(sizeof(AX6CharacterLightBase) == 0x0003B8, "Wrong size on AX6CharacterLightBase");
static_assert(offsetof(AX6CharacterLightBase, SpringArmComponent) == 0x0003A8, "Member 'AX6CharacterLightBase::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(AX6CharacterLightBase, LightComponent) == 0x0003B0, "Member 'AX6CharacterLightBase::LightComponent' has a wrong offset!");

// Class X6Game.X6CharacterDirectLight
// 0x0000 (0x03B8 - 0x03B8)
class AX6CharacterDirectLight final : public AX6CharacterLightBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterDirectLight">();
	}
	static class AX6CharacterDirectLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CharacterDirectLight>();
	}
};
static_assert(alignof(AX6CharacterDirectLight) == 0x000008, "Wrong alignment on AX6CharacterDirectLight");
static_assert(sizeof(AX6CharacterDirectLight) == 0x0003B8, "Wrong size on AX6CharacterDirectLight");

// Class X6Game.X6UtcPlayerInputComponent
// 0x0000 (0x00A8 - 0x00A8)
class UX6UtcPlayerInputComponent final : public UX6ActorComponent
{
public:
	void HandleTouchEvent(EX6InputTouchEvent X6InputTouchEvent, ETouchIndex FingerIndex, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6UtcPlayerInputComponent">();
	}
	static class UX6UtcPlayerInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6UtcPlayerInputComponent>();
	}
};
static_assert(alignof(UX6UtcPlayerInputComponent) == 0x000008, "Wrong alignment on UX6UtcPlayerInputComponent");
static_assert(sizeof(UX6UtcPlayerInputComponent) == 0x0000A8, "Wrong size on UX6UtcPlayerInputComponent");

// Class X6Game.X6CharacterVisualEffectComponent
// 0x0210 (0x02B8 - 0x00A8)
class UX6CharacterVisualEffectComponent : public UX6ActorComponent
{
public:
	bool                                          bDissolveEnable;                                   // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDissolveAttachedActors;                           // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDissolveByMeshSocket;                             // 0x00AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5D];                                      // 0x00AB(0x005D)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DissolveDistance;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolvePitchMin;                                  // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolvePitchMax;                                  // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMultipleDissolvePitchRange;                 // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDissolvePitchLimit>            DissolvePitchLimitsArray;                          // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMustLowerThanActorCanDissolve;                    // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DissolveByPitchMaxDistance;                        // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolveInterpSpeed;                               // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDissolveValue;                                  // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x58];                                     // 0x0138(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FDissolveCondition>  DefaultSocketDissolveCondition;                    // 0x0190(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0xD8];                                     // 0x01E0(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCustomDissolveSocket(const class FName& InSocketName, const bool bSpecifyDissolveCondition, const struct FDissolveCondition& InDissolveCondition);
	void AppendCustomDissolveSocket(const TMap<class FName, struct FDissolveCondition>& InDissolveSocketMap);
	void ClearCustomDissolveSocket();
	void RemoveCustomDissolveSocket(const class FName& InSocketName);
	void SetDissolveByMesh(const bool bInDissolveByMesh, const int32 Reason);
	void SetDissolveEnable(bool bEnable, const bool bClearCurrentEffect);
	void SetDissolveEnableByReason(bool bEnable, int32 Reason, const bool bClearCurrentEffect);
	void UpdateDissolveEffect(const float& InDissolveValue);
	void UpdateDissolveEffectInTime(float InDissolveValue, float DissolveTime);

	const TSet<int32> GetDissolveByMeshReasons() const;
	const TSet<int32> GetDissolveDisableReasons() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterVisualEffectComponent">();
	}
	static class UX6CharacterVisualEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CharacterVisualEffectComponent>();
	}
};
static_assert(alignof(UX6CharacterVisualEffectComponent) == 0x000008, "Wrong alignment on UX6CharacterVisualEffectComponent");
static_assert(sizeof(UX6CharacterVisualEffectComponent) == 0x0002B8, "Wrong size on UX6CharacterVisualEffectComponent");
static_assert(offsetof(UX6CharacterVisualEffectComponent, bDissolveEnable) == 0x0000A8, "Member 'UX6CharacterVisualEffectComponent::bDissolveEnable' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, bDissolveAttachedActors) == 0x0000A9, "Member 'UX6CharacterVisualEffectComponent::bDissolveAttachedActors' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, bDissolveByMeshSocket) == 0x0000AA, "Member 'UX6CharacterVisualEffectComponent::bDissolveByMeshSocket' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DissolveDistance) == 0x000108, "Member 'UX6CharacterVisualEffectComponent::DissolveDistance' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DissolvePitchMin) == 0x00010C, "Member 'UX6CharacterVisualEffectComponent::DissolvePitchMin' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DissolvePitchMax) == 0x000110, "Member 'UX6CharacterVisualEffectComponent::DissolvePitchMax' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, bEnableMultipleDissolvePitchRange) == 0x000114, "Member 'UX6CharacterVisualEffectComponent::bEnableMultipleDissolvePitchRange' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DissolvePitchLimitsArray) == 0x000118, "Member 'UX6CharacterVisualEffectComponent::DissolvePitchLimitsArray' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, bMustLowerThanActorCanDissolve) == 0x000128, "Member 'UX6CharacterVisualEffectComponent::bMustLowerThanActorCanDissolve' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DissolveByPitchMaxDistance) == 0x00012C, "Member 'UX6CharacterVisualEffectComponent::DissolveByPitchMaxDistance' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DissolveInterpSpeed) == 0x000130, "Member 'UX6CharacterVisualEffectComponent::DissolveInterpSpeed' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, MaxDissolveValue) == 0x000134, "Member 'UX6CharacterVisualEffectComponent::MaxDissolveValue' has a wrong offset!");
static_assert(offsetof(UX6CharacterVisualEffectComponent, DefaultSocketDissolveCondition) == 0x000190, "Member 'UX6CharacterVisualEffectComponent::DefaultSocketDissolveCondition' has a wrong offset!");

// Class X6Game.X6CharacterEffectComponent
// 0x0390 (0x0648 - 0x02B8)
class UX6CharacterEffectComponent final : public UX6CharacterVisualEffectComponent
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              FootstepEffectDataTable;                           // 0x02C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseChooserTable;                                  // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UChooserTable>           FootstepEffectConfig_FloorFX;                      // 0x02F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UChooserTable>           FootstepEffectConfig_FloorFootprint;               // 0x0318(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UChooserTable>           FootstepEffectConfig_WaterFX;                      // 0x0340(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UChooserTable>           FootstepEffectConfig_WaterFootprint;               // 0x0368(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaterConstantEffect;                              // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeepWater;                                      // 0x0391(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, EFootstepAnimationType>     AnimationTypeMap;                                  // 0x0398(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, NativeAccessSpecifierPublic)
	EPhysicalSurface                              DefaultPhysicalSurfaceType;                        // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootstepEffectEnvironmentType                DefaultEnvironmentType;                            // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootstepEffectShoeType                       DefaultShoeType;                                   // 0x03EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EB[0x5];                                      // 0x03EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SocketNameLeftSuffix;                              // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorTraceHeightAdjust;                            // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorTraceLength;                                  // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloorTraceProfileName;                             // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysTraceForSurfaceType;                        // 0x0410(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      LastAnimSequence;                                  // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastFootstepRowName;                               // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastFootstepSocketName;                            // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastFootstepInWater;                              // 0x0430(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              LastFootstepSurfaceType;                           // 0x0431(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_432[0x6];                                      // 0x0432(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          LastFootstepNiagaraSystemRef;                      // 0x0438(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFootstepDecalConfigTemplate> LastFootstepDecalConfigRef;                   // 0x0460(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsLeftFoot, const struct FHitResult& HitResult, const class FName& RowName)> HandlePlayFootstepEffectDelegate; // 0x0488(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FootstepEffectDataTablePtr;                        // 0x0498(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChooserTable*                          FootstepEffectConfigPtr_FloorFX;                   // 0x04A0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChooserTable*                          FootstepEffectConfigPtr_FloorFootprint;            // 0x04A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChooserTable*                          FootstepEffectConfigPtr_WaterFX;                   // 0x04B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChooserTable*                          FootstepEffectConfigPtr_WaterFootprint;            // 0x04B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              CurrentSurfaceType;                                // 0x04C0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFootstepEffectShoeType                       CurrentShoeType;                                   // 0x04C1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFootstepEffectEnvironmentType                CurrentEnvironmentType;                            // 0x04C2(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFootstepAnimationType                        CurrentAnimationType;                              // 0x04C3(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UX6GeneralAnimationDataComponent> OwnerAnimDataComponent;                   // 0x04C4(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentWaterDepth;                                 // 0x04CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DebugString;                                       // 0x04D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         TraceIgnoreActors;                                 // 0x04E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x18];                                     // 0x04F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UNiagaraComponent*>   FootstepNscBySocketName;                           // 0x0508(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, TSoftObjectPtr<class UNiagaraSystem>> PendingTemplateRefByTag;                 // 0x0558(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x9C];                                     // 0x05A8(0x009C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInBush;                                           // 0x0644(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShrubTypeAsByte;                                   // 0x0645(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_646[0x2];                                      // 0x0646(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDisplayDebugValue(const class FString& ValueName, const class FString& ValueString);
	void CreateOwnerDecalComponent();
	void DestroyOwnerDecalComponent(bool bDestroyImmediately);
	void GetFootstepEffectConfigInWater(const class FName& RowName, EPhysicalSurface InSurfaceType, TSoftObjectPtr<class UNiagaraSystem>* OutNiagaraSystemRef, struct FFootprintConfig* OutFootprintConfig, bool* OutConstantEffect);
	void GetFootstepEffectConfigOnGround(const class FName& RowName, EPhysicalSurface InSurfaceType, TSoftObjectPtr<class UNiagaraSystem>* OutNiagaraSystemRef, struct FFootprintConfig* OutFootprintConfig);
	bool GetOwnerFloorSurfaceType(const struct FVector& InLocation, bool bUseAccurateTraceLocation, struct FHitResult* OutHitResult, EPhysicalSurface* OutSurfaceType);
	void OnEnterShrubArea(const int32 InShrubType);
	void OnExitShrubArea();
	void PlayFootstepEffect(class USkeletalMeshComponent* MeshComponent, class FName SocketName, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const struct FVector& Scale, bool bAttached, class FName RowName);
	void ReceiveOwnerBecomeViewTarget();
	void ReceiveOwnerEndViewTarget();
	void SetConfigDeepWaterDepth(float InDepth);
	void SetCurrentEnvironmentType(const EFootstepEffectEnvironmentType InEnvironmentType);
	void SetCurrentShoeType(const EFootstepEffectShoeType InShoeType);
	void SetCurrentSurfaceType(EPhysicalSurface InSurfaceType);
	void SetEnableFootstepDebug(const bool bEnable);
	void UpdateFootstepNiagaraSystemParamOverrideMap(const TMap<class FName, float>& InParamMap);

	const TMap<class FName, float> GetFootstepNiagaraSystemParamOverrideMap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterEffectComponent">();
	}
	static class UX6CharacterEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CharacterEffectComponent>();
	}
};
static_assert(alignof(UX6CharacterEffectComponent) == 0x000008, "Wrong alignment on UX6CharacterEffectComponent");
static_assert(sizeof(UX6CharacterEffectComponent) == 0x000648, "Wrong size on UX6CharacterEffectComponent");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectDataTable) == 0x0002C0, "Member 'UX6CharacterEffectComponent::FootstepEffectDataTable' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, bUseChooserTable) == 0x0002E8, "Member 'UX6CharacterEffectComponent::bUseChooserTable' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfig_FloorFX) == 0x0002F0, "Member 'UX6CharacterEffectComponent::FootstepEffectConfig_FloorFX' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfig_FloorFootprint) == 0x000318, "Member 'UX6CharacterEffectComponent::FootstepEffectConfig_FloorFootprint' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfig_WaterFX) == 0x000340, "Member 'UX6CharacterEffectComponent::FootstepEffectConfig_WaterFX' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfig_WaterFootprint) == 0x000368, "Member 'UX6CharacterEffectComponent::FootstepEffectConfig_WaterFootprint' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, bWaterConstantEffect) == 0x000390, "Member 'UX6CharacterEffectComponent::bWaterConstantEffect' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, bIsDeepWater) == 0x000391, "Member 'UX6CharacterEffectComponent::bIsDeepWater' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, AnimationTypeMap) == 0x000398, "Member 'UX6CharacterEffectComponent::AnimationTypeMap' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, DefaultPhysicalSurfaceType) == 0x0003E8, "Member 'UX6CharacterEffectComponent::DefaultPhysicalSurfaceType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, DefaultEnvironmentType) == 0x0003E9, "Member 'UX6CharacterEffectComponent::DefaultEnvironmentType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, DefaultShoeType) == 0x0003EA, "Member 'UX6CharacterEffectComponent::DefaultShoeType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, SocketNameLeftSuffix) == 0x0003F0, "Member 'UX6CharacterEffectComponent::SocketNameLeftSuffix' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FloorTraceHeightAdjust) == 0x000400, "Member 'UX6CharacterEffectComponent::FloorTraceHeightAdjust' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FloorTraceLength) == 0x000404, "Member 'UX6CharacterEffectComponent::FloorTraceLength' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FloorTraceProfileName) == 0x000408, "Member 'UX6CharacterEffectComponent::FloorTraceProfileName' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, bAlwaysTraceForSurfaceType) == 0x000410, "Member 'UX6CharacterEffectComponent::bAlwaysTraceForSurfaceType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, LastAnimSequence) == 0x000418, "Member 'UX6CharacterEffectComponent::LastAnimSequence' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, LastFootstepRowName) == 0x000420, "Member 'UX6CharacterEffectComponent::LastFootstepRowName' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, LastFootstepSocketName) == 0x000428, "Member 'UX6CharacterEffectComponent::LastFootstepSocketName' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, bLastFootstepInWater) == 0x000430, "Member 'UX6CharacterEffectComponent::bLastFootstepInWater' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, LastFootstepSurfaceType) == 0x000431, "Member 'UX6CharacterEffectComponent::LastFootstepSurfaceType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, LastFootstepNiagaraSystemRef) == 0x000438, "Member 'UX6CharacterEffectComponent::LastFootstepNiagaraSystemRef' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, LastFootstepDecalConfigRef) == 0x000460, "Member 'UX6CharacterEffectComponent::LastFootstepDecalConfigRef' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, HandlePlayFootstepEffectDelegate) == 0x000488, "Member 'UX6CharacterEffectComponent::HandlePlayFootstepEffectDelegate' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectDataTablePtr) == 0x000498, "Member 'UX6CharacterEffectComponent::FootstepEffectDataTablePtr' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfigPtr_FloorFX) == 0x0004A0, "Member 'UX6CharacterEffectComponent::FootstepEffectConfigPtr_FloorFX' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfigPtr_FloorFootprint) == 0x0004A8, "Member 'UX6CharacterEffectComponent::FootstepEffectConfigPtr_FloorFootprint' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfigPtr_WaterFX) == 0x0004B0, "Member 'UX6CharacterEffectComponent::FootstepEffectConfigPtr_WaterFX' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepEffectConfigPtr_WaterFootprint) == 0x0004B8, "Member 'UX6CharacterEffectComponent::FootstepEffectConfigPtr_WaterFootprint' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, CurrentSurfaceType) == 0x0004C0, "Member 'UX6CharacterEffectComponent::CurrentSurfaceType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, CurrentShoeType) == 0x0004C1, "Member 'UX6CharacterEffectComponent::CurrentShoeType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, CurrentEnvironmentType) == 0x0004C2, "Member 'UX6CharacterEffectComponent::CurrentEnvironmentType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, CurrentAnimationType) == 0x0004C3, "Member 'UX6CharacterEffectComponent::CurrentAnimationType' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, OwnerAnimDataComponent) == 0x0004C4, "Member 'UX6CharacterEffectComponent::OwnerAnimDataComponent' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, CurrentWaterDepth) == 0x0004CC, "Member 'UX6CharacterEffectComponent::CurrentWaterDepth' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, DebugString) == 0x0004D0, "Member 'UX6CharacterEffectComponent::DebugString' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, TraceIgnoreActors) == 0x0004E0, "Member 'UX6CharacterEffectComponent::TraceIgnoreActors' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, FootstepNscBySocketName) == 0x000508, "Member 'UX6CharacterEffectComponent::FootstepNscBySocketName' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, PendingTemplateRefByTag) == 0x000558, "Member 'UX6CharacterEffectComponent::PendingTemplateRefByTag' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, bInBush) == 0x000644, "Member 'UX6CharacterEffectComponent::bInBush' has a wrong offset!");
static_assert(offsetof(UX6CharacterEffectComponent, ShrubTypeAsByte) == 0x000645, "Member 'UX6CharacterEffectComponent::ShrubTypeAsByte' has a wrong offset!");

// Class X6Game.X6TargetingFilter_GamePlayTags
// 0x0040 (0x0068 - 0x0028)
class UX6TargetingFilter_GamePlayTags final : public UTargetingFilterTask_BasicFilterTemplate
{
public:
	struct FGameplayTagContainer                  TargetGameplayTags;                                // 0x0028(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExcludeGamePlayTags;                               // 0x0048(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingFilter_GamePlayTags">();
	}
	static class UX6TargetingFilter_GamePlayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingFilter_GamePlayTags>();
	}
};
static_assert(alignof(UX6TargetingFilter_GamePlayTags) == 0x000008, "Wrong alignment on UX6TargetingFilter_GamePlayTags");
static_assert(sizeof(UX6TargetingFilter_GamePlayTags) == 0x000068, "Wrong size on UX6TargetingFilter_GamePlayTags");
static_assert(offsetof(UX6TargetingFilter_GamePlayTags, TargetGameplayTags) == 0x000028, "Member 'UX6TargetingFilter_GamePlayTags::TargetGameplayTags' has a wrong offset!");
static_assert(offsetof(UX6TargetingFilter_GamePlayTags, ExcludeGamePlayTags) == 0x000048, "Member 'UX6TargetingFilter_GamePlayTags::ExcludeGamePlayTags' has a wrong offset!");

// Class X6Game.X6CharacterPointLight
// 0x0000 (0x03B8 - 0x03B8)
class AX6CharacterPointLight final : public AX6CharacterLightBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterPointLight">();
	}
	static class AX6CharacterPointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CharacterPointLight>();
	}
};
static_assert(alignof(AX6CharacterPointLight) == 0x000008, "Wrong alignment on AX6CharacterPointLight");
static_assert(sizeof(AX6CharacterPointLight) == 0x0003B8, "Wrong size on AX6CharacterPointLight");

// Class X6Game.X6CharacterSpotLight
// 0x0000 (0x03B8 - 0x03B8)
class AX6CharacterSpotLight final : public AX6CharacterLightBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CharacterSpotLight">();
	}
	static class AX6CharacterSpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CharacterSpotLight>();
	}
};
static_assert(alignof(AX6CharacterSpotLight) == 0x000008, "Wrong alignment on AX6CharacterSpotLight");
static_assert(sizeof(AX6CharacterSpotLight) == 0x0003B8, "Wrong size on AX6CharacterSpotLight");

// Class X6Game.X6StrafeMovementComponent
// 0x0038 (0x00E0 - 0x00A8)
class UX6StrafeMovementComponent final : public UX6ActorComponent
{
public:
	bool                                          bIsEnabled;                                        // 0x00A8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x00A9(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTurnAroundAngle;                            // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCameraManager*                   CameraManager;                                     // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             CharacterOwner;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAdvancedCamera*                        AdCamera;                                          // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UX6RMWalkingComponent*                  RMWalkingComp;                                     // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMBaseLogicProcessor*                  CurRMBaseLogicProcessor;                           // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_UpdateMovingState(bool bNewMoveFlag);

	float CalcTurnAroundAngle(const struct FVector& InputDirection, const struct FVector& ForwardVector) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6StrafeMovementComponent">();
	}
	static class UX6StrafeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6StrafeMovementComponent>();
	}
};
static_assert(alignof(UX6StrafeMovementComponent) == 0x000008, "Wrong alignment on UX6StrafeMovementComponent");
static_assert(sizeof(UX6StrafeMovementComponent) == 0x0000E0, "Wrong size on UX6StrafeMovementComponent");
static_assert(offsetof(UX6StrafeMovementComponent, bIsEnabled) == 0x0000A8, "Member 'UX6StrafeMovementComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, bInterrupted) == 0x0000A9, "Member 'UX6StrafeMovementComponent::bInterrupted' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, CurrentTurnAroundAngle) == 0x0000AC, "Member 'UX6StrafeMovementComponent::CurrentTurnAroundAngle' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, CameraManager) == 0x0000B0, "Member 'UX6StrafeMovementComponent::CameraManager' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, CharacterOwner) == 0x0000B8, "Member 'UX6StrafeMovementComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, AdCamera) == 0x0000C0, "Member 'UX6StrafeMovementComponent::AdCamera' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, CharacterMovement) == 0x0000C8, "Member 'UX6StrafeMovementComponent::CharacterMovement' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, RMWalkingComp) == 0x0000D0, "Member 'UX6StrafeMovementComponent::RMWalkingComp' has a wrong offset!");
static_assert(offsetof(UX6StrafeMovementComponent, CurRMBaseLogicProcessor) == 0x0000D8, "Member 'UX6StrafeMovementComponent::CurRMBaseLogicProcessor' has a wrong offset!");

// Class X6Game.X6CheatManager
// 0x0038 (0x00C0 - 0x0088)
class UX6CheatManager final : public UCheatManager
{
public:
	struct FVector                                DebugLoadStreamingLevelLocation;                   // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void X6ChangeSize(float F);
	void X6Fly();
	void X6ForceMove(bool ForceIgnoreNikki);
	void X6Ghost();
	void X6Walk();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CheatManager">();
	}
	static class UX6CheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CheatManager>();
	}
};
static_assert(alignof(UX6CheatManager) == 0x000008, "Wrong alignment on UX6CheatManager");
static_assert(sizeof(UX6CheatManager) == 0x0000C0, "Wrong size on UX6CheatManager");
static_assert(offsetof(UX6CheatManager, DebugLoadStreamingLevelLocation) == 0x000088, "Member 'UX6CheatManager::DebugLoadStreamingLevelLocation' has a wrong offset!");

// Class X6Game.CinePawn
// 0x0010 (0x0440 - 0x0430)
class ACinePawn final : public APawn
{
public:
	class USceneComponent*                        DefaultRootComponent;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 mesh;                                              // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinePawn">();
	}
	static class ACinePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACinePawn>();
	}
};
static_assert(alignof(ACinePawn) == 0x000008, "Wrong alignment on ACinePawn");
static_assert(sizeof(ACinePawn) == 0x000440, "Wrong size on ACinePawn");
static_assert(offsetof(ACinePawn, DefaultRootComponent) == 0x000430, "Member 'ACinePawn::DefaultRootComponent' has a wrong offset!");
static_assert(offsetof(ACinePawn, mesh) == 0x000438, "Member 'ACinePawn::mesh' has a wrong offset!");

// Class X6Game.X6CircularListPanel
// 0x0028 (0x01C8 - 0x01A0)
class UX6CircularListPanel final : public UPanelWidget
{
public:
	float                                         ItemWidth;                                         // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemHeight;                                        // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAngle;                                         // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAngleSpacing;                                  // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstAngleOffset;                                  // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CircularListPanel">();
	}
	static class UX6CircularListPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CircularListPanel>();
	}
};
static_assert(alignof(UX6CircularListPanel) == 0x000008, "Wrong alignment on UX6CircularListPanel");
static_assert(sizeof(UX6CircularListPanel) == 0x0001C8, "Wrong size on UX6CircularListPanel");
static_assert(offsetof(UX6CircularListPanel, ItemWidth) == 0x0001A0, "Member 'UX6CircularListPanel::ItemWidth' has a wrong offset!");
static_assert(offsetof(UX6CircularListPanel, ItemHeight) == 0x0001A4, "Member 'UX6CircularListPanel::ItemHeight' has a wrong offset!");
static_assert(offsetof(UX6CircularListPanel, Radius) == 0x0001A8, "Member 'UX6CircularListPanel::Radius' has a wrong offset!");
static_assert(offsetof(UX6CircularListPanel, ItemAngle) == 0x0001AC, "Member 'UX6CircularListPanel::ItemAngle' has a wrong offset!");
static_assert(offsetof(UX6CircularListPanel, ItemAngleSpacing) == 0x0001B0, "Member 'UX6CircularListPanel::ItemAngleSpacing' has a wrong offset!");
static_assert(offsetof(UX6CircularListPanel, FirstAngleOffset) == 0x0001B4, "Member 'UX6CircularListPanel::FirstAngleOffset' has a wrong offset!");

// Class X6Game.X6AbilityTask_ApplyRootMotionAccelOrForward
// 0x0030 (0x00F8 - 0x00C8)
class UX6AbilityTask_ApplyRootMotionAccelOrForward final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x00DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x00E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x00E4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime;                                  // 0x00E8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGravity;                                    // 0x00F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_ApplyRootMotionAccelOrForward* ApplyRootMotionAccelOrForward(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float InterpSpeed_0, float Strength_0, float Duration_0, bool bIsAdditive_0, class UCurveFloat* StrengthOverTime_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bEnableGravity_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_ApplyRootMotionAccelOrForward">();
	}
	static class UX6AbilityTask_ApplyRootMotionAccelOrForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_ApplyRootMotionAccelOrForward>();
	}
};
static_assert(alignof(UX6AbilityTask_ApplyRootMotionAccelOrForward) == 0x000008, "Wrong alignment on UX6AbilityTask_ApplyRootMotionAccelOrForward");
static_assert(sizeof(UX6AbilityTask_ApplyRootMotionAccelOrForward) == 0x0000F8, "Wrong size on UX6AbilityTask_ApplyRootMotionAccelOrForward");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, OnFinish) == 0x0000C8, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::OnFinish' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, InterpSpeed) == 0x0000D8, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, Strength) == 0x0000DC, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::Strength' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, Duration) == 0x0000E0, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::Duration' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, bIsAdditive) == 0x0000E4, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::bIsAdditive' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, StrengthOverTime) == 0x0000E8, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionAccelOrForward, bEnableGravity) == 0x0000F0, "Member 'UX6AbilityTask_ApplyRootMotionAccelOrForward::bEnableGravity' has a wrong offset!");

// Class X6Game.X6CircularListSlot
// 0x0008 (0x0040 - 0x0038)
class UX6CircularListSlot final : public UPanelSlot
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CircularListSlot">();
	}
	static class UX6CircularListSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CircularListSlot>();
	}
};
static_assert(alignof(UX6CircularListSlot) == 0x000008, "Wrong alignment on UX6CircularListSlot");
static_assert(sizeof(UX6CircularListSlot) == 0x000040, "Wrong size on UX6CircularListSlot");

// Class X6Game.CircularListViewDesignerPreviewItem
// 0x0000 (0x0028 - 0x0028)
class UCircularListViewDesignerPreviewItem final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CircularListViewDesignerPreviewItem">();
	}
	static class UCircularListViewDesignerPreviewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCircularListViewDesignerPreviewItem>();
	}
};
static_assert(alignof(UCircularListViewDesignerPreviewItem) == 0x000008, "Wrong alignment on UCircularListViewDesignerPreviewItem");
static_assert(sizeof(UCircularListViewDesignerPreviewItem) == 0x000028, "Wrong size on UCircularListViewDesignerPreviewItem");

// Class X6Game.X6CircularListView
// 0x0210 (0x0398 - 0x0188)
class UX6CircularListView final : public UWidget
{
public:
	TSubclassOf<class UUserWidget>                EntryWidgetClass;                                  // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelScrollMultiplier;                             // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableScrollAnimation;                            // 0x0194(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserWidgetPool                        EntryWidgetPool;                                   // 0x0198(0x0088)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ESlateVisibility                              ScrollBarVisibility;                               // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EConsumeMouseWheel                            ConsumeMouseWheel;                                 // 0x0239(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrientation                                  Orientation;                                       // 0x023A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClearSelectionOnClick;                            // 0x023B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleSelect;                                     // 0x023C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibleAngleBegin;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSnapAngleByIndex;                                 // 0x0244(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SnapItemIndex;                                     // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapToAngle;                                       // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VisibleAngle;                                      // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemWidth;                                         // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemHeight;                                        // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CircleAlignment;                                   // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CircleAnchor;                                      // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemAngle;                                         // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemAngleSpacing;                                  // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateItemToCenter;                               // 0x0288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopList;                                         // 0x0289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopBeginItemIndex;                                // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ItemAlignment;                                     // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bScrollWithStep;                                   // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ListItems;                                         // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            BackgroundWidget;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget)> BP_OnEntryInitialized; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UUserWidget* Widget)> BP_OnEntryGenerated;                   // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UUserWidget* Widget)> BP_OnEntryReleased;                    // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item)> BP_OnItemClicked;                            // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget, bool bIsSelected, bool bWasUserDirected)> BP_OnItemSelectionChanged; // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget, bool bIsCenter)> BP_OnCenterItemChanged; // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget)> BP_OnItemScrolledIntoView; // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, bool bIsHovered)> BP_OnItemIsHoveredChanged;  // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void AddItem(class UObject* Item);
	void BP_CancelScrollIntoView();
	void BP_ClearSelection();
	void BP_ScrollItemIntoView(class UObject* Item);
	void BP_SetItemSelection(class UObject* Item, bool bSelected);
	void BP_SetListItems(const TArray<class UObject*>& InListItems);
	void BP_SetSelectedItem(class UObject* Item);
	void ClearListItems();
	void RegenerateAllEntries();
	void RemoveItem(class UObject* Item);
	void RequestRefresh();
	void ScrollIndexIntoView(int32 Index_0);
	void ScrollToBottom();
	void ScrollToTop();
	void SetScrollbarVisibility(ESlateVisibility InVisibility);
	void SetScrollOffset(const float InScrollOffset);
	void SetSelectedIndex(int32 Index_0);
	void SetWheelScrollMultiplier(float NewWheelScrollMultiplier);

	class UObject* BP_GetSelectedItem() const;
	bool BP_IsItemVisible(class UObject* Item) const;
	const TArray<class UUserWidget*> GetDisplayedEntryWidgets() const;
	int32 GetIndexForItem(class UObject* Item) const;
	class UObject* GetItemAt(int32 Index_0) const;
	const TArray<class UObject*> GetListItems() const;
	int32 GetNumItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CircularListView">();
	}
	static class UX6CircularListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CircularListView>();
	}
};
static_assert(alignof(UX6CircularListView) == 0x000008, "Wrong alignment on UX6CircularListView");
static_assert(sizeof(UX6CircularListView) == 0x000398, "Wrong size on UX6CircularListView");
static_assert(offsetof(UX6CircularListView, EntryWidgetClass) == 0x000188, "Member 'UX6CircularListView::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, WheelScrollMultiplier) == 0x000190, "Member 'UX6CircularListView::WheelScrollMultiplier' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bEnableScrollAnimation) == 0x000194, "Member 'UX6CircularListView::bEnableScrollAnimation' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, EntryWidgetPool) == 0x000198, "Member 'UX6CircularListView::EntryWidgetPool' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ScrollBarVisibility) == 0x000238, "Member 'UX6CircularListView::ScrollBarVisibility' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ConsumeMouseWheel) == 0x000239, "Member 'UX6CircularListView::ConsumeMouseWheel' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, Orientation) == 0x00023A, "Member 'UX6CircularListView::Orientation' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bClearSelectionOnClick) == 0x00023B, "Member 'UX6CircularListView::bClearSelectionOnClick' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bToggleSelect) == 0x00023C, "Member 'UX6CircularListView::bToggleSelect' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, VisibleAngleBegin) == 0x000240, "Member 'UX6CircularListView::VisibleAngleBegin' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bSnapAngleByIndex) == 0x000244, "Member 'UX6CircularListView::bSnapAngleByIndex' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, SnapItemIndex) == 0x000248, "Member 'UX6CircularListView::SnapItemIndex' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, SnapToAngle) == 0x00024C, "Member 'UX6CircularListView::SnapToAngle' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, VisibleAngle) == 0x000250, "Member 'UX6CircularListView::VisibleAngle' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ItemWidth) == 0x000254, "Member 'UX6CircularListView::ItemWidth' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ItemHeight) == 0x000258, "Member 'UX6CircularListView::ItemHeight' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, Radius) == 0x00025C, "Member 'UX6CircularListView::Radius' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, CircleAlignment) == 0x000260, "Member 'UX6CircularListView::CircleAlignment' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, CircleAnchor) == 0x000270, "Member 'UX6CircularListView::CircleAnchor' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ItemAngle) == 0x000280, "Member 'UX6CircularListView::ItemAngle' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ItemAngleSpacing) == 0x000284, "Member 'UX6CircularListView::ItemAngleSpacing' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bRotateItemToCenter) == 0x000288, "Member 'UX6CircularListView::bRotateItemToCenter' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bLoopList) == 0x000289, "Member 'UX6CircularListView::bLoopList' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, LoopBeginItemIndex) == 0x00028C, "Member 'UX6CircularListView::LoopBeginItemIndex' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ItemAlignment) == 0x0002A0, "Member 'UX6CircularListView::ItemAlignment' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, bScrollWithStep) == 0x0002C0, "Member 'UX6CircularListView::bScrollWithStep' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, ListItems) == 0x0002C8, "Member 'UX6CircularListView::ListItems' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BackgroundWidget) == 0x0002E8, "Member 'UX6CircularListView::BackgroundWidget' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnEntryInitialized) == 0x0002F0, "Member 'UX6CircularListView::BP_OnEntryInitialized' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnEntryGenerated) == 0x000300, "Member 'UX6CircularListView::BP_OnEntryGenerated' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnEntryReleased) == 0x000310, "Member 'UX6CircularListView::BP_OnEntryReleased' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnItemClicked) == 0x000320, "Member 'UX6CircularListView::BP_OnItemClicked' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnItemSelectionChanged) == 0x000340, "Member 'UX6CircularListView::BP_OnItemSelectionChanged' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnCenterItemChanged) == 0x000350, "Member 'UX6CircularListView::BP_OnCenterItemChanged' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnItemScrolledIntoView) == 0x000378, "Member 'UX6CircularListView::BP_OnItemScrolledIntoView' has a wrong offset!");
static_assert(offsetof(UX6CircularListView, BP_OnItemIsHoveredChanged) == 0x000388, "Member 'UX6CircularListView::BP_OnItemIsHoveredChanged' has a wrong offset!");

// Class X6Game.X6CombatBossSlotMgrComponent
// 0x0068 (0x0110 - 0x00A8)
class UX6CombatBossSlotMgrComponent final : public UX6ActorComponent
{
public:
	TArray<struct FAttachSlotDefinition>          Slots;                                             // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         PreviewCapsuleRadius;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x54];                                      // 0x00BC(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetSlotRelativeTransformByIndex(const int32 SlotIndex) const;
	TArray<struct FTransform> GetSlotRelativeTransformByTagName(const class FName& TagName) const;
	TArray<struct FAttachSlotDefinition> GetSlots() const;
	struct FTransform GetSlotTransformByIndex(const int32 SlotIndex) const;
	TArray<struct FTransform> GetSlotTransformByTagName(const class FName& TagName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatBossSlotMgrComponent">();
	}
	static class UX6CombatBossSlotMgrComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatBossSlotMgrComponent>();
	}
};
static_assert(alignof(UX6CombatBossSlotMgrComponent) == 0x000008, "Wrong alignment on UX6CombatBossSlotMgrComponent");
static_assert(sizeof(UX6CombatBossSlotMgrComponent) == 0x000110, "Wrong size on UX6CombatBossSlotMgrComponent");
static_assert(offsetof(UX6CombatBossSlotMgrComponent, Slots) == 0x0000A8, "Member 'UX6CombatBossSlotMgrComponent::Slots' has a wrong offset!");
static_assert(offsetof(UX6CombatBossSlotMgrComponent, PreviewCapsuleRadius) == 0x0000B8, "Member 'UX6CombatBossSlotMgrComponent::PreviewCapsuleRadius' has a wrong offset!");

// Class X6Game.X6CombatBoxCollisionComponent
// 0x0010 (0x0610 - 0x0600)
class UX6CombatBoxCollisionComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBulletFilter;                                     // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FilterPriority;                                    // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatBoxCollisionComponent">();
	}
	static class UX6CombatBoxCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatBoxCollisionComponent>();
	}
};
static_assert(alignof(UX6CombatBoxCollisionComponent) == 0x000010, "Wrong alignment on UX6CombatBoxCollisionComponent");
static_assert(sizeof(UX6CombatBoxCollisionComponent) == 0x000610, "Wrong size on UX6CombatBoxCollisionComponent");
static_assert(offsetof(UX6CombatBoxCollisionComponent, bBulletFilter) == 0x000600, "Member 'UX6CombatBoxCollisionComponent::bBulletFilter' has a wrong offset!");
static_assert(offsetof(UX6CombatBoxCollisionComponent, FilterPriority) == 0x000604, "Member 'UX6CombatBoxCollisionComponent::FilterPriority' has a wrong offset!");

// Class X6Game.X6CombatCameraSynchronizer
// 0x0010 (0x01F0 - 0x01E0)
class UX6CombatCameraSynchronizer final : public UX6CombatCameraSynchronizerBase
{
public:
	uint8                                         Pad_1E0[0x10];                                     // 0x01E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearRotationTargetCandidates();
	void SetRotationTargetCandidates(const TArray<class AActor*>& CandidatesArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatCameraSynchronizer">();
	}
	static class UX6CombatCameraSynchronizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatCameraSynchronizer>();
	}
};
static_assert(alignof(UX6CombatCameraSynchronizer) == 0x000010, "Wrong alignment on UX6CombatCameraSynchronizer");
static_assert(sizeof(UX6CombatCameraSynchronizer) == 0x0001F0, "Wrong size on UX6CombatCameraSynchronizer");

// Class X6Game.X6WorldCarriageCharacter
// 0x0000 (0x08B0 - 0x08B0)
class AX6WorldCarriageCharacter final : public AX6CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6WorldCarriageCharacter">();
	}
	static class AX6WorldCarriageCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6WorldCarriageCharacter>();
	}
};
static_assert(alignof(AX6WorldCarriageCharacter) == 0x000010, "Wrong alignment on AX6WorldCarriageCharacter");
static_assert(sizeof(AX6WorldCarriageCharacter) == 0x0008B0, "Wrong size on AX6WorldCarriageCharacter");

// Class X6Game.X6CombatCapsuleComponent
// 0x0010 (0x0600 - 0x05F0)
class UX6CombatCapsuleComponent final : public UCapsuleComponent
{
public:
	bool                                          bBulletFilter;                                     // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FilterPriority;                                    // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatCapsuleComponent">();
	}
	static class UX6CombatCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatCapsuleComponent>();
	}
};
static_assert(alignof(UX6CombatCapsuleComponent) == 0x000010, "Wrong alignment on UX6CombatCapsuleComponent");
static_assert(sizeof(UX6CombatCapsuleComponent) == 0x000600, "Wrong size on UX6CombatCapsuleComponent");
static_assert(offsetof(UX6CombatCapsuleComponent, bBulletFilter) == 0x0005F0, "Member 'UX6CombatCapsuleComponent::bBulletFilter' has a wrong offset!");
static_assert(offsetof(UX6CombatCapsuleComponent, FilterPriority) == 0x0005F4, "Member 'UX6CombatCapsuleComponent::FilterPriority' has a wrong offset!");

// Class X6Game.X6CombatComponent
// 0x0010 (0x00B8 - 0x00A8)
class UX6CombatComponent final : public UX6ActorComponent
{
public:
	class UX6AbilitySystemComponent*              X6AbilitySystemComponent;                          // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableFilterOutline;                              // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAbilityDataAsset(const class UX6AbilitySet* InAbilitySet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatComponent">();
	}
	static class UX6CombatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatComponent>();
	}
};
static_assert(alignof(UX6CombatComponent) == 0x000008, "Wrong alignment on UX6CombatComponent");
static_assert(sizeof(UX6CombatComponent) == 0x0000B8, "Wrong size on UX6CombatComponent");
static_assert(offsetof(UX6CombatComponent, X6AbilitySystemComponent) == 0x0000A8, "Member 'UX6CombatComponent::X6AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UX6CombatComponent, bEnableFilterOutline) == 0x0000B0, "Member 'UX6CombatComponent::bEnableFilterOutline' has a wrong offset!");

// Class X6Game.X6AbilityTagRelationshipMapping
// 0x0010 (0x0040 - 0x0030)
class UX6AbilityTagRelationshipMapping final : public UDataAsset
{
public:
	TArray<struct FX6AbilityTagRelationship>      AbilityTagRelationships;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTagRelationshipMapping">();
	}
	static class UX6AbilityTagRelationshipMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTagRelationshipMapping>();
	}
};
static_assert(alignof(UX6AbilityTagRelationshipMapping) == 0x000008, "Wrong alignment on UX6AbilityTagRelationshipMapping");
static_assert(sizeof(UX6AbilityTagRelationshipMapping) == 0x000040, "Wrong size on UX6AbilityTagRelationshipMapping");
static_assert(offsetof(UX6AbilityTagRelationshipMapping, AbilityTagRelationships) == 0x000030, "Member 'UX6AbilityTagRelationshipMapping::AbilityTagRelationships' has a wrong offset!");

// Class X6Game.X6CombatMovementComponent
// 0x0068 (0x0110 - 0x00A8)
class UX6CombatMovementComponent final : public UActorComponent
{
public:
	float                                         MaxStartTime;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlaceStartTime;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlaceMinTime;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CycleMaxAcceleration;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlaceMaxAcceleration;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartReadyAcceleration;                            // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnabled;                                        // 0x00C1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartMovingDirection;                              // 0x00C8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTime;                                         // 0x00E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   CameraManager;                                     // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             CharacterOwner;                                    // 0x00F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMBaseLogicProcessor*                  CurRMBaseLogicProcessor;                           // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanWalkNow;                                       // 0x0108(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanData();
	void K2_UpdateMovingState(bool bNewMoveFlag);
	struct FVector UpdateMovingData(float DeltaTime, bool bNewMoveFlag, const struct FVector& NewMoveDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatMovementComponent">();
	}
	static class UX6CombatMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatMovementComponent>();
	}
};
static_assert(alignof(UX6CombatMovementComponent) == 0x000008, "Wrong alignment on UX6CombatMovementComponent");
static_assert(sizeof(UX6CombatMovementComponent) == 0x000110, "Wrong size on UX6CombatMovementComponent");
static_assert(offsetof(UX6CombatMovementComponent, MaxStartTime) == 0x0000A8, "Member 'UX6CombatMovementComponent::MaxStartTime' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, InPlaceStartTime) == 0x0000AC, "Member 'UX6CombatMovementComponent::InPlaceStartTime' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, InPlaceMinTime) == 0x0000B0, "Member 'UX6CombatMovementComponent::InPlaceMinTime' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, CycleMaxAcceleration) == 0x0000B4, "Member 'UX6CombatMovementComponent::CycleMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, InPlaceMaxAcceleration) == 0x0000B8, "Member 'UX6CombatMovementComponent::InPlaceMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, StartReadyAcceleration) == 0x0000BC, "Member 'UX6CombatMovementComponent::StartReadyAcceleration' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, bIsMoving) == 0x0000C0, "Member 'UX6CombatMovementComponent::bIsMoving' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, bIsEnabled) == 0x0000C1, "Member 'UX6CombatMovementComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, StartMovingDirection) == 0x0000C8, "Member 'UX6CombatMovementComponent::StartMovingDirection' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, StartTime) == 0x0000E0, "Member 'UX6CombatMovementComponent::StartTime' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, CameraManager) == 0x0000E8, "Member 'UX6CombatMovementComponent::CameraManager' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, CharacterOwner) == 0x0000F0, "Member 'UX6CombatMovementComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, CharacterMovement) == 0x0000F8, "Member 'UX6CombatMovementComponent::CharacterMovement' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, CurRMBaseLogicProcessor) == 0x000100, "Member 'UX6CombatMovementComponent::CurRMBaseLogicProcessor' has a wrong offset!");
static_assert(offsetof(UX6CombatMovementComponent, bCanWalkNow) == 0x000108, "Member 'UX6CombatMovementComponent::bCanWalkNow' has a wrong offset!");

// Class X6Game.X6CombatPerformanceProcessorComponent
// 0x0000 (0x00A8 - 0x00A8)
class UX6CombatPerformanceProcessorComponent final : public UActorComponent
{
public:
	class UDataAsset* K2_GetABPConfigs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatPerformanceProcessorComponent">();
	}
	static class UX6CombatPerformanceProcessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatPerformanceProcessorComponent>();
	}
};
static_assert(alignof(UX6CombatPerformanceProcessorComponent) == 0x000008, "Wrong alignment on UX6CombatPerformanceProcessorComponent");
static_assert(sizeof(UX6CombatPerformanceProcessorComponent) == 0x0000A8, "Wrong size on UX6CombatPerformanceProcessorComponent");

// Class X6Game.X6AbilityTask_PlayMontageAndWait
// 0x00B0 (0x0130 - 0x0080)
class UX6AbilityTask_PlayMontageAndWait final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class FName NotifyName)> OnCompleted;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnBlendOut;                               // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnInterrupted;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnCancelled;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyBegin;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyName)> OnNotifyEnd;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x0108(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rate;                                              // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartSection;                                      // 0x0114(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimRootMotionTranslationScale;                    // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTimeSeconds;                                  // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopWhenAbilityEnds;                              // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMirror;                                           // 0x0125(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayWithShadow;                                   // 0x0126(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127[0x9];                                      // 0x0127(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_PlayMontageAndWait* CreatePlayMontageAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0, float StartTimeSeconds_0, bool bMirror_0, bool bPlayWithShadow_0);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageInterrupted();
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_PlayMontageAndWait">();
	}
	static class UX6AbilityTask_PlayMontageAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_PlayMontageAndWait>();
	}
};
static_assert(alignof(UX6AbilityTask_PlayMontageAndWait) == 0x000008, "Wrong alignment on UX6AbilityTask_PlayMontageAndWait");
static_assert(sizeof(UX6AbilityTask_PlayMontageAndWait) == 0x000130, "Wrong size on UX6AbilityTask_PlayMontageAndWait");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, OnCompleted) == 0x000080, "Member 'UX6AbilityTask_PlayMontageAndWait::OnCompleted' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, OnBlendOut) == 0x000090, "Member 'UX6AbilityTask_PlayMontageAndWait::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, OnInterrupted) == 0x0000A0, "Member 'UX6AbilityTask_PlayMontageAndWait::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, OnCancelled) == 0x0000B0, "Member 'UX6AbilityTask_PlayMontageAndWait::OnCancelled' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, OnNotifyBegin) == 0x0000C0, "Member 'UX6AbilityTask_PlayMontageAndWait::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, OnNotifyEnd) == 0x0000D0, "Member 'UX6AbilityTask_PlayMontageAndWait::OnNotifyEnd' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, MontageToPlay) == 0x000108, "Member 'UX6AbilityTask_PlayMontageAndWait::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, Rate) == 0x000110, "Member 'UX6AbilityTask_PlayMontageAndWait::Rate' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, StartSection) == 0x000114, "Member 'UX6AbilityTask_PlayMontageAndWait::StartSection' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, AnimRootMotionTranslationScale) == 0x00011C, "Member 'UX6AbilityTask_PlayMontageAndWait::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, StartTimeSeconds) == 0x000120, "Member 'UX6AbilityTask_PlayMontageAndWait::StartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, bStopWhenAbilityEnds) == 0x000124, "Member 'UX6AbilityTask_PlayMontageAndWait::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, bMirror) == 0x000125, "Member 'UX6AbilityTask_PlayMontageAndWait::bMirror' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_PlayMontageAndWait, bPlayWithShadow) == 0x000126, "Member 'UX6AbilityTask_PlayMontageAndWait::bPlayWithShadow' has a wrong offset!");

// Class X6Game.X6CombatSummonBase
// 0x0000 (0x0460 - 0x0460)
class AX6CombatSummonBase final : public AX6ActorWithTag
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatSummonBase">();
	}
	static class AX6CombatSummonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CombatSummonBase>();
	}
};
static_assert(alignof(AX6CombatSummonBase) == 0x000008, "Wrong alignment on AX6CombatSummonBase");
static_assert(sizeof(AX6CombatSummonBase) == 0x000460, "Wrong size on AX6CombatSummonBase");

// Class X6Game.X6CombatTargetingFilterSetting
// 0x0110 (0x0148 - 0x0038)
class UX6CombatTargetingFilterSetting final : public UDeveloperSettings
{
public:
	int32                                         DefaultFlag;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigTickDuration;                                // 0x003C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterAreaDistance;                                // 0x0040(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CameraOutLineMaterial;                             // 0x0048(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BaseTargetingPreset;                               // 0x0068(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BaseChargeUpPreTargetingPreset;                    // 0x0088(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BaseChargeUpFinishTargetingPreset;                 // 0x00A8(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ReinforceTargetingPreset;                          // 0x00C8(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ReinforceChargeUpPreTargetingPreset;               // 0x00E8(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ReinforceChargeUpFinishTargetingPreset;            // 0x0108(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BaseCrashTargetingPreset;                          // 0x0128(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatTargetingFilterSetting">();
	}
	static class UX6CombatTargetingFilterSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatTargetingFilterSetting>();
	}
};
static_assert(alignof(UX6CombatTargetingFilterSetting) == 0x000008, "Wrong alignment on UX6CombatTargetingFilterSetting");
static_assert(sizeof(UX6CombatTargetingFilterSetting) == 0x000148, "Wrong size on UX6CombatTargetingFilterSetting");
static_assert(offsetof(UX6CombatTargetingFilterSetting, DefaultFlag) == 0x000038, "Member 'UX6CombatTargetingFilterSetting::DefaultFlag' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, ConfigTickDuration) == 0x00003C, "Member 'UX6CombatTargetingFilterSetting::ConfigTickDuration' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, FilterAreaDistance) == 0x000040, "Member 'UX6CombatTargetingFilterSetting::FilterAreaDistance' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, CameraOutLineMaterial) == 0x000048, "Member 'UX6CombatTargetingFilterSetting::CameraOutLineMaterial' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, BaseTargetingPreset) == 0x000068, "Member 'UX6CombatTargetingFilterSetting::BaseTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, BaseChargeUpPreTargetingPreset) == 0x000088, "Member 'UX6CombatTargetingFilterSetting::BaseChargeUpPreTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, BaseChargeUpFinishTargetingPreset) == 0x0000A8, "Member 'UX6CombatTargetingFilterSetting::BaseChargeUpFinishTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, ReinforceTargetingPreset) == 0x0000C8, "Member 'UX6CombatTargetingFilterSetting::ReinforceTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, ReinforceChargeUpPreTargetingPreset) == 0x0000E8, "Member 'UX6CombatTargetingFilterSetting::ReinforceChargeUpPreTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, ReinforceChargeUpFinishTargetingPreset) == 0x000108, "Member 'UX6CombatTargetingFilterSetting::ReinforceChargeUpFinishTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSetting, BaseCrashTargetingPreset) == 0x000128, "Member 'UX6CombatTargetingFilterSetting::BaseCrashTargetingPreset' has a wrong offset!");

// Class X6Game.X6WaterSimulationComponent
// 0x0048 (0x00F0 - 0x00A8)
class UX6WaterSimulationComponent final : public UX6ActorComponent
{
public:
	ESimulateWaterFlowType                        WaterFlowType;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimulateWaterFlowKeyPoint             TargetPointToToward;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimulateWaterFlowKeyPoint             PointToLeave;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSimulateWaterFlowKeyPoint>     MovementTrackKeyPoints;                            // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InitialConfigDensity;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentWaterDensity;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSimulateWaterFlowKeyPoint GetPointToLeave();
	struct FSimulateWaterFlowKeyPoint GetTargetPointToToward();
	float GetWaterCurrentDensity();
	float GetWaterSurfaceHeightInWorldCoordinate();
	void UpdateWaterDensity(float NewDensity);
	void UpdateWaterIceState(bool ToIceOrExit);
	void UpdateWaterSurfaceHeight(float HeightOfffsetToUpdate);
	void UpdateWaterSurfaceHeightInTime(float TimeDuration, float TotalHeightToUpdate);
	void UpdateWaterSurfaceHeightWithSpeed(float UpdateHeightSpeed, float TotalHeightToUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6WaterSimulationComponent">();
	}
	static class UX6WaterSimulationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6WaterSimulationComponent>();
	}
};
static_assert(alignof(UX6WaterSimulationComponent) == 0x000008, "Wrong alignment on UX6WaterSimulationComponent");
static_assert(sizeof(UX6WaterSimulationComponent) == 0x0000F0, "Wrong size on UX6WaterSimulationComponent");
static_assert(offsetof(UX6WaterSimulationComponent, WaterFlowType) == 0x0000A8, "Member 'UX6WaterSimulationComponent::WaterFlowType' has a wrong offset!");
static_assert(offsetof(UX6WaterSimulationComponent, TargetPointToToward) == 0x0000B0, "Member 'UX6WaterSimulationComponent::TargetPointToToward' has a wrong offset!");
static_assert(offsetof(UX6WaterSimulationComponent, PointToLeave) == 0x0000C0, "Member 'UX6WaterSimulationComponent::PointToLeave' has a wrong offset!");
static_assert(offsetof(UX6WaterSimulationComponent, MovementTrackKeyPoints) == 0x0000D0, "Member 'UX6WaterSimulationComponent::MovementTrackKeyPoints' has a wrong offset!");
static_assert(offsetof(UX6WaterSimulationComponent, InitialConfigDensity) == 0x0000E0, "Member 'UX6WaterSimulationComponent::InitialConfigDensity' has a wrong offset!");
static_assert(offsetof(UX6WaterSimulationComponent, CurrentWaterDensity) == 0x0000E4, "Member 'UX6WaterSimulationComponent::CurrentWaterDensity' has a wrong offset!");

// Class X6Game.X6CombatTargetingFilterSubsystem
// 0x0138 (0x0168 - 0x0030)
class UX6CombatTargetingFilterSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetingPreset*                       BaseCrashTargetingPreset;                          // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     CameraOutLineMaterial;                             // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x58];                                      // 0x0068(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6AbilitySystemComponent*              X6AbilitySystemComponent;                          // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingPreset*                       RunningTargetingPreset;                            // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingPreset*                       RunningPreChargeUpTargetingPreset;                 // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingPreset*                       RunningFinishChargeUpTargetingPreset;              // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingPreset*                       RunningCrashTargetingPreset;                       // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingPreset*                       CurStageTargetingPreset;                           // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          CurrentOutlineTargets;                             // 0x00F8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          FilterListenerTargets;                             // 0x0108(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x50];                                     // 0x0118(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAreaListenerTarget(class AActor* InTargetActor);
	void K2_ExecuteNormalTargetingPreset(const class UTargetingPreset* InFilterTargetingPreset, const class UTargetingPreset* InOnlyOutlineTargetingPreset);
	void K2_GetTargetingResults(const class UTargetingPreset* InTargetingPreset, TArray<struct FHitResult>* OutTargets);
	void K2_ResetCrashTargetingPreset();
	void K2_ResetPerfumeTargetingPreset(const bool bReinforce);
	void K2_SetRunningCrashTargetingPreset(class UTargetingPreset* InTargetingPreset);
	void K2_SetRunningPerfumeTargetingPreset(class UTargetingPreset* InTargetingPreset, class UTargetingPreset* InChargeUpPreTargetingPreset, class UTargetingPreset* InChargeUpFinishTargetingPreset);
	void OnControlMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void RemoveAreaListenerTarget(class AActor* InTargetActor);
	bool SetActiveOutlineCameraBlend(bool bActive, int32 InFlag, bool bClearFlag);
	void SetActiveTargetingFilter(bool bActive);

	bool IsAreaExistTarget(const struct FBox& BoxArea) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CombatTargetingFilterSubsystem">();
	}
	static class UX6CombatTargetingFilterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6CombatTargetingFilterSubsystem>();
	}
};
static_assert(alignof(UX6CombatTargetingFilterSubsystem) == 0x000008, "Wrong alignment on UX6CombatTargetingFilterSubsystem");
static_assert(sizeof(UX6CombatTargetingFilterSubsystem) == 0x000168, "Wrong size on UX6CombatTargetingFilterSubsystem");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, BaseCrashTargetingPreset) == 0x000058, "Member 'UX6CombatTargetingFilterSubsystem::BaseCrashTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, CameraOutLineMaterial) == 0x000060, "Member 'UX6CombatTargetingFilterSubsystem::CameraOutLineMaterial' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, Mid) == 0x0000C0, "Member 'UX6CombatTargetingFilterSubsystem::Mid' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, X6AbilitySystemComponent) == 0x0000C8, "Member 'UX6CombatTargetingFilterSubsystem::X6AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, RunningTargetingPreset) == 0x0000D0, "Member 'UX6CombatTargetingFilterSubsystem::RunningTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, RunningPreChargeUpTargetingPreset) == 0x0000D8, "Member 'UX6CombatTargetingFilterSubsystem::RunningPreChargeUpTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, RunningFinishChargeUpTargetingPreset) == 0x0000E0, "Member 'UX6CombatTargetingFilterSubsystem::RunningFinishChargeUpTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, RunningCrashTargetingPreset) == 0x0000E8, "Member 'UX6CombatTargetingFilterSubsystem::RunningCrashTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, CurStageTargetingPreset) == 0x0000F0, "Member 'UX6CombatTargetingFilterSubsystem::CurStageTargetingPreset' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, CurrentOutlineTargets) == 0x0000F8, "Member 'UX6CombatTargetingFilterSubsystem::CurrentOutlineTargets' has a wrong offset!");
static_assert(offsetof(UX6CombatTargetingFilterSubsystem, FilterListenerTargets) == 0x000108, "Member 'UX6CombatTargetingFilterSubsystem::FilterListenerTargets' has a wrong offset!");

// Class X6Game.X6CustomLevelSequenceActor
// 0x0008 (0x03B0 - 0x03A8)
class AX6CustomLevelSequenceActor final : public AActor
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveLevelSequenceActorBeginAttach(class AActor* AttachActor);
	void ReceiveLevelSequenceActorEndAttach();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6CustomLevelSequenceActor">();
	}
	static class AX6CustomLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6CustomLevelSequenceActor>();
	}
};
static_assert(alignof(AX6CustomLevelSequenceActor) == 0x000008, "Wrong alignment on AX6CustomLevelSequenceActor");
static_assert(sizeof(AX6CustomLevelSequenceActor) == 0x0003B0, "Wrong size on AX6CustomLevelSequenceActor");

// Class X6Game.X6AbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6AbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorDoesContainerMatchTagQuery(const class AActor* Actor, const struct FGameplayTagQuery& TagQuery);
	static bool ActorHasAllGameplayTags(const class AActor* Actor, const struct FGameplayTagContainer& TagContainer);
	static bool ActorHasAnyGameplayTags(const class AActor* Actor, const struct FGameplayTagContainer& TagContainer);
	static bool ActorHasGameplayTag(const class AActor* Actor, const struct FGameplayTag& TagToCheck);
	static bool ActorIsBoss(const class AActor* Actor);
	static bool ActorIsEliteMonster(const class AActor* Actor);
	static bool ActorIsMonster(const class AActor* Actor);
	static bool ActorIsNormalMonster(const class AActor* Actor);
	static bool AddLooseGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag);
	static bool AddLooseGameplayTagName(class AActor* Actor, const class FName& GameplayTagName);
	static int32 ApplyConstantForceRootMotion(const class AActor* Actor, const struct FVector& Force, class UCurveFloat* StrengthOverTime, float Duration, ERootMotionAccumulateMode AccumulateMode, bool bInLocalSpace, ERootMotionFinishVelocityMode FinishMode, float ClampVelocity, const struct FVector& SetVelocity, bool bEnableGravity, bool bDisablePartialEndTick, bool bUseSensitiveLiftoffCheck);
	static bool CheckActorCanBeSeen(class AActor* Actor, const TArray<class AActor*>& IgnoreTraceActors);
	static void CurrentMontageJumpToSection(class USkeletalMeshComponent* InSkeletalMeshComponent, class FName SectionName);
	static void DrawTargetingSelectionTaskAOE(const class AActor* Actor, const class UTargetingPreset* TargetingPreset, const struct FColor& Color, const struct FColor& InnerRingColor);
	static const TArray<struct FVector> GetRandomPointsFromSquare(const struct FVector& SquareCenter, float YawAngle, float XLength, float YLength, int32 XNum, int32 YNum);
	static class UX6AbilitySystemComponent* GetX6AbilitySystemComponent(const class AActor* Actor);
	static struct FTargetingSourceContext MakeTargetingSourceContextWithParam();
	static bool RemoveLooseGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag);
	static bool RemoveLooseGameplayTagName(class AActor* Actor, const class FName& GameplayTagName);
	static void RemoveRootMotionBySourceID(const class AActor* Actor, int32 SourceId);
	static bool SendGameplayEventToActorWithRet(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	static void StopAnimMontage(class USkeletalMeshComponent* InSkeletalMeshComponent, const class UAnimMontage* Montage, float OverrideBlendOutTime);
	static void UpdateConstantForceBySourceID(const class AActor* Actor, int32 SourceId, const struct FVector& NewForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilitySystemBlueprintLibrary">();
	}
	static class UX6AbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UX6AbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UX6AbilitySystemBlueprintLibrary");
static_assert(sizeof(UX6AbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UX6AbilitySystemBlueprintLibrary");

// Class X6Game.X6DaMiaoMainAnimInstance
// 0x00B0 (0x0480 - 0x03D0)
class UX6DaMiaoMainAnimInstance final : public UAnimInstance
{
public:
	struct FTimerHandle                           Timer_X6NikkiMainAnimInstancePrepare;              // 0x03C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6NikkiCPPTickHelperComponent*         X6NikkiCPPTickHelperComponent;                     // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFootIKFeatureTargetDataV2             CurFootIKFeatureTargetData;                        // 0x03D8(0x00A0)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool PrepareInitializationData();

	struct FFootIKFeatureTargetDataV2 GetCurFootIKFeatureTargetData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6DaMiaoMainAnimInstance">();
	}
	static class UX6DaMiaoMainAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6DaMiaoMainAnimInstance>();
	}
};
static_assert(alignof(UX6DaMiaoMainAnimInstance) == 0x000010, "Wrong alignment on UX6DaMiaoMainAnimInstance");
static_assert(sizeof(UX6DaMiaoMainAnimInstance) == 0x000480, "Wrong size on UX6DaMiaoMainAnimInstance");
static_assert(offsetof(UX6DaMiaoMainAnimInstance, Timer_X6NikkiMainAnimInstancePrepare) == 0x0003C8, "Member 'UX6DaMiaoMainAnimInstance::Timer_X6NikkiMainAnimInstancePrepare' has a wrong offset!");
static_assert(offsetof(UX6DaMiaoMainAnimInstance, X6NikkiCPPTickHelperComponent) == 0x0003D0, "Member 'UX6DaMiaoMainAnimInstance::X6NikkiCPPTickHelperComponent' has a wrong offset!");
static_assert(offsetof(UX6DaMiaoMainAnimInstance, CurFootIKFeatureTargetData) == 0x0003D8, "Member 'UX6DaMiaoMainAnimInstance::CurFootIKFeatureTargetData' has a wrong offset!");

// Class X6Game.X6DispatchInputComponent
// 0x0048 (0x00F0 - 0x00A8)
class UX6DispatchInputComponent final : public UX6ActorComponent
{
public:
	TMulticastInlineDelegate<void(EX6InputTouchEvent X6InputTouchEvent, ETouchIndex FingerIndex, const struct FVector& Location)> OnHandleTouch; // 0x00A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         JudgeSize;                                         // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x14];                                      // 0x00BC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        OwnerInputComp;                                    // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      BindedPlayerController;                            // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindInputByPlayerController(class APlayerController* InPlayerController);
	bool UnBindInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6DispatchInputComponent">();
	}
	static class UX6DispatchInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6DispatchInputComponent>();
	}
};
static_assert(alignof(UX6DispatchInputComponent) == 0x000008, "Wrong alignment on UX6DispatchInputComponent");
static_assert(sizeof(UX6DispatchInputComponent) == 0x0000F0, "Wrong size on UX6DispatchInputComponent");
static_assert(offsetof(UX6DispatchInputComponent, OnHandleTouch) == 0x0000A8, "Member 'UX6DispatchInputComponent::OnHandleTouch' has a wrong offset!");
static_assert(offsetof(UX6DispatchInputComponent, JudgeSize) == 0x0000B8, "Member 'UX6DispatchInputComponent::JudgeSize' has a wrong offset!");
static_assert(offsetof(UX6DispatchInputComponent, OwnerInputComp) == 0x0000D0, "Member 'UX6DispatchInputComponent::OwnerInputComp' has a wrong offset!");
static_assert(offsetof(UX6DispatchInputComponent, BindedPlayerController) == 0x0000D8, "Member 'UX6DispatchInputComponent::BindedPlayerController' has a wrong offset!");

// Class X6Game.GameFeatureAction_AddGameplayCuePath
// 0x0010 (0x0038 - 0x0028)
class UGameFeatureAction_AddGameplayCuePath final : public UGameFeatureAction
{
public:
	TArray<struct FDirectoryPath>                 DirectoryPathsToAdd;                               // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddGameplayCuePath">();
	}
	static class UGameFeatureAction_AddGameplayCuePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddGameplayCuePath>();
	}
};
static_assert(alignof(UGameFeatureAction_AddGameplayCuePath) == 0x000008, "Wrong alignment on UGameFeatureAction_AddGameplayCuePath");
static_assert(sizeof(UGameFeatureAction_AddGameplayCuePath) == 0x000038, "Wrong size on UGameFeatureAction_AddGameplayCuePath");
static_assert(offsetof(UGameFeatureAction_AddGameplayCuePath, DirectoryPathsToAdd) == 0x000028, "Member 'UGameFeatureAction_AddGameplayCuePath::DirectoryPathsToAdd' has a wrong offset!");

// Class X6Game.X6DynamicObstacleComponent
// 0x0030 (0x06F0 - 0x06C0)
class UX6DynamicObstacleComponent final : public USplineComponent
{
public:
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoActive : 1;                                   // 0x06C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActivated : 1;                                    // 0x06C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6C1[0x7];                                      // 0x06C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FailsafeExtent;                                    // 0x06C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateObstacle();
	void DeactivateObstacle();
	void RebuildObstacle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6DynamicObstacleComponent">();
	}
	static class UX6DynamicObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6DynamicObstacleComponent>();
	}
};
static_assert(alignof(UX6DynamicObstacleComponent) == 0x000010, "Wrong alignment on UX6DynamicObstacleComponent");
static_assert(sizeof(UX6DynamicObstacleComponent) == 0x0006F0, "Wrong size on UX6DynamicObstacleComponent");
static_assert(offsetof(UX6DynamicObstacleComponent, FailsafeExtent) == 0x0006C8, "Member 'UX6DynamicObstacleComponent::FailsafeExtent' has a wrong offset!");

// Class X6Game.X6EditableText
// 0x0010 (0x0530 - 0x0520)
class UX6EditableText final : public UEditableText
{
public:
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextComposed;                          // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTextWithCursorStay(const class FText& InText);

	bool IsComposing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6EditableText">();
	}
	static class UX6EditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6EditableText>();
	}
};
static_assert(alignof(UX6EditableText) == 0x000010, "Wrong alignment on UX6EditableText");
static_assert(sizeof(UX6EditableText) == 0x000530, "Wrong size on UX6EditableText");
static_assert(offsetof(UX6EditableText, OnTextComposed) == 0x000518, "Member 'UX6EditableText::OnTextComposed' has a wrong offset!");

// Class X6Game.X6AnimNotifyState_ComboInputData
// 0x0018 (0x0048 - 0x0030)
class UX6AnimNotifyState_ComboInputData final : public UAnimNotifyState
{
public:
	TArray<class UComboInputData*>                InputData;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bInactivateWhenNotifyEnd : 1;                      // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimNotifyState_ComboInputData">();
	}
	static class UX6AnimNotifyState_ComboInputData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimNotifyState_ComboInputData>();
	}
};
static_assert(alignof(UX6AnimNotifyState_ComboInputData) == 0x000008, "Wrong alignment on UX6AnimNotifyState_ComboInputData");
static_assert(sizeof(UX6AnimNotifyState_ComboInputData) == 0x000048, "Wrong size on UX6AnimNotifyState_ComboInputData");
static_assert(offsetof(UX6AnimNotifyState_ComboInputData, InputData) == 0x000030, "Member 'UX6AnimNotifyState_ComboInputData::InputData' has a wrong offset!");

// Class X6Game.X6EditableTextBox
// 0x0010 (0x10C0 - 0x10B0)
class UX6EditableTextBox final : public UEditableTextBox
{
public:
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextComposed;                          // 0x10B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsComposing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6EditableTextBox">();
	}
	static class UX6EditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6EditableTextBox>();
	}
};
static_assert(alignof(UX6EditableTextBox) == 0x000010, "Wrong alignment on UX6EditableTextBox");
static_assert(sizeof(UX6EditableTextBox) == 0x0010C0, "Wrong size on UX6EditableTextBox");
static_assert(offsetof(UX6EditableTextBox, OnTextComposed) == 0x0010B0, "Member 'UX6EditableTextBox::OnTextComposed' has a wrong offset!");

// Class X6Game.X6EditInLinePropertyBase
// 0x0000 (0x0028 - 0x0028)
class UX6EditInLinePropertyBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6EditInLinePropertyBase">();
	}
	static class UX6EditInLinePropertyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6EditInLinePropertyBase>();
	}
};
static_assert(alignof(UX6EditInLinePropertyBase) == 0x000008, "Wrong alignment on UX6EditInLinePropertyBase");
static_assert(sizeof(UX6EditInLinePropertyBase) == 0x000028, "Wrong size on UX6EditInLinePropertyBase");

// Class X6Game.MotionModifier_AdjustmentBlendWarp
// 0x01D0 (0x0330 - 0x0160)
class UMotionModifier_AdjustmentBlendWarp final : public URootMotionModifier
{
public:
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WarpTargetName;                                    // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarpTranslation;                                  // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZAxis;                                      // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             AddTranslationEasingFunc;                          // 0x016A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B[0x5];                                      // 0x016B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AddTranslationEasingCurve;                         // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarpRotation;                                     // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarpIKBones;                                      // 0x0179(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetBone;                                        // 0x017C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedTargetTransform;                             // 0x0190(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CachedMeshTransform;                               // 0x01F0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CachedMeshRelativeTransform;                       // 0x0250(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CachedRootMotion;                                  // 0x02B0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimSequenceTrackContainer            Result;                                            // 0x0310(0x0020)(Protected, NativeAccessSpecifierProtected)

public:
	static void GetAdjustmentBlendIKBoneTransformAndAlpha(const class USkeletalMeshComponent* OwnerComp, class FName BoneName, struct FTransform* OutTransform, float* OutAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionModifier_AdjustmentBlendWarp">();
	}
	static class UMotionModifier_AdjustmentBlendWarp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionModifier_AdjustmentBlendWarp>();
	}
};
static_assert(alignof(UMotionModifier_AdjustmentBlendWarp) == 0x000010, "Wrong alignment on UMotionModifier_AdjustmentBlendWarp");
static_assert(sizeof(UMotionModifier_AdjustmentBlendWarp) == 0x000330, "Wrong size on UMotionModifier_AdjustmentBlendWarp");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, WarpTargetName) == 0x000160, "Member 'UMotionModifier_AdjustmentBlendWarp::WarpTargetName' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, bWarpTranslation) == 0x000168, "Member 'UMotionModifier_AdjustmentBlendWarp::bWarpTranslation' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, bIgnoreZAxis) == 0x000169, "Member 'UMotionModifier_AdjustmentBlendWarp::bIgnoreZAxis' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, AddTranslationEasingFunc) == 0x00016A, "Member 'UMotionModifier_AdjustmentBlendWarp::AddTranslationEasingFunc' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, AddTranslationEasingCurve) == 0x000170, "Member 'UMotionModifier_AdjustmentBlendWarp::AddTranslationEasingCurve' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, bWarpRotation) == 0x000178, "Member 'UMotionModifier_AdjustmentBlendWarp::bWarpRotation' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, bWarpIKBones) == 0x000179, "Member 'UMotionModifier_AdjustmentBlendWarp::bWarpIKBones' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, TargetBone) == 0x00017C, "Member 'UMotionModifier_AdjustmentBlendWarp::TargetBone' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, BlendOutTime) == 0x000184, "Member 'UMotionModifier_AdjustmentBlendWarp::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, CachedTargetTransform) == 0x000190, "Member 'UMotionModifier_AdjustmentBlendWarp::CachedTargetTransform' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, CachedMeshTransform) == 0x0001F0, "Member 'UMotionModifier_AdjustmentBlendWarp::CachedMeshTransform' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, CachedMeshRelativeTransform) == 0x000250, "Member 'UMotionModifier_AdjustmentBlendWarp::CachedMeshRelativeTransform' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, CachedRootMotion) == 0x0002B0, "Member 'UMotionModifier_AdjustmentBlendWarp::CachedRootMotion' has a wrong offset!");
static_assert(offsetof(UMotionModifier_AdjustmentBlendWarp, Result) == 0x000310, "Member 'UMotionModifier_AdjustmentBlendWarp::Result' has a wrong offset!");

// Class X6Game.X6EffectWindZone
// 0x0040 (0x03E8 - 0x03A8)
class AX6EffectWindZone final : public AActor
{
public:
	float                                         LoopDuration;                                      // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForce;                                          // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WindForceCurve;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindDirection;                                     // 0x03C0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetInfluenceActor();
	void SetInfluenceActor(class AActor* InActor);
	void SetWindDirection(const struct FVector& InWindDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6EffectWindZone">();
	}
	static class AX6EffectWindZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6EffectWindZone>();
	}
};
static_assert(alignof(AX6EffectWindZone) == 0x000008, "Wrong alignment on AX6EffectWindZone");
static_assert(sizeof(AX6EffectWindZone) == 0x0003E8, "Wrong size on AX6EffectWindZone");
static_assert(offsetof(AX6EffectWindZone, LoopDuration) == 0x0003A8, "Member 'AX6EffectWindZone::LoopDuration' has a wrong offset!");
static_assert(offsetof(AX6EffectWindZone, MaxForce) == 0x0003AC, "Member 'AX6EffectWindZone::MaxForce' has a wrong offset!");
static_assert(offsetof(AX6EffectWindZone, Radius) == 0x0003B0, "Member 'AX6EffectWindZone::Radius' has a wrong offset!");
static_assert(offsetof(AX6EffectWindZone, WindForceCurve) == 0x0003B8, "Member 'AX6EffectWindZone::WindForceCurve' has a wrong offset!");
static_assert(offsetof(AX6EffectWindZone, WindDirection) == 0x0003C0, "Member 'AX6EffectWindZone::WindDirection' has a wrong offset!");

// Class X6Game.X6EncounterManager
// 0x0010 (0x0448 - 0x0438)
class AX6EncounterManager final : public AX6Actor
{
public:
	struct FX6SpawnerIDRef                        TriggerSpawnerID;                                  // 0x0438(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6EncounterManager">();
	}
	static class AX6EncounterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6EncounterManager>();
	}
};
static_assert(alignof(AX6EncounterManager) == 0x000008, "Wrong alignment on AX6EncounterManager");
static_assert(sizeof(AX6EncounterManager) == 0x000448, "Wrong size on AX6EncounterManager");
static_assert(offsetof(AX6EncounterManager, TriggerSpawnerID) == 0x000438, "Member 'AX6EncounterManager::TriggerSpawnerID' has a wrong offset!");

// Class X6Game.GameFeatureAction_WorldActionBase
// 0x0050 (0x0078 - 0x0028)
class UGameFeatureAction_WorldActionBase : public UGameFeatureAction
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_WorldActionBase">();
	}
	static class UGameFeatureAction_WorldActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_WorldActionBase>();
	}
};
static_assert(alignof(UGameFeatureAction_WorldActionBase) == 0x000008, "Wrong alignment on UGameFeatureAction_WorldActionBase");
static_assert(sizeof(UGameFeatureAction_WorldActionBase) == 0x000078, "Wrong size on UGameFeatureAction_WorldActionBase");

// Class X6Game.X6FBoxesRenderingComp
// 0x0010 (0x05D0 - 0x05C0)
class UX6FBoxesRenderingComp final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FBoxesRenderingComp">();
	}
	static class UX6FBoxesRenderingComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6FBoxesRenderingComp>();
	}
};
static_assert(alignof(UX6FBoxesRenderingComp) == 0x000010, "Wrong alignment on UX6FBoxesRenderingComp");
static_assert(sizeof(UX6FBoxesRenderingComp) == 0x0005D0, "Wrong size on UX6FBoxesRenderingComp");

// Class X6Game.X6FileBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6FileBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString AESDecrypt(const class FString& InMessageNeedDecrypt, const class FString& Key);
	static class FString AESEncrypt(const class FString& InMessageNeedEncrypt, const class FString& Key);
	static bool CompressImageWithEncryption(const class FString& SourceImgPath, const class FString& DestPath, const class FString& EncryionKey, int32 Quality);
	static bool DeleteInternalFile(const class FString& DeleteFilePath);
	static void DeleteInternalFileAsync(const class FString& DeleteFilePaths, TDelegate<void(bool Ret, const class FString& Path)> Callback);
	static void ForceDestroyAsyncCreatedTexture2D(class UTexture2D* InTexture);
	static class UTexture2D* GetCroppedTexture(class UTexture2D* Tex, const struct FVector2D& StartPos, int32 Width, int32 Height);
	static TArray<class FString> GetCustomDataFromPhotos(const TArray<class FString>& InPhotoPathList, const class FString& EncryptionKey);
	static int64 GetFileModificationTime(const class FString& InPath);
	static bool GetFileNames(const class FString& InDirPath, TArray<class FString>* OutFileNames);
	static double GetFileSizeInKBOfPath(const class FString& InPath);
	static class FString GetGamePath(EGameSavedDirType DirType);
	static double GetStorageSizeInMBOfPath(const class FString& InPath);
	static class UTexture2D* ReadAsResizedTexture(const class FString& TexPath, const float Ratio, bool bSingleUse);
	static void ReadAsResizedTextureAsync(const class FString& TexPath, const float Ratio, TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback, bool bSingleUse);
	static class UTexture2D* ReadAsResizedTextureWithEncryptionCheck(const class FString& TexPath, const float Ratio, const class FString& EncryptionKey, bool bSingleUse);
	static void ReadAsResizedTextureWithEncryptionCheckAsync(const class FString& TexPath, const float Ratio, const class FString& EncryptionKey, TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback, bool bSingleUse);
	static class UTexture2D* ReadAsTexture(const class FString& TexPath);
	static void ReadAsTextureAsync(const class FString& TexPath, TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback);
	static void ReadAsTextureWithEncryptionCheckAsync(const class FString& TexPath, const class FString& EncryptionKey, TDelegate<void(const class FString& Path, class UTexture2D* Tex)> Callback, bool bSingleUse);
	static bool ReadFile(const class FString& FilePath, TArray<uint8>* Result);
	static void ReadPhotosAsResizedTextureAsync(const TArray<class FString>& PhotoPaths, const float Ratio, TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback, bool bSingleUse);
	static void ReadPhotosAsResizedTextureWithEncryptionCheckAsync(const TArray<class FString>& PhotoPaths, const float Ratio, const class FString& EncryptionKey, TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback, bool bSingleUse);
	static void ReadPhotosAsTextureAsync(const TArray<class FString>& PhotoPaths, TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback);
	static void ReadPhotosAsTextureWithEncryptionCheckAsync(const TArray<class FString>& PhotoPaths, const class FString& EncryptionKey, TDelegate<void(const TArray<class FString>& Paths, const TArray<class UTexture2D*>& Tex)> Callback);
	static void ResizeAndSaveTextureWithEncryption(class UTexture2D* Texture, const class FString& InPath, const float Ratio, const class FString& EncryionKey, int32 Quality, const class FString& CustomData);
	static void SaveImageToAlbum(class UObject* Context, const class FString& FromPath, const class FString& TargetDir, const class FString& NewFileName, TDelegate<void(bool Result)> Delegate);
	static void SaveRenderTexture(const class FString& SavePath, class UTextureRenderTarget2D* Tex, int32 Quality);
	static void SaveRenderTextureWithEncryption(const class FString& SavePath, class UTextureRenderTarget2D* Tex, const class FString& EncryionKey, int32 Quality, const class FString& CustomData);
	static bool SaveTexture(const class FString& SavePath, class UTexture2D* Tex, int32 Quality);
	static void SaveTextureAsync(const class FString& SavePath, class UTexture2D* Tex, int32 Quality, TDelegate<void(bool Ret, const class FString& Path)> Callback);
	static void SaveTextureWithEncryptionAsync(const class FString& SavePath, class UTexture2D* Tex, const class FString& EncryionKey, int32 Quality, const class FString& CustomData, TDelegate<void(bool Ret, const class FString& Path)> Callback);
	static bool SetFileHidden_WindowsOnly(const class FString& InPath, bool InHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FileBlueprintLibrary">();
	}
	static class UX6FileBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6FileBlueprintLibrary>();
	}
};
static_assert(alignof(UX6FileBlueprintLibrary) == 0x000008, "Wrong alignment on UX6FileBlueprintLibrary");
static_assert(sizeof(UX6FileBlueprintLibrary) == 0x000028, "Wrong size on UX6FileBlueprintLibrary");

// Class X6Game.X6FixedStepSizeMoveCharacterBase
// 0x0000 (0x08B0 - 0x08B0)
class AX6FixedStepSizeMoveCharacterBase final : public AX6CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FixedStepSizeMoveCharacterBase">();
	}
	static class AX6FixedStepSizeMoveCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6FixedStepSizeMoveCharacterBase>();
	}
};
static_assert(alignof(AX6FixedStepSizeMoveCharacterBase) == 0x000010, "Wrong alignment on AX6FixedStepSizeMoveCharacterBase");
static_assert(sizeof(AX6FixedStepSizeMoveCharacterBase) == 0x0008B0, "Wrong size on AX6FixedStepSizeMoveCharacterBase");

// Class X6Game.X6FlatCapsuleComponent
// 0x0010 (0x0600 - 0x05F0)
class UX6FlatCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FlatCapsuleComponent">();
	}
	static class UX6FlatCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6FlatCapsuleComponent>();
	}
};
static_assert(alignof(UX6FlatCapsuleComponent) == 0x000010, "Wrong alignment on UX6FlatCapsuleComponent");
static_assert(sizeof(UX6FlatCapsuleComponent) == 0x000600, "Wrong size on UX6FlatCapsuleComponent");

// Class X6Game.X6GameFeature_AddGameplayCuePaths
// 0x0008 (0x0030 - 0x0028)
class UX6GameFeature_AddGameplayCuePaths final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameFeature_AddGameplayCuePaths">();
	}
	static class UX6GameFeature_AddGameplayCuePaths* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameFeature_AddGameplayCuePaths>();
	}
};
static_assert(alignof(UX6GameFeature_AddGameplayCuePaths) == 0x000008, "Wrong alignment on UX6GameFeature_AddGameplayCuePaths");
static_assert(sizeof(UX6GameFeature_AddGameplayCuePaths) == 0x000030, "Wrong size on UX6GameFeature_AddGameplayCuePaths");

// Class X6Game.X6FlyItemLogicComponent
// 0x0168 (0x0210 - 0x00A8)
class UX6FlyItemLogicComponent final : public UActorComponent
{
public:
	TArray<EObjectTypeQuery>                      CollisionTraceObjectTypes;                         // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      FloorTraceObjectTypes;                             // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      HitTraceObjectTypes;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              TraceType_SkillReceiver;                           // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPenetrateTarget;                                  // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DebugCollisionDraw;                                // 0x00DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DebugTraceDraw;                                    // 0x00DB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DebugHitDraw;                                      // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamiaoActor;                                       // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CollisionIgnoreActors;                             // 0x00E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         HitIgnoreActors;                                   // 0x00F8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class USceneComponent*                        TargetComponent;                                   // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 FollowActor;                                       // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CasterActor;                                       // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBulletOrientationTarget;                          // 0x0128(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveFollowMovement;                             // 0x0129(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPendingDestroy;                                 // 0x012A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyByHitTarget;                               // 0x012B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EX6BulletDestroyType                          DestroyType;                                       // 0x012C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHitBlockSummon;                                   // 0x012D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccumulateSeconds;                                 // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccumulateFrameSeconds;                            // 0x0134(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccumulateFollowTime;                              // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeCompensate;                                    // 0x013C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepSecond;                                        // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentVelocity;                                   // 0x0148(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseSpeed;                                         // 0x0164(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedUpTime;                                       // 0x0168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCurve;                                        // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FX6FlyItemTraceContext                 CollisionTraceContext;                             // 0x0178(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FX6FlyItemTraceContext                 HitTraceContext;                                   // 0x01A0(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x01C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorAngle;                                        // 0x01CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallAngle;                                         // 0x01D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToLevelOffset;                                     // 0x01D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FollowRefreshInterval;                             // 0x01D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FollowTargetRotator;                               // 0x01E0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FollowCanRotator;                                  // 0x01F8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	float GetSpeedRateValue(float RateValue);
	void InitData(class UCurveFloat* InSpeedCurve, float InBaseSpeed, float inDuration, float InSpeedUpTime, const struct FX6FlyItemTraceContext& InCollisionTraceContext, const struct FX6FlyItemTraceContext& InHitTraceContext, float InRadius, float InFloorAngle, float InWallAngle, float InToLevelOffset, class USceneComponent* InTargetComponent, class AActor* InTargetActor, float InFollowRefreshInterval, const struct FRotator& InFollowTargetRotator, const struct FRotator& InFollowCanRotator);
	void K2_DoPendingDestroy(bool bHitDamage, class AActor* HitActor);
	void SetCacheDamiaoActor(class AActor* InActor);
	void TickCollision(const struct FVector& StartLocation, const struct FVector& EndLocation);

	bool K2_ShouldDestroyByActor(class AActor* HitActor) const;
	void K2_TickHit(const struct FVector& StartLocation, const TArray<struct FHitResult>& HitResults) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FlyItemLogicComponent">();
	}
	static class UX6FlyItemLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6FlyItemLogicComponent>();
	}
};
static_assert(alignof(UX6FlyItemLogicComponent) == 0x000008, "Wrong alignment on UX6FlyItemLogicComponent");
static_assert(sizeof(UX6FlyItemLogicComponent) == 0x000210, "Wrong size on UX6FlyItemLogicComponent");
static_assert(offsetof(UX6FlyItemLogicComponent, CollisionTraceObjectTypes) == 0x0000A8, "Member 'UX6FlyItemLogicComponent::CollisionTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, FloorTraceObjectTypes) == 0x0000B8, "Member 'UX6FlyItemLogicComponent::FloorTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, HitTraceObjectTypes) == 0x0000C8, "Member 'UX6FlyItemLogicComponent::HitTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, TraceType_SkillReceiver) == 0x0000D8, "Member 'UX6FlyItemLogicComponent::TraceType_SkillReceiver' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, bPenetrateTarget) == 0x0000D9, "Member 'UX6FlyItemLogicComponent::bPenetrateTarget' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, DebugCollisionDraw) == 0x0000DA, "Member 'UX6FlyItemLogicComponent::DebugCollisionDraw' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, DebugTraceDraw) == 0x0000DB, "Member 'UX6FlyItemLogicComponent::DebugTraceDraw' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, DebugHitDraw) == 0x0000DC, "Member 'UX6FlyItemLogicComponent::DebugHitDraw' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, DamiaoActor) == 0x0000E0, "Member 'UX6FlyItemLogicComponent::DamiaoActor' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, CollisionIgnoreActors) == 0x0000E8, "Member 'UX6FlyItemLogicComponent::CollisionIgnoreActors' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, HitIgnoreActors) == 0x0000F8, "Member 'UX6FlyItemLogicComponent::HitIgnoreActors' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, TargetComponent) == 0x000108, "Member 'UX6FlyItemLogicComponent::TargetComponent' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, TargetActor) == 0x000110, "Member 'UX6FlyItemLogicComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, FollowActor) == 0x000118, "Member 'UX6FlyItemLogicComponent::FollowActor' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, CasterActor) == 0x000120, "Member 'UX6FlyItemLogicComponent::CasterActor' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, bBulletOrientationTarget) == 0x000128, "Member 'UX6FlyItemLogicComponent::bBulletOrientationTarget' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, bActiveFollowMovement) == 0x000129, "Member 'UX6FlyItemLogicComponent::bActiveFollowMovement' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, bIsPendingDestroy) == 0x00012A, "Member 'UX6FlyItemLogicComponent::bIsPendingDestroy' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, bDestroyByHitTarget) == 0x00012B, "Member 'UX6FlyItemLogicComponent::bDestroyByHitTarget' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, DestroyType) == 0x00012C, "Member 'UX6FlyItemLogicComponent::DestroyType' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, bHitBlockSummon) == 0x00012D, "Member 'UX6FlyItemLogicComponent::bHitBlockSummon' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, AccumulateSeconds) == 0x000130, "Member 'UX6FlyItemLogicComponent::AccumulateSeconds' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, AccumulateFrameSeconds) == 0x000134, "Member 'UX6FlyItemLogicComponent::AccumulateFrameSeconds' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, AccumulateFollowTime) == 0x000138, "Member 'UX6FlyItemLogicComponent::AccumulateFollowTime' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, TimeCompensate) == 0x00013C, "Member 'UX6FlyItemLogicComponent::TimeCompensate' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, StepSecond) == 0x000140, "Member 'UX6FlyItemLogicComponent::StepSecond' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, CurrentVelocity) == 0x000148, "Member 'UX6FlyItemLogicComponent::CurrentVelocity' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, Duration) == 0x000160, "Member 'UX6FlyItemLogicComponent::Duration' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, BaseSpeed) == 0x000164, "Member 'UX6FlyItemLogicComponent::BaseSpeed' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, SpeedUpTime) == 0x000168, "Member 'UX6FlyItemLogicComponent::SpeedUpTime' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, SpeedCurve) == 0x000170, "Member 'UX6FlyItemLogicComponent::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, CollisionTraceContext) == 0x000178, "Member 'UX6FlyItemLogicComponent::CollisionTraceContext' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, HitTraceContext) == 0x0001A0, "Member 'UX6FlyItemLogicComponent::HitTraceContext' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, Radius) == 0x0001C8, "Member 'UX6FlyItemLogicComponent::Radius' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, FloorAngle) == 0x0001CC, "Member 'UX6FlyItemLogicComponent::FloorAngle' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, WallAngle) == 0x0001D0, "Member 'UX6FlyItemLogicComponent::WallAngle' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, ToLevelOffset) == 0x0001D4, "Member 'UX6FlyItemLogicComponent::ToLevelOffset' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, FollowRefreshInterval) == 0x0001D8, "Member 'UX6FlyItemLogicComponent::FollowRefreshInterval' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, FollowTargetRotator) == 0x0001E0, "Member 'UX6FlyItemLogicComponent::FollowTargetRotator' has a wrong offset!");
static_assert(offsetof(UX6FlyItemLogicComponent, FollowCanRotator) == 0x0001F8, "Member 'UX6FlyItemLogicComponent::FollowCanRotator' has a wrong offset!");

// Class X6Game.X6FollowSplineMoveCharacterBase
// 0x0000 (0x08B0 - 0x08B0)
class AX6FollowSplineMoveCharacterBase final : public AX6CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FollowSplineMoveCharacterBase">();
	}
	static class AX6FollowSplineMoveCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6FollowSplineMoveCharacterBase>();
	}
};
static_assert(alignof(AX6FollowSplineMoveCharacterBase) == 0x000010, "Wrong alignment on AX6FollowSplineMoveCharacterBase");
static_assert(sizeof(AX6FollowSplineMoveCharacterBase) == 0x0008B0, "Wrong size on AX6FollowSplineMoveCharacterBase");

// Class X6Game.X6AnimNotifyState_TimedNiagaraEffect
// 0x0070 (0x00A0 - 0x0030)
class UX6AnimNotifyState_TimedNiagaraEffect final : public UAnimNotifyState
{
public:
	class UNiagaraSystem*                         Template;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0070(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UX6NiagaraEffectParam*>          Parameters;                                        // 0x0088(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAttachParentBound;                             // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFXSystemComponent* GetSpawnedEffect(class UMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimNotifyState_TimedNiagaraEffect">();
	}
	static class UX6AnimNotifyState_TimedNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimNotifyState_TimedNiagaraEffect>();
	}
};
static_assert(alignof(UX6AnimNotifyState_TimedNiagaraEffect) == 0x000008, "Wrong alignment on UX6AnimNotifyState_TimedNiagaraEffect");
static_assert(sizeof(UX6AnimNotifyState_TimedNiagaraEffect) == 0x0000A0, "Wrong size on UX6AnimNotifyState_TimedNiagaraEffect");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, Template) == 0x000030, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::Template' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, SocketName) == 0x000038, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, LocationOffset) == 0x000040, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, RotationOffset) == 0x000058, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, Scale) == 0x000070, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::Scale' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, Parameters) == 0x000088, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::Parameters' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, bDestroyAtEnd) == 0x000098, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(UX6AnimNotifyState_TimedNiagaraEffect, bUseAttachParentBound) == 0x000099, "Member 'UX6AnimNotifyState_TimedNiagaraEffect::bUseAttachParentBound' has a wrong offset!");

// Class X6Game.X6FollowSplineMovementComponent
// 0x05F0 (0x1AD0 - 0x14E0)
class UX6FollowSplineMovementComponent final : public UX6CustomizeMovementComponentBase
{
public:
	float                                         StartStepDistance;                                 // 0x14E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMoveTimeOutThreshold;                          // 0x14E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanShowThreshold;                                  // 0x14E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTurnSpeed;                                   // 0x14EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastMovingTurnSpeed;                               // 0x14F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerFastTurnYawDistance;                        // 0x14F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingVerticalSpeed;                               // 0x14F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarMoveTimeOut;                                   // 0x14FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AvoidCheckName;                                    // 0x1500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanMoveCheckDistance;                              // 0x1508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidOffsetDistance;                               // 0x150C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidTurnAngle;                                    // 0x1510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidReturnCenterThreshold;                        // 0x1514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidTraceCapsuleHalfHeightScale;                  // 0x1518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidTraceCapsuleRadiusScale;                      // 0x151C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidCanMoveDistanceToHitLocation;                 // 0x1520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidCanMoveDistanceToWorld;                       // 0x1524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidCheckSweepAngle;                              // 0x1528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvoidCheckSweepCount;                              // 0x152C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShowTimeAnimSlot;                                  // 0x1530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TurnInPlaceStateName;                              // 0x1538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartStateName;                                    // 0x1540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CycleStateName;                                    // 0x1548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StopStateName;                                     // 0x1550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCLocomotionInstanceTag;                          // 0x1558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FT2MovableNPCIKConfig                  T2MovableNPCIKConfig;                              // 0x1560(0x002C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   IKRootBoneName;                                    // 0x158C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IKFootLeftBoneName;                                // 0x1594(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IKFootRightBoneName;                               // 0x159C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFootIK;                                     // 0x15A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A5[0x3];                                     // 0x15A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SplineHeightIterationNum;                          // 0x15A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15AC[0x2BC];                                   // 0x15AC(0x02BC)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       TargetSplinePathComponent;                         // 0x1868(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1870[0x1D0];                                   // 0x1870(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ShowTimeAnimSoftPath;                              // 0x1A40(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A60[0x10];                                    // 0x1A60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNPCLocomotionTemplateBase*             LocomotionABPInstance;                             // 0x1A70(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FSplinePathNodeInfo>       PathNodesConfigMap;                                // 0x1A78(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC8[0x8];                                     // 0x1AC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FBoxSphereBounds GetSplineBoundBox();
	void OnPopObjectPool();
	void OnPushObjectPool();
	void RequestKeepOffLocation(const struct FVector& InWorldLocation);
	void RequestStartMove();
	void RequestStopMove();
	void SetAllowRootMotionTickPose(bool bNewAllowRootMotionTickPose);
	void SetFastMovingTurnSpeed(float InFastMovingTurnSpeed);
	void SetMoveConfig(float InMovingTurnSpeed, float InFastMovingTurnSpeed, float InAvoidOffsetDistance, float InAvoidTraceCapsuleHalfHeightScale, float InAvoidCheckSweepAngle, float InAvoidReturnCenterThreshold);
	void SetMoveSpeed(float InMoveSpeed);
	void SetMoveVerticalSpeed(float InMoveVerticalSpeed);
	void SetPathNodeInfo(const TMap<int32, struct FSplinePathNodeInfo>& PathNodeInfo);
	void SetShouldReturnWhenEnd(bool bNewReturn);
	void SetTargetSplinePath(const class USplineComponent* InTargetSplinePathComponent);
	void SetTriggerFastTurnYawDistance(float InTriggerFastTurnYawDistance);
	void StopKeepOffLocation();
	void TriggerReactToNikki(float TurnToNikkiYaw, float ReactTimeLength, bool inbReactWithoutTurn);
	void TriggerTurnInReact(float TurnToNikkiYaw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6FollowSplineMovementComponent">();
	}
	static class UX6FollowSplineMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6FollowSplineMovementComponent>();
	}
};
static_assert(alignof(UX6FollowSplineMovementComponent) == 0x000010, "Wrong alignment on UX6FollowSplineMovementComponent");
static_assert(sizeof(UX6FollowSplineMovementComponent) == 0x001AD0, "Wrong size on UX6FollowSplineMovementComponent");
static_assert(offsetof(UX6FollowSplineMovementComponent, StartStepDistance) == 0x0014E0, "Member 'UX6FollowSplineMovementComponent::StartStepDistance' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, StopMoveTimeOutThreshold) == 0x0014E4, "Member 'UX6FollowSplineMovementComponent::StopMoveTimeOutThreshold' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, CanShowThreshold) == 0x0014E8, "Member 'UX6FollowSplineMovementComponent::CanShowThreshold' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, MovingTurnSpeed) == 0x0014EC, "Member 'UX6FollowSplineMovementComponent::MovingTurnSpeed' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, FastMovingTurnSpeed) == 0x0014F0, "Member 'UX6FollowSplineMovementComponent::FastMovingTurnSpeed' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, TriggerFastTurnYawDistance) == 0x0014F4, "Member 'UX6FollowSplineMovementComponent::TriggerFastTurnYawDistance' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, MovingVerticalSpeed) == 0x0014F8, "Member 'UX6FollowSplineMovementComponent::MovingVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, StarMoveTimeOut) == 0x0014FC, "Member 'UX6FollowSplineMovementComponent::StarMoveTimeOut' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidCheckName) == 0x001500, "Member 'UX6FollowSplineMovementComponent::AvoidCheckName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, CanMoveCheckDistance) == 0x001508, "Member 'UX6FollowSplineMovementComponent::CanMoveCheckDistance' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidOffsetDistance) == 0x00150C, "Member 'UX6FollowSplineMovementComponent::AvoidOffsetDistance' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidTurnAngle) == 0x001510, "Member 'UX6FollowSplineMovementComponent::AvoidTurnAngle' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidReturnCenterThreshold) == 0x001514, "Member 'UX6FollowSplineMovementComponent::AvoidReturnCenterThreshold' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidTraceCapsuleHalfHeightScale) == 0x001518, "Member 'UX6FollowSplineMovementComponent::AvoidTraceCapsuleHalfHeightScale' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidTraceCapsuleRadiusScale) == 0x00151C, "Member 'UX6FollowSplineMovementComponent::AvoidTraceCapsuleRadiusScale' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidCanMoveDistanceToHitLocation) == 0x001520, "Member 'UX6FollowSplineMovementComponent::AvoidCanMoveDistanceToHitLocation' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidCanMoveDistanceToWorld) == 0x001524, "Member 'UX6FollowSplineMovementComponent::AvoidCanMoveDistanceToWorld' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidCheckSweepAngle) == 0x001528, "Member 'UX6FollowSplineMovementComponent::AvoidCheckSweepAngle' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, AvoidCheckSweepCount) == 0x00152C, "Member 'UX6FollowSplineMovementComponent::AvoidCheckSweepCount' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, ShowTimeAnimSlot) == 0x001530, "Member 'UX6FollowSplineMovementComponent::ShowTimeAnimSlot' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, TurnInPlaceStateName) == 0x001538, "Member 'UX6FollowSplineMovementComponent::TurnInPlaceStateName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, StartStateName) == 0x001540, "Member 'UX6FollowSplineMovementComponent::StartStateName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, CycleStateName) == 0x001548, "Member 'UX6FollowSplineMovementComponent::CycleStateName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, StopStateName) == 0x001550, "Member 'UX6FollowSplineMovementComponent::StopStateName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, NPCLocomotionInstanceTag) == 0x001558, "Member 'UX6FollowSplineMovementComponent::NPCLocomotionInstanceTag' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, T2MovableNPCIKConfig) == 0x001560, "Member 'UX6FollowSplineMovementComponent::T2MovableNPCIKConfig' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, IKRootBoneName) == 0x00158C, "Member 'UX6FollowSplineMovementComponent::IKRootBoneName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, IKFootLeftBoneName) == 0x001594, "Member 'UX6FollowSplineMovementComponent::IKFootLeftBoneName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, IKFootRightBoneName) == 0x00159C, "Member 'UX6FollowSplineMovementComponent::IKFootRightBoneName' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, bEnableFootIK) == 0x0015A4, "Member 'UX6FollowSplineMovementComponent::bEnableFootIK' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, SplineHeightIterationNum) == 0x0015A8, "Member 'UX6FollowSplineMovementComponent::SplineHeightIterationNum' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, TargetSplinePathComponent) == 0x001868, "Member 'UX6FollowSplineMovementComponent::TargetSplinePathComponent' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, ShowTimeAnimSoftPath) == 0x001A40, "Member 'UX6FollowSplineMovementComponent::ShowTimeAnimSoftPath' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, LocomotionABPInstance) == 0x001A70, "Member 'UX6FollowSplineMovementComponent::LocomotionABPInstance' has a wrong offset!");
static_assert(offsetof(UX6FollowSplineMovementComponent, PathNodesConfigMap) == 0x001A78, "Member 'UX6FollowSplineMovementComponent::PathNodesConfigMap' has a wrong offset!");

// Class X6Game.X6GameInstance
// 0x00C0 (0x0618 - 0x0558)
class UX6GameInstance final : public UPaperPlatformGameInstance
{
public:
	bool                                          DisableFadeEffectInEditor;                         // 0x0558(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeInTime;                                        // 0x055C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInBlackTime;                                   // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0564(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADonNavigationManagerUnbound*           AirPathFindingManager;                             // 0x0568(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APaperDissolveManager*                  PaperDissolveMng;                                  // 0x0570(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x50];                                     // 0x0578(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIPFManager*                           UIPFManagerForFX;                                  // 0x05C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUIPFManager*                           UIPFManagerForFoliage;                             // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 UIWSManagerForWaterInteraction;                    // 0x05D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 UIPFManagerForMultiFoliageInteraction;             // 0x05E0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UX6InputProcessorHelper*                InputProcessorHelper;                              // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APaperDissolveManager>      PaperDissolveClass;                                // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUIPFManager>               UIPFManagerForFXClass;                             // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUIPFManager>               UIPFManagerForFoliageClass;                        // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     UIWSManagerForWaterInteractionClass;               // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     UIPFManagerForMultiFoliageInteractionClass;        // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class AActor*> GetActorsByTag(const class FString& Tag);
	class ADonNavigationManagerUnbound* GetAirPathfindManager();
	class UX6InputProcessorHelper* GetInputProcessorHelper();
	class APaperDissolveManager* GetPaperDissolveManager();
	class AActor* GetUIMultiFoliageInteractionManager();
	class AUIPFManager* GetUIPFManager(const EUIPFManagerType& UIPFManagerType);
	class AActor* GetUIWSManager();
	void OnSetSpawnerCachedata(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameInstance">();
	}
	static class UX6GameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameInstance>();
	}
};
static_assert(alignof(UX6GameInstance) == 0x000008, "Wrong alignment on UX6GameInstance");
static_assert(sizeof(UX6GameInstance) == 0x000618, "Wrong size on UX6GameInstance");
static_assert(offsetof(UX6GameInstance, DisableFadeEffectInEditor) == 0x000558, "Member 'UX6GameInstance::DisableFadeEffectInEditor' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, FadeInTime) == 0x00055C, "Member 'UX6GameInstance::FadeInTime' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, FadeInBlackTime) == 0x000560, "Member 'UX6GameInstance::FadeInBlackTime' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, FadeOutTime) == 0x000564, "Member 'UX6GameInstance::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, AirPathFindingManager) == 0x000568, "Member 'UX6GameInstance::AirPathFindingManager' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, PaperDissolveMng) == 0x000570, "Member 'UX6GameInstance::PaperDissolveMng' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIPFManagerForFX) == 0x0005C8, "Member 'UX6GameInstance::UIPFManagerForFX' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIPFManagerForFoliage) == 0x0005D0, "Member 'UX6GameInstance::UIPFManagerForFoliage' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIWSManagerForWaterInteraction) == 0x0005D8, "Member 'UX6GameInstance::UIWSManagerForWaterInteraction' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIPFManagerForMultiFoliageInteraction) == 0x0005E0, "Member 'UX6GameInstance::UIPFManagerForMultiFoliageInteraction' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, InputProcessorHelper) == 0x0005E8, "Member 'UX6GameInstance::InputProcessorHelper' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, PaperDissolveClass) == 0x0005F0, "Member 'UX6GameInstance::PaperDissolveClass' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIPFManagerForFXClass) == 0x0005F8, "Member 'UX6GameInstance::UIPFManagerForFXClass' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIPFManagerForFoliageClass) == 0x000600, "Member 'UX6GameInstance::UIPFManagerForFoliageClass' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIWSManagerForWaterInteractionClass) == 0x000608, "Member 'UX6GameInstance::UIWSManagerForWaterInteractionClass' has a wrong offset!");
static_assert(offsetof(UX6GameInstance, UIPFManagerForMultiFoliageInteractionClass) == 0x000610, "Member 'UX6GameInstance::UIPFManagerForMultiFoliageInteractionClass' has a wrong offset!");

// Class X6Game.X6Pawn
// 0x0060 (0x0490 - 0x0430)
class AX6Pawn : public APawn
{
public:
	TArray<class FName>                           X6Tags;                                            // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x50];                                     // 0x0440(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttributeChange(const class FString& AttributeName);
	void PostServerInit(bool bServer);
	void ServerInit(bool bServer);
	void X6_AddTag(const TArray<class FName>& NewX6Tags);
	void X6_DeleteTag(const class FString& strTag);
	bool X6_GetActorHiddenFlags(TSet<int32>* OutFlags);
	TArray<class FName> X6_GetTag();
	bool X6_HasTag(const class FString& strTag);
	void X6_RequireActorFade(bool bFadeIn, int32 FadeOutHiddenFlag, bool bInView);
	bool X6_SetActorHiddenInGame(bool bNewHidden, int32 Flag, bool bClearFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6Pawn">();
	}
	static class AX6Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6Pawn>();
	}
};
static_assert(alignof(AX6Pawn) == 0x000008, "Wrong alignment on AX6Pawn");
static_assert(sizeof(AX6Pawn) == 0x000490, "Wrong size on AX6Pawn");
static_assert(offsetof(AX6Pawn, X6Tags) == 0x000430, "Member 'AX6Pawn::X6Tags' has a wrong offset!");

// Class X6Game.ActivateCondition
// 0x0000 (0x0028 - 0x0028)
class UActivateCondition : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateCondition">();
	}
	static class UActivateCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateCondition>();
	}
};
static_assert(alignof(UActivateCondition) == 0x000008, "Wrong alignment on UActivateCondition");
static_assert(sizeof(UActivateCondition) == 0x000028, "Wrong size on UActivateCondition");

// Class X6Game.ActivateCondition_SkillEnd
// 0x0000 (0x0028 - 0x0028)
class UActivateCondition_SkillEnd final : public UActivateCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateCondition_SkillEnd">();
	}
	static class UActivateCondition_SkillEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateCondition_SkillEnd>();
	}
};
static_assert(alignof(UActivateCondition_SkillEnd) == 0x000008, "Wrong alignment on UActivateCondition_SkillEnd");
static_assert(sizeof(UActivateCondition_SkillEnd) == 0x000028, "Wrong size on UActivateCondition_SkillEnd");

// Class X6Game.ComboInputData
// 0x0028 (0x0050 - 0x0028)
class UComboInputData : public UObject
{
public:
	struct FInstancedStruct                       ActivationSetting;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActivateCondition*                     ActivateCondition;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationDuration;                                // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboInputData">();
	}
	static class UComboInputData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboInputData>();
	}
};
static_assert(alignof(UComboInputData) == 0x000008, "Wrong alignment on UComboInputData");
static_assert(sizeof(UComboInputData) == 0x000050, "Wrong size on UComboInputData");
static_assert(offsetof(UComboInputData, ActivationSetting) == 0x000028, "Member 'UComboInputData::ActivationSetting' has a wrong offset!");
static_assert(offsetof(UComboInputData, InputTag) == 0x000038, "Member 'UComboInputData::InputTag' has a wrong offset!");
static_assert(offsetof(UComboInputData, ActivateCondition) == 0x000040, "Member 'UComboInputData::ActivateCondition' has a wrong offset!");
static_assert(offsetof(UComboInputData, ActivationDuration) == 0x000048, "Member 'UComboInputData::ActivationDuration' has a wrong offset!");

// Class X6Game.ComboInputData_Montage
// 0x0008 (0x0058 - 0x0050)
class UComboInputData_Montage final : public UComboInputData
{
public:
	struct FGameplayTag                           AnimTag;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboInputData_Montage">();
	}
	static class UComboInputData_Montage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboInputData_Montage>();
	}
};
static_assert(alignof(UComboInputData_Montage) == 0x000008, "Wrong alignment on UComboInputData_Montage");
static_assert(sizeof(UComboInputData_Montage) == 0x000058, "Wrong size on UComboInputData_Montage");
static_assert(offsetof(UComboInputData_Montage, AnimTag) == 0x000050, "Member 'UComboInputData_Montage::AnimTag' has a wrong offset!");

// Class X6Game.X6PlayerMantleComponent
// 0x0318 (0x03C0 - 0x00A8)
class UX6PlayerMantleComponent final : public UX6ActorComponent
{
public:
	bool                                          bWithNative;                                       // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivateMantleFeature;                           // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurDeltaSeconds;                                   // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMantleDebugLog;                             // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayerHasState_Mantling;                     // 0x00B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayerCanDoAction_Mantling;                  // 0x00B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMantleTypeNative                             CurrentMantleType;                                 // 0x00B3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMotionWarping;                              // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentMantleCostTime;                             // 0x00B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     CurrentDynamicMovementBaseTobeAttached;            // 0x00BC(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            OwnerCharacterMovementComponent;                   // 0x00C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastDynamicMovementBaseLocation;                   // 0x00D0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WithLastDynamicMovementBaseLocation;               // 0x00E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PendingProcessActorLocationZDuringMantle;          // 0x00EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheMantleHeight;                                 // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CacheTargetTransform;                              // 0x0100(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    CacheHitComponent;                                 // 0x0160(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CacheMantleTriggerStartLocation;                   // 0x0168(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             CacheHitResult;                                    // 0x0180(0x00F8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OriginalMaxStepHeight;                             // 0x0278(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalMeshRelativeLocationZ;                     // 0x027C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurAdjustLength;                                   // 0x0280(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAdjustActorToAnimTarget;                        // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MovingToAnimStartTarget_InitialTansform;           // 0x02A0(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MovingToAnimStartTarget_TargetActor;               // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovingToAnimStartTarget_TargetLocation;            // 0x0308(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MovingToAnimStartTarget_TargetRotation;            // 0x0320(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MovingToAnimStartTarget_Duration;                  // 0x0338(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateMovingToAnimStartTarget_CurrentTime;         // 0x033C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLimitMantleTime;                                // 0x0340(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SKMeshLerpSpeedCurve;                              // 0x0348(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownwardTraceRadiusCfg;                            // 0x0350(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownwardTraceForwardOffsetCfg;                     // 0x0354(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeastHeightInFallingCfg;                           // 0x0358(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeastHeightCheckCapsuleRadius;                     // 0x035C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustLengthCfg;                                   // 0x0360(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffsetCfg;                                        // 0x0378(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableOnGroundCfg;                                 // 0x037C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableMustJumpOperationBeforeMantleCfg;            // 0x037D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceTypeCfg;                                      // 0x037E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37F[0x1];                                      // 0x037F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReachDistanceInFallingCfg;                         // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachDistanceCfg;                                  // 0x0384(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardTraceCapsuleRediusCfg;                      // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugTypeCfg;                                  // 0x038C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDeflectionYawAngleCfg;                          // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGradCheckCfg;                                // 0x0394(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GradCheckAccuracyCfg;                              // 0x0398(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidToHighHeightBoundaryInFallingCfg;               // 0x039C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowToMidHeightBoundaryInFallingCfg;                // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinToLowHeightBoundaryInFallingCfg;                // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLedgeHeightInFallingCfg;                        // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLedgeHeightInFallingCfg;                        // 0x03AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLandingAreaSideLengthCfg;                   // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ValidMantleCollisionChannelCfg;                    // 0x03B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentUpdateTime;                                 // 0x03B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUpdate;                                         // 0x03BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCooldown;                                     // 0x03BD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveDoneJumpOrFloat;                              // 0x03BE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BF[0x1];                                      // 0x03BF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CapsuleHasLargeEnoughAreaCheck(class UCapsuleComponent* CapsuleComponent, const struct FVector& TargetLocation, float HeightOffset, float RadiusOffset, const struct FRotator& TargetRotation);
	bool CapsuleHasRoomCheck(class UCapsuleComponent* CapsuleComponent, const struct FVector& TargetLocation, float HeightOffset, float RadiusOffset);
	void ForceEndCheck();
	struct FVector GetCapsuleBaseLocation(float ZOffset);
	struct FVector GetCapsuleTopLocation(float ZOffset);
	struct FVector GetCurrentReachDistance(EMovementMode CurMovementMode, const struct FVector& CurInputDirection);
	EMantleTypeNative GetMantleTypeByHeightAndMovementMode(float MantleHeight, EMovementMode MovementMode);
	class ACharacter* GetOwnerCharacter();
	bool Internal_MantleMainCheckInFalling(const struct FVector& CapsuleBaseLocation, const struct FVector& CurrentPlayerInputVector, const struct FVector& CurActorLocation, float MinLedgeHeight, float MaxLedgeHeight, float ZOffset, bool bJustCheck);
	bool IsValidMantleTraceChannel(class UPrimitiveComponent* PrimitiveComponent, ECollisionChannel TraceChannel);
	void Lua_AddMantlingState();
	bool Lua_CurMantleInfoExist();
	bool Lua_GetCurMantleInfo_KeyOperationIsRequired();
	float Lua_GetCurMantleInfo_MontageAdjustHeightTime();
	float Lua_GetCurrentMantleInfoByName(const class FString& Name_0, EMovementMode MovementMode);
	bool Lua_IsCurWorldTypeInDoor();
	float Lua_MantleJumpStart(float MantleHeight);
	bool Lua_MantlePreCheck_InAir();
	float Lua_MantleQuicklyStart(float MantleHeight, float DeltaTime);
	float Lua_OnCurrentMantleTypeChanged();
	bool Lua_OwnerMantleConfigExist();
	void Lua_PostStart();
	void Lua_PostStartMotionWarping();
	void Lua_RemoveMantlingState();
	struct FVector Lua_TryGetCurInputDirection();
	bool MantleAllCheck(bool ReceivedInput);
	void MantleJumpStart(float MantleHeight);
	bool MantleMainCheck(float ZOffset);
	bool MantleMainCheckInFalling(float ZOffset);
	bool MantlePostCheck(bool ReceivedInput);
	bool MantlePreCheck();
	void MantleQuicklyStart(float MantleHeight, float DeltaTime);
	void MantleUpdate(float DeltaSeconds);
	void MantleUpdateMotionWarping(float DeltaSeconds);
	void PostStart();
	void PostStartMotionWarping();
	bool ProcessTransitionMantle();
	void UpdateDynamicMovementBaseTobeAttached();
	void UpdateMovingToAnimStartTarget(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PlayerMantleComponent">();
	}
	static class UX6PlayerMantleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PlayerMantleComponent>();
	}
};
static_assert(alignof(UX6PlayerMantleComponent) == 0x000010, "Wrong alignment on UX6PlayerMantleComponent");
static_assert(sizeof(UX6PlayerMantleComponent) == 0x0003C0, "Wrong size on UX6PlayerMantleComponent");
static_assert(offsetof(UX6PlayerMantleComponent, bWithNative) == 0x0000A8, "Member 'UX6PlayerMantleComponent::bWithNative' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, IsActivateMantleFeature) == 0x0000A9, "Member 'UX6PlayerMantleComponent::IsActivateMantleFeature' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CurDeltaSeconds) == 0x0000AC, "Member 'UX6PlayerMantleComponent::CurDeltaSeconds' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, bEnableMantleDebugLog) == 0x0000B0, "Member 'UX6PlayerMantleComponent::bEnableMantleDebugLog' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, bLocalPlayerHasState_Mantling) == 0x0000B1, "Member 'UX6PlayerMantleComponent::bLocalPlayerHasState_Mantling' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, bLocalPlayerCanDoAction_Mantling) == 0x0000B2, "Member 'UX6PlayerMantleComponent::bLocalPlayerCanDoAction_Mantling' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CurrentMantleType) == 0x0000B3, "Member 'UX6PlayerMantleComponent::CurrentMantleType' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, bEnableMotionWarping) == 0x0000B4, "Member 'UX6PlayerMantleComponent::bEnableMotionWarping' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CurrentMantleCostTime) == 0x0000B8, "Member 'UX6PlayerMantleComponent::CurrentMantleCostTime' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CurrentDynamicMovementBaseTobeAttached) == 0x0000BC, "Member 'UX6PlayerMantleComponent::CurrentDynamicMovementBaseTobeAttached' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, OwnerCharacterMovementComponent) == 0x0000C8, "Member 'UX6PlayerMantleComponent::OwnerCharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, LastDynamicMovementBaseLocation) == 0x0000D0, "Member 'UX6PlayerMantleComponent::LastDynamicMovementBaseLocation' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, WithLastDynamicMovementBaseLocation) == 0x0000E8, "Member 'UX6PlayerMantleComponent::WithLastDynamicMovementBaseLocation' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, PendingProcessActorLocationZDuringMantle) == 0x0000EC, "Member 'UX6PlayerMantleComponent::PendingProcessActorLocationZDuringMantle' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CacheMantleHeight) == 0x0000F0, "Member 'UX6PlayerMantleComponent::CacheMantleHeight' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CacheTargetTransform) == 0x000100, "Member 'UX6PlayerMantleComponent::CacheTargetTransform' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CacheHitComponent) == 0x000160, "Member 'UX6PlayerMantleComponent::CacheHitComponent' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CacheMantleTriggerStartLocation) == 0x000168, "Member 'UX6PlayerMantleComponent::CacheMantleTriggerStartLocation' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CacheHitResult) == 0x000180, "Member 'UX6PlayerMantleComponent::CacheHitResult' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, OriginalMaxStepHeight) == 0x000278, "Member 'UX6PlayerMantleComponent::OriginalMaxStepHeight' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, OriginalMeshRelativeLocationZ) == 0x00027C, "Member 'UX6PlayerMantleComponent::OriginalMeshRelativeLocationZ' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CurAdjustLength) == 0x000280, "Member 'UX6PlayerMantleComponent::CurAdjustLength' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CanAdjustActorToAnimTarget) == 0x000298, "Member 'UX6PlayerMantleComponent::CanAdjustActorToAnimTarget' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MovingToAnimStartTarget_InitialTansform) == 0x0002A0, "Member 'UX6PlayerMantleComponent::MovingToAnimStartTarget_InitialTansform' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MovingToAnimStartTarget_TargetActor) == 0x000300, "Member 'UX6PlayerMantleComponent::MovingToAnimStartTarget_TargetActor' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MovingToAnimStartTarget_TargetLocation) == 0x000308, "Member 'UX6PlayerMantleComponent::MovingToAnimStartTarget_TargetLocation' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MovingToAnimStartTarget_TargetRotation) == 0x000320, "Member 'UX6PlayerMantleComponent::MovingToAnimStartTarget_TargetRotation' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MovingToAnimStartTarget_Duration) == 0x000338, "Member 'UX6PlayerMantleComponent::MovingToAnimStartTarget_Duration' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, UpdateMovingToAnimStartTarget_CurrentTime) == 0x00033C, "Member 'UX6PlayerMantleComponent::UpdateMovingToAnimStartTarget_CurrentTime' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MaxLimitMantleTime) == 0x000340, "Member 'UX6PlayerMantleComponent::MaxLimitMantleTime' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, SKMeshLerpSpeedCurve) == 0x000348, "Member 'UX6PlayerMantleComponent::SKMeshLerpSpeedCurve' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, DownwardTraceRadiusCfg) == 0x000350, "Member 'UX6PlayerMantleComponent::DownwardTraceRadiusCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, DownwardTraceForwardOffsetCfg) == 0x000354, "Member 'UX6PlayerMantleComponent::DownwardTraceForwardOffsetCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, LeastHeightInFallingCfg) == 0x000358, "Member 'UX6PlayerMantleComponent::LeastHeightInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, LeastHeightCheckCapsuleRadius) == 0x00035C, "Member 'UX6PlayerMantleComponent::LeastHeightCheckCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, AdjustLengthCfg) == 0x000360, "Member 'UX6PlayerMantleComponent::AdjustLengthCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, ZOffsetCfg) == 0x000378, "Member 'UX6PlayerMantleComponent::ZOffsetCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, EnableOnGroundCfg) == 0x00037C, "Member 'UX6PlayerMantleComponent::EnableOnGroundCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, EnableMustJumpOperationBeforeMantleCfg) == 0x00037D, "Member 'UX6PlayerMantleComponent::EnableMustJumpOperationBeforeMantleCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, TraceTypeCfg) == 0x00037E, "Member 'UX6PlayerMantleComponent::TraceTypeCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, ReachDistanceInFallingCfg) == 0x000380, "Member 'UX6PlayerMantleComponent::ReachDistanceInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, ReachDistanceCfg) == 0x000384, "Member 'UX6PlayerMantleComponent::ReachDistanceCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, ForwardTraceCapsuleRediusCfg) == 0x000388, "Member 'UX6PlayerMantleComponent::ForwardTraceCapsuleRediusCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, DrawDebugTypeCfg) == 0x00038C, "Member 'UX6PlayerMantleComponent::DrawDebugTypeCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MaxDeflectionYawAngleCfg) == 0x000390, "Member 'UX6PlayerMantleComponent::MaxDeflectionYawAngleCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, EnableGradCheckCfg) == 0x000394, "Member 'UX6PlayerMantleComponent::EnableGradCheckCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, GradCheckAccuracyCfg) == 0x000398, "Member 'UX6PlayerMantleComponent::GradCheckAccuracyCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MidToHighHeightBoundaryInFallingCfg) == 0x00039C, "Member 'UX6PlayerMantleComponent::MidToHighHeightBoundaryInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, LowToMidHeightBoundaryInFallingCfg) == 0x0003A0, "Member 'UX6PlayerMantleComponent::LowToMidHeightBoundaryInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MinToLowHeightBoundaryInFallingCfg) == 0x0003A4, "Member 'UX6PlayerMantleComponent::MinToLowHeightBoundaryInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MinLedgeHeightInFallingCfg) == 0x0003A8, "Member 'UX6PlayerMantleComponent::MinLedgeHeightInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MaxLedgeHeightInFallingCfg) == 0x0003AC, "Member 'UX6PlayerMantleComponent::MaxLedgeHeightInFallingCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, MinimumLandingAreaSideLengthCfg) == 0x0003B0, "Member 'UX6PlayerMantleComponent::MinimumLandingAreaSideLengthCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, ValidMantleCollisionChannelCfg) == 0x0003B4, "Member 'UX6PlayerMantleComponent::ValidMantleCollisionChannelCfg' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CurrentUpdateTime) == 0x0003B8, "Member 'UX6PlayerMantleComponent::CurrentUpdateTime' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, CanUpdate) == 0x0003BC, "Member 'UX6PlayerMantleComponent::CanUpdate' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, bIsInCooldown) == 0x0003BD, "Member 'UX6PlayerMantleComponent::bIsInCooldown' has a wrong offset!");
static_assert(offsetof(UX6PlayerMantleComponent, bHaveDoneJumpOrFloat) == 0x0003BE, "Member 'UX6PlayerMantleComponent::bHaveDoneJumpOrFloat' has a wrong offset!");

// Class X6Game.ComboInputData_Ability
// 0x0008 (0x0058 - 0x0050)
class UComboInputData_Ability final : public UComboInputData
{
public:
	TSubclassOf<class UGameplayAbility>           Ability;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboInputData_Ability">();
	}
	static class UComboInputData_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboInputData_Ability>();
	}
};
static_assert(alignof(UComboInputData_Ability) == 0x000008, "Wrong alignment on UComboInputData_Ability");
static_assert(sizeof(UComboInputData_Ability) == 0x000058, "Wrong size on UComboInputData_Ability");
static_assert(offsetof(UComboInputData_Ability, Ability) == 0x000050, "Member 'UComboInputData_Ability::Ability' has a wrong offset!");

// Class X6Game.X6HandHeldObjTemplate
// 0x0020 (0x0050 - 0x0030)
class UX6HandHeldObjTemplate final : public UPrimaryDataAsset
{
public:
	struct FInstancedStruct                       LeftHandObj;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FInstancedStruct                       RightHandObj;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HandHeldObjTemplate">();
	}
	static class UX6HandHeldObjTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HandHeldObjTemplate>();
	}
};
static_assert(alignof(UX6HandHeldObjTemplate) == 0x000008, "Wrong alignment on UX6HandHeldObjTemplate");
static_assert(sizeof(UX6HandHeldObjTemplate) == 0x000050, "Wrong size on UX6HandHeldObjTemplate");
static_assert(offsetof(UX6HandHeldObjTemplate, LeftHandObj) == 0x000030, "Member 'UX6HandHeldObjTemplate::LeftHandObj' has a wrong offset!");
static_assert(offsetof(UX6HandHeldObjTemplate, RightHandObj) == 0x000040, "Member 'UX6HandHeldObjTemplate::RightHandObj' has a wrong offset!");

// Class X6Game.X6PathFollowingComponent
// 0x0128 (0x0438 - 0x0310)
class UX6PathFollowingComponent final : public UServerPathFollowingComponent
{
public:
	uint8                                         Pad_310[0xA0];                                     // 0x0310(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseCustomNavLinkMove : 1;                         // 0x03B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisablePhysicsRotationWhenFalling : 1;            // 0x03B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_3B0_2 : 6;                                  // 0x03B0(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_3B1[0x1F];                                     // 0x03B1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_3D0_0 : 3;                                  // 0x03D0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bPerformingCustomLinkMove : 1;                     // 0x03D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStopCheckingReachTargetInNavLink : 1;             // 0x03D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDonNotWalkOffLedgesOnLastSegment : 1;             // 0x03D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableLargeAngleRotationRate : 1;                 // 0x03D0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LargeAngleRotationRate;                            // 0x03D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LargeAngleCos;                                     // 0x03F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x2C];                                     // 0x03F4(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6CharacterMovementComponent*          X6MovementComp;                                    // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCustomNavLinkMoveBase>     CustomNavLinkMoveClass;                            // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                CustomNavLinkMove;                                 // 0x0430(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddReachSegmentDelegate(int32 SegmentIndex, const TDelegate<void(int32 SegmentIndex)>& ReachSegmentDelegate);
	void FinishCustomLinkMove();
	struct FVector GetCurrentTargetPosition();
	bool GetSmoothPathEnable();
	void K2_SetBlockDetectionState(bool bEnable);
	void RemoveCustomNavLinkMove();
	void RemoveReachSegmentDelegate(int32 SegmentIndex, const TDelegate<void(int32 SegmentIndex)>& ReachSegmentDelegate);
	void SetCustomNavLinkMove(class UObject* LinkMove);
	void SetSmoothInterval(float Interval);
	void SetSmoothPathDirectMoveParams(const struct FDirectMoveParams& NewSmoothPathDirectMoveParams);
	void SetSmoothPathEnable(bool bEnable);
	void SetSmoothPathParams(const struct FSmoothPathParams& NewSmoothPathParams);
	void SetTargetMoveSegment(int32 TargetIndex);

	struct FRotator GetFinalRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PathFollowingComponent">();
	}
	static class UX6PathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PathFollowingComponent>();
	}
};
static_assert(alignof(UX6PathFollowingComponent) == 0x000008, "Wrong alignment on UX6PathFollowingComponent");
static_assert(sizeof(UX6PathFollowingComponent) == 0x000438, "Wrong size on UX6PathFollowingComponent");
static_assert(offsetof(UX6PathFollowingComponent, LargeAngleRotationRate) == 0x0003D8, "Member 'UX6PathFollowingComponent::LargeAngleRotationRate' has a wrong offset!");
static_assert(offsetof(UX6PathFollowingComponent, LargeAngleCos) == 0x0003F0, "Member 'UX6PathFollowingComponent::LargeAngleCos' has a wrong offset!");
static_assert(offsetof(UX6PathFollowingComponent, X6MovementComp) == 0x000420, "Member 'UX6PathFollowingComponent::X6MovementComp' has a wrong offset!");
static_assert(offsetof(UX6PathFollowingComponent, CustomNavLinkMoveClass) == 0x000428, "Member 'UX6PathFollowingComponent::CustomNavLinkMoveClass' has a wrong offset!");
static_assert(offsetof(UX6PathFollowingComponent, CustomNavLinkMove) == 0x000430, "Member 'UX6PathFollowingComponent::CustomNavLinkMove' has a wrong offset!");

// Class X6Game.X6GameUserSettings
// 0x0120 (0x0270 - 0x0150)
class UX6GameUserSettings final : public UGameUserSettings
{
public:
	TMulticastInlineDelegate<void(int32 IntParam)> OnSpawnDistanceChangedDelegate;                   // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float FloatParam)> OnAnimCurveMDIParamDistanceChangedDelegate;     // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float FloatParam)> OnT2NPCSpawnRateChangedDelegate;                // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float FloatParam)> OnEnableNPCSimpleLocomotionChangedDelegate;     // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool BoolParam)> OnEnableSkipUpdateAnimationChangedDelegate;       // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 IntParam)> OnAkMaxNumVoicesLimitChangedDelegate;             // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 IntParam)> OnLightedPlayerMaxCountChangedDelegate;           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float FloatParam)> OnX6GamePreLoadPoolMemoryThresholdScalarChanged; // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 LastCPUBrand;                                      // 0x01E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastGPUBrand;                                      // 0x01F0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBloom;                                         // 0x0200(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMotionBlur;                                    // 0x0201(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAmbientOcclusion;                              // 0x0202(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGUSAntiAliasingMethod                        AntiAliasingMethod;                                // 0x0203(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGlobalIlluminationMethod                     GlobalIlluminationMethod;                          // 0x0204(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESceneDetailMode                              SceneDetailMode;                                   // 0x0205(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUpScaleMode                                  UpscaleMode;                                       // 0x0206(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_207[0x1];                                      // 0x0207(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomUpscaleRate;                                 // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         X6SaveDataVersion;                                 // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        UIResolutionSizeX;                                 // 0x0210(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        UIResolutionSizeY;                                 // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastCPUBenchmarkMultiplier;                        // 0x0218(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         X6DisplayGamma;                                    // 0x021C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MobileContentScaleFactor;                          // 0x0220(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRayTracingReflections;                         // 0x0224(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRayTracingAmbientOcclusion;                    // 0x0225(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRayTracingEnableInGame;                        // 0x0226(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_227[0x1];                                      // 0x0227(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastMaterialQualityLevel;                          // 0x0228(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x44];                                     // 0x022C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyResolutionQualityRate(float ResolutionQualityRate);
	int32 GetAkMaxNumVoicesLimit();
	float GetAnimCurveMDIParamDistance();
	bool GetBenchmarkResultFromDeviceList();
	float GetCustomUpScaleRate();
	bool GetEnableAbilityPreload();
	bool GetEnableAllPreloadFeature();
	bool GetEnableClothesPreload();
	bool GetEnableCombatPreload();
	bool GetEnableDressupFeature();
	bool GetEnableGraphPreload();
	bool GetEnableNPCSimpleLocomotion();
	bool GetEnableObjectPoolPreCreate();
	bool GetEnableRewardPreload();
	bool GetEnableSkipUpdateAnimation();
	bool GetEnableSoundPreload();
	int32 GetLightedPlayerMaxCount();
	int32 GetMaxRefreshRate();
	float GetObjectPoolMemoryThreshold();
	float GetPreLoadPoolMemoryThresholdScalar();
	float GetResolutionQualityForScreenSize(float Width, float Height, bool bUseFullScreen);
	float GetResolutionQualityRate(EGUSAntiAliasingMethod AntiAliasingMethod_0);
	int32 GetSpawnDistance();
	float GetT2NPCSpawnRate();
	float GetTotalPhysicalGB();
	struct FIntPoint GetUIResolution();
	float GetX6DisplayGamma();
	struct FRecommendQualityLevels GetX6RecommendQuality();
	void SetAmbientOcclusionEnabled(bool bEnable);
	void SetAntiAliasingMethod(EGUSAntiAliasingMethod Value);
	void SetBloomEnabled(bool bEnable);
	void SetCustomUpScaleRate(float InValue);
	void SetDefaultFrameRateFromIni(int32 DeviceLevel);
	void SetGlobalIlluminationMethod(EGlobalIlluminationMethod Value);
	void SetGlobalIlluminationMethodCVar(EGlobalIlluminationMethod Value);
	void SetLastCPUBenchmarkResult(float Val);
	void SetLastGPUBenchmarkResult(float Val);
	void SetMobileContentScaleFactor(float Value);
	void SetMotionBlurEnabled(bool bEnable);
	void SetRayTracingAmbientOcclusionEnable(bool IsEnable);
	void SetRayTracingEnableInGame(bool IsEnable);
	void SetRayTracingReflectionEnable(bool IsEnable);
	void SetSceneDetailMode(ESceneDetailMode Value);
	void SetSceneDetailModeCVar(ESceneDetailMode Value);
	void SetSecondaryUpscaleCVar(float Value);
	void SetUIResolution(const struct FIntPoint& Resolution);
	void SetUpScaleMode(EUpScaleMode InMode);
	void SetX6DisplayGamma(float NewGamma);
	void SetX6RecommendQuality();
	void SetX6SaveDataVersion(int32 InVersion);

	EGUSAntiAliasingMethod GetAntiAliasingMethod() const;
	struct FIntPoint GetDesiredScreenResolution() const;
	EGlobalIlluminationMethod GetGlobalIlluminationMethod() const;
	float GetMobileContentScaleFactorValue() const;
	ESceneDetailMode GetSceneDetailMode() const;
	EUpScaleMode GetUpScaleMode() const;
	int32 GetX6SaveDataVersion() const;
	bool IsAmbientOcclusionEnabled() const;
	bool IsBloomEnabled() const;
	bool IsMotionBlurEnabled() const;
	bool IsRayTracingAmbientOcclusionEnabled() const;
	bool IsRayTracingEnableInGame() const;
	bool IsRayTracingReflectionsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameUserSettings">();
	}
	static class UX6GameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameUserSettings>();
	}
};
static_assert(alignof(UX6GameUserSettings) == 0x000008, "Wrong alignment on UX6GameUserSettings");
static_assert(sizeof(UX6GameUserSettings) == 0x000270, "Wrong size on UX6GameUserSettings");
static_assert(offsetof(UX6GameUserSettings, OnSpawnDistanceChangedDelegate) == 0x000150, "Member 'UX6GameUserSettings::OnSpawnDistanceChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnAnimCurveMDIParamDistanceChangedDelegate) == 0x000160, "Member 'UX6GameUserSettings::OnAnimCurveMDIParamDistanceChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnT2NPCSpawnRateChangedDelegate) == 0x000170, "Member 'UX6GameUserSettings::OnT2NPCSpawnRateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnEnableNPCSimpleLocomotionChangedDelegate) == 0x000180, "Member 'UX6GameUserSettings::OnEnableNPCSimpleLocomotionChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnEnableSkipUpdateAnimationChangedDelegate) == 0x000190, "Member 'UX6GameUserSettings::OnEnableSkipUpdateAnimationChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnAkMaxNumVoicesLimitChangedDelegate) == 0x0001A0, "Member 'UX6GameUserSettings::OnAkMaxNumVoicesLimitChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnLightedPlayerMaxCountChangedDelegate) == 0x0001B0, "Member 'UX6GameUserSettings::OnLightedPlayerMaxCountChangedDelegate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, OnX6GamePreLoadPoolMemoryThresholdScalarChanged) == 0x0001D0, "Member 'UX6GameUserSettings::OnX6GamePreLoadPoolMemoryThresholdScalarChanged' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, LastCPUBrand) == 0x0001E0, "Member 'UX6GameUserSettings::LastCPUBrand' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, LastGPUBrand) == 0x0001F0, "Member 'UX6GameUserSettings::LastGPUBrand' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, bUseBloom) == 0x000200, "Member 'UX6GameUserSettings::bUseBloom' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, bUseMotionBlur) == 0x000201, "Member 'UX6GameUserSettings::bUseMotionBlur' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, bUseAmbientOcclusion) == 0x000202, "Member 'UX6GameUserSettings::bUseAmbientOcclusion' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, AntiAliasingMethod) == 0x000203, "Member 'UX6GameUserSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, GlobalIlluminationMethod) == 0x000204, "Member 'UX6GameUserSettings::GlobalIlluminationMethod' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, SceneDetailMode) == 0x000205, "Member 'UX6GameUserSettings::SceneDetailMode' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, UpscaleMode) == 0x000206, "Member 'UX6GameUserSettings::UpscaleMode' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, CustomUpscaleRate) == 0x000208, "Member 'UX6GameUserSettings::CustomUpscaleRate' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, X6SaveDataVersion) == 0x00020C, "Member 'UX6GameUserSettings::X6SaveDataVersion' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, UIResolutionSizeX) == 0x000210, "Member 'UX6GameUserSettings::UIResolutionSizeX' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, UIResolutionSizeY) == 0x000214, "Member 'UX6GameUserSettings::UIResolutionSizeY' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, LastCPUBenchmarkMultiplier) == 0x000218, "Member 'UX6GameUserSettings::LastCPUBenchmarkMultiplier' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, X6DisplayGamma) == 0x00021C, "Member 'UX6GameUserSettings::X6DisplayGamma' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, MobileContentScaleFactor) == 0x000220, "Member 'UX6GameUserSettings::MobileContentScaleFactor' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, bUseRayTracingReflections) == 0x000224, "Member 'UX6GameUserSettings::bUseRayTracingReflections' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, bUseRayTracingAmbientOcclusion) == 0x000225, "Member 'UX6GameUserSettings::bUseRayTracingAmbientOcclusion' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, bUseRayTracingEnableInGame) == 0x000226, "Member 'UX6GameUserSettings::bUseRayTracingEnableInGame' has a wrong offset!");
static_assert(offsetof(UX6GameUserSettings, LastMaterialQualityLevel) == 0x000228, "Member 'UX6GameUserSettings::LastMaterialQualityLevel' has a wrong offset!");

// Class X6Game.X6GameViewportClient
// 0x0090 (0x0458 - 0x03C8)
class UX6GameViewportClient final : public UGameViewportClient
{
public:
	TMulticastInlineDelegate<void()>              OnFadeinFinishEvent;                               // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x80];                                     // 0x03D8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameViewportClient">();
	}
	static class UX6GameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameViewportClient>();
	}
};
static_assert(alignof(UX6GameViewportClient) == 0x000008, "Wrong alignment on UX6GameViewportClient");
static_assert(sizeof(UX6GameViewportClient) == 0x000458, "Wrong size on UX6GameViewportClient");
static_assert(offsetof(UX6GameViewportClient, OnFadeinFinishEvent) == 0x0003C8, "Member 'UX6GameViewportClient::OnFadeinFinishEvent' has a wrong offset!");

// Class X6Game.X6GeneralAnimationDataComponent
// 0x0200 (0x02A8 - 0x00A8)
class UX6GeneralAnimationDataComponent final : public UX6ActorComponent
{
public:
	class AX6CharacterBase*                       X6CharacterOwner;                                  // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnCharacterSituationTypeUpdated;                   // 0x00B0(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECharacterSituationType>                 CurrentSituationTypes;                             // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPublic)
	float                                         CurrentWaterDepth;                                 // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RegularMovementBaseVelocity;                       // 0x0110(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6CharacterMovementComponent*          X6CharacterMovementComponent;                      // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableSlopeCalculate;                             // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightTraceOffset;                                  // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardTraceOffset;                                // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x14];                                     // 0x013C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDamiaoInFollowFloat;                              // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamiaoCacheTargetLocation;                         // 0x0158(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDaMiaoDisableIdleBreak;                           // 0x0170(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLookAtValid;                                    // 0x0171(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAimOffsetIfValid;                             // 0x0172(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173[0x5];                                      // 0x0173(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtLocation;                                    // 0x0178(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffsetDeadZone;                                 // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetAlpha;                                    // 0x01A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EyeOffsetRotator_BoneSpace;                        // 0x01A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EyeBlinkWeight;                                    // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULookAtLogicHandler*                    LookAtLogicHandler;                                // 0x01C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullAnimAdditiveWeight;                            // 0x01D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseAOHead;                                    // 0x01D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseAimOffset;                                   // 0x01D5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomAOSmoothingTime;                            // 0x01D6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7[0x1];                                      // 0x01D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AOSmoothingTime;                                   // 0x01D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnEyeBlinkEnd;                                     // 0x01DC(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SaccadeAnim;                                       // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          GazeDiversionAnim_L;                               // 0x01E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          GazeDiversionAnim_R;                               // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCharacterIsLookAtChanged;                        // 0x01F8(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnLookAtTargetRefreshed;                           // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ULookAtLogicHandler>        LookAtLogicHandlerClass;                           // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            EyeBlinkCurve;                                     // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UObject>                 LocomotionRequestObject;                           // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocomotionDataContainerBase*           LocomotionDataContainer;                           // 0x0228(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x3C];                                     // 0x0230(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableClothBoneFollow : 1;                        // 0x026C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bStylizedDressIK;                                  // 0x026D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FT2MovableNPCFeetIKInfo                T2MovableNPCFeetIKInfo;                            // 0x0270(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void AddSituationType(ECharacterSituationType NewSituationType);
	class ULocomotionDataContainerBase* InitializeLocomotionDataContainer(TSubclassOf<class ULocomotionDataContainerBase> LocomotionDataContainerClass);
	void OnLocomotionTurnInPlaceFinished();
	void RemoveSituationType(ECharacterSituationType NewSituationType);
	void SetCurrentWaterDepth(float NewWaterDepth);
	void SetDamiaoInFollowFloat(bool FollowFloat);
	void SetDamiaoTargetLocation(const struct FVector& TargetLoc);
	void SetEnableSlopeCalculate(bool bNewEnable);
	void SetLocomotionRequestObject(class UObject* InObject);
	bool TurnInPlaceByAngle(const float TurnAngle, const TDelegate<void()>& OnComplete, const TDelegate<void()>& OnInterrupt);

	float GetCurrentWaterDepth() const;
	float GetForwardSlopeAngle() const;
	bool GetLocomotionCanEverTurnInPlace() const;
	struct FVector GetRegularMovementBaseVelocity() const;
	float GetRightSlopeAngle() const;
	bool HasSituationType(ECharacterSituationType NewSituationType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GeneralAnimationDataComponent">();
	}
	static class UX6GeneralAnimationDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GeneralAnimationDataComponent>();
	}
};
static_assert(alignof(UX6GeneralAnimationDataComponent) == 0x000008, "Wrong alignment on UX6GeneralAnimationDataComponent");
static_assert(sizeof(UX6GeneralAnimationDataComponent) == 0x0002A8, "Wrong size on UX6GeneralAnimationDataComponent");
static_assert(offsetof(UX6GeneralAnimationDataComponent, X6CharacterOwner) == 0x0000A8, "Member 'UX6GeneralAnimationDataComponent::X6CharacterOwner' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, OnCharacterSituationTypeUpdated) == 0x0000B0, "Member 'UX6GeneralAnimationDataComponent::OnCharacterSituationTypeUpdated' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, CurrentSituationTypes) == 0x0000B8, "Member 'UX6GeneralAnimationDataComponent::CurrentSituationTypes' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, CurrentWaterDepth) == 0x000108, "Member 'UX6GeneralAnimationDataComponent::CurrentWaterDepth' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, RegularMovementBaseVelocity) == 0x000110, "Member 'UX6GeneralAnimationDataComponent::RegularMovementBaseVelocity' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, X6CharacterMovementComponent) == 0x000128, "Member 'UX6GeneralAnimationDataComponent::X6CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bEnableSlopeCalculate) == 0x000130, "Member 'UX6GeneralAnimationDataComponent::bEnableSlopeCalculate' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, RightTraceOffset) == 0x000134, "Member 'UX6GeneralAnimationDataComponent::RightTraceOffset' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, ForwardTraceOffset) == 0x000138, "Member 'UX6GeneralAnimationDataComponent::ForwardTraceOffset' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bDamiaoInFollowFloat) == 0x000150, "Member 'UX6GeneralAnimationDataComponent::bDamiaoInFollowFloat' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, DamiaoCacheTargetLocation) == 0x000158, "Member 'UX6GeneralAnimationDataComponent::DamiaoCacheTargetLocation' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bDaMiaoDisableIdleBreak) == 0x000170, "Member 'UX6GeneralAnimationDataComponent::bDaMiaoDisableIdleBreak' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bIsLookAtValid) == 0x000171, "Member 'UX6GeneralAnimationDataComponent::bIsLookAtValid' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bShowAimOffsetIfValid) == 0x000172, "Member 'UX6GeneralAnimationDataComponent::bShowAimOffsetIfValid' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, LookAtLocation) == 0x000178, "Member 'UX6GeneralAnimationDataComponent::LookAtLocation' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, AimOffsetDeadZone) == 0x000190, "Member 'UX6GeneralAnimationDataComponent::AimOffsetDeadZone' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, AimOffsetAlpha) == 0x0001A0, "Member 'UX6GeneralAnimationDataComponent::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, EyeOffsetRotator_BoneSpace) == 0x0001A8, "Member 'UX6GeneralAnimationDataComponent::EyeOffsetRotator_BoneSpace' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, EyeBlinkWeight) == 0x0001C0, "Member 'UX6GeneralAnimationDataComponent::EyeBlinkWeight' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, LookAtLogicHandler) == 0x0001C8, "Member 'UX6GeneralAnimationDataComponent::LookAtLogicHandler' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, FullAnimAdditiveWeight) == 0x0001D0, "Member 'UX6GeneralAnimationDataComponent::FullAnimAdditiveWeight' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bOnlyUseAOHead) == 0x0001D4, "Member 'UX6GeneralAnimationDataComponent::bOnlyUseAOHead' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bPauseAimOffset) == 0x0001D5, "Member 'UX6GeneralAnimationDataComponent::bPauseAimOffset' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bCustomAOSmoothingTime) == 0x0001D6, "Member 'UX6GeneralAnimationDataComponent::bCustomAOSmoothingTime' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, AOSmoothingTime) == 0x0001D8, "Member 'UX6GeneralAnimationDataComponent::AOSmoothingTime' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, OnEyeBlinkEnd) == 0x0001DC, "Member 'UX6GeneralAnimationDataComponent::OnEyeBlinkEnd' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, SaccadeAnim) == 0x0001E0, "Member 'UX6GeneralAnimationDataComponent::SaccadeAnim' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, GazeDiversionAnim_L) == 0x0001E8, "Member 'UX6GeneralAnimationDataComponent::GazeDiversionAnim_L' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, GazeDiversionAnim_R) == 0x0001F0, "Member 'UX6GeneralAnimationDataComponent::GazeDiversionAnim_R' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, OnCharacterIsLookAtChanged) == 0x0001F8, "Member 'UX6GeneralAnimationDataComponent::OnCharacterIsLookAtChanged' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, OnLookAtTargetRefreshed) == 0x000200, "Member 'UX6GeneralAnimationDataComponent::OnLookAtTargetRefreshed' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, LookAtLogicHandlerClass) == 0x000210, "Member 'UX6GeneralAnimationDataComponent::LookAtLogicHandlerClass' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, EyeBlinkCurve) == 0x000218, "Member 'UX6GeneralAnimationDataComponent::EyeBlinkCurve' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, LocomotionRequestObject) == 0x000220, "Member 'UX6GeneralAnimationDataComponent::LocomotionRequestObject' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, LocomotionDataContainer) == 0x000228, "Member 'UX6GeneralAnimationDataComponent::LocomotionDataContainer' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, bStylizedDressIK) == 0x00026D, "Member 'UX6GeneralAnimationDataComponent::bStylizedDressIK' has a wrong offset!");
static_assert(offsetof(UX6GeneralAnimationDataComponent, T2MovableNPCFeetIKInfo) == 0x000270, "Member 'UX6GeneralAnimationDataComponent::T2MovableNPCFeetIKInfo' has a wrong offset!");

// Class X6Game.X6GroundFlyCharacterBase
// 0x0000 (0x08B0 - 0x08B0)
class AX6GroundFlyCharacterBase final : public AX6CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GroundFlyCharacterBase">();
	}
	static class AX6GroundFlyCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6GroundFlyCharacterBase>();
	}
};
static_assert(alignof(AX6GroundFlyCharacterBase) == 0x000010, "Wrong alignment on AX6GroundFlyCharacterBase");
static_assert(sizeof(AX6GroundFlyCharacterBase) == 0x0008B0, "Wrong size on AX6GroundFlyCharacterBase");

// Class X6Game.X6GroundFlyMovementComponent
// 0x0100 (0x15E0 - 0x14E0)
class UX6GroundFlyMovementComponent final : public UX6CharacterMovementComponent
{
public:
	float                                         GroundFlyHeight;                                   // 0x14E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomGroundFlyHeight;                             // 0x14E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceGroundFlyMaxHeight;                           // 0x14E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZMaxSpeed;                                         // 0x14EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZAcceleration;                                     // 0x14F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRootmotionAtAccelerationDirectionInFly;          // 0x14F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRotationInLanding;                               // 0x14F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStraightFlyToEndPath;                            // 0x14F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F7[0x1];                                     // 0x14F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnGroundHeightOffset;                              // 0x14F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNavMeshZOffset;                                 // 0x14FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLandSnapFloor;                                   // 0x1500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1501[0x3];                                     // 0x1501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LandSnapFloorTraceProfileName;                     // 0x1504(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandSnapFloorTraceRadiusFactor;                    // 0x150C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLandSnapMaxHeight;                            // 0x1510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableClimbOver;                                   // 0x1514(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1515[0x3];                                     // 0x1515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbOverHeight;                                   // 0x1518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingHorizontalThreshold;                        // 0x151C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHeightTimeInterval;                           // 0x1520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TracePathEndTimeInterval;                          // 0x1524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EGroundFlyMovementMode PrevMode, EGroundFlyMovementMode CurrentMode)> OnX6GroundFlyMovementModeChanged; // 0x1528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& TargetStopLocation)> OnPathFollowStopEarly;  // 0x1538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1548[0x98];                                    // 0x1548(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetGroundFlyHeight();
	EGroundFlyMovementMode GetMovementArriveMode();
	EGroundFlyMovementMode GetMovementMode();
	float GetTargetModeGroundFlyHeight(EGroundFlyMovementMode TargetMode);
	bool InstantChangeHeight();
	EMovementMode MapGroundFlyMode2MoveMode(EGroundFlyMovementMode TargetMode);
	void SetGroundFlyDefaultMovementMode(EGroundFlyMovementMode TargetMoveMode, EGroundFlyMovementMode TargetArriveMode);
	void SetGroundFlyMovementMode(const struct FGroundFlyMovementSettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GroundFlyMovementComponent">();
	}
	static class UX6GroundFlyMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GroundFlyMovementComponent>();
	}
};
static_assert(alignof(UX6GroundFlyMovementComponent) == 0x000010, "Wrong alignment on UX6GroundFlyMovementComponent");
static_assert(sizeof(UX6GroundFlyMovementComponent) == 0x0015E0, "Wrong size on UX6GroundFlyMovementComponent");
static_assert(offsetof(UX6GroundFlyMovementComponent, GroundFlyHeight) == 0x0014E0, "Member 'UX6GroundFlyMovementComponent::GroundFlyHeight' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, CustomGroundFlyHeight) == 0x0014E4, "Member 'UX6GroundFlyMovementComponent::CustomGroundFlyHeight' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, TraceGroundFlyMaxHeight) == 0x0014E8, "Member 'UX6GroundFlyMovementComponent::TraceGroundFlyMaxHeight' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, ZMaxSpeed) == 0x0014EC, "Member 'UX6GroundFlyMovementComponent::ZMaxSpeed' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, ZAcceleration) == 0x0014F0, "Member 'UX6GroundFlyMovementComponent::ZAcceleration' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, IsRootmotionAtAccelerationDirectionInFly) == 0x0014F4, "Member 'UX6GroundFlyMovementComponent::IsRootmotionAtAccelerationDirectionInFly' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, IsRotationInLanding) == 0x0014F5, "Member 'UX6GroundFlyMovementComponent::IsRotationInLanding' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, IsStraightFlyToEndPath) == 0x0014F6, "Member 'UX6GroundFlyMovementComponent::IsStraightFlyToEndPath' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, OnGroundHeightOffset) == 0x0014F8, "Member 'UX6GroundFlyMovementComponent::OnGroundHeightOffset' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, MaxNavMeshZOffset) == 0x0014FC, "Member 'UX6GroundFlyMovementComponent::MaxNavMeshZOffset' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, IsLandSnapFloor) == 0x001500, "Member 'UX6GroundFlyMovementComponent::IsLandSnapFloor' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, LandSnapFloorTraceProfileName) == 0x001504, "Member 'UX6GroundFlyMovementComponent::LandSnapFloorTraceProfileName' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, LandSnapFloorTraceRadiusFactor) == 0x00150C, "Member 'UX6GroundFlyMovementComponent::LandSnapFloorTraceRadiusFactor' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, TraceLandSnapMaxHeight) == 0x001510, "Member 'UX6GroundFlyMovementComponent::TraceLandSnapMaxHeight' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, EnableClimbOver) == 0x001514, "Member 'UX6GroundFlyMovementComponent::EnableClimbOver' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, ClimbOverHeight) == 0x001518, "Member 'UX6GroundFlyMovementComponent::ClimbOverHeight' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, LandingHorizontalThreshold) == 0x00151C, "Member 'UX6GroundFlyMovementComponent::LandingHorizontalThreshold' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, TraceHeightTimeInterval) == 0x001520, "Member 'UX6GroundFlyMovementComponent::TraceHeightTimeInterval' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, TracePathEndTimeInterval) == 0x001524, "Member 'UX6GroundFlyMovementComponent::TracePathEndTimeInterval' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, OnX6GroundFlyMovementModeChanged) == 0x001528, "Member 'UX6GroundFlyMovementComponent::OnX6GroundFlyMovementModeChanged' has a wrong offset!");
static_assert(offsetof(UX6GroundFlyMovementComponent, OnPathFollowStopEarly) == 0x001538, "Member 'UX6GroundFlyMovementComponent::OnPathFollowStopEarly' has a wrong offset!");

// Class X6Game.X6HardWareBenchmarkBlueprintFunctions
// 0x0000 (0x0028 - 0x0028)
class UX6HardWareBenchmarkBlueprintFunctions final : public UBlueprintFunctionLibrary
{
public:
	static float GetCPUBenchMark(const class FString& InBrandInfo);
	static class FString GetCPUBrand();
	static class FString GetCPUInfo();
	static class FString GetCPUVendor();
	static float GetGPUBenchMark(const class FString& InBrandInfo);
	static class FString GetGPUBrand();
	static bool IsCPUReachedSuggestedVersion(const class FString& InBrandInfo);
	static bool IsCPUReachedTargetVersion(const class FString& InBrandInfo, const class FString& TargetInfo);
	static bool IsGPUReachedSuggestedVersion(const class FString& InBrandInfo);
	static bool IsGPUReachedTargetVersion(const class FString& InBrandInfo, const class FString& TargetInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HardWareBenchmarkBlueprintFunctions">();
	}
	static class UX6HardWareBenchmarkBlueprintFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HardWareBenchmarkBlueprintFunctions>();
	}
};
static_assert(alignof(UX6HardWareBenchmarkBlueprintFunctions) == 0x000008, "Wrong alignment on UX6HardWareBenchmarkBlueprintFunctions");
static_assert(sizeof(UX6HardWareBenchmarkBlueprintFunctions) == 0x000028, "Wrong size on UX6HardWareBenchmarkBlueprintFunctions");

// Class X6Game.X6HeadInfoComponent
// 0x00F0 (0x06B0 - 0x05C0)
class UX6HeadInfoComponent final : public UPrimitiveComponent
{
public:
	class FText                                   Text;                                              // 0x05B8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TextMaterial;                                      // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextScale;                                         // 0x05D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     IconMaterial;                                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              IconSize;                                          // 0x05F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIconVisible;                                      // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     InteractiveIconMaterial;                           // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InteractiveIconSize;                               // 0x0610(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractiveIconVisible;                           // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x17];                                     // 0x0621(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UMaterialInstanceDynamic*>  TextMIDCache;                                      // 0x0638(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x10];                                     // 0x0688(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               IconMID;                                           // 0x0698(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               InteractiveIconMID;                                // 0x06A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x8];                                      // 0x06A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UMaterialInstanceDynamic*> GetAllTextMaterialInstanceDynamic();
	class UMaterialInstanceDynamic* GetIconMaterialInstanceDynamic();
	struct FVector2D GetIconSize();
	class UMaterialInstanceDynamic* GetInteractiveIconMaterialInstanceDynamic();
	struct FVector2D GetInteractiveIconSize();
	class UMaterialInstanceDynamic* GetTextMaterialInstanceDynamic(int32 PageIndex);
	void SetFont(class UFont* InFont);
	void SetIconMaterial(class UMaterialInterface* InIconMaterial);
	void SetIconSize(const struct FVector2D& InIconSize);
	void SetIconVisible(bool Visible);
	void SetInteractiveIconMaterial(class UMaterialInterface* InInteractiveIconMaterial);
	void SetInteractiveIconSize(const struct FVector2D& InInteractiveIconSize);
	void SetInteractiveIconVisible(bool Visible);
	void SetText(const class FText& InText);
	void SetTextMaterial(class UMaterialInterface* InTextMaterial);
	void SetTextScale(const struct FVector2D& InTextScale);
	void SetTimerDelegate(class UCurveFloat* CurveFloat, TDelegate<void(float Time, float Value, bool bFinished)> Delegate);

	struct FVector2D GetTextSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HeadInfoComponent">();
	}
	static class UX6HeadInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HeadInfoComponent>();
	}
};
static_assert(alignof(UX6HeadInfoComponent) == 0x000010, "Wrong alignment on UX6HeadInfoComponent");
static_assert(sizeof(UX6HeadInfoComponent) == 0x0006B0, "Wrong size on UX6HeadInfoComponent");
static_assert(offsetof(UX6HeadInfoComponent, Text) == 0x0005B8, "Member 'UX6HeadInfoComponent::Text' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, TextMaterial) == 0x0005C8, "Member 'UX6HeadInfoComponent::TextMaterial' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, Font) == 0x0005D0, "Member 'UX6HeadInfoComponent::Font' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, TextScale) == 0x0005D8, "Member 'UX6HeadInfoComponent::TextScale' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, IconMaterial) == 0x0005E8, "Member 'UX6HeadInfoComponent::IconMaterial' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, IconSize) == 0x0005F0, "Member 'UX6HeadInfoComponent::IconSize' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, bIconVisible) == 0x000600, "Member 'UX6HeadInfoComponent::bIconVisible' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, InteractiveIconMaterial) == 0x000608, "Member 'UX6HeadInfoComponent::InteractiveIconMaterial' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, InteractiveIconSize) == 0x000610, "Member 'UX6HeadInfoComponent::InteractiveIconSize' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, bInteractiveIconVisible) == 0x000620, "Member 'UX6HeadInfoComponent::bInteractiveIconVisible' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, TextMIDCache) == 0x000638, "Member 'UX6HeadInfoComponent::TextMIDCache' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, IconMID) == 0x000698, "Member 'UX6HeadInfoComponent::IconMID' has a wrong offset!");
static_assert(offsetof(UX6HeadInfoComponent, InteractiveIconMID) == 0x0006A0, "Member 'UX6HeadInfoComponent::InteractiveIconMID' has a wrong offset!");

// Class X6Game.X6HISMManagerSubSystem
// 0x00A8 (0x00D8 - 0x0030)
class UX6HISMManagerSubSystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, class AActor*>            HISMMapData;                                       // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class FString>             InstanceGridDataMap;                               // 0x0080(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FGuid> AddStaticMeshesToHISM(class UStaticMesh* StaticMesh, const TArray<struct FTransform>& Transforms, const TArray<class UMaterialInterface*>& CustomMaterials, TSubclassOf<class UHierarchicalInstancedStaticMeshComponent> InstanceClass);
	struct FGuid AddStaticMeshtoHISM(class UStaticMesh* StaticMesh, const struct FTransform& Transform, TSubclassOf<class UHierarchicalInstancedStaticMeshComponent> InstanceClass);
	struct FGuid AddStaticMeshToHISMV2(class UStaticMesh* StaticMesh, const struct FTransform& Transform, const TArray<class UMaterialInterface*>& CustomMaterials, TSubclassOf<class UHierarchicalInstancedStaticMeshComponent> InstanceClass);
	void DestroyHISMByGuids(const TArray<struct FGuid>& InstanceGuids);
	class UHierarchicalInstancedStaticMeshComponent* GetHISMComponentByGuid(const struct FGuid& Guid);
	class FString GetHISMKeyByGuid(const struct FGuid& Guid);
	float GetMaxDistanceLimit();
	void RemoveInstanceByGuid(class UStaticMesh* StaticMesh, const struct FGuid& InstanceGuid);
	void RemoveInstancesByGuid(const TArray<struct FGuid>& InstanceGuids);
	void RemoveStaticMeshFromHISM(const class FString& HISMKey);
	struct FGuid ReplaceInstanceMaterial(const struct FGuid& Guid, const TArray<class UMaterialInterface*>& NewMaterials);
	void SetHISMCollisionEnabled(const class FString& HISMKey, ECollisionEnabled NewType);
	void SetInstanceCustomDataValue(const struct FGuid& InstanceId, int32 CustomDataIndex, float CustomDataValue, bool bMarkRenderStateDirty);
	void SetMaxDistanceLimit(float limitValue);
	struct FGuid UpdateInstanceTransform(const struct FGuid& InstanceGuid, const struct FTransform& NewTransform, bool bMarkRenderStateDirty, bool bTeleport);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HISMManagerSubSystem">();
	}
	static class UX6HISMManagerSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HISMManagerSubSystem>();
	}
};
static_assert(alignof(UX6HISMManagerSubSystem) == 0x000008, "Wrong alignment on UX6HISMManagerSubSystem");
static_assert(sizeof(UX6HISMManagerSubSystem) == 0x0000D8, "Wrong size on UX6HISMManagerSubSystem");
static_assert(offsetof(UX6HISMManagerSubSystem, HISMMapData) == 0x000030, "Member 'UX6HISMManagerSubSystem::HISMMapData' has a wrong offset!");
static_assert(offsetof(UX6HISMManagerSubSystem, InstanceGridDataMap) == 0x000080, "Member 'UX6HISMManagerSubSystem::InstanceGridDataMap' has a wrong offset!");

// Class X6Game.X6HyperLinkTextBlockDecorator
// 0x0758 (0x0780 - 0x0028)
class UX6HyperLinkTextBlockDecorator : public URichTextBlockDecorator
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHyperlinkStyle                        Style;                                             // 0x0030(0x0750)(Edit, NativeAccessSpecifierPublic)

public:
	void OnLinkClick(const TMap<class FString, class FString>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HyperLinkTextBlockDecorator">();
	}
	static class UX6HyperLinkTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HyperLinkTextBlockDecorator>();
	}
};
static_assert(alignof(UX6HyperLinkTextBlockDecorator) == 0x000010, "Wrong alignment on UX6HyperLinkTextBlockDecorator");
static_assert(sizeof(UX6HyperLinkTextBlockDecorator) == 0x000780, "Wrong size on UX6HyperLinkTextBlockDecorator");
static_assert(offsetof(UX6HyperLinkTextBlockDecorator, Style) == 0x000030, "Member 'UX6HyperLinkTextBlockDecorator::Style' has a wrong offset!");

// Class X6Game.X6InputProcessorHelper
// 0x0010 (0x0038 - 0x0028)
class UX6InputProcessorHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindAnalogInputEvent(TDelegate<void(const struct FAnalogInputEvent& AnalogInputEvent)> InOnAnalogInput, int32 InPriority);
	void BindGestureEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnGesture, int32 InPriority);
	void BindInputDeviceEvent(TDelegate<void(EX6InputDeviceKeyType InputDeviceKeyType)> InOnInputDevice);
	void BindKeyDownEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyDown, int32 InPriority);
	void BindKeyUpEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyUp, int32 InPriority);
	void BindMotionDetectedEvent(TDelegate<void(const struct FMotionEvent& MotionEvent)> InOnMotionDetected, int32 InPriority);
	void BindMouseButtonDoubleClickEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDoubleClick, int32 InPriority);
	void BindMouseButtonDownEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDown, int32 InPriority);
	void BindMouseButtonUpEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonUp, int32 InPriority);
	void BindMouseMoveEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseMove, int32 InPriority);
	void BindMouseWheelEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseWheel, int32 InPriority);
	EX6InputDeviceKeyType GetCurInputDeviceKeyType();
	bool GetMouseResponseDisabled();
	void SetInputDeviceIgnoreValue(float InInputDeviceIgnoreValue);
	bool SetMouseResponseDisabled(bool bDisable);
	void UnbindAnalogInputEvent(TDelegate<void(const struct FAnalogInputEvent& AnalogInputEvent)> InOnAnalogInput, int32 InPriority);
	void UnbindGestureEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnGesture, int32 InPriority);
	void UnbindInputDeviceEvent(TDelegate<void(EX6InputDeviceKeyType InputDeviceKeyType)> InOnInputDevice);
	void UnbindKeyDownEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyDown, int32 InPriority);
	void UnbindKeyUpEvent(TDelegate<void(const struct FKeyEvent& KeyEvent)> InOnKeyUp, int32 InPriority);
	void UnbindMotionDetectedEvent(TDelegate<void(const struct FMotionEvent& MotionEvent)> InOnMotionDetected, int32 InPriority);
	void UnbindMouseButtonDoubleClickEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDoubleClick, int32 InPriority);
	void UnbindMouseButtonDownEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonDown, int32 InPriority);
	void UnbindMouseButtonUpEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseButtonUp, int32 InPriority);
	void UnbindMouseMoveEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseMove, int32 InPriority);
	void UnbindMouseWheelEvent(TDelegate<void(const struct FPointerEvent& MouseEvent)> InOnMouseWheel, int32 InPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6InputProcessorHelper">();
	}
	static class UX6InputProcessorHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6InputProcessorHelper>();
	}
};
static_assert(alignof(UX6InputProcessorHelper) == 0x000008, "Wrong alignment on UX6InputProcessorHelper");
static_assert(sizeof(UX6InputProcessorHelper) == 0x000038, "Wrong size on UX6InputProcessorHelper");

// Class X6Game.X6InputTouchDelegateBinding
// 0x00B8 (0x00E0 - 0x0028)
class UX6InputTouchDelegateBinding final : public UInputDelegateBinding
{
public:
	TArray<struct FX6BlueprintInputTouchDelegateBinding> InputTouchDelegateBindings;                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInputTouch_0(ETouchIndex FingerIndex, const struct FVector& Location);
	void HandleInputTouch_1(ETouchIndex FingerIndex, const struct FVector& Location);
	void HandleInputTouch_2(ETouchIndex FingerIndex, const struct FVector& Location);
	void HandleInputTouch_3(ETouchIndex FingerIndex, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6InputTouchDelegateBinding">();
	}
	static class UX6InputTouchDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6InputTouchDelegateBinding>();
	}
};
static_assert(alignof(UX6InputTouchDelegateBinding) == 0x000008, "Wrong alignment on UX6InputTouchDelegateBinding");
static_assert(sizeof(UX6InputTouchDelegateBinding) == 0x0000E0, "Wrong size on UX6InputTouchDelegateBinding");
static_assert(offsetof(UX6InputTouchDelegateBinding, InputTouchDelegateBindings) == 0x000028, "Member 'UX6InputTouchDelegateBinding::InputTouchDelegateBindings' has a wrong offset!");

// Class X6Game.InteractSlotDataAsset
// 0x0000 (0x0030 - 0x0030)
class UInteractSlotDataAsset final : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractSlotDataAsset">();
	}
	static class UInteractSlotDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractSlotDataAsset>();
	}
};
static_assert(alignof(UInteractSlotDataAsset) == 0x000008, "Wrong alignment on UInteractSlotDataAsset");
static_assert(sizeof(UInteractSlotDataAsset) == 0x000030, "Wrong size on UInteractSlotDataAsset");

// Class X6Game.X6InteractiveActorComponent
// 0x0088 (0x0130 - 0x00A8)
class UX6InteractiveActorComponent final : public UX6ActorComponent
{
public:
	TArray<struct FInteractSlotDefinition>        Slots;                                             // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FVector                                InteractWidgetOffset;                              // 0x00B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                InteractPointWidgetOffset;                         // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InteractWidgetAttachSocketName;                    // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InteractWidgetAttachComponentTag;                  // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ChatBubbleActive;                                  // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChatBubbleSlotDefinition              ChatBubbleSlot;                                    // 0x0100(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void BakeArrowsToSlot(TSubclassOf<class UObject> ObjectClass);

	struct FChatBubbleSlotDefinition GetChatBubbleSlot() const;
	int32 GetNearestSlotIndex(const struct FVector& TargetLocation) const;
	struct FTransform GetSlotTransform(const int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6InteractiveActorComponent">();
	}
	static class UX6InteractiveActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6InteractiveActorComponent>();
	}
};
static_assert(alignof(UX6InteractiveActorComponent) == 0x000008, "Wrong alignment on UX6InteractiveActorComponent");
static_assert(sizeof(UX6InteractiveActorComponent) == 0x000130, "Wrong size on UX6InteractiveActorComponent");
static_assert(offsetof(UX6InteractiveActorComponent, Slots) == 0x0000A8, "Member 'UX6InteractiveActorComponent::Slots' has a wrong offset!");
static_assert(offsetof(UX6InteractiveActorComponent, InteractWidgetOffset) == 0x0000B8, "Member 'UX6InteractiveActorComponent::InteractWidgetOffset' has a wrong offset!");
static_assert(offsetof(UX6InteractiveActorComponent, InteractPointWidgetOffset) == 0x0000D0, "Member 'UX6InteractiveActorComponent::InteractPointWidgetOffset' has a wrong offset!");
static_assert(offsetof(UX6InteractiveActorComponent, InteractWidgetAttachSocketName) == 0x0000E8, "Member 'UX6InteractiveActorComponent::InteractWidgetAttachSocketName' has a wrong offset!");
static_assert(offsetof(UX6InteractiveActorComponent, InteractWidgetAttachComponentTag) == 0x0000F0, "Member 'UX6InteractiveActorComponent::InteractWidgetAttachComponentTag' has a wrong offset!");
static_assert(offsetof(UX6InteractiveActorComponent, ChatBubbleActive) == 0x0000F8, "Member 'UX6InteractiveActorComponent::ChatBubbleActive' has a wrong offset!");
static_assert(offsetof(UX6InteractiveActorComponent, ChatBubbleSlot) == 0x000100, "Member 'UX6InteractiveActorComponent::ChatBubbleSlot' has a wrong offset!");

// Class X6Game.X6LevelSequencePreLoadObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IX6LevelSequencePreLoadObjectInterface final : public IInterface
{
public:
	void StartLoad(const class FString& LevelSequenceName, const TArray<struct FLoadProperty>& LoadProperties);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6LevelSequencePreLoadObjectInterface">();
	}
	static class IX6LevelSequencePreLoadObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6LevelSequencePreLoadObjectInterface>();
	}
};
static_assert(alignof(IX6LevelSequencePreLoadObjectInterface) == 0x000001, "Wrong alignment on IX6LevelSequencePreLoadObjectInterface");
static_assert(sizeof(IX6LevelSequencePreLoadObjectInterface) == 0x000001, "Wrong size on IX6LevelSequencePreLoadObjectInterface");

// Class X6Game.X6LevelSequencePreLoadSectionInterface
// 0x0000 (0x0000 - 0x0000)
class IX6LevelSequencePreLoadSectionInterface final : public IInterface
{
public:
	void StartLoad(const class FString& LevelSequenceName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6LevelSequencePreLoadSectionInterface">();
	}
	static class IX6LevelSequencePreLoadSectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6LevelSequencePreLoadSectionInterface>();
	}
};
static_assert(alignof(IX6LevelSequencePreLoadSectionInterface) == 0x000001, "Wrong alignment on IX6LevelSequencePreLoadSectionInterface");
static_assert(sizeof(IX6LevelSequencePreLoadSectionInterface) == 0x000001, "Wrong size on IX6LevelSequencePreLoadSectionInterface");

// Class X6Game.X6ListViewItem
// 0x0008 (0x0030 - 0x0028)
class UX6ListViewItem final : public UObject
{
public:
	int32                                         ItemIndex;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ListViewItem">();
	}
	static class UX6ListViewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ListViewItem>();
	}
};
static_assert(alignof(UX6ListViewItem) == 0x000008, "Wrong alignment on UX6ListViewItem");
static_assert(sizeof(UX6ListViewItem) == 0x000030, "Wrong size on UX6ListViewItem");
static_assert(offsetof(UX6ListViewItem, ItemIndex) == 0x000028, "Member 'UX6ListViewItem::ItemIndex' has a wrong offset!");

// Class X6Game.X6UserObjectListEntry
// 0x0000 (0x0000 - 0x0000)
class IX6UserObjectListEntry final : public IUserListEntry
{
public:
	void OnListItemObjectSetViaIndex(int32 Index_0);
	void OnListItemValueChangedViaIndex(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6UserObjectListEntry">();
	}
	static class IX6UserObjectListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<IX6UserObjectListEntry>();
	}
};
static_assert(alignof(IX6UserObjectListEntry) == 0x000001, "Wrong alignment on IX6UserObjectListEntry");
static_assert(sizeof(IX6UserObjectListEntry) == 0x000001, "Wrong size on IX6UserObjectListEntry");

// Class X6Game.X6ListView
// 0x0790 (0x1440 - 0x0CB0)
#pragma pack(push, 0x1)
class alignas(0x10) UX6ListView : public UListView
{
public:
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x0CB0(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasMask;                                          // 0x1420(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1421[0x3];                                     // 0x1421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopMaskParameterName;                              // 0x1424(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomMaskParameterName;                           // 0x142C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1434[0x4];                                     // 0x1434(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAnItem();
	void BP_NavigateToItemIndex(int32 ItemIndex);
	void BP_OnListItemValueChanged(int32 Index_0);
	void BP_ScrollItemIndexIntoView(int32 ItemIndex);
	void BP_SetItemSelectionByIndex(int32 Index_0, bool bSelected);
	void BP_SetListItemCount(int32 Count);
	void BP_SetSelectedItemByIndex(int32 Index_0);
	void RemoveItemByIndex(int32 Index_0);
	void SetOverriddenItemLength(int32 Index_0, double Value);
	void SetOverriddenItemLengthByArray(TArray<float>* ItemsLength, bool bClearOldData);
	void SetOverriddenTotalLength(double TotalLength);
	void SetScrollBarAlwaysVisible(bool bAlwaysShowScrollbar);
	void SetScrollBarTrackAlwaysVisible(bool bAlwaysShowScrollbarTrack);
	void SetScrollSizeNotBaseOnNumLines(bool bNotBaseOnNumLines);

	int32 BP_GetSelectedIndex() const;
	bool BP_GetSelectedItemsViaIndex(TArray<int32>* Items) const;
	bool BP_IsItemVisibleByIndex(int32 Index_0) const;
	float GetScrollDistance() const;
	float GetScrollDistanceRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ListView">();
	}
	static class UX6ListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ListView>();
	}
};
#pragma pack(pop)
static_assert(alignof(UX6ListView) == 0x000010, "Wrong alignment on UX6ListView");
static_assert(sizeof(UX6ListView) == 0x001440, "Wrong size on UX6ListView");
static_assert(offsetof(UX6ListView, WidgetBarStyle) == 0x000CB0, "Member 'UX6ListView::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UX6ListView, bHasMask) == 0x001420, "Member 'UX6ListView::bHasMask' has a wrong offset!");
static_assert(offsetof(UX6ListView, TopMaskParameterName) == 0x001424, "Member 'UX6ListView::TopMaskParameterName' has a wrong offset!");
static_assert(offsetof(UX6ListView, BottomMaskParameterName) == 0x00142C, "Member 'UX6ListView::BottomMaskParameterName' has a wrong offset!");

// Class X6Game.X6LocalizationSettings
// 0x0060 (0x0088 - 0x0028)
class UX6LocalizationSettings final : public UObject
{
public:
	TArray<struct FDirectoryPath>                 MouthShapePaths;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FString, struct FAreaInfo>         AreaMap;                                           // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static const class UX6LocalizationSettings* GetX6LocalizationSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6LocalizationSettings">();
	}
	static class UX6LocalizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6LocalizationSettings>();
	}
};
static_assert(alignof(UX6LocalizationSettings) == 0x000008, "Wrong alignment on UX6LocalizationSettings");
static_assert(sizeof(UX6LocalizationSettings) == 0x000088, "Wrong size on UX6LocalizationSettings");
static_assert(offsetof(UX6LocalizationSettings, MouthShapePaths) == 0x000028, "Member 'UX6LocalizationSettings::MouthShapePaths' has a wrong offset!");
static_assert(offsetof(UX6LocalizationSettings, AreaMap) == 0x000038, "Member 'UX6LocalizationSettings::AreaMap' has a wrong offset!");

// Class X6Game.X6MapHudBase
// 0x0068 (0x0358 - 0x02F0)
class UX6MapHudBase final : public UUserWidget
{
public:
	double                                        nt_lastTime;                                       // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_cDeltaTime;                                     // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_minMapRootX;                                    // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_maxMapRootX;                                    // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_minMapRootY;                                    // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_maxMapRootY;                                    // 0x0318(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_customConstrainOffsetLeft;                      // 0x0320(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_customConstrainOffsetTop;                       // 0x0328(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_customConstrainOffsetRight;                     // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        nt_customConstrainOffsetBottom;                    // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          nt_isMoved;                                        // 0x0340(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           MapContent;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MoveRoot;                                          // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NT_CalculateTime();
	void NT_OnPostMoveContentPosition(const struct FVector2D& Pos);
	void NT_PostProcessMapMoveInternalNormal();
	void NT_SetMoveContentPosition(const struct FVector2D& Pos);
	void NT_UpdateMapRootConstraintInfo(const struct FGeometry& Geometry);

	struct FVector2D NT_ConstraintMoveRootPos(const struct FVector2D& originPos) const;
	struct FVector2D NT_ConvertMapPosToWindowPos(const struct FVector2D& mapPos) const;
	struct FVector2D NT_ConvertWindowPosToMapPos(const struct FVector2D& windowPos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6MapHudBase">();
	}
	static class UX6MapHudBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6MapHudBase>();
	}
};
static_assert(alignof(UX6MapHudBase) == 0x000008, "Wrong alignment on UX6MapHudBase");
static_assert(sizeof(UX6MapHudBase) == 0x000358, "Wrong size on UX6MapHudBase");
static_assert(offsetof(UX6MapHudBase, nt_lastTime) == 0x0002F0, "Member 'UX6MapHudBase::nt_lastTime' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_cDeltaTime) == 0x0002F8, "Member 'UX6MapHudBase::nt_cDeltaTime' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_minMapRootX) == 0x000300, "Member 'UX6MapHudBase::nt_minMapRootX' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_maxMapRootX) == 0x000308, "Member 'UX6MapHudBase::nt_maxMapRootX' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_minMapRootY) == 0x000310, "Member 'UX6MapHudBase::nt_minMapRootY' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_maxMapRootY) == 0x000318, "Member 'UX6MapHudBase::nt_maxMapRootY' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_customConstrainOffsetLeft) == 0x000320, "Member 'UX6MapHudBase::nt_customConstrainOffsetLeft' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_customConstrainOffsetTop) == 0x000328, "Member 'UX6MapHudBase::nt_customConstrainOffsetTop' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_customConstrainOffsetRight) == 0x000330, "Member 'UX6MapHudBase::nt_customConstrainOffsetRight' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_customConstrainOffsetBottom) == 0x000338, "Member 'UX6MapHudBase::nt_customConstrainOffsetBottom' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, nt_isMoved) == 0x000340, "Member 'UX6MapHudBase::nt_isMoved' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, MapContent) == 0x000348, "Member 'UX6MapHudBase::MapContent' has a wrong offset!");
static_assert(offsetof(UX6MapHudBase, MoveRoot) == 0x000350, "Member 'UX6MapHudBase::MoveRoot' has a wrong offset!");

// Class X6Game.X6ModularFeaturesContainerComp
// 0x0008 (0x00B0 - 0x00A8)
class UX6ModularFeaturesContainerComp final : public UX6ActorComponent
{
public:
	class UPlayerShadowDecalProcessor*            PlayerShadowDecalProcessor;                        // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UPlayerShadowDecalProcessor* GetPlayerShadowDecalProcessor();
	float K2_GetCurTargetShadowGroundDistance();
	void K2_InitConfigInformation(float MaxTraceDownHeight, float MaxJumpHeight, const struct FVector& ShadowDecalSize, float SphereTraceRadius, class UCurveFloat* Curve_ShadowDecalDistanceMappedToScale2D);
	void K2_InitShadowDynamicMIParam(class FName OpacityParamName, class FName BlurWeightParamName, class FName ScaleParamName);
	void K2_UpdateDecalMaterialInstanceParam(float DeltaSeconds, class ACharacter* OwnerCharacter, class UMaterialInstanceDynamic* ShadowDynamicMI);
	bool K2_UpdateDrawPlayerShadowDecal(float DeltaSeconds, class ACharacter* OwnerCharacter, class USkeletalMeshComponent* SkeletalMeshComponent, class UDecalComponent* DecalComponent, class USceneComponent* ShadowOnWaterPlaneMeshComp);
	bool K2_UpdateDrawPlayerShadowDecal_Mobile(float DeltaSeconds, class ACharacter* OwnerCharacter, class USkeletalMeshComponent* SkeletalMeshComponent, class USceneComponent* CubeMeshComponent, class USceneComponent* ShadowOnWaterPlaneMeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ModularFeaturesContainerComp">();
	}
	static class UX6ModularFeaturesContainerComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ModularFeaturesContainerComp>();
	}
};
static_assert(alignof(UX6ModularFeaturesContainerComp) == 0x000008, "Wrong alignment on UX6ModularFeaturesContainerComp");
static_assert(sizeof(UX6ModularFeaturesContainerComp) == 0x0000B0, "Wrong size on UX6ModularFeaturesContainerComp");
static_assert(offsetof(UX6ModularFeaturesContainerComp, PlayerShadowDecalProcessor) == 0x0000A8, "Member 'UX6ModularFeaturesContainerComp::PlayerShadowDecalProcessor' has a wrong offset!");

// Class X6Game.X6MonsterAnimInstance
// 0x0010 (0x0400 - 0x03F0)
class UX6MonsterAnimInstance final : public UX6AnimInstanceWithTag
{
public:
	TWeakObjectPtr<class UX6CharacterMovementComponent> X6OwnerCharacterMovementComp;                // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UX6RMWalkingComponent>   X6OwnerRMWalkingComp;                              // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimAssetSetEvent();
	void PostOwnerBeginPlay(class AActor* OwnerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6MonsterAnimInstance">();
	}
	static class UX6MonsterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6MonsterAnimInstance>();
	}
};
static_assert(alignof(UX6MonsterAnimInstance) == 0x000010, "Wrong alignment on UX6MonsterAnimInstance");
static_assert(sizeof(UX6MonsterAnimInstance) == 0x000400, "Wrong size on UX6MonsterAnimInstance");
static_assert(offsetof(UX6MonsterAnimInstance, X6OwnerCharacterMovementComp) == 0x0003E8, "Member 'UX6MonsterAnimInstance::X6OwnerCharacterMovementComp' has a wrong offset!");
static_assert(offsetof(UX6MonsterAnimInstance, X6OwnerRMWalkingComp) == 0x0003F0, "Member 'UX6MonsterAnimInstance::X6OwnerRMWalkingComp' has a wrong offset!");

// Class X6Game.X6MultiLineEditableText
// 0x0010 (0x0580 - 0x0570)
class UX6MultiLineEditableText final : public UMultiLineEditableText
{
public:
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextComposed;                          // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetTextWithCursorStay(const class FText& InText);

	bool IsComposing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6MultiLineEditableText">();
	}
	static class UX6MultiLineEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6MultiLineEditableText>();
	}
};
static_assert(alignof(UX6MultiLineEditableText) == 0x000010, "Wrong alignment on UX6MultiLineEditableText");
static_assert(sizeof(UX6MultiLineEditableText) == 0x000580, "Wrong size on UX6MultiLineEditableText");
static_assert(offsetof(UX6MultiLineEditableText, OnTextComposed) == 0x000570, "Member 'UX6MultiLineEditableText::OnTextComposed' has a wrong offset!");

// Class X6Game.X6ReplicateAssetData
// 0x0010 (0x0040 - 0x0030)
class UX6ReplicateAssetData final : public UDataAsset
{
public:
	TArray<struct FSoftObjectPath>                AssetPaths;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ReplicateAssetData">();
	}
	static class UX6ReplicateAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ReplicateAssetData>();
	}
};
static_assert(alignof(UX6ReplicateAssetData) == 0x000008, "Wrong alignment on UX6ReplicateAssetData");
static_assert(sizeof(UX6ReplicateAssetData) == 0x000040, "Wrong size on UX6ReplicateAssetData");
static_assert(offsetof(UX6ReplicateAssetData, AssetPaths) == 0x000030, "Member 'UX6ReplicateAssetData::AssetPaths' has a wrong offset!");

// Class X6Game.X6ReplicateAssetSetting
// 0x0028 (0x0060 - 0x0038)
class UX6ReplicateAssetSetting final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UX6ReplicateAssetData>   GlobalReplicateConfigDataAsset;                    // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ReplicateAssetSetting">();
	}
	static class UX6ReplicateAssetSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ReplicateAssetSetting>();
	}
};
static_assert(alignof(UX6ReplicateAssetSetting) == 0x000008, "Wrong alignment on UX6ReplicateAssetSetting");
static_assert(sizeof(UX6ReplicateAssetSetting) == 0x000060, "Wrong size on UX6ReplicateAssetSetting");
static_assert(offsetof(UX6ReplicateAssetSetting, GlobalReplicateConfigDataAsset) == 0x000038, "Member 'UX6ReplicateAssetSetting::GlobalReplicateConfigDataAsset' has a wrong offset!");

// Class X6Game.X6NavigationRegionComponent
// 0x0050 (0x00F8 - 0x00A8)
class UX6NavigationRegionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateRegionBounds(const struct FVector& Center, const struct FVector& Extent);
	void UpdateRegionFlag(int32 InRegionFlag);
	void UpdateRegionPassableState(bool bPassable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NavigationRegionComponent">();
	}
	static class UX6NavigationRegionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NavigationRegionComponent>();
	}
};
static_assert(alignof(UX6NavigationRegionComponent) == 0x000008, "Wrong alignment on UX6NavigationRegionComponent");
static_assert(sizeof(UX6NavigationRegionComponent) == 0x0000F8, "Wrong size on UX6NavigationRegionComponent");

// Class X6Game.X6NavigationPathPoints
// 0x0028 (0x0050 - 0x0028)
class UX6NavigationPathPoints final : public UObject
{
public:
	TArray<struct FVector>                        PointLocations;                                    // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsPartial;                                        // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x17];                                      // 0x0039(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPathPoint(const struct FVector& Location);
	void InsertPathPoint(const struct FVector& Location, int32 Index_0);
	void RemoveAgentPassedPoints(const class AAIController* Controller);
	void RemovePassedPoints(const struct FVector& CurrentLocation);
	void RemovePathPoint(int32 Index_0);
	void ResetPathPointsHeight(float NewHeight);

	void DrawDebugPath(float Duration, const struct FLinearColor& NormalPathColor, const struct FLinearColor& RoadPathColor, const struct FLinearColor& RoadTransactionColor, const struct FLinearColor& RoadNodeColor, const struct FLinearColor& StartSegmentColor, const struct FLinearColor& EndSegmentColor) const;
	bool IsGeneratedRoadPoint(int32 PointIndex) const;
	bool IsNavLink(int32 PointIndex) const;
	bool IsRoadPoint(int32 PointIndex) const;
	bool IsValidPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NavigationPathPoints">();
	}
	static class UX6NavigationPathPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NavigationPathPoints>();
	}
};
static_assert(alignof(UX6NavigationPathPoints) == 0x000008, "Wrong alignment on UX6NavigationPathPoints");
static_assert(sizeof(UX6NavigationPathPoints) == 0x000050, "Wrong size on UX6NavigationPathPoints");
static_assert(offsetof(UX6NavigationPathPoints, PointLocations) == 0x000028, "Member 'UX6NavigationPathPoints::PointLocations' has a wrong offset!");
static_assert(offsetof(UX6NavigationPathPoints, bIsPartial) == 0x000038, "Member 'UX6NavigationPathPoints::bIsPartial' has a wrong offset!");

// Class X6Game.X6NiagaraEffectParamVector
// 0x0018 (0x0048 - 0x0030)
class UX6NiagaraEffectParamVector final : public UX6NiagaraEffectParam
{
public:
	struct FVector                                Value;                                             // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NiagaraEffectParamVector">();
	}
	static class UX6NiagaraEffectParamVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NiagaraEffectParamVector>();
	}
};
static_assert(alignof(UX6NiagaraEffectParamVector) == 0x000008, "Wrong alignment on UX6NiagaraEffectParamVector");
static_assert(sizeof(UX6NiagaraEffectParamVector) == 0x000048, "Wrong size on UX6NiagaraEffectParamVector");
static_assert(offsetof(UX6NiagaraEffectParamVector, Value) == 0x000030, "Member 'UX6NiagaraEffectParamVector::Value' has a wrong offset!");

// Class X6Game.X6NikkiCPPTickHelperComponent
// 0x01B0 (0x0258 - 0x00A8)
class UX6NikkiCPPTickHelperComponent final : public UX6ActorComponent
{
public:
	bool                                          bUseCustomizeTickGroup;                            // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETickingGroup                                 CustomizeTickGroup;                                // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftFootBoneName;                                  // 0x00AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFootBoneName;                                 // 0x00B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftToesBoneName;                                  // 0x00BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightToesBoneName;                                 // 0x00C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MeshRootBoneName;                                  // 0x00CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftVirtualFootBoneName;                           // 0x00D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightVirtualFootBoneName;                          // 0x00DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftVirtualToesBoneName;                           // 0x00E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightVirtualToesBoneName;                          // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Debug_DrawPointSize;                               // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightfieldOffsetThrehold;                         // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             PlayerCharacter;                                   // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      OwnerCapsuleComponent;                             // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerActor;                                        // 0x0118(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         TraceIngoreActorArray;                             // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x2C];                                     // 0x0130(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurFloorAngle;                                     // 0x015C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FConfigMonitoringPointsWidth;                      // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FConfigMonitoringPointsDeltaHeight;                // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCalculateCurFloorAngleV2Debug;              // 0x0168(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwnerSkeletalMeshComp;                             // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimInstance*                          OwnerAnimInstance;                                 // 0x0178(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x40];                                     // 0x0180(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FootTraceIngoreActorArray;                         // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x29];                                     // 0x01D0(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableAvoidMinorDisturbancesForOriginalFootLocation; // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA[0x6];                                      // 0x01FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DisturbanceThresholdForOriginalFootLocation;       // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPelvisIKOffset;                                 // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionMaxPelvisIKOffset;                       // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeMaxPelvisIKOffsetInterpSpeed;                // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchMovePelvisOffsetSpeed;                       // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeetMaxDistance;                                   // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKTraceUPOffset;                               // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKTraceDownOffset;                             // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKResetLerpSpeed;                              // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKTranceDistanceForAdjustAngle;                // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FConfigMaxPitchAngleForFeetOnTheGround;            // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigMaxPitchAngleForFeetOnIntorsion;             // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FConfigMaxRollAngleForFeetOnTheGround;             // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigMaxRollAngleForFeetOnDownhill;               // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdjustFootAngleByToesAdditionalCheck;       // 0x023C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdjustFootAngleOnlyOneHit;                  // 0x023D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdjustFootLocation;                         // 0x023E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F[0x1];                                      // 0x023F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FConfigMaxAdjustHeight;                            // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFootPlacementIK;                            // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0xF];                                      // 0x0249(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateCurFloorAngleV2(bool bForceUpdate);
	void GeneratedFeetIKFeatureTargetV2(struct FFootIKFeatureTargetDataV2* OutFootIKFeatureTarget);
	struct FHitResult IsLandedGroundWithDeltaInAir();
	void ResetIKOffsets(struct FVector* FootOffsetLLocation, struct FVector* FootOffsetRLocation, struct FRotator* FootOffsetLRotation, struct FRotator* FootOffsetRRotation);
	void ResetPelvisIKOffsets(float* PelvisAlpha, struct FVector* PelvisOffset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NikkiCPPTickHelperComponent">();
	}
	static class UX6NikkiCPPTickHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NikkiCPPTickHelperComponent>();
	}
};
static_assert(alignof(UX6NikkiCPPTickHelperComponent) == 0x000008, "Wrong alignment on UX6NikkiCPPTickHelperComponent");
static_assert(sizeof(UX6NikkiCPPTickHelperComponent) == 0x000258, "Wrong size on UX6NikkiCPPTickHelperComponent");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bUseCustomizeTickGroup) == 0x0000A8, "Member 'UX6NikkiCPPTickHelperComponent::bUseCustomizeTickGroup' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, CustomizeTickGroup) == 0x0000A9, "Member 'UX6NikkiCPPTickHelperComponent::CustomizeTickGroup' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, LeftFootBoneName) == 0x0000AC, "Member 'UX6NikkiCPPTickHelperComponent::LeftFootBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, RightFootBoneName) == 0x0000B4, "Member 'UX6NikkiCPPTickHelperComponent::RightFootBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, LeftToesBoneName) == 0x0000BC, "Member 'UX6NikkiCPPTickHelperComponent::LeftToesBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, RightToesBoneName) == 0x0000C4, "Member 'UX6NikkiCPPTickHelperComponent::RightToesBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, MeshRootBoneName) == 0x0000CC, "Member 'UX6NikkiCPPTickHelperComponent::MeshRootBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, LeftVirtualFootBoneName) == 0x0000D4, "Member 'UX6NikkiCPPTickHelperComponent::LeftVirtualFootBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, RightVirtualFootBoneName) == 0x0000DC, "Member 'UX6NikkiCPPTickHelperComponent::RightVirtualFootBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, LeftVirtualToesBoneName) == 0x0000E4, "Member 'UX6NikkiCPPTickHelperComponent::LeftVirtualToesBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, RightVirtualToesBoneName) == 0x0000EC, "Member 'UX6NikkiCPPTickHelperComponent::RightVirtualToesBoneName' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, Debug_DrawPointSize) == 0x0000F4, "Member 'UX6NikkiCPPTickHelperComponent::Debug_DrawPointSize' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, HeightfieldOffsetThrehold) == 0x0000F8, "Member 'UX6NikkiCPPTickHelperComponent::HeightfieldOffsetThrehold' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, PlayerCharacter) == 0x000100, "Member 'UX6NikkiCPPTickHelperComponent::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, OwnerCapsuleComponent) == 0x000108, "Member 'UX6NikkiCPPTickHelperComponent::OwnerCapsuleComponent' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, OwnerActor) == 0x000118, "Member 'UX6NikkiCPPTickHelperComponent::OwnerActor' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, TraceIngoreActorArray) == 0x000120, "Member 'UX6NikkiCPPTickHelperComponent::TraceIngoreActorArray' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, CurFloorAngle) == 0x00015C, "Member 'UX6NikkiCPPTickHelperComponent::CurFloorAngle' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FConfigMonitoringPointsWidth) == 0x000160, "Member 'UX6NikkiCPPTickHelperComponent::FConfigMonitoringPointsWidth' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FConfigMonitoringPointsDeltaHeight) == 0x000164, "Member 'UX6NikkiCPPTickHelperComponent::FConfigMonitoringPointsDeltaHeight' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bEnableCalculateCurFloorAngleV2Debug) == 0x000168, "Member 'UX6NikkiCPPTickHelperComponent::bEnableCalculateCurFloorAngleV2Debug' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, OwnerSkeletalMeshComp) == 0x000170, "Member 'UX6NikkiCPPTickHelperComponent::OwnerSkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, OwnerAnimInstance) == 0x000178, "Member 'UX6NikkiCPPTickHelperComponent::OwnerAnimInstance' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FootTraceIngoreActorArray) == 0x0001C0, "Member 'UX6NikkiCPPTickHelperComponent::FootTraceIngoreActorArray' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bEnableAvoidMinorDisturbancesForOriginalFootLocation) == 0x0001F9, "Member 'UX6NikkiCPPTickHelperComponent::bEnableAvoidMinorDisturbancesForOriginalFootLocation' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, DisturbanceThresholdForOriginalFootLocation) == 0x000200, "Member 'UX6NikkiCPPTickHelperComponent::DisturbanceThresholdForOriginalFootLocation' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, MaxPelvisIKOffset) == 0x000208, "Member 'UX6NikkiCPPTickHelperComponent::MaxPelvisIKOffset' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, LocomotionMaxPelvisIKOffset) == 0x00020C, "Member 'UX6NikkiCPPTickHelperComponent::LocomotionMaxPelvisIKOffset' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, ChangeMaxPelvisIKOffsetInterpSpeed) == 0x000210, "Member 'UX6NikkiCPPTickHelperComponent::ChangeMaxPelvisIKOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, SwitchMovePelvisOffsetSpeed) == 0x000214, "Member 'UX6NikkiCPPTickHelperComponent::SwitchMovePelvisOffsetSpeed' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FeetMaxDistance) == 0x000218, "Member 'UX6NikkiCPPTickHelperComponent::FeetMaxDistance' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FootIKTraceUPOffset) == 0x00021C, "Member 'UX6NikkiCPPTickHelperComponent::FootIKTraceUPOffset' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FootIKTraceDownOffset) == 0x000220, "Member 'UX6NikkiCPPTickHelperComponent::FootIKTraceDownOffset' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FootIKResetLerpSpeed) == 0x000224, "Member 'UX6NikkiCPPTickHelperComponent::FootIKResetLerpSpeed' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FootIKTranceDistanceForAdjustAngle) == 0x000228, "Member 'UX6NikkiCPPTickHelperComponent::FootIKTranceDistanceForAdjustAngle' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FConfigMaxPitchAngleForFeetOnTheGround) == 0x00022C, "Member 'UX6NikkiCPPTickHelperComponent::FConfigMaxPitchAngleForFeetOnTheGround' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, ConfigMaxPitchAngleForFeetOnIntorsion) == 0x000230, "Member 'UX6NikkiCPPTickHelperComponent::ConfigMaxPitchAngleForFeetOnIntorsion' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FConfigMaxRollAngleForFeetOnTheGround) == 0x000234, "Member 'UX6NikkiCPPTickHelperComponent::FConfigMaxRollAngleForFeetOnTheGround' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, ConfigMaxRollAngleForFeetOnDownhill) == 0x000238, "Member 'UX6NikkiCPPTickHelperComponent::ConfigMaxRollAngleForFeetOnDownhill' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bEnableAdjustFootAngleByToesAdditionalCheck) == 0x00023C, "Member 'UX6NikkiCPPTickHelperComponent::bEnableAdjustFootAngleByToesAdditionalCheck' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bEnableAdjustFootAngleOnlyOneHit) == 0x00023D, "Member 'UX6NikkiCPPTickHelperComponent::bEnableAdjustFootAngleOnlyOneHit' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bEnableAdjustFootLocation) == 0x00023E, "Member 'UX6NikkiCPPTickHelperComponent::bEnableAdjustFootLocation' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, FConfigMaxAdjustHeight) == 0x000240, "Member 'UX6NikkiCPPTickHelperComponent::FConfigMaxAdjustHeight' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, TraceDistance) == 0x000244, "Member 'UX6NikkiCPPTickHelperComponent::TraceDistance' has a wrong offset!");
static_assert(offsetof(UX6NikkiCPPTickHelperComponent, bEnableFootPlacementIK) == 0x000248, "Member 'UX6NikkiCPPTickHelperComponent::bEnableFootPlacementIK' has a wrong offset!");

// Class X6Game.X6NikkiMainAnimInstance
// 0x00B0 (0x0480 - 0x03D0)
class UX6NikkiMainAnimInstance final : public UAnimInstance
{
public:
	struct FTimerHandle                           Timer_X6NikkiMainAnimInstancePrepare;              // 0x03C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UX6NikkiCPPTickHelperComponent*         X6NikkiCPPTickHelperComponent;                     // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFootIKFeatureTargetDataV2             CurFootIKFeatureTargetData;                        // 0x03D8(0x00A0)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FFootIKFeatureTargetDataV2 GetCurFootIKFeatureTargetData();
	bool PrepareInitializationData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NikkiMainAnimInstance">();
	}
	static class UX6NikkiMainAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NikkiMainAnimInstance>();
	}
};
static_assert(alignof(UX6NikkiMainAnimInstance) == 0x000010, "Wrong alignment on UX6NikkiMainAnimInstance");
static_assert(sizeof(UX6NikkiMainAnimInstance) == 0x000480, "Wrong size on UX6NikkiMainAnimInstance");
static_assert(offsetof(UX6NikkiMainAnimInstance, Timer_X6NikkiMainAnimInstancePrepare) == 0x0003C8, "Member 'UX6NikkiMainAnimInstance::Timer_X6NikkiMainAnimInstancePrepare' has a wrong offset!");
static_assert(offsetof(UX6NikkiMainAnimInstance, X6NikkiCPPTickHelperComponent) == 0x0003D0, "Member 'UX6NikkiMainAnimInstance::X6NikkiCPPTickHelperComponent' has a wrong offset!");
static_assert(offsetof(UX6NikkiMainAnimInstance, CurFootIKFeatureTargetData) == 0x0003D8, "Member 'UX6NikkiMainAnimInstance::CurFootIKFeatureTargetData' has a wrong offset!");

// Class X6Game.X6NpcDataProcessor
// 0x0198 (0x01C0 - 0x0028)
class UX6NpcDataProcessor final : public UObject
{
public:
	uint8                                         Pad_28[0x108];                                     // 0x0028(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MeshRootMBoneName;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, bool>                     RegisteredActorShouldCheckMaterialCurve;           // 0x0138(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x20];                                     // 0x0188(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  PlayerPawn;                                        // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitFaceMaterialCurvesCheckParam(const TArray<class FName>& FaceMaterialCurvesArray, const float EnabledAngle, class FName NPCMainMeshTag);
	bool RegisterActorShouldCheckMaterialCurve(class AActor* ActorShouldCheckMaterialCurve);
	bool RegisterT2StaticNpcActors(const int64& SpawnerID, class AActor* GroupActor, const TArray<struct FT2NpcRadiusHalfHeightStruct>& T2NpcActors);
	void SetNpcMainMeshTag(class FName NPCMainMeshTag);
	bool UnregisterActorShouldCheckMaterialCurve(class AActor* ActorShouldCheckMaterialCurve);
	bool UnregisterT2StaticNpcActors(const int64& SpawnerID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6NpcDataProcessor">();
	}
	static class UX6NpcDataProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6NpcDataProcessor>();
	}
};
static_assert(alignof(UX6NpcDataProcessor) == 0x000008, "Wrong alignment on UX6NpcDataProcessor");
static_assert(sizeof(UX6NpcDataProcessor) == 0x0001C0, "Wrong size on UX6NpcDataProcessor");
static_assert(offsetof(UX6NpcDataProcessor, MeshRootMBoneName) == 0x000130, "Member 'UX6NpcDataProcessor::MeshRootMBoneName' has a wrong offset!");
static_assert(offsetof(UX6NpcDataProcessor, RegisteredActorShouldCheckMaterialCurve) == 0x000138, "Member 'UX6NpcDataProcessor::RegisteredActorShouldCheckMaterialCurve' has a wrong offset!");
static_assert(offsetof(UX6NpcDataProcessor, PlayerPawn) == 0x0001A8, "Member 'UX6NpcDataProcessor::PlayerPawn' has a wrong offset!");

// Class X6Game.X6ObjectOctree
// 0x0080 (0x0428 - 0x03A8)
class AX6ObjectOctree final : public AActor
{
public:
	uint8                                         bEnableDrawing : 1;                                // 0x03A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3A9[0x77];                                     // 0x03A9(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6ObjectOctreeRenderingComp*           X6OctreeRenderComp;                                // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddOctreeElement(const struct FX6OctreeElement& inNewOctreeElement);
	bool AddOctreeElementByActor(class AActor* Actor);
	void GetActorsWithinBounds(const struct FBoxSphereBounds& BoundsQuery, TArray<class AActor*>* OutResult);
	void GetElementsWithinBounds(const struct FBoxSphereBounds& BoundsQuery, TArray<struct FX6OctreeElement>* OutResult);
	bool GetOctreeBoundsByActor(class AActor* Actor, struct FBoxSphereBounds* OutBounds);
	bool GetOctreeIdByActor(class AActor* Actor, int32* OutNodeIndex, int32* OutElemenetIndex);
	bool InitOctree(const struct FVector& Origin, float Radius, TSubclassOf<class AActor> Class_0);
	bool IsReady();
	bool ObserveMovableObjects(const TArray<class AActor*>& MoveableActos);
	void PostActorEndPlay(class AActor* Actor, const EEndPlayReason EndPlayReason);
	bool RemoveObservedMovableObjects(const TArray<class AActor*>& MoveableActos);
	void RemoveOctreeElement(const struct FX6OctreeElement& inNewOctreeElement);
	void RemoveOctreeElementByActor(class AActor* Actor);
	void SetEnableDebugDraw(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ObjectOctree">();
	}
	static class AX6ObjectOctree* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6ObjectOctree>();
	}
};
static_assert(alignof(AX6ObjectOctree) == 0x000008, "Wrong alignment on AX6ObjectOctree");
static_assert(sizeof(AX6ObjectOctree) == 0x000428, "Wrong size on AX6ObjectOctree");
static_assert(offsetof(AX6ObjectOctree, X6OctreeRenderComp) == 0x000420, "Member 'AX6ObjectOctree::X6OctreeRenderComp' has a wrong offset!");

// Class X6Game.X6ObjectPoolSubSystem
// 0x0080 (0x00B0 - 0x0030)
class UX6ObjectPoolSubSystem final : public UGameInstanceSubsystem
{
public:
	TDelegate<void(class UObject* ObjectToDestroy)> OnObjectPreDestroy;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanUpPools(bool bTryCleanMoreObjects);
	void CreatePoolByClass(class UClass* InClass);
	void DestroyPoolByClass(class UClass* InClass);
	const class FName GetFreeByPoolTag();
	class UObject* GetObjectByClass(class UClass* InClass, class UObject* Outer_0, const class FString& ObjectName);
	class UObject* GetObjectByClassEvenIfNoPool(class UClass* InClass, class UObject* Outer_0, const class FString& ObjectName);
	bool HasPoolOfClass(class UClass* InClass);
	bool IsPooledObject(class UObject* InObject);
	bool IsVaildForUse(class UObject* InObject);
	void PreCreateObjects(class UClass* InClass, int32 PreCreateNum);
	bool RecycleObject(class UObject* InObject, const TArray<class FString>& ModifiedProperties);
	void ReportMemoryUsage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ObjectPoolSubSystem">();
	}
	static class UX6ObjectPoolSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ObjectPoolSubSystem>();
	}
};
static_assert(alignof(UX6ObjectPoolSubSystem) == 0x000008, "Wrong alignment on UX6ObjectPoolSubSystem");
static_assert(sizeof(UX6ObjectPoolSubSystem) == 0x0000B0, "Wrong size on UX6ObjectPoolSubSystem");
static_assert(offsetof(UX6ObjectPoolSubSystem, OnObjectPreDestroy) == 0x000030, "Member 'UX6ObjectPoolSubSystem::OnObjectPreDestroy' has a wrong offset!");

// Class X6Game.X6PackageSettings
// 0x0140 (0x0168 - 0x0028)
class UX6PackageSettings final : public UCMSConfigProvider
{
public:
	bool                                          bEnableDebugMenu;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableConsoleComand;                              // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdvConsoleComand;                           // 0x002A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableX6ConsoleCommandDisOrder;                   // 0x002B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeaderInfo;                                 // 0x002C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableQuickReportError;                           // 0x002D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFormalLogin;                                   // 0x002E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowServerList;                                   // 0x002F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CMSApiUrl;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SensitiveWordApiUrl;                               // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SupportUrl;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReportUrl;                                         // 0x0060(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProductQueryUrl;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClientID;                                          // 0x0080(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClientKey;                                         // 0x0090(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        RegionId;                                          // 0x00A0(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        RegionIdAudit;                                     // 0x00A2(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ChannelId;                                         // 0x00A4(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Role;                                              // 0x00A6(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SDKLoginUrl;                                       // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ChargeType;                                        // 0x00B8(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Environment;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppID;                                             // 0x00D0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppKey;                                            // 0x00E0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ApiServer;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BffEncryptionKey;                                  // 0x0100(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BffRiskUrl;                                        // 0x0110(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6GameArea                                   GameArea;                                          // 0x0120(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverseaRegion;                                     // 0x0128(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountCancellationURL_Mobile;                     // 0x0138(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountCancellationURL_PC_Console;                 // 0x0148(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DistributionChannelName;                           // 0x0158(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static const class UX6PackageSettings* GetX6PackageSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PackageSettings">();
	}
	static class UX6PackageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PackageSettings>();
	}
};
static_assert(alignof(UX6PackageSettings) == 0x000008, "Wrong alignment on UX6PackageSettings");
static_assert(sizeof(UX6PackageSettings) == 0x000168, "Wrong size on UX6PackageSettings");
static_assert(offsetof(UX6PackageSettings, bEnableDebugMenu) == 0x000028, "Member 'UX6PackageSettings::bEnableDebugMenu' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bEnableConsoleComand) == 0x000029, "Member 'UX6PackageSettings::bEnableConsoleComand' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bEnableAdvConsoleComand) == 0x00002A, "Member 'UX6PackageSettings::bEnableAdvConsoleComand' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bEnableX6ConsoleCommandDisOrder) == 0x00002B, "Member 'UX6PackageSettings::bEnableX6ConsoleCommandDisOrder' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bEnableHeaderInfo) == 0x00002C, "Member 'UX6PackageSettings::bEnableHeaderInfo' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bEnableQuickReportError) == 0x00002D, "Member 'UX6PackageSettings::bEnableQuickReportError' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bUseFormalLogin) == 0x00002E, "Member 'UX6PackageSettings::bUseFormalLogin' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, bShowServerList) == 0x00002F, "Member 'UX6PackageSettings::bShowServerList' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, CMSApiUrl) == 0x000030, "Member 'UX6PackageSettings::CMSApiUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, SensitiveWordApiUrl) == 0x000040, "Member 'UX6PackageSettings::SensitiveWordApiUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, SupportUrl) == 0x000050, "Member 'UX6PackageSettings::SupportUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ReportUrl) == 0x000060, "Member 'UX6PackageSettings::ReportUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ProductQueryUrl) == 0x000070, "Member 'UX6PackageSettings::ProductQueryUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ClientID) == 0x000080, "Member 'UX6PackageSettings::ClientID' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ClientKey) == 0x000090, "Member 'UX6PackageSettings::ClientKey' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, RegionId) == 0x0000A0, "Member 'UX6PackageSettings::RegionId' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, RegionIdAudit) == 0x0000A2, "Member 'UX6PackageSettings::RegionIdAudit' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ChannelId) == 0x0000A4, "Member 'UX6PackageSettings::ChannelId' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, Role) == 0x0000A6, "Member 'UX6PackageSettings::Role' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, SDKLoginUrl) == 0x0000A8, "Member 'UX6PackageSettings::SDKLoginUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ChargeType) == 0x0000B8, "Member 'UX6PackageSettings::ChargeType' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, Environment) == 0x0000C0, "Member 'UX6PackageSettings::Environment' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, AppID) == 0x0000D0, "Member 'UX6PackageSettings::AppID' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, AppKey) == 0x0000E0, "Member 'UX6PackageSettings::AppKey' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, ApiServer) == 0x0000F0, "Member 'UX6PackageSettings::ApiServer' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, BffEncryptionKey) == 0x000100, "Member 'UX6PackageSettings::BffEncryptionKey' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, BffRiskUrl) == 0x000110, "Member 'UX6PackageSettings::BffRiskUrl' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, GameArea) == 0x000120, "Member 'UX6PackageSettings::GameArea' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, OverseaRegion) == 0x000128, "Member 'UX6PackageSettings::OverseaRegion' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, AccountCancellationURL_Mobile) == 0x000138, "Member 'UX6PackageSettings::AccountCancellationURL_Mobile' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, AccountCancellationURL_PC_Console) == 0x000148, "Member 'UX6PackageSettings::AccountCancellationURL_PC_Console' has a wrong offset!");
static_assert(offsetof(UX6PackageSettings, DistributionChannelName) == 0x000158, "Member 'UX6PackageSettings::DistributionChannelName' has a wrong offset!");

// Class X6Game.X6PathfindingSubSystem
// 0x00B0 (0x00E0 - 0x0030)
class UX6PathfindingSubSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FAIRequestID, struct FAirPathingRequest> AirPathFindingRequests;                     // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class AAIController>, struct FRepathObserverInfo> RepathObserverMap;         // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PathfindingSubSystem">();
	}
	static class UX6PathfindingSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PathfindingSubSystem>();
	}
};
static_assert(alignof(UX6PathfindingSubSystem) == 0x000008, "Wrong alignment on UX6PathfindingSubSystem");
static_assert(sizeof(UX6PathfindingSubSystem) == 0x0000E0, "Wrong size on UX6PathfindingSubSystem");
static_assert(offsetof(UX6PathfindingSubSystem, AirPathFindingRequests) == 0x000038, "Member 'UX6PathfindingSubSystem::AirPathFindingRequests' has a wrong offset!");
static_assert(offsetof(UX6PathfindingSubSystem, RepathObserverMap) == 0x000088, "Member 'UX6PathfindingSubSystem::RepathObserverMap' has a wrong offset!");

// Class X6Game.NavLinkLaunchMove
// 0x0050 (0x0090 - 0x0040)
class UNavLinkLaunchMove final : public UCustomNavLinkMoveBase
{
public:
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkLaunchMove">();
	}
	static class UNavLinkLaunchMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkLaunchMove>();
	}
};
static_assert(alignof(UNavLinkLaunchMove) == 0x000008, "Wrong alignment on UNavLinkLaunchMove");
static_assert(sizeof(UNavLinkLaunchMove) == 0x000090, "Wrong size on UNavLinkLaunchMove");

// Class X6Game.X6PhotographCameraComponent
// 0x0000 (0x0C50 - 0x0C50)
class UX6PhotographCameraComponent final : public UCineCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PhotographCameraComponent">();
	}
	static class UX6PhotographCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6PhotographCameraComponent>();
	}
};
static_assert(alignof(UX6PhotographCameraComponent) == 0x000010, "Wrong alignment on UX6PhotographCameraComponent");
static_assert(sizeof(UX6PhotographCameraComponent) == 0x000C50, "Wrong size on UX6PhotographCameraComponent");

// Class X6Game.X6PlayerCharacterBase
// 0x0000 (0x08D0 - 0x08D0)
class AX6PlayerCharacterBase final : public AX6CharacterWithAbilities
{
public:
	bool                                          bCanCombatFilterListener;                          // 0x08C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6PlayerCharacterBase">();
	}
	static class AX6PlayerCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6PlayerCharacterBase>();
	}
};
static_assert(alignof(AX6PlayerCharacterBase) == 0x000010, "Wrong alignment on AX6PlayerCharacterBase");
static_assert(sizeof(AX6PlayerCharacterBase) == 0x0008D0, "Wrong size on AX6PlayerCharacterBase");
static_assert(offsetof(AX6PlayerCharacterBase, bCanCombatFilterListener) == 0x0008C8, "Member 'AX6PlayerCharacterBase::bCanCombatFilterListener' has a wrong offset!");

// Class X6Game.X6ProjectileMovementComponent
// 0x0000 (0x0260 - 0x0260)
class UX6ProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ProjectileMovementComponent">();
	}
	static class UX6ProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ProjectileMovementComponent>();
	}
};
static_assert(alignof(UX6ProjectileMovementComponent) == 0x000010, "Wrong alignment on UX6ProjectileMovementComponent");
static_assert(sizeof(UX6ProjectileMovementComponent) == 0x000260, "Wrong size on UX6ProjectileMovementComponent");

// Class X6Game.X6RadialListView
// 0x0010 (0x1450 - 0x1440)
class UX6RadialListView final : public UX6ListView
{
public:
	float                                         Curvature;                                         // 0x1438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EX6ArcOrientation                             ArcOrientation;                                    // 0x143C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_143D[0x13];                                    // 0x143D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RadialListView">();
	}
	static class UX6RadialListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6RadialListView>();
	}
};
static_assert(alignof(UX6RadialListView) == 0x000010, "Wrong alignment on UX6RadialListView");
static_assert(sizeof(UX6RadialListView) == 0x001450, "Wrong size on UX6RadialListView");
static_assert(offsetof(UX6RadialListView, Curvature) == 0x001438, "Member 'UX6RadialListView::Curvature' has a wrong offset!");
static_assert(offsetof(UX6RadialListView, ArcOrientation) == 0x00143C, "Member 'UX6RadialListView::ArcOrientation' has a wrong offset!");

// Class X6Game.X6ReceiveSkillBaseComponent
// 0x0008 (0x00B0 - 0x00A8)
class UX6ReceiveSkillBaseComponent final : public UX6ActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsAlwaysChargeOutLineEffect(bool IsAlwaysChargeOutLineEffect);
	void SetIsBulletAttachment(bool IsBulletAttachment);
	void SetIsBulletDestroyWhenNotSimulation(bool IsBulletDestroyWhenNotSimulation);
	void SetIsBulletPenetrateWhenSimulation(bool IsBulletPenetrateWhenSimulation);
	void SetIsChargeOutLineEffect(bool IsChargeOutLineEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ReceiveSkillBaseComponent">();
	}
	static class UX6ReceiveSkillBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ReceiveSkillBaseComponent>();
	}
};
static_assert(alignof(UX6ReceiveSkillBaseComponent) == 0x000008, "Wrong alignment on UX6ReceiveSkillBaseComponent");
static_assert(sizeof(UX6ReceiveSkillBaseComponent) == 0x0000B0, "Wrong size on UX6ReceiveSkillBaseComponent");

// Class X6Game.X6RichTextBlockNetImageDecorator
// 0x00C8 (0x00F0 - 0x0028)
class UX6RichTextBlockNetImageDecorator final : public URichTextBlockDecorator
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResFolderPath;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                PlaceHolderImage;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USimpleDownloader*                      ResDownloader;                                     // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UObject*>           LoadedImagesMap;                                   // 0x00A0(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnResDownloaded(bool bSuccess, int32 ResponseCode, int32 Size, int32 RequestID, const class FString& CurrentDownloadFileName);
	void ReleaseLoadedImages();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RichTextBlockNetImageDecorator">();
	}
	static class UX6RichTextBlockNetImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6RichTextBlockNetImageDecorator>();
	}
};
static_assert(alignof(UX6RichTextBlockNetImageDecorator) == 0x000008, "Wrong alignment on UX6RichTextBlockNetImageDecorator");
static_assert(sizeof(UX6RichTextBlockNetImageDecorator) == 0x0000F0, "Wrong size on UX6RichTextBlockNetImageDecorator");
static_assert(offsetof(UX6RichTextBlockNetImageDecorator, ResFolderPath) == 0x000030, "Member 'UX6RichTextBlockNetImageDecorator::ResFolderPath' has a wrong offset!");
static_assert(offsetof(UX6RichTextBlockNetImageDecorator, PlaceHolderImage) == 0x000040, "Member 'UX6RichTextBlockNetImageDecorator::PlaceHolderImage' has a wrong offset!");
static_assert(offsetof(UX6RichTextBlockNetImageDecorator, ResDownloader) == 0x000048, "Member 'UX6RichTextBlockNetImageDecorator::ResDownloader' has a wrong offset!");
static_assert(offsetof(UX6RichTextBlockNetImageDecorator, LoadedImagesMap) == 0x0000A0, "Member 'UX6RichTextBlockNetImageDecorator::LoadedImagesMap' has a wrong offset!");

// Class X6Game.X6RMWalkingComponent
// 0x00C8 (0x01A8 - 0x00E0)
class UX6RMWalkingComponent final : public UX6BasicRegularMovementComponent
{
public:
	float                                         RMBlockedByAngleThreshold;                         // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URMBaseLogicProcessor>      RMBaseLogicProcessorClass;                         // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMConfigContext_OnGround>  RMConfigContextClass;                              // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMStateInstructionContext> StateInstructionContextClass;                      // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMPTickRecord_OnGround>    RMProxyTickRecordClass;                            // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMOutputContext_OnGround>  RMOutputContextClass;                              // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URMBehaviorTreeProxyInterface> RMBehaviorTreeProxyClass;                       // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URegularMovementDebugContext> RMDebugContextClass;                             // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSyncAnimStates;                                // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementAffectedBySlopeFactor;                    // 0x0121(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurFloorAngle;                                     // 0x0124(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStartMovingMovementCurve;                      // 0x0128(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OwnerAttribute_MaxWalkSpeed_GroundCorrectionFactor; // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentActualGait;                                 // 0x0130(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERegularLocomotionType                        CurrentAllowedGait;                                // 0x0131(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URMPTickRecord_OnGround*                CurRMProxyTickRecord;                              // 0x0138(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UX6NikkiCPPTickHelperComponent*         PlayerCPPTickHelperComp;                           // 0x0140(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URMBaseLogicProcessor*                  CurRMBaseLogicProcessor;                           // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URMBehaviorTreeProxyInterface*          CurRMProxy_OnGround;                               // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FX6RMWalkingReplicatedMovementData     ReplicatedMovementData;                            // 0x0158(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	ERegularLocomotionType                        NP_ReplicatedAllowedGait;                          // 0x0180(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    NP_ReplicatedInputMovingDirection;                 // 0x0188(0x0018)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NP_ReplicatedTurnAroundAngleToInt;                 // 0x01A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_PostUpdateRegularMovementBehavior(float DeltaSeconds);
	void Blueprint_PreUpdateRegularMovementBehavior(float DeltaSeconds);
	void ChangeDesiredGait(ERegularLocomotionType NewGait, bool bForceChangeOperationInput);
	void DeinitRegularMovementBehaviorProxy();
	float GetConfigMaxSpeedByCurAllowedGait();
	void GetConfigMaxSpeedData(float* MaxSpeed_Walk, float* MaxSpeed_Run, float* MaxSpeed_Sprint);
	float GetCurConfigMaxSpeed();
	ERegularLocomotionType GetCurLocomotionTypeBySpeed(float Speed2D);
	class URMBaseLogicProcessor* GetCurRMBaseLogicProcessor();
	void InitRegularMovementBehaviorProxy();
	void InitRMBaseLogicProcessor(class URMBaseLogicProcessor* RMBaseLogicProcessor);
	bool IsValidReplicatedMovingDirection();
	void NotifyBeforeMovementPropertyChanged(float* MaxWalkSpeed, float* MaxWalkSpeedCrouched, float* MinAnalogWalkSpeed, float* MaxAcceleration, float* BrakingDecelerationWalking, float* GroundFriction);
	void NotifyCurActualGaitChanged(ERegularLocomotionType NewGait, ERegularLocomotionType CurrentGait);
	void NotifyCurAllowedGaitChanged(ERegularLocomotionType NewGait, ERegularLocomotionType CurrentGait);
	void NotifyCurReplicatedAllowedGaitChanged(ERegularLocomotionType NewGait, ERegularLocomotionType CurrentGait);
	void OnMovementBlockedBy(const struct FHitResult& Impact);
	void OnRep_MovementData_AllowedGait();
	void OnRep_MovementData_InputMovingDirection();
	void OnRep_MovementData_TurnAroundAngle();
	bool ShouldUpdateRegularMovementBehaviorTree();
	void SyncAnimStatesWithTick();
	void UpdateCurActualGait();
	void UpdateCurAllowedGait();
	void UpdateDynamicMovmentSettings(bool bForceUpdate);
	void UpdateReplicatedMovementData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6RMWalkingComponent">();
	}
	static class UX6RMWalkingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6RMWalkingComponent>();
	}
};
static_assert(alignof(UX6RMWalkingComponent) == 0x000008, "Wrong alignment on UX6RMWalkingComponent");
static_assert(sizeof(UX6RMWalkingComponent) == 0x0001A8, "Wrong size on UX6RMWalkingComponent");
static_assert(offsetof(UX6RMWalkingComponent, RMBlockedByAngleThreshold) == 0x0000E0, "Member 'UX6RMWalkingComponent::RMBlockedByAngleThreshold' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, RMBaseLogicProcessorClass) == 0x0000E8, "Member 'UX6RMWalkingComponent::RMBaseLogicProcessorClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, RMConfigContextClass) == 0x0000F0, "Member 'UX6RMWalkingComponent::RMConfigContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, StateInstructionContextClass) == 0x0000F8, "Member 'UX6RMWalkingComponent::StateInstructionContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, RMProxyTickRecordClass) == 0x000100, "Member 'UX6RMWalkingComponent::RMProxyTickRecordClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, RMOutputContextClass) == 0x000108, "Member 'UX6RMWalkingComponent::RMOutputContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, RMBehaviorTreeProxyClass) == 0x000110, "Member 'UX6RMWalkingComponent::RMBehaviorTreeProxyClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, RMDebugContextClass) == 0x000118, "Member 'UX6RMWalkingComponent::RMDebugContextClass' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, bCanSyncAnimStates) == 0x000120, "Member 'UX6RMWalkingComponent::bCanSyncAnimStates' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, bMovementAffectedBySlopeFactor) == 0x000121, "Member 'UX6RMWalkingComponent::bMovementAffectedBySlopeFactor' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, CurFloorAngle) == 0x000124, "Member 'UX6RMWalkingComponent::CurFloorAngle' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, bUseStartMovingMovementCurve) == 0x000128, "Member 'UX6RMWalkingComponent::bUseStartMovingMovementCurve' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, OwnerAttribute_MaxWalkSpeed_GroundCorrectionFactor) == 0x00012C, "Member 'UX6RMWalkingComponent::OwnerAttribute_MaxWalkSpeed_GroundCorrectionFactor' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, CurrentActualGait) == 0x000130, "Member 'UX6RMWalkingComponent::CurrentActualGait' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, CurrentAllowedGait) == 0x000131, "Member 'UX6RMWalkingComponent::CurrentAllowedGait' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, CurRMProxyTickRecord) == 0x000138, "Member 'UX6RMWalkingComponent::CurRMProxyTickRecord' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, PlayerCPPTickHelperComp) == 0x000140, "Member 'UX6RMWalkingComponent::PlayerCPPTickHelperComp' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, CurRMBaseLogicProcessor) == 0x000148, "Member 'UX6RMWalkingComponent::CurRMBaseLogicProcessor' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, CurRMProxy_OnGround) == 0x000150, "Member 'UX6RMWalkingComponent::CurRMProxy_OnGround' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, ReplicatedMovementData) == 0x000158, "Member 'UX6RMWalkingComponent::ReplicatedMovementData' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, NP_ReplicatedAllowedGait) == 0x000180, "Member 'UX6RMWalkingComponent::NP_ReplicatedAllowedGait' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, NP_ReplicatedInputMovingDirection) == 0x000188, "Member 'UX6RMWalkingComponent::NP_ReplicatedInputMovingDirection' has a wrong offset!");
static_assert(offsetof(UX6RMWalkingComponent, NP_ReplicatedTurnAroundAngleToInt) == 0x0001A0, "Member 'UX6RMWalkingComponent::NP_ReplicatedTurnAroundAngleToInt' has a wrong offset!");

// Class X6Game.X6ScrollBox
// 0x0030 (0x0D40 - 0x0D10)
class UX6ScrollBox final : public UScrollBox
{
public:
	bool                                          bHasMask;                                          // 0x0D08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D09[0x3];                                      // 0x0D09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopMaskParameterName;                              // 0x0D0C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomMaskParameterName;                           // 0x0D14(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1C[0x4];                                      // 0x0D1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnScrollBoxTouchEnded;                             // 0x0D20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D30[0x10];                                     // 0x0D30(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleScollBoxScrolling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ScrollBox">();
	}
	static class UX6ScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ScrollBox>();
	}
};
static_assert(alignof(UX6ScrollBox) == 0x000010, "Wrong alignment on UX6ScrollBox");
static_assert(sizeof(UX6ScrollBox) == 0x000D40, "Wrong size on UX6ScrollBox");
static_assert(offsetof(UX6ScrollBox, bHasMask) == 0x000D08, "Member 'UX6ScrollBox::bHasMask' has a wrong offset!");
static_assert(offsetof(UX6ScrollBox, TopMaskParameterName) == 0x000D0C, "Member 'UX6ScrollBox::TopMaskParameterName' has a wrong offset!");
static_assert(offsetof(UX6ScrollBox, BottomMaskParameterName) == 0x000D14, "Member 'UX6ScrollBox::BottomMaskParameterName' has a wrong offset!");
static_assert(offsetof(UX6ScrollBox, OnScrollBoxTouchEnded) == 0x000D20, "Member 'UX6ScrollBox::OnScrollBoxTouchEnded' has a wrong offset!");

// Class X6Game.X6SoftRefWidget
// 0x0048 (0x01D0 - 0x0188)
class UX6SoftRefWidget final : public UWidget
{
public:
	struct FSoftClassPath                         ContentWidgetSoftClassPath;                        // 0x0188(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UUserWidget* ContentWidget)> OnContentWidgetLoaded;          // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UUserWidget*                            ContentWidget;                                     // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearContentWidget();
	class UUserWidget* GetContentWidget();
	void LoadContentWidget(bool bSyncLoad, bool bNeedRecreate);
	void OnLoaded(int32 AsyncId, const TArray<class UObject*>& InLoadedObjects);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SoftRefWidget">();
	}
	static class UX6SoftRefWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SoftRefWidget>();
	}
};
static_assert(alignof(UX6SoftRefWidget) == 0x000008, "Wrong alignment on UX6SoftRefWidget");
static_assert(sizeof(UX6SoftRefWidget) == 0x0001D0, "Wrong size on UX6SoftRefWidget");
static_assert(offsetof(UX6SoftRefWidget, ContentWidgetSoftClassPath) == 0x000188, "Member 'UX6SoftRefWidget::ContentWidgetSoftClassPath' has a wrong offset!");
static_assert(offsetof(UX6SoftRefWidget, OnContentWidgetLoaded) == 0x0001A8, "Member 'UX6SoftRefWidget::OnContentWidgetLoaded' has a wrong offset!");
static_assert(offsetof(UX6SoftRefWidget, ContentWidget) == 0x0001B8, "Member 'UX6SoftRefWidget::ContentWidget' has a wrong offset!");

// Class X6Game.X6SteamFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6SteamFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdateAchievements(const TMap<class FString, int32>& InAchievements, const class FString& ChannelString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SteamFunctionLibrary">();
	}
	static class UX6SteamFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SteamFunctionLibrary>();
	}
};
static_assert(alignof(UX6SteamFunctionLibrary) == 0x000008, "Wrong alignment on UX6SteamFunctionLibrary");
static_assert(sizeof(UX6SteamFunctionLibrary) == 0x000028, "Wrong size on UX6SteamFunctionLibrary");

// Class X6Game.X6SuitDisplayComponent
// 0x0048 (0x00F0 - 0x00A8)
class UX6SuitDisplayComponent final : public UX6ActorComponent
{
public:
	bool                                          bEnableRaycastingShadow;                           // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFurCurvePassing;                            // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0xE];                                       // 0x00AA(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MPC_TOD;                                           // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperFurComponent*                     FurComp;                                           // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                AsyncResultObject;                                 // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CallPreivewFunction(class AActor* InActor, class FName InFunctionName, int32 InParams);
	static void SetPreviewProperty(class AActor* InActor, class FName InPropertyName, int32 InPropertyValue);

	void AsyncCallBPFunction(class FName FunctionName, const TArray<class USkeletalMesh*>& MeshArr);
	class UObject* AsyncNewObject(TSubclassOf<class UObject> InObjectClass);
	void NotifyCppClothID2ClothPath(const TMap<int64, class FString>& ClothPair);
	void OnAsyncCallFinished(class UObject* AsyncResult);
	void RenameComponent(class UActorComponent* InComponent, const class FString& InNewName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SuitDisplayComponent">();
	}
	static class UX6SuitDisplayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SuitDisplayComponent>();
	}
};
static_assert(alignof(UX6SuitDisplayComponent) == 0x000008, "Wrong alignment on UX6SuitDisplayComponent");
static_assert(sizeof(UX6SuitDisplayComponent) == 0x0000F0, "Wrong size on UX6SuitDisplayComponent");
static_assert(offsetof(UX6SuitDisplayComponent, bEnableRaycastingShadow) == 0x0000A8, "Member 'UX6SuitDisplayComponent::bEnableRaycastingShadow' has a wrong offset!");
static_assert(offsetof(UX6SuitDisplayComponent, bEnableFurCurvePassing) == 0x0000A9, "Member 'UX6SuitDisplayComponent::bEnableFurCurvePassing' has a wrong offset!");
static_assert(offsetof(UX6SuitDisplayComponent, MPC_TOD) == 0x0000B8, "Member 'UX6SuitDisplayComponent::MPC_TOD' has a wrong offset!");
static_assert(offsetof(UX6SuitDisplayComponent, FurComp) == 0x0000C8, "Member 'UX6SuitDisplayComponent::FurComp' has a wrong offset!");
static_assert(offsetof(UX6SuitDisplayComponent, AsyncResultObject) == 0x0000E0, "Member 'UX6SuitDisplayComponent::AsyncResultObject' has a wrong offset!");

// Class X6Game.X6TargetingFilterTask_Num
// 0x0008 (0x0030 - 0x0028)
class UX6TargetingFilterTask_Num final : public UTargetingTask
{
public:
	int32                                         Num;                                               // 0x0028(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingFilterTask_Num">();
	}
	static class UX6TargetingFilterTask_Num* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingFilterTask_Num>();
	}
};
static_assert(alignof(UX6TargetingFilterTask_Num) == 0x000008, "Wrong alignment on UX6TargetingFilterTask_Num");
static_assert(sizeof(UX6TargetingFilterTask_Num) == 0x000030, "Wrong size on UX6TargetingFilterTask_Num");
static_assert(offsetof(UX6TargetingFilterTask_Num, Num) == 0x000028, "Member 'UX6TargetingFilterTask_Num::Num' has a wrong offset!");

// Class X6Game.X6TargetingFilter_ChargeUpAiming
// 0x0020 (0x0048 - 0x0028)
class UX6TargetingFilter_ChargeUpAiming final : public UTargetingFilterTask_BasicFilterTemplate
{
public:
	struct FGameplayTagContainer                  TargetGameplayTags;                                // 0x0028(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingFilter_ChargeUpAiming">();
	}
	static class UX6TargetingFilter_ChargeUpAiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingFilter_ChargeUpAiming>();
	}
};
static_assert(alignof(UX6TargetingFilter_ChargeUpAiming) == 0x000008, "Wrong alignment on UX6TargetingFilter_ChargeUpAiming");
static_assert(sizeof(UX6TargetingFilter_ChargeUpAiming) == 0x000048, "Wrong size on UX6TargetingFilter_ChargeUpAiming");
static_assert(offsetof(UX6TargetingFilter_ChargeUpAiming, TargetGameplayTags) == 0x000028, "Member 'UX6TargetingFilter_ChargeUpAiming::TargetGameplayTags' has a wrong offset!");

// Class X6Game.X6TargetingSelectionTask_AOE
// 0x00C0 (0x00E8 - 0x0028)
class UX6TargetingSelectionTask_AOE final : public UTargetingTask
{
public:
	bool                                          bIsDependencyPreTarget;                            // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyMultipleComponentResult;                     // 0x0029(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EX6TargetingAOEShape                          ShapeType;                                         // 0x002A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x002B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  CollisionProfileName;                              // 0x002C(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionObjectTypes;                              // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DefaultSourceOffset;                               // 0x0048(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseRelativeOffset : 1;                            // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreSourceActor : 1;                            // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreInstigatorActor : 1;                        // 0x0068(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HalfExtent;                                        // 0x0070(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Angle;                                             // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InnerRadius;                                       // 0x008C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Radius;                                            // 0x0090(0x0028)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HalfHeight;                                        // 0x00B8(0x0028)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   ComponentTag;                                      // 0x00E0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_GetTargetingResultDataByIndex(const struct FTargetingRequestHandle& TargetingHandle, const int32 Index_0, struct FTargetingDefaultResultData* ResultData) const;
	struct FQuat GetOffsetRotationInEditor(const class AActor* Actor) const;
	struct FVector GetSourceLocation(const struct FTargetingRequestHandle& TargetingHandle) const;
	struct FVector GetSourceOffset(const struct FTargetingRequestHandle& TargetingHandle) const;
	struct FQuat GetSourceRotation(const struct FTargetingRequestHandle& TargetingHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingSelectionTask_AOE">();
	}
	static class UX6TargetingSelectionTask_AOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingSelectionTask_AOE>();
	}
};
static_assert(alignof(UX6TargetingSelectionTask_AOE) == 0x000008, "Wrong alignment on UX6TargetingSelectionTask_AOE");
static_assert(sizeof(UX6TargetingSelectionTask_AOE) == 0x0000E8, "Wrong size on UX6TargetingSelectionTask_AOE");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, bIsDependencyPreTarget) == 0x000028, "Member 'UX6TargetingSelectionTask_AOE::bIsDependencyPreTarget' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, bApplyMultipleComponentResult) == 0x000029, "Member 'UX6TargetingSelectionTask_AOE::bApplyMultipleComponentResult' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, ShapeType) == 0x00002A, "Member 'UX6TargetingSelectionTask_AOE::ShapeType' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, CollisionChannel) == 0x00002B, "Member 'UX6TargetingSelectionTask_AOE::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, CollisionProfileName) == 0x00002C, "Member 'UX6TargetingSelectionTask_AOE::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, CollisionObjectTypes) == 0x000038, "Member 'UX6TargetingSelectionTask_AOE::CollisionObjectTypes' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, DefaultSourceOffset) == 0x000048, "Member 'UX6TargetingSelectionTask_AOE::DefaultSourceOffset' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, SocketName) == 0x000060, "Member 'UX6TargetingSelectionTask_AOE::SocketName' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, HalfExtent) == 0x000070, "Member 'UX6TargetingSelectionTask_AOE::HalfExtent' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, Angle) == 0x000088, "Member 'UX6TargetingSelectionTask_AOE::Angle' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, InnerRadius) == 0x00008C, "Member 'UX6TargetingSelectionTask_AOE::InnerRadius' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, Radius) == 0x000090, "Member 'UX6TargetingSelectionTask_AOE::Radius' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, HalfHeight) == 0x0000B8, "Member 'UX6TargetingSelectionTask_AOE::HalfHeight' has a wrong offset!");
static_assert(offsetof(UX6TargetingSelectionTask_AOE, ComponentTag) == 0x0000E0, "Member 'UX6TargetingSelectionTask_AOE::ComponentTag' has a wrong offset!");

// Class X6Game.X6TargetingSortTask_ChargeUp
// 0x0080 (0x00A8 - 0x0028)
class UX6TargetingSortTask_ChargeUp final : public UTargetingTask
{
public:
	uint8                                         bAngleAscending : 1;                               // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleWeight;                                       // 0x002C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleRefScore;                                     // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisAscending : 1;                                 // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisWeight;                                         // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisRefScore;                                       // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCharacterAscending : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterWeight;                                   // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterRefScore;                                 // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, float>              CharacterTagBaseScoreMap;                          // 0x0050(0x0050)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         OtherCharacterBaseScore;                           // 0x00A0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TargetingSortTask_ChargeUp">();
	}
	static class UX6TargetingSortTask_ChargeUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TargetingSortTask_ChargeUp>();
	}
};
static_assert(alignof(UX6TargetingSortTask_ChargeUp) == 0x000008, "Wrong alignment on UX6TargetingSortTask_ChargeUp");
static_assert(sizeof(UX6TargetingSortTask_ChargeUp) == 0x0000A8, "Wrong size on UX6TargetingSortTask_ChargeUp");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, AngleWeight) == 0x00002C, "Member 'UX6TargetingSortTask_ChargeUp::AngleWeight' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, AngleRefScore) == 0x000030, "Member 'UX6TargetingSortTask_ChargeUp::AngleRefScore' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, DisWeight) == 0x000038, "Member 'UX6TargetingSortTask_ChargeUp::DisWeight' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, DisRefScore) == 0x00003C, "Member 'UX6TargetingSortTask_ChargeUp::DisRefScore' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, CharacterWeight) == 0x000044, "Member 'UX6TargetingSortTask_ChargeUp::CharacterWeight' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, CharacterRefScore) == 0x000048, "Member 'UX6TargetingSortTask_ChargeUp::CharacterRefScore' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, CharacterTagBaseScoreMap) == 0x000050, "Member 'UX6TargetingSortTask_ChargeUp::CharacterTagBaseScoreMap' has a wrong offset!");
static_assert(offsetof(UX6TargetingSortTask_ChargeUp, OtherCharacterBaseScore) == 0x0000A0, "Member 'UX6TargetingSortTask_ChargeUp::OtherCharacterBaseScore' has a wrong offset!");

// Class X6Game.X6TRCBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6TRCBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeActivityAvailability(const TArray<class FString>& AvailableIDs, const TArray<class FString>& UnavailableIDs);
	static bool CheckPSPremium();
	static void CheckPSPremiumAsync(TDelegate<void(bool Result)> Callback);
	static bool EndActivity(const class FString& activityID);
	static bool ExportToAlbum(const class FString& FromPath, const class FString& Filename);
	static bool IsPremiumFeatureNotifying();
	static void LaunchURLForPredeterminedContent(const class FString& URL);
	static void RequestTRCWebApi(const class FString& ApiGroup, const class FString& ApiPath, const class FString& httpMethod, const class FString& JsonContent, TDelegate<void(int32 ResponceCode, const class FString& Content, float NextRequestTime)> Callback);
	static bool ResetActivity(const class FString& activityID);
	static void ShowCommerceDialog(EX6CommerceType CommerceType);
	static void ShowSystemMsgDialog(EX6SystemMsgType MsgType);
	static bool StartActivity(const class FString& activityID);
	static void StartPSNotifyPremiumFeature(float TimeInterval);
	static void StopPSNotifyPremiumFeature();
	static void UpdateAchievements(const TMap<int32, int32>& Achievements);
	static float X6GetDiskFreeSpace(const class FString& InPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6TRCBlueprintLibrary">();
	}
	static class UX6TRCBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6TRCBlueprintLibrary>();
	}
};
static_assert(alignof(UX6TRCBlueprintLibrary) == 0x000008, "Wrong alignment on UX6TRCBlueprintLibrary");
static_assert(sizeof(UX6TRCBlueprintLibrary) == 0x000028, "Wrong size on UX6TRCBlueprintLibrary");

// Class X6Game.X6VehicleBikeAnimInstace
// 0x00A0 (0x0470 - 0x03D0)
class UX6VehicleBikeAnimInstace final : public UAnimInstance
{
public:
	TWeakObjectPtr<class UX6BikeDataContext>      BikeDataContext;                                   // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BikeCyclingStateL1;                                // 0x03D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeStartRidingType;                               // 0x03D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeSpotTurnType;                                  // 0x03D2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeRidingType;                                    // 0x03D3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeBrakeType;                                     // 0x03D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeStartJumpType;                                 // 0x03D5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeJumpEndType;                                   // 0x03D6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeDebarkationType;                               // 0x03D7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeCyclingInAirType;                              // 0x03D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BikeEnterBikeType;                                 // 0x03D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PreBikeCyclingType;                                // 0x03DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBikeIdleLeft;                                     // 0x03DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BikeSteeringValue;                                 // 0x03DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BikeBodyLeanAngle;                                 // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerRootMOffset;                                 // 0x03E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RawBikeForeakeInput;                               // 0x03E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RawBikeHeelInput;                                  // 0x03EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHaveValidComponent;                               // 0x03F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerAttachToBike;                               // 0x03F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBikeSwitchIdle;                                   // 0x03F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMoveMode;                                   // 0x03F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentSlopeAngle;                                 // 0x03F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BikeSpeedValue;                                    // 0x03F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLaunchedInAir;                                    // 0x03FC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDirectlyFall;                                     // 0x03FD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FE[0x2];                                      // 0x03FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetSteerValue;                                  // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LHandLockPosition;                                 // 0x0408(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LHandLockRotation;                                 // 0x0420(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RHandLockPosition;                                 // 0x0438(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RHandLockRotation;                                 // 0x0450(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HandIKAlpha;                                       // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHandLockPositionL;                          // 0x046C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHandLockPositionR;                          // 0x046D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHandLockRotateL;                            // 0x046E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHandLockRotateR;                            // 0x046F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6VehicleBikeAnimInstace">();
	}
	static class UX6VehicleBikeAnimInstace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6VehicleBikeAnimInstace>();
	}
};
static_assert(alignof(UX6VehicleBikeAnimInstace) == 0x000010, "Wrong alignment on UX6VehicleBikeAnimInstace");
static_assert(sizeof(UX6VehicleBikeAnimInstace) == 0x000470, "Wrong size on UX6VehicleBikeAnimInstace");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeDataContext) == 0x0003C8, "Member 'UX6VehicleBikeAnimInstace::BikeDataContext' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeCyclingStateL1) == 0x0003D0, "Member 'UX6VehicleBikeAnimInstace::BikeCyclingStateL1' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeStartRidingType) == 0x0003D1, "Member 'UX6VehicleBikeAnimInstace::BikeStartRidingType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeSpotTurnType) == 0x0003D2, "Member 'UX6VehicleBikeAnimInstace::BikeSpotTurnType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeRidingType) == 0x0003D3, "Member 'UX6VehicleBikeAnimInstace::BikeRidingType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeBrakeType) == 0x0003D4, "Member 'UX6VehicleBikeAnimInstace::BikeBrakeType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeStartJumpType) == 0x0003D5, "Member 'UX6VehicleBikeAnimInstace::BikeStartJumpType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeJumpEndType) == 0x0003D6, "Member 'UX6VehicleBikeAnimInstace::BikeJumpEndType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeDebarkationType) == 0x0003D7, "Member 'UX6VehicleBikeAnimInstace::BikeDebarkationType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeCyclingInAirType) == 0x0003D8, "Member 'UX6VehicleBikeAnimInstace::BikeCyclingInAirType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeEnterBikeType) == 0x0003D9, "Member 'UX6VehicleBikeAnimInstace::BikeEnterBikeType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, PreBikeCyclingType) == 0x0003DA, "Member 'UX6VehicleBikeAnimInstace::PreBikeCyclingType' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bBikeIdleLeft) == 0x0003DB, "Member 'UX6VehicleBikeAnimInstace::bBikeIdleLeft' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeSteeringValue) == 0x0003DC, "Member 'UX6VehicleBikeAnimInstace::BikeSteeringValue' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeBodyLeanAngle) == 0x0003E0, "Member 'UX6VehicleBikeAnimInstace::BikeBodyLeanAngle' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, PlayerRootMOffset) == 0x0003E4, "Member 'UX6VehicleBikeAnimInstace::PlayerRootMOffset' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, RawBikeForeakeInput) == 0x0003E8, "Member 'UX6VehicleBikeAnimInstace::RawBikeForeakeInput' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, RawBikeHeelInput) == 0x0003EC, "Member 'UX6VehicleBikeAnimInstace::RawBikeHeelInput' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bHaveValidComponent) == 0x0003F0, "Member 'UX6VehicleBikeAnimInstace::bHaveValidComponent' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bPlayerAttachToBike) == 0x0003F1, "Member 'UX6VehicleBikeAnimInstace::bPlayerAttachToBike' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bBikeSwitchIdle) == 0x0003F2, "Member 'UX6VehicleBikeAnimInstace::bBikeSwitchIdle' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bEnableMoveMode) == 0x0003F3, "Member 'UX6VehicleBikeAnimInstace::bEnableMoveMode' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, CurrentSlopeAngle) == 0x0003F4, "Member 'UX6VehicleBikeAnimInstace::CurrentSlopeAngle' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, BikeSpeedValue) == 0x0003F8, "Member 'UX6VehicleBikeAnimInstace::BikeSpeedValue' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bLaunchedInAir) == 0x0003FC, "Member 'UX6VehicleBikeAnimInstace::bLaunchedInAir' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bDirectlyFall) == 0x0003FD, "Member 'UX6VehicleBikeAnimInstace::bDirectlyFall' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, TargetSteerValue) == 0x000400, "Member 'UX6VehicleBikeAnimInstace::TargetSteerValue' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, LHandLockPosition) == 0x000408, "Member 'UX6VehicleBikeAnimInstace::LHandLockPosition' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, LHandLockRotation) == 0x000420, "Member 'UX6VehicleBikeAnimInstace::LHandLockRotation' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, RHandLockPosition) == 0x000438, "Member 'UX6VehicleBikeAnimInstace::RHandLockPosition' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, RHandLockRotation) == 0x000450, "Member 'UX6VehicleBikeAnimInstace::RHandLockRotation' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, HandIKAlpha) == 0x000468, "Member 'UX6VehicleBikeAnimInstace::HandIKAlpha' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bEnableHandLockPositionL) == 0x00046C, "Member 'UX6VehicleBikeAnimInstace::bEnableHandLockPositionL' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bEnableHandLockPositionR) == 0x00046D, "Member 'UX6VehicleBikeAnimInstace::bEnableHandLockPositionR' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bEnableHandLockRotateL) == 0x00046E, "Member 'UX6VehicleBikeAnimInstace::bEnableHandLockRotateL' has a wrong offset!");
static_assert(offsetof(UX6VehicleBikeAnimInstace, bEnableHandLockRotateR) == 0x00046F, "Member 'UX6VehicleBikeAnimInstace::bEnableHandLockRotateR' has a wrong offset!");

// Class X6Game.X6WaterBuoyancyManagerComponent
// 0x0098 (0x0140 - 0x00A8)
class UX6WaterBuoyancyManagerComponent final : public UActorComponent
{
public:
	ESimulateWaterFlowType                        WaterFlowType;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimulateWaterFlowKeyPoint             TargetPointToToward;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimulateWaterFlowKeyPoint             PointToLeave;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSimulateWaterFlowKeyPoint>     MovementTrackKeyPoints;                            // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InitialConfigDensity;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentWaterDensity;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x58];                                      // 0x00E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateSplineTrackForWater();
	struct FSimulateWaterFlowKeyPoint GetPointToLeave();
	struct FSimulateWaterFlowKeyPoint GetTargetPointToToward();
	float GetWaterCurrentDensity();
	float GetWaterSurfaceHeightInWorldCoordinate();
	void InitializeBuoyancyData();
	void OnTriggerWaterOverlapCheck();
	void OnUpdateWaterSurfaceHeight(float DeltaTime);
	void OnWaterActorBeginOverlaped(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnWaterActorEndOverlaped(class AActor* OverlappedActor, class AActor* OtherActor);
	void UpdateWaterDensity(float NewDensity);
	void UpdateWaterIceState(bool ToIceOrExit);
	void UpdateWaterSurfaceHeight(float HeightOfffsetToUpdate);
	void UpdateWaterSurfaceHeightInTime(float TimeDuration, float TotalHeightToUpdate);
	void UpdateWaterSurfaceHeightWithSpeed(float UpdateHeightSpeed, float TotalHeightToUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6WaterBuoyancyManagerComponent">();
	}
	static class UX6WaterBuoyancyManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6WaterBuoyancyManagerComponent>();
	}
};
static_assert(alignof(UX6WaterBuoyancyManagerComponent) == 0x000008, "Wrong alignment on UX6WaterBuoyancyManagerComponent");
static_assert(sizeof(UX6WaterBuoyancyManagerComponent) == 0x000140, "Wrong size on UX6WaterBuoyancyManagerComponent");
static_assert(offsetof(UX6WaterBuoyancyManagerComponent, WaterFlowType) == 0x0000A8, "Member 'UX6WaterBuoyancyManagerComponent::WaterFlowType' has a wrong offset!");
static_assert(offsetof(UX6WaterBuoyancyManagerComponent, TargetPointToToward) == 0x0000B0, "Member 'UX6WaterBuoyancyManagerComponent::TargetPointToToward' has a wrong offset!");
static_assert(offsetof(UX6WaterBuoyancyManagerComponent, PointToLeave) == 0x0000C0, "Member 'UX6WaterBuoyancyManagerComponent::PointToLeave' has a wrong offset!");
static_assert(offsetof(UX6WaterBuoyancyManagerComponent, MovementTrackKeyPoints) == 0x0000D0, "Member 'UX6WaterBuoyancyManagerComponent::MovementTrackKeyPoints' has a wrong offset!");
static_assert(offsetof(UX6WaterBuoyancyManagerComponent, InitialConfigDensity) == 0x0000E0, "Member 'UX6WaterBuoyancyManagerComponent::InitialConfigDensity' has a wrong offset!");
static_assert(offsetof(UX6WaterBuoyancyManagerComponent, CurrentWaterDensity) == 0x0000E4, "Member 'UX6WaterBuoyancyManagerComponent::CurrentWaterDensity' has a wrong offset!");

// Class X6Game.X6WheeledVehicle
// 0x0010 (0x04A0 - 0x0490)
class AX6WheeledVehicle final : public AX6Pawn
{
public:
	class USkeletalMeshComponent*                 mesh;                                              // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChaosWheeledVehicleMovementComponent*  VehicleMovement;                                   // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6WheeledVehicle">();
	}
	static class AX6WheeledVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6WheeledVehicle>();
	}
};
static_assert(alignof(AX6WheeledVehicle) == 0x000008, "Wrong alignment on AX6WheeledVehicle");
static_assert(sizeof(AX6WheeledVehicle) == 0x0004A0, "Wrong size on AX6WheeledVehicle");
static_assert(offsetof(AX6WheeledVehicle, mesh) == 0x000490, "Member 'AX6WheeledVehicle::mesh' has a wrong offset!");
static_assert(offsetof(AX6WheeledVehicle, VehicleMovement) == 0x000498, "Member 'AX6WheeledVehicle::VehicleMovement' has a wrong offset!");

// Class X6Game.X6WorldCarriageMovementComponent
// 0x00F0 (0x15D0 - 0x14E0)
class UX6WorldCarriageMovementComponent final : public UX6CustomizeMovementComponentBase
{
public:
	float                                         StartStepDistance;                                 // 0x14E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMoveTimeOutThreshold;                          // 0x14E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanShowThreshold;                                  // 0x14E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTurnSpeed;                                   // 0x14EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarMoveTimeOut;                                   // 0x14F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TurnInPlaceStateName;                              // 0x14F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartStateName;                                    // 0x14FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CycleStateName;                                    // 0x1504(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StopStateName;                                     // 0x150C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCLocomotionInstanceTag;                          // 0x1514(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidOffsetDistance;                               // 0x151C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidReturnCenterThreshold;                        // 0x1520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCarriageMoveStopped;                             // 0x1524(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1525[0x3];                                     // 0x1525(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       TargetSplinePathComponent;                         // 0x1528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1530[0x88];                                    // 0x1530(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UNPCLocomotionTemplateBase*             LocomotionABPInstance;                             // 0x15B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C0[0x10];                                    // 0x15C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitMoveCtrlValue();
	void RequestStartMove();
	void RequestStopMove();
	void SetMoveSpeed(float InMoveSpeed);
	void SetTargetSplinePath(const class USplineComponent* InTargetSplinePathComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6WorldCarriageMovementComponent">();
	}
	static class UX6WorldCarriageMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6WorldCarriageMovementComponent>();
	}
};
static_assert(alignof(UX6WorldCarriageMovementComponent) == 0x000010, "Wrong alignment on UX6WorldCarriageMovementComponent");
static_assert(sizeof(UX6WorldCarriageMovementComponent) == 0x0015D0, "Wrong size on UX6WorldCarriageMovementComponent");
static_assert(offsetof(UX6WorldCarriageMovementComponent, StartStepDistance) == 0x0014E0, "Member 'UX6WorldCarriageMovementComponent::StartStepDistance' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, StopMoveTimeOutThreshold) == 0x0014E4, "Member 'UX6WorldCarriageMovementComponent::StopMoveTimeOutThreshold' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, CanShowThreshold) == 0x0014E8, "Member 'UX6WorldCarriageMovementComponent::CanShowThreshold' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, MovingTurnSpeed) == 0x0014EC, "Member 'UX6WorldCarriageMovementComponent::MovingTurnSpeed' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, StarMoveTimeOut) == 0x0014F0, "Member 'UX6WorldCarriageMovementComponent::StarMoveTimeOut' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, TurnInPlaceStateName) == 0x0014F4, "Member 'UX6WorldCarriageMovementComponent::TurnInPlaceStateName' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, StartStateName) == 0x0014FC, "Member 'UX6WorldCarriageMovementComponent::StartStateName' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, CycleStateName) == 0x001504, "Member 'UX6WorldCarriageMovementComponent::CycleStateName' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, StopStateName) == 0x00150C, "Member 'UX6WorldCarriageMovementComponent::StopStateName' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, NPCLocomotionInstanceTag) == 0x001514, "Member 'UX6WorldCarriageMovementComponent::NPCLocomotionInstanceTag' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, AvoidOffsetDistance) == 0x00151C, "Member 'UX6WorldCarriageMovementComponent::AvoidOffsetDistance' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, AvoidReturnCenterThreshold) == 0x001520, "Member 'UX6WorldCarriageMovementComponent::AvoidReturnCenterThreshold' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, OnCarriageMoveStopped) == 0x001524, "Member 'UX6WorldCarriageMovementComponent::OnCarriageMoveStopped' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, TargetSplinePathComponent) == 0x001528, "Member 'UX6WorldCarriageMovementComponent::TargetSplinePathComponent' has a wrong offset!");
static_assert(offsetof(UX6WorldCarriageMovementComponent, LocomotionABPInstance) == 0x0015B8, "Member 'UX6WorldCarriageMovementComponent::LocomotionABPInstance' has a wrong offset!");

// Class X6Game.X6AbilityTask_ApplyRootMotionJumpForce
// 0x0068 (0x0130 - 0x00C8)
class UX6AbilityTask_ApplyRootMotionJumpForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLanded;                                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00E8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Distance;                                          // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0108(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumLandedTriggerTime;                          // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishOnLanded;                                   // 0x0110(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0118(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0120(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UX6AbilityTask_ApplyRootMotionJumpForce* X6ApplyRootMotionJumpForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FRotator& Rotation_0, float Distance_0, float Height_0, float Duration_0, float MinimumLandedTriggerTime_0, bool bFinishOnLanded_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0);

	void Finish();
	void OnLandedCallback(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilityTask_ApplyRootMotionJumpForce">();
	}
	static class UX6AbilityTask_ApplyRootMotionJumpForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilityTask_ApplyRootMotionJumpForce>();
	}
};
static_assert(alignof(UX6AbilityTask_ApplyRootMotionJumpForce) == 0x000008, "Wrong alignment on UX6AbilityTask_ApplyRootMotionJumpForce");
static_assert(sizeof(UX6AbilityTask_ApplyRootMotionJumpForce) == 0x000130, "Wrong size on UX6AbilityTask_ApplyRootMotionJumpForce");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, OnFinish) == 0x0000C8, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::OnFinish' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, OnLanded) == 0x0000D8, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::OnLanded' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, Rotation) == 0x0000E8, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::Rotation' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, Distance) == 0x000100, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::Distance' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, Height) == 0x000104, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::Height' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, Duration) == 0x000108, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::Duration' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, MinimumLandedTriggerTime) == 0x00010C, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::MinimumLandedTriggerTime' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, bFinishOnLanded) == 0x000110, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::bFinishOnLanded' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, PathOffsetCurve) == 0x000118, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::PathOffsetCurve' has a wrong offset!");
static_assert(offsetof(UX6AbilityTask_ApplyRootMotionJumpForce, TimeMappingCurve) == 0x000120, "Member 'UX6AbilityTask_ApplyRootMotionJumpForce::TimeMappingCurve' has a wrong offset!");

// Class X6Game.X6GameplayAbility
// 0x00B8 (0x0468 - 0x03B0)
class UX6GameplayAbility final : public UGameplayAbility
{
public:
	EX6AbilityActivationPolicy                    ActivationPolicy;                                  // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbilityInputTimeoutPeriod;                         // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAbilityInputDuration;                           // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EX6AbilityActivationGroup                     ActivationGroup;                                   // 0x03BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class FText>        FailureTagToUserFacingMessages;                    // 0x03C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAnimMontage*> FailureTagToAnimMontage;                          // 0x0410(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bLogCancelation;                                   // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPassive;                                        // 0x0461(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_462[0x6];                                      // 0x0462(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeActivationGroup(EX6AbilityActivationGroup NewGroup);
	void ClearRootMotionParam();
	void K2_OnAbilityAdded();
	void K2_OnAbilityRemoved();
	void K2_OnPawnAvatarSet();
	void K2_OnPreActivateAbility();
	void MontageDisableRootMotion(bool bDisable);
	int32 SendGameplayEventWithRet(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);

	bool CanChangeActivationGroup(EX6AbilityActivationGroup NewGroup) const;
	class UX6AbilitySystemComponent* GetX6AbilitySystemComponentFromActorInfo() const;
	bool HasAnyTag(const struct FGameplayTagContainer& ContainerToCheck) const;
	bool HasTag(const struct FGameplayTag& TagToCheck) const;
	bool K2_CanActivateAbilityEx(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle) const;
	bool K2_OnCheckCooldown(class AActor* OwnerActor) const;
	bool K2_OnCheckCost(class AActor* OwnerActor) const;
	void ScriptOnAbilityFailedToActivate(const struct FGameplayTagContainer& FailedReason) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameplayAbility">();
	}
	static class UX6GameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameplayAbility>();
	}
};
static_assert(alignof(UX6GameplayAbility) == 0x000008, "Wrong alignment on UX6GameplayAbility");
static_assert(sizeof(UX6GameplayAbility) == 0x000468, "Wrong size on UX6GameplayAbility");
static_assert(offsetof(UX6GameplayAbility, ActivationPolicy) == 0x0003B0, "Member 'UX6GameplayAbility::ActivationPolicy' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, AbilityInputTimeoutPeriod) == 0x0003B4, "Member 'UX6GameplayAbility::AbilityInputTimeoutPeriod' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, MaxAbilityInputDuration) == 0x0003B8, "Member 'UX6GameplayAbility::MaxAbilityInputDuration' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, ActivationGroup) == 0x0003BC, "Member 'UX6GameplayAbility::ActivationGroup' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, FailureTagToUserFacingMessages) == 0x0003C0, "Member 'UX6GameplayAbility::FailureTagToUserFacingMessages' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, FailureTagToAnimMontage) == 0x000410, "Member 'UX6GameplayAbility::FailureTagToAnimMontage' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, bLogCancelation) == 0x000460, "Member 'UX6GameplayAbility::bLogCancelation' has a wrong offset!");
static_assert(offsetof(UX6GameplayAbility, bIsPassive) == 0x000461, "Member 'UX6GameplayAbility::bIsPassive' has a wrong offset!");

// Class X6Game.X6AbilitySet
// 0x0010 (0x0040 - 0x0030)
class UX6AbilitySet final : public UPrimaryDataAsset
{
public:
	TArray<struct FX6AbilitySet_GameplayAbility>  GrantedGameplayAbilities;                          // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilitySet">();
	}
	static class UX6AbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilitySet>();
	}
};
static_assert(alignof(UX6AbilitySet) == 0x000008, "Wrong alignment on UX6AbilitySet");
static_assert(sizeof(UX6AbilitySet) == 0x000040, "Wrong size on UX6AbilitySet");
static_assert(offsetof(UX6AbilitySet, GrantedGameplayAbilities) == 0x000030, "Member 'UX6AbilitySet::GrantedGameplayAbilities' has a wrong offset!");

// Class X6Game.X6AbilitySystemComponent
// 0x0120 (0x1388 - 0x1268)
class UX6AbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_1268[0x8];                                     // 0x1268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNeedReplicateMontageEnded;                        // 0x1270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1271[0x7];                                     // 0x1271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UX6AbilityTagRelationshipMapping*       TagRelationshipMapping;                            // 0x1278(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1280[0x50];                                    // 0x1280(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       CacheAnimatingAbility;                             // 0x12D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilityLocalAnimMontageForMesh> LocalAnimMontageInfoForMeshes;            // 0x12D8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UComboInputData*>                NextComboInputList;                                // 0x12E8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         ComboInputAccumulatedTime;                         // 0x12F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12FC[0x4];                                     // 0x12FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FGameplayAbilitySpecHandle> SkillGroupEndBlockMap;                            // 0x1300(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1350[0x38];                                    // 0x1350(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityInputTagPressed(const struct FGameplayTag& InputTag);
	void AbilityInputTagReleased(const struct FGameplayTag& InputTag);
	void AddGenericTarget(class AActor* Target);
	void AddGenericTargetHitResult(const struct FHitResult& HitResult);
	void CancelAllAbilitiesExceptPassive();
	void ClearGenericTargets();
	void ClearNextComboInputList();
	void ClearTimeOutComboInputData();
	void ClientNotifyAbilityFailed(const class UGameplayAbility* Ability, const struct FGameplayTagContainer& FailureReason);
	void CurrentMontageDisableRootMotion(bool bDisable);
	void EnableComboInputCache(const bool bEnable, const TArray<class UComboInputData*>& InComboInputDataList);
	class AActor* GetGenericTargetActorByIndex(const int32 Index_0);
	class USceneComponent* GetGenericTargetComponentByIndex(const int32 Index_0);
	void K2_CancelAbilitesByTag(const struct FGameplayTag& Tag);
	void K2_ClearAbilitiesFromClass(TSubclassOf<class UX6GameplayAbility> InAbilityClass, bool bClearOnlyOnce);
	class UGameplayAbility* K2_GetAnimatingAbility();
	struct FGameplayAbilitySpecHandle K2_GiveAbilityWithInputTag(TSubclassOf<class UX6GameplayAbility> InAbilityClass, const struct FGameplayTag& InputTag);
	void K2_ReceiveBeginPlay();
	void K2_ReceiveEndPlay(const EEndPlayReason EndPlayReason);
	void K2_SetSkillEndBlock(int32 GroupID, bool bShouldBlock);
	void K2_SpawnBullet(class UPrimaryDataAsset* TriggerData, bool IsModifyHitDirection, class AActor* TargetActor);
	void OnPlayedMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void RemoveGenericTarget(const class AActor* Target);
	void SetTagRelationshipMapping(class UX6AbilityTagRelationshipMapping* NewMapping);
	void SkillInputCancel();
	void SkillInputPressed();
	void SkillInputReleased();
	void UpdateNextComboInputList(const TArray<class UComboInputData*>& InComboInputDataList, float ActivationDuration);
	bool X6HasActivatableAbilityClass(TSubclassOf<class UGameplayAbility> InAbilityToActivate);
	bool X6HasActivatableTriggeredAbility(const struct FGameplayTag& Tag);

	void GetGenericTargetActors(TArray<class AActor*>* OutTargetActors) const;
	void GetGenericTargetComponents(TArray<class USceneComponent*>* OutTargetComponents) const;
	class UGameplayAbility* K2_GetActiveAbilityByTag(const struct FGameplayTag& Tag) const;
	bool K2_GetSkillEndFlag(int32 GroupID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AbilitySystemComponent">();
	}
	static class UX6AbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AbilitySystemComponent>();
	}
};
static_assert(alignof(UX6AbilitySystemComponent) == 0x000008, "Wrong alignment on UX6AbilitySystemComponent");
static_assert(sizeof(UX6AbilitySystemComponent) == 0x001388, "Wrong size on UX6AbilitySystemComponent");
static_assert(offsetof(UX6AbilitySystemComponent, bNeedReplicateMontageEnded) == 0x001270, "Member 'UX6AbilitySystemComponent::bNeedReplicateMontageEnded' has a wrong offset!");
static_assert(offsetof(UX6AbilitySystemComponent, TagRelationshipMapping) == 0x001278, "Member 'UX6AbilitySystemComponent::TagRelationshipMapping' has a wrong offset!");
static_assert(offsetof(UX6AbilitySystemComponent, CacheAnimatingAbility) == 0x0012D0, "Member 'UX6AbilitySystemComponent::CacheAnimatingAbility' has a wrong offset!");
static_assert(offsetof(UX6AbilitySystemComponent, LocalAnimMontageInfoForMeshes) == 0x0012D8, "Member 'UX6AbilitySystemComponent::LocalAnimMontageInfoForMeshes' has a wrong offset!");
static_assert(offsetof(UX6AbilitySystemComponent, NextComboInputList) == 0x0012E8, "Member 'UX6AbilitySystemComponent::NextComboInputList' has a wrong offset!");
static_assert(offsetof(UX6AbilitySystemComponent, ComboInputAccumulatedTime) == 0x0012F8, "Member 'UX6AbilitySystemComponent::ComboInputAccumulatedTime' has a wrong offset!");
static_assert(offsetof(UX6AbilitySystemComponent, SkillGroupEndBlockMap) == 0x001300, "Member 'UX6AbilitySystemComponent::SkillGroupEndBlockMap' has a wrong offset!");

// Class X6Game.X6GameplayCueManager
// 0x0130 (0x0440 - 0x0310)
class UX6GameplayCueManager final : public UGameplayCueManager
{
public:
	TSet<TSubclassOf<class UObject>>              PreloadedCues;                                     // 0x0310(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x50];                                     // 0x0360(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UObject>>              AlwaysLoadedCues;                                  // 0x03B0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x40];                                     // 0x0400(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameplayCueManager">();
	}
	static class UX6GameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameplayCueManager>();
	}
};
static_assert(alignof(UX6GameplayCueManager) == 0x000008, "Wrong alignment on UX6GameplayCueManager");
static_assert(sizeof(UX6GameplayCueManager) == 0x000440, "Wrong size on UX6GameplayCueManager");
static_assert(offsetof(UX6GameplayCueManager, PreloadedCues) == 0x000310, "Member 'UX6GameplayCueManager::PreloadedCues' has a wrong offset!");
static_assert(offsetof(UX6GameplayCueManager, AlwaysLoadedCues) == 0x0003B0, "Member 'UX6GameplayCueManager::AlwaysLoadedCues' has a wrong offset!");

// Class X6Game.X6AnimNotifyState_DisableRootMotion
// 0x0000 (0x0030 - 0x0030)
class UX6AnimNotifyState_DisableRootMotion final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimNotifyState_DisableRootMotion">();
	}
	static class UX6AnimNotifyState_DisableRootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimNotifyState_DisableRootMotion>();
	}
};
static_assert(alignof(UX6AnimNotifyState_DisableRootMotion) == 0x000008, "Wrong alignment on UX6AnimNotifyState_DisableRootMotion");
static_assert(sizeof(UX6AnimNotifyState_DisableRootMotion) == 0x000030, "Wrong size on UX6AnimNotifyState_DisableRootMotion");

// Class X6Game.X6AnimNotify_PlayNiagaraEffect
// 0x00A8 (0x00E0 - 0x0038)
class alignas(0x10) UX6AnimNotify_PlayNiagaraEffect final : public UAnimNotify
{
public:
	class UNiagaraSystem*                         Template;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0070(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UX6NiagaraEffectParam*>          Parameters;                                        // 0x0088(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x37];                                      // 0x0099(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         Attached : 1;                                      // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x00D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAttachParentBound;                             // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFXSystemComponent* GetSpawnedEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AnimNotify_PlayNiagaraEffect">();
	}
	static class UX6AnimNotify_PlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AnimNotify_PlayNiagaraEffect>();
	}
};
static_assert(alignof(UX6AnimNotify_PlayNiagaraEffect) == 0x000010, "Wrong alignment on UX6AnimNotify_PlayNiagaraEffect");
static_assert(sizeof(UX6AnimNotify_PlayNiagaraEffect) == 0x0000E0, "Wrong size on UX6AnimNotify_PlayNiagaraEffect");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, Template) == 0x000038, "Member 'UX6AnimNotify_PlayNiagaraEffect::Template' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, LocationOffset) == 0x000040, "Member 'UX6AnimNotify_PlayNiagaraEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, RotationOffset) == 0x000058, "Member 'UX6AnimNotify_PlayNiagaraEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, Scale) == 0x000070, "Member 'UX6AnimNotify_PlayNiagaraEffect::Scale' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, Parameters) == 0x000088, "Member 'UX6AnimNotify_PlayNiagaraEffect::Parameters' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, bAbsoluteScale) == 0x000098, "Member 'UX6AnimNotify_PlayNiagaraEffect::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, SocketName) == 0x0000D4, "Member 'UX6AnimNotify_PlayNiagaraEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UX6AnimNotify_PlayNiagaraEffect, bUseAttachParentBound) == 0x0000DC, "Member 'UX6AnimNotify_PlayNiagaraEffect::bUseAttachParentBound' has a wrong offset!");

// Class X6Game.GameFeatureAction_AddAbilities
// 0x0060 (0x00D8 - 0x0078)
class UGameFeatureAction_AddAbilities final : public UGameFeatureAction_WorldActionBase
{
public:
	TArray<struct FGameFeatureAbilitiesEntry>     AbilitiesList;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x50];                                      // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_AddAbilities">();
	}
	static class UGameFeatureAction_AddAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_AddAbilities>();
	}
};
static_assert(alignof(UGameFeatureAction_AddAbilities) == 0x000008, "Wrong alignment on UGameFeatureAction_AddAbilities");
static_assert(sizeof(UGameFeatureAction_AddAbilities) == 0x0000D8, "Wrong size on UGameFeatureAction_AddAbilities");
static_assert(offsetof(UGameFeatureAction_AddAbilities, AbilitiesList) == 0x000078, "Member 'UGameFeatureAction_AddAbilities::AbilitiesList' has a wrong offset!");

// Class X6Game.X6GameFeaturePolicy
// 0x0010 (0x0038 - 0x0028)
class UX6GameFeaturePolicy final : public UDefaultGameFeaturesProjectPolicies
{
public:
	TArray<class UObject*>                        Observers;                                         // 0x0028(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6GameFeaturePolicy">();
	}
	static class UX6GameFeaturePolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6GameFeaturePolicy>();
	}
};
static_assert(alignof(UX6GameFeaturePolicy) == 0x000008, "Wrong alignment on UX6GameFeaturePolicy");
static_assert(sizeof(UX6GameFeaturePolicy) == 0x000038, "Wrong size on UX6GameFeaturePolicy");
static_assert(offsetof(UX6GameFeaturePolicy, Observers) == 0x000028, "Member 'UX6GameFeaturePolicy::Observers' has a wrong offset!");

// Class X6Game.CombatCollisionInterface
// 0x0000 (0x0000 - 0x0000)
class ICombatCollisionInterface final : public IInterface
{
public:
	int32 GetCombatFilterPriority() const;
	bool IsCombatBulletFilter() const;
	bool IsCombatHitCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombatCollisionInterface">();
	}
	static class ICombatCollisionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICombatCollisionInterface>();
	}
};
static_assert(alignof(ICombatCollisionInterface) == 0x000001, "Wrong alignment on ICombatCollisionInterface");
static_assert(sizeof(ICombatCollisionInterface) == 0x000001, "Wrong size on ICombatCollisionInterface");

// Class X6Game.X6ArcListView
// 0x0288 (0x0550 - 0x02C8)
class UX6ArcListView final : public UListViewBase
{
public:
	uint8                                         Pad_2C8[0xD8];                                     // 0x02C8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTableViewStyle                        WidgetStyle;                                       // 0x03A0(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EConsumeMouseWheel                            ConsumeMouseWheel;                                 // 0x0480(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClearSelectionOnClick;                            // 0x0481(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFocusable;                                      // 0x0482(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EX6ArcOrientation                             ArcOrientation;                                    // 0x0483(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Curvature;                                         // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EntrySpacing;                                      // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleDecreasingPerItem;                            // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ColorDecreasingPerItem;                            // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSnapToSlot;                                       // 0x0498(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignToEdge;                                      // 0x0499(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCenterArrange;                                    // 0x049A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEntryRotate;                                      // 0x049B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableInertial;                                   // 0x049C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnFocusToSelection;                           // 0x049D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasMask;                                          // 0x049E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49F[0x1];                                      // 0x049F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopMaskParameterName;                              // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BottomMaskParameterName;                           // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        ListItems;                                         // 0x04B0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget)> BP_OnEntryInitialized; // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item)> BP_OnItemClicked;                            // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item)> BP_OnItemDoubleClicked;                      // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, bool bIsHovered)> BP_OnItemIsHoveredChanged;  // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, bool bIsSelected)> BP_OnItemSelectionChanged; // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget)> BP_OnItemScrolledIntoView; // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item)> BP_OnItemSnapToSlot;                         // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItem(class UObject* Item);
	void BP_CancelScrollIntoView();
	void BP_ClearSelection();
	void BP_NavigateToItem(class UObject* Item);
	void BP_NavigateToWidget(class UUserWidget* EntryWidget);
	void BP_ScrollItemIntoView(class UObject* Item);
	void BP_SetItemSelection(class UObject* Item, bool bSelected);
	void BP_SetListItems(const TArray<class UObject*>& InListItems);
	void BP_SetSelectedItem(class UObject* Item);
	void ClearListItems();
	void NavigateToIndex(int32 Index_0);
	void OnListItemEndPlayed(class AActor* Item, EEndPlayReason EndPlayReason);
	void OnListItemOuterEndPlayed(class AActor* ItemOuter, EEndPlayReason EndPlayReason);
	void RemoveItem(class UObject* Item);
	void ScrollIndexIntoView(int32 Index_0);
	void SetSelectedIndex(int32 Index_0);

	bool BP_CanScrollWithLoop() const;
	int32 BP_GetNumItemsSelected() const;
	class UObject* BP_GetSelectedItem() const;
	bool BP_GetSelectedItems(TArray<class UObject*>* Items) const;
	bool BP_IsItemVisible(class UObject* Item) const;
	int32 GetIndexForItem(const class UObject* Item) const;
	class UObject* GetItemAt(int32 Index_0) const;
	const TArray<class UObject*> GetListItems() const;
	int32 GetNumItems() const;
	bool IsRefreshPending() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ArcListView">();
	}
	static class UX6ArcListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ArcListView>();
	}
};
static_assert(alignof(UX6ArcListView) == 0x000010, "Wrong alignment on UX6ArcListView");
static_assert(sizeof(UX6ArcListView) == 0x000550, "Wrong size on UX6ArcListView");
static_assert(offsetof(UX6ArcListView, WidgetStyle) == 0x0003A0, "Member 'UX6ArcListView::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, ConsumeMouseWheel) == 0x000480, "Member 'UX6ArcListView::ConsumeMouseWheel' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bClearSelectionOnClick) == 0x000481, "Member 'UX6ArcListView::bClearSelectionOnClick' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bIsFocusable) == 0x000482, "Member 'UX6ArcListView::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, ArcOrientation) == 0x000483, "Member 'UX6ArcListView::ArcOrientation' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, Curvature) == 0x000488, "Member 'UX6ArcListView::Curvature' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, EntrySpacing) == 0x00048C, "Member 'UX6ArcListView::EntrySpacing' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, ScaleDecreasingPerItem) == 0x000490, "Member 'UX6ArcListView::ScaleDecreasingPerItem' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, ColorDecreasingPerItem) == 0x000494, "Member 'UX6ArcListView::ColorDecreasingPerItem' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bSnapToSlot) == 0x000498, "Member 'UX6ArcListView::bSnapToSlot' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bAlignToEdge) == 0x000499, "Member 'UX6ArcListView::bAlignToEdge' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bCenterArrange) == 0x00049A, "Member 'UX6ArcListView::bCenterArrange' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bEntryRotate) == 0x00049B, "Member 'UX6ArcListView::bEntryRotate' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bEnableInertial) == 0x00049C, "Member 'UX6ArcListView::bEnableInertial' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bReturnFocusToSelection) == 0x00049D, "Member 'UX6ArcListView::bReturnFocusToSelection' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, bHasMask) == 0x00049E, "Member 'UX6ArcListView::bHasMask' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, TopMaskParameterName) == 0x0004A0, "Member 'UX6ArcListView::TopMaskParameterName' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BottomMaskParameterName) == 0x0004A8, "Member 'UX6ArcListView::BottomMaskParameterName' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, ListItems) == 0x0004B0, "Member 'UX6ArcListView::ListItems' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnEntryInitialized) == 0x0004D0, "Member 'UX6ArcListView::BP_OnEntryInitialized' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnItemClicked) == 0x0004E0, "Member 'UX6ArcListView::BP_OnItemClicked' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnItemDoubleClicked) == 0x0004F0, "Member 'UX6ArcListView::BP_OnItemDoubleClicked' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnItemIsHoveredChanged) == 0x000500, "Member 'UX6ArcListView::BP_OnItemIsHoveredChanged' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnItemSelectionChanged) == 0x000510, "Member 'UX6ArcListView::BP_OnItemSelectionChanged' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnItemScrolledIntoView) == 0x000520, "Member 'UX6ArcListView::BP_OnItemScrolledIntoView' has a wrong offset!");
static_assert(offsetof(UX6ArcListView, BP_OnItemSnapToSlot) == 0x000530, "Member 'UX6ArcListView::BP_OnItemSnapToSlot' has a wrong offset!");

// Class X6Game.X6ArcListViewDesignerPreviewItem
// 0x0000 (0x0028 - 0x0028)
class UX6ArcListViewDesignerPreviewItem final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6ArcListViewDesignerPreviewItem">();
	}
	static class UX6ArcListViewDesignerPreviewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6ArcListViewDesignerPreviewItem>();
	}
};
static_assert(alignof(UX6ArcListViewDesignerPreviewItem) == 0x000008, "Wrong alignment on UX6ArcListViewDesignerPreviewItem");
static_assert(sizeof(UX6ArcListViewDesignerPreviewItem) == 0x000028, "Wrong size on UX6ArcListViewDesignerPreviewItem");

// Class X6Game.X6HitThroughImage
// 0x0188 (0x0310 - 0x0188)
class UX6HitThroughImage final : public UWidget
{
public:
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0190(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0260(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0280(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipForRightToLeftFlowDirection;                  // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent; // 0x0294(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonUpEvent; // 0x02A4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseMoveEvent; // 0x02B4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4C];                                     // 0x02C4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromAtlasInterface(TScriptInterface<class ISlateTextureAtlasInterface> AtlasRegion, bool bMatchSize);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromSoftMaterial(TSoftObjectPtr<class UMaterialInterface> SoftMaterial);
	void SetBrushFromSoftTexture(TSoftObjectPtr<class UTexture2D> SoftTexture, bool bMatchSize);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize);
	void SetBrushResourceObject(class UObject* ResourceObject);
	void SetBrushTintColor(const struct FSlateColor& TintColor);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetDesiredSizeOverride(const struct FVector2D& DesiredSize);
	void SetOpacity(float InOpacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6HitThroughImage">();
	}
	static class UX6HitThroughImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6HitThroughImage>();
	}
};
static_assert(alignof(UX6HitThroughImage) == 0x000010, "Wrong alignment on UX6HitThroughImage");
static_assert(sizeof(UX6HitThroughImage) == 0x000310, "Wrong size on UX6HitThroughImage");
static_assert(offsetof(UX6HitThroughImage, Brush) == 0x000190, "Member 'UX6HitThroughImage::Brush' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, BrushDelegate) == 0x000260, "Member 'UX6HitThroughImage::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, ColorAndOpacity) == 0x000270, "Member 'UX6HitThroughImage::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, ColorAndOpacityDelegate) == 0x000280, "Member 'UX6HitThroughImage::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, bFlipForRightToLeftFlowDirection) == 0x000290, "Member 'UX6HitThroughImage::bFlipForRightToLeftFlowDirection' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, OnMouseButtonDownEvent) == 0x000294, "Member 'UX6HitThroughImage::OnMouseButtonDownEvent' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, OnMouseButtonUpEvent) == 0x0002A4, "Member 'UX6HitThroughImage::OnMouseButtonUpEvent' has a wrong offset!");
static_assert(offsetof(UX6HitThroughImage, OnMouseMoveEvent) == 0x0002B4, "Member 'UX6HitThroughImage::OnMouseMoveEvent' has a wrong offset!");

// Class X6Game.X6SoloLevelSubsystem
// 0x0028 (0x0058 - 0x0030)
class UX6SoloLevelSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindSoloLevelPausedEvent(TDelegate<void(bool bPaused)> PausedDelegate);
	bool IsInSoloLevelPausedMode(class UObject* InWorldContextObject);
	void SetDefaultSoloLevelPaused(class UObject* InWorldContextObject, bool bPaused);
	void SetSoloLevelPauseEnabled(class UObject* InWorldContextObject, bool bEnabled);
	void UnbindSoloLevelPausedEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6SoloLevelSubsystem">();
	}
	static class UX6SoloLevelSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6SoloLevelSubsystem>();
	}
};
static_assert(alignof(UX6SoloLevelSubsystem) == 0x000008, "Wrong alignment on UX6SoloLevelSubsystem");
static_assert(sizeof(UX6SoloLevelSubsystem) == 0x000058, "Wrong size on UX6SoloLevelSubsystem");

}

