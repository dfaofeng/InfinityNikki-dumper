#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SMSystem

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SMSystem_structs.hpp"


namespace SDK
{

// Class SMSystem.SMInstanceInterface
// 0x0000 (0x0000 - 0x0000)
class ISMInstanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMInstanceInterface">();
	}
	static class ISMInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISMInstanceInterface>();
	}
};
static_assert(alignof(ISMInstanceInterface) == 0x000001, "Wrong alignment on ISMInstanceInterface");
static_assert(sizeof(ISMInstanceInterface) == 0x000001, "Wrong size on ISMInstanceInterface");

// Class SMSystem.SMStateMachineInterface
// 0x0000 (0x0000 - 0x0000)
class ISMStateMachineInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineInterface">();
	}
	static class ISMStateMachineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISMStateMachineInterface>();
	}
};
static_assert(alignof(ISMStateMachineInterface) == 0x000001, "Wrong alignment on ISMStateMachineInterface");
static_assert(sizeof(ISMStateMachineInterface) == 0x000001, "Wrong size on ISMStateMachineInterface");

// Class SMSystem.SMStateMachineNetworkedInterface
// 0x0000 (0x0000 - 0x0000)
class ISMStateMachineNetworkedInterface final : public IInterface
{
public:
	bool HasAuthority() const;
	bool IsConfiguredForNetworking() const;
	bool IsSimulatedProxy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineNetworkedInterface">();
	}
	static class ISMStateMachineNetworkedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISMStateMachineNetworkedInterface>();
	}
};
static_assert(alignof(ISMStateMachineNetworkedInterface) == 0x000001, "Wrong alignment on ISMStateMachineNetworkedInterface");
static_assert(sizeof(ISMStateMachineNetworkedInterface) == 0x000001, "Wrong size on ISMStateMachineNetworkedInterface");

// Class SMSystem.SMBlueprint
// 0x0008 (0x00B0 - 0x00A8)
class USMBlueprint final : public UBlueprint
{
public:
	int32                                         AssetVersion;                                      // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PluginVersion;                                     // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMBlueprint">();
	}
	static class USMBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMBlueprint>();
	}
};
static_assert(alignof(USMBlueprint) == 0x000008, "Wrong alignment on USMBlueprint");
static_assert(sizeof(USMBlueprint) == 0x0000B0, "Wrong size on USMBlueprint");
static_assert(offsetof(USMBlueprint, AssetVersion) == 0x0000A8, "Member 'USMBlueprint::AssetVersion' has a wrong offset!");
static_assert(offsetof(USMBlueprint, PluginVersion) == 0x0000AC, "Member 'USMBlueprint::PluginVersion' has a wrong offset!");

// Class SMSystem.SMNodeBlueprint
// 0x0008 (0x00B0 - 0x00A8)
class USMNodeBlueprint final : public UBlueprint
{
public:
	int32                                         AssetVersion;                                      // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PluginVersion;                                     // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMNodeBlueprint">();
	}
	static class USMNodeBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMNodeBlueprint>();
	}
};
static_assert(alignof(USMNodeBlueprint) == 0x000008, "Wrong alignment on USMNodeBlueprint");
static_assert(sizeof(USMNodeBlueprint) == 0x0000B0, "Wrong size on USMNodeBlueprint");
static_assert(offsetof(USMNodeBlueprint, AssetVersion) == 0x0000A8, "Member 'USMNodeBlueprint::AssetVersion' has a wrong offset!");
static_assert(offsetof(USMNodeBlueprint, PluginVersion) == 0x0000AC, "Member 'USMNodeBlueprint::PluginVersion' has a wrong offset!");

// Class SMSystem.SMBlueprintGeneratedClass
// 0x0010 (0x0370 - 0x0360)
class USMBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	struct FGuid                                  RootGuid;                                          // 0x0360(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMBlueprintGeneratedClass">();
	}
	static class USMBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMBlueprintGeneratedClass>();
	}
};
static_assert(alignof(USMBlueprintGeneratedClass) == 0x000008, "Wrong alignment on USMBlueprintGeneratedClass");
static_assert(sizeof(USMBlueprintGeneratedClass) == 0x000370, "Wrong size on USMBlueprintGeneratedClass");
static_assert(offsetof(USMBlueprintGeneratedClass, RootGuid) == 0x000360, "Member 'USMBlueprintGeneratedClass::RootGuid' has a wrong offset!");

// Class SMSystem.SMNodeBlueprintGeneratedClass
// 0x0000 (0x0360 - 0x0360)
class USMNodeBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMNodeBlueprintGeneratedClass">();
	}
	static class USMNodeBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMNodeBlueprintGeneratedClass>();
	}
};
static_assert(alignof(USMNodeBlueprintGeneratedClass) == 0x000008, "Wrong alignment on USMNodeBlueprintGeneratedClass");
static_assert(sizeof(USMNodeBlueprintGeneratedClass) == 0x000360, "Wrong size on USMNodeBlueprintGeneratedClass");

// Class SMSystem.SMNodeInstance
// 0x0020 (0x0048 - 0x0028)
class USMNodeInstance : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  TemplateGuid;                                      // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UObject* GetContext() const;
	const struct FGuid GetGuid() const;
	TScriptInterface<class ISMStateMachineNetworkedInterface> GetNetworkInterface() const;
	class FString GetNodeName() const;
	class USMStateMachineInstance* GetOwningStateMachineNodeInstance() const;
	class USMInstance* GetStateMachineInstance(bool bTopMostInstance) const;
	float GetTimeInState() const;
	bool HasUpdated() const;
	bool IsActive() const;
	bool IsInEndState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMNodeInstance">();
	}
	static class USMNodeInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMNodeInstance>();
	}
};
static_assert(alignof(USMNodeInstance) == 0x000008, "Wrong alignment on USMNodeInstance");
static_assert(sizeof(USMNodeInstance) == 0x000048, "Wrong size on USMNodeInstance");
static_assert(offsetof(USMNodeInstance, TemplateGuid) == 0x000038, "Member 'USMNodeInstance::TemplateGuid' has a wrong offset!");

// Class SMSystem.SMStateInstance_Base
// 0x0060 (0x00A8 - 0x0048)
class USMStateInstance_Base : public USMNodeInstance
{
public:
	bool                                          bAlwaysUpdate;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableTickTransitionEvaluation;                  // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEvalTransitionsOnStart;                           // 0x004A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bExcludeFromAnyState : 1;                          // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AnimGroupTag;                                      // 0x0050(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   StanceTagGroup;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class USMStateInstance_Base* StateInstance)> OnStateBeginEvent;    // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMStateInstance_Base* StateInstance)> OnPostStateBeginEvent; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMStateInstance_Base* StateInstance, float DeltaSeconds)> OnStateUpdateEvent; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMStateInstance_Base* StateInstance)> OnStateEndEvent;      // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void EvaluateTransitions();
	void SetActive(bool bValue, bool bSetAllParents, bool bActivateNow);
	void SetAlwaysUpdate(const bool bValue);
	void SetAnimGroupTag(const struct FGameplayTag& Value);
	void SetDisableTickTransitionEvaluation(const bool bValue);
	void SetEvalTransitionsOnStart(const bool bValue);
	void SetExcludeFromAnyState(const bool bValue);
	void SetStanceTagGroup(const TArray<struct FGameplayTag>& StanceTagGroup_0);
	bool SwitchToLinkedState(class USMStateInstance_Base* NextStateInstance, bool bRequireTransitionToPass, bool bActivateNow);
	bool SwitchToLinkedStateByName(const class FString& NextStateName, bool bRequireTransitionToPass, bool bActivateNow);
	bool SwitchToLinkedStateByTransition(class USMTransitionInstance* TransitionInstance, bool bRequireTransitionToPass, bool bActivateNow);

	bool AreAllIncomingTransitionsFromAnAnyState() const;
	bool AreAllOutgoingTransitionsFromAnAnyState() const;
	bool GetAlwaysUpdate() const;
	struct FGameplayTag GetAnimGroupTag() const;
	bool GetDisableTickTransitionEvaluation() const;
	bool GetEvalTransitionsOnStart() const;
	bool GetExcludeFromAnyState() const;
	bool GetIncomingTransitions(TArray<class USMTransitionInstance*>* Transitions, bool bExcludeAlwaysFalse) const;
	class USMStateInstance_Base* GetNextStateByName(const class FString& StateName) const;
	class USMStateInstance_Base* GetNextStateByTransitionIndex(int32 Index_0) const;
	bool GetOutgoingTransitions(TArray<class USMTransitionInstance*>* Transitions, bool bExcludeAlwaysFalse) const;
	class USMStateInstance_Base* GetPreviousActiveState() const;
	class USMTransitionInstance* GetPreviousActiveTransition() const;
	class USMStateInstance_Base* GetPreviousStateByName(const class FString& StateName) const;
	float GetServerTimeInState(bool* bOutUsedLocalTime) const;
	TArray<struct FGameplayTag> GetStanceTagGroup() const;
	const struct FDateTime GetStartTime() const;
	void GetStateInfo(struct FSMStateInfo* State) const;
	class USMTransitionInstance* GetTransitionByIndex(int32 Index_0) const;
	class USMTransitionInstance* GetTransitionToTake() const;
	bool IsEntryState() const;
	bool IsStateMachine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateInstance_Base">();
	}
	static class USMStateInstance_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateInstance_Base>();
	}
};
static_assert(alignof(USMStateInstance_Base) == 0x000008, "Wrong alignment on USMStateInstance_Base");
static_assert(sizeof(USMStateInstance_Base) == 0x0000A8, "Wrong size on USMStateInstance_Base");
static_assert(offsetof(USMStateInstance_Base, bAlwaysUpdate) == 0x000048, "Member 'USMStateInstance_Base::bAlwaysUpdate' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, bDisableTickTransitionEvaluation) == 0x000049, "Member 'USMStateInstance_Base::bDisableTickTransitionEvaluation' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, bEvalTransitionsOnStart) == 0x00004A, "Member 'USMStateInstance_Base::bEvalTransitionsOnStart' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, AnimGroupTag) == 0x000050, "Member 'USMStateInstance_Base::AnimGroupTag' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, StanceTagGroup) == 0x000058, "Member 'USMStateInstance_Base::StanceTagGroup' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnStateBeginEvent) == 0x000068, "Member 'USMStateInstance_Base::OnStateBeginEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnPostStateBeginEvent) == 0x000078, "Member 'USMStateInstance_Base::OnPostStateBeginEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnStateUpdateEvent) == 0x000088, "Member 'USMStateInstance_Base::OnStateUpdateEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnStateEndEvent) == 0x000098, "Member 'USMStateInstance_Base::OnStateEndEvent' has a wrong offset!");

// Class SMSystem.SMConduitInstance
// 0x0008 (0x00B0 - 0x00A8)
class USMConduitInstance final : public USMStateInstance_Base
{
public:
	bool                                          bEvalWithTransitions;                              // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEvaluate;                                      // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanEvaluate(const bool bValue);
	void SetEvalWithTransitions(const bool bValue);

	bool GetCanEvaluate() const;
	bool GetEvalWithTransitions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMConduitInstance">();
	}
	static class USMConduitInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMConduitInstance>();
	}
};
static_assert(alignof(USMConduitInstance) == 0x000008, "Wrong alignment on USMConduitInstance");
static_assert(sizeof(USMConduitInstance) == 0x0000B0, "Wrong size on USMConduitInstance");
static_assert(offsetof(USMConduitInstance, bEvalWithTransitions) == 0x0000A8, "Member 'USMConduitInstance::bEvalWithTransitions' has a wrong offset!");
static_assert(offsetof(USMConduitInstance, bCanEvaluate) == 0x0000A9, "Member 'USMConduitInstance::bCanEvaluate' has a wrong offset!");

// Class SMSystem.SMInstance
// 0x05D0 (0x05F8 - 0x0028)
class USMInstance : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSMReferenceContainer>          ReplicatedReferences;                              // 0x0060(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FGuid                                  RootStateMachineGuid;                              // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnPreStateMachineInitializedEvent;   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineInitializedEvent;      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineStartedEvent;          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, float DeltaSeconds)> OnStateMachineUpdatedEvent; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineStoppedEvent;          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineShutdownEvent;         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, const struct FSMTransitionInfo& Transition)> OnStateMachineTransitionTakenEvent; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, const struct FSMStateInfo& NewState, const struct FSMStateInfo& PreviousState)> OnStateMachineStateChangedEvent; // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, const struct FSMStateInfo& State)> OnStateMachineStateStartedEvent; // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USMStateMachineComponent*               ComponentOwner;                                    // 0x0110(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class ISMStateMachineNetworkedInterface> NetworkInterface;                      // 0x0118(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x140];                                    // 0x0128(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSMStateMachine                        RootStateMachine;                                  // 0x0268(0x0240)(Protected, NativeAccessSpecifierProtected)
	class UObject*                                R_StateMachineContext;                             // 0x04A8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USMInstance*                            ReferenceOwner;                                    // 0x04B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USMStateMachineInstance>    StateMachineClass;                                 // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoManageTime : 1;                               // 0x04C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStopOnEndState : 1;                               // 0x04C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanEverTick : 1;                                  // 0x04C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanTickWhenPaused : 1;                            // 0x04C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickRegistered : 1;                               // 0x04C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickBeforeInitialize : 1;                         // 0x04C0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickBeforeBeginPlay : 1;                          // 0x04C0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x04C4(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSMStateHistory>                StateHistory;                                      // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         StateHistoryMaxCount;                              // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableLogging : 1;                                // 0x04EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLogStateChange : 1;                               // 0x04EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLogTransitionTaken : 1;                           // 0x04EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanReplicateAsReference : 1;                      // 0x04EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4ED[0x3];                                      // 0x04ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FGuid>              PathGuidRedirectMap;                               // 0x04F0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UDataTable*                             ExportDataTable;                                   // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FSMGuidMap>         RootPathGuidCache;                                 // 0x0548(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ReferenceTemplates;                                // 0x0598(0x0010)(ExportObject, ZeroConstructor, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FSMExposedNodeFunctions> NodeExposedFunctions;                         // 0x05A8(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ClearLoadedStates();
	void ClearStateHistory();
	bool EvaluateAndFindTransitionChain(class USMTransitionInstance* InFirstTransitionInstance, TArray<class USMTransitionInstance*>* OutTransitionChain, class USMStateInstance_Base** OutDestinationState, bool bRequirePreviousStateActive);
	bool EvaluateAndTakeTransitionChain(class USMTransitionInstance* InFirstTransitionInstance);
	void EvaluateTransitions();
	TMap<struct FGuid, struct FGuid> GetGuidRedirectMap();
	class USMInstance* GetMasterReferenceOwner();
	class USMInstance* GetPrimaryReferenceOwner();
	void Initialize(class UObject* Context);
	bool Internal_EvaluateAndTakeTransitionChainByGuid(const struct FGuid& PathGuid);
	void Internal_EventCleanup(const struct FGuid& PathGuid);
	void Internal_EventUpdate();
	void Internal_Update(float DeltaSeconds);
	void K2_TryGetNetworkInterface(TScriptInterface<class ISMStateMachineNetworkedInterface>* Interface, bool* bIsValid);
	void LoadFromMultipleStates(const TArray<struct FGuid>& FromGuids, bool bNotify);
	void LoadFromState(const struct FGuid& FromGuid, bool bAllParents, bool bNotify);
	void OnPreStateMachineInitialized();
	void OnStateMachineInitialized();
	void OnStateMachineInitialStateLoaded(const struct FGuid& StateGuid);
	void OnStateMachineShutdown();
	void OnStateMachineStart();
	void OnStateMachineStateChanged(const struct FSMStateInfo& ToState, const struct FSMStateInfo& FromState);
	void OnStateMachineStateStarted(const struct FSMStateInfo& State);
	void OnStateMachineStop();
	void OnStateMachineTransitionTaken(const struct FSMTransitionInfo& Transition);
	void OnStateMachineUpdate(float DeltaSeconds);
	void PreloadAllNodeInstances();
	void REP_OnReplicatedReferencesLoaded();
	void ReplicatedRestart();
	void ReplicatedStart();
	void ReplicatedStop();
	void Restart();
	void RunUpdateAsReference(float DeltaSeconds);
	void SetAutoManageTime(bool Value);
	void SetCanEverTick(bool Value);
	void SetCanTickWhenPaused(bool Value);
	void SetContext(class UObject* Context);
	void SetGuidRedirectMap(const TMap<struct FGuid, struct FGuid>& InGuidMap);
	void SetStateHistoryMaxCount(int32 NewSize);
	void SetStateMachineClass(TSubclassOf<class USMStateMachineInstance> NewStateMachineClass);
	void SetStopOnEndState(bool Value);
	void SetTickBeforeBeginPlay(bool Value);
	void SetTickInterval(float Value);
	void SetTickOnManualUpdate(bool Value);
	void Shutdown();
	void Start();
	void StartWithNewContext(class UObject* Context);
	void Stop();
	void SwitchActiveState(class USMStateInstance_Base* NewStateInstance, bool bDeactivateOtherStates);
	void SwitchActiveStateByQualifiedName(const class FString& InFullPath, bool bDeactivateOtherStates);
	bool TakeTransitionChain(const TArray<class USMTransitionInstance*>& InTransitionChain);
	void Tick(float DeltaTime);
	void Update(float DeltaSeconds);

	bool AreInitialStatesSetFromLoad() const;
	bool CanAutoManageTime() const;
	bool CanEverTick() const;
	bool CanTickOnManualUpdate() const;
	struct FGuid GetActiveStateGuid() const;
	class USMStateInstance_Base* GetActiveStateInstance(bool bCheckNested) const;
	class FString GetActiveStateName() const;
	void GetAllActiveStateGuids(TArray<struct FGuid>* ActiveGuids) const;
	void GetAllActiveStateInstances(TArray<class USMStateInstance_Base*>* ActiveStateInstances) const;
	TArray<struct FGuid> GetAllCurrentStateGuids() const;
	TArray<class USMInstance*> GetAllReferencedInstances(bool bIncludeChildren) const;
	void GetAllStateInstances(TArray<class USMStateInstance_Base*>* StateInstances) const;
	void GetAllTransitionInstances(TArray<class USMTransitionInstance*>* TransitionInstances) const;
	class USMStateMachineComponent* GetComponentOwner() const;
	class UObject* GetContext() const;
	class UDataTable* GetExportDataTable() const;
	struct FGuid GetNestedActiveStateGuid() const;
	class FString GetNestedActiveStateName() const;
	TScriptInterface<class ISMStateMachineNetworkedInterface> GetNetworkInterface() const;
	class USMNodeInstance* GetNodeInstanceByGuid(const struct FGuid& Guid) const;
	class USMInstance* GetReferencedInstanceByGuid(const struct FGuid& Guid) const;
	class USMInstance* GetReferenceOwner() const;
	class USMStateMachineInstance* GetRootStateMachineInstance() const;
	class USMStateMachineInstance* GetRootStateMachineNodeInstance() const;
	struct FGuid GetSingleActiveStateGuid(bool bCheckNested) const;
	class USMStateInstance_Base* GetSingleActiveStateInstance(bool bCheckNested) const;
	const TArray<struct FSMStateHistory> GetStateHistory() const;
	int32 GetStateHistoryMaxCount() const;
	class USMStateInstance_Base* GetStateInstanceByGuid(const struct FGuid& Guid) const;
	class USMStateInstance_Base* GetStateInstanceByQualifiedName(const class FString& InFullPath) const;
	TSubclassOf<class USMStateMachineInstance> GetStateMachineClass() const;
	bool GetStopOnEndState() const;
	float GetTickInterval() const;
	class USMTransitionInstance* GetTransitionInstanceByGuid(const struct FGuid& Guid) const;
	bool HasStarted() const;
	bool IsActive() const;
	bool IsInEndState() const;
	bool IsInitialized() const;
	bool IsTickable() const;
	bool IsTickableWhenPaused() const;
	void TryGetNestedActiveState(struct FSMStateInfo* FoundState, bool* bSuccess) const;
	void TryGetStateInfo(const struct FGuid& Guid, struct FSMStateInfo* StateInfo, bool* bSuccess) const;
	void TryGetTransitionInfo(const struct FGuid& Guid, struct FSMTransitionInfo* TransitionInfo, bool* bSuccess) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMInstance">();
	}
	static class USMInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMInstance>();
	}
};
static_assert(alignof(USMInstance) == 0x000008, "Wrong alignment on USMInstance");
static_assert(sizeof(USMInstance) == 0x0005F8, "Wrong size on USMInstance");
static_assert(offsetof(USMInstance, ReplicatedReferences) == 0x000060, "Member 'USMInstance::ReplicatedReferences' has a wrong offset!");
static_assert(offsetof(USMInstance, RootStateMachineGuid) == 0x000070, "Member 'USMInstance::RootStateMachineGuid' has a wrong offset!");
static_assert(offsetof(USMInstance, OnPreStateMachineInitializedEvent) == 0x000080, "Member 'USMInstance::OnPreStateMachineInitializedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineInitializedEvent) == 0x000090, "Member 'USMInstance::OnStateMachineInitializedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStartedEvent) == 0x0000A0, "Member 'USMInstance::OnStateMachineStartedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineUpdatedEvent) == 0x0000B0, "Member 'USMInstance::OnStateMachineUpdatedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStoppedEvent) == 0x0000C0, "Member 'USMInstance::OnStateMachineStoppedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineShutdownEvent) == 0x0000D0, "Member 'USMInstance::OnStateMachineShutdownEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineTransitionTakenEvent) == 0x0000E0, "Member 'USMInstance::OnStateMachineTransitionTakenEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStateChangedEvent) == 0x0000F0, "Member 'USMInstance::OnStateMachineStateChangedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStateStartedEvent) == 0x000100, "Member 'USMInstance::OnStateMachineStateStartedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, ComponentOwner) == 0x000110, "Member 'USMInstance::ComponentOwner' has a wrong offset!");
static_assert(offsetof(USMInstance, NetworkInterface) == 0x000118, "Member 'USMInstance::NetworkInterface' has a wrong offset!");
static_assert(offsetof(USMInstance, RootStateMachine) == 0x000268, "Member 'USMInstance::RootStateMachine' has a wrong offset!");
static_assert(offsetof(USMInstance, R_StateMachineContext) == 0x0004A8, "Member 'USMInstance::R_StateMachineContext' has a wrong offset!");
static_assert(offsetof(USMInstance, ReferenceOwner) == 0x0004B0, "Member 'USMInstance::ReferenceOwner' has a wrong offset!");
static_assert(offsetof(USMInstance, StateMachineClass) == 0x0004B8, "Member 'USMInstance::StateMachineClass' has a wrong offset!");
static_assert(offsetof(USMInstance, TickInterval) == 0x0004C4, "Member 'USMInstance::TickInterval' has a wrong offset!");
static_assert(offsetof(USMInstance, StateHistory) == 0x0004D8, "Member 'USMInstance::StateHistory' has a wrong offset!");
static_assert(offsetof(USMInstance, StateHistoryMaxCount) == 0x0004E8, "Member 'USMInstance::StateHistoryMaxCount' has a wrong offset!");
static_assert(offsetof(USMInstance, PathGuidRedirectMap) == 0x0004F0, "Member 'USMInstance::PathGuidRedirectMap' has a wrong offset!");
static_assert(offsetof(USMInstance, ExportDataTable) == 0x000540, "Member 'USMInstance::ExportDataTable' has a wrong offset!");
static_assert(offsetof(USMInstance, RootPathGuidCache) == 0x000548, "Member 'USMInstance::RootPathGuidCache' has a wrong offset!");
static_assert(offsetof(USMInstance, ReferenceTemplates) == 0x000598, "Member 'USMInstance::ReferenceTemplates' has a wrong offset!");
static_assert(offsetof(USMInstance, NodeExposedFunctions) == 0x0005A8, "Member 'USMInstance::NodeExposedFunctions' has a wrong offset!");

// Class SMSystem.SMRuntimeSettings
// 0x0008 (0x0030 - 0x0028)
class USMRuntimeSettings final : public UObject
{
public:
	bool                                          bPreloadDefaultNodes;                              // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMRuntimeSettings">();
	}
	static class USMRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMRuntimeSettings>();
	}
};
static_assert(alignof(USMRuntimeSettings) == 0x000008, "Wrong alignment on USMRuntimeSettings");
static_assert(sizeof(USMRuntimeSettings) == 0x000030, "Wrong size on USMRuntimeSettings");
static_assert(offsetof(USMRuntimeSettings, bPreloadDefaultNodes) == 0x000028, "Member 'USMRuntimeSettings::bPreloadDefaultNodes' has a wrong offset!");

// Class SMSystem.SMStateInstance
// 0x0000 (0x00A8 - 0x00A8)
class USMStateInstance final : public USMStateInstance_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateInstance">();
	}
	static class USMStateInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateInstance>();
	}
};
static_assert(alignof(USMStateInstance) == 0x000008, "Wrong alignment on USMStateInstance");
static_assert(sizeof(USMStateInstance) == 0x0000A8, "Wrong size on USMStateInstance");

// Class SMSystem.SMStateMachineComponent
// 0x0160 (0x0208 - 0x00A8)
class USMStateMachineComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineInitializedEvent;      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineStartedEvent;          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, float DeltaSeconds)> OnStateMachineUpdatedEvent; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineStoppedEvent;          // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance)> OnStateMachineShutdownEvent;         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, const struct FSMTransitionInfo& Transition)> OnStateMachineTransitionTakenEvent; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, const struct FSMStateInfo& NewState, const struct FSMStateInfo& PreviousState)> OnStateMachineStateChangedEvent; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USMInstance* Instance, const struct FSMStateInfo& State)> OnStateMachineStateStartedEvent; // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class UActorChannel*>                    CurrentActorChannels;                              // 0x0138(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x24];                                     // 0x0188(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutomaticallyHandleNewConnections : 1;            // 0x01AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USMInstance>                StateMachineClass;                                 // 0x01B0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInitializeOnBeginPlay : 1;                        // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartOnBeginPlay : 1;                             // 0x01B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopOnEndPlay : 1;                                // 0x01B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLetInstanceManageTick : 1;                        // 0x01B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReuseInstanceAfterShutdown : 1;                   // 0x01B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESMNetworkConfigurationType                   StateChangeAuthority;                              // 0x01B9(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkTransitionConfiguration;                    // 0x01BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkTickConfiguration;                          // 0x01BB(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkStateExecution;                             // 0x01BC(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkStateConfiguration;                         // 0x01BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeSimulatedProxies : 1;                      // 0x01BE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESMNetworkConfigurationType                   NetworkTransitionEnteredConfiguration;             // 0x01BF(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWaitForTransactionsFromServer : 1;                // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTakeTransitionsFromServerOnly : 1;                // 0x01C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHandleControllerChange : 1;                       // 0x01C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCalculateServerTimeForClients : 1;                // 0x01C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseOwnerNetUpdateFrequency : 1;                   // 0x01C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerNetUpdateFrequency;                          // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientNetUpdateFrequency;                          // 0x01C8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysMulticast : 1;                              // 0x01CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDiscardTransitionsBeforeInitialize : 1;           // 0x01CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReplicateStatesOnLoad : 1;                        // 0x01CC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionResetTimeSeconds;                        // 0x01D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToWaitForTransitionUpdate;                  // 0x01D4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USMStateMachineComponent*               ComponentToCopy;                                   // 0x01D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USMInstance*                            R_Instance;                                        // 0x01E8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USMInstance*                            InstanceTemplate;                                  // 0x01F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, DuplicateTransient, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverrideTick : 1;                                 // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanEverTick : 1;                                  // 0x01F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverrideTickInterval : 1;                         // 0x01F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanInstanceNetworkTick : 1;                       // 0x01F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x01FC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CLIENT_ActivateStates(const TArray<struct FSMActivateStateTransaction>& StateTransactions);
	void CLIENT_FullSync(const struct FSMFullSyncTransaction& FullSyncTransaction);
	void CLIENT_Shutdown(const struct FSMTransaction_Base& Transaction);
	void CLIENT_Start(const struct FSMTransaction_Base& Transaction);
	void CLIENT_Stop(const struct FSMTransaction_Base& Transaction);
	void CLIENT_TakeTransitions(const TArray<struct FSMTransitionTransaction>& Transactions);
	void CopySettingsFromOtherComponent(class USMStateMachineComponent* OtherComponent);
	void Initialize(class UObject* Context);
	void Internal_OnReplicatedInstanceInitialized(class USMInstance* Instance);
	void Internal_OnStateMachineShutdown(class USMInstance* Instance);
	void Internal_OnStateMachineStarted(class USMInstance* Instance);
	void Internal_OnStateMachineStateChanged(class USMInstance* Instance, const struct FSMStateInfo& ToState, const struct FSMStateInfo& FromState);
	void Internal_OnStateMachineStateStarted(class USMInstance* Instance, const struct FSMStateInfo& State);
	void Internal_OnStateMachineStopped(class USMInstance* Instance);
	void Internal_OnStateMachineTransitionTaken(class USMInstance* Instance, const struct FSMTransitionInfo& Transition);
	void Internal_OnStateMachineUpdated(class USMInstance* Instance, float DeltaSeconds);
	void MULTICAST_ActivateStates(const TArray<struct FSMActivateStateTransaction>& StateTransactions);
	void MULTICAST_FullSync(const struct FSMFullSyncTransaction& FullSyncTransaction);
	void MULTICAST_Shutdown(const struct FSMTransaction_Base& Transaction);
	void MULTICAST_Start(const struct FSMTransaction_Base& Transaction);
	void MULTICAST_Stop(const struct FSMTransaction_Base& Transaction);
	void MULTICAST_TakeTransitions(const TArray<struct FSMTransitionTransaction>& Transactions);
	void OnContextPawnControllerChanged(class APawn* Pawn, class AController* NewController);
	void OnPostInitialize();
	void REP_OnInstanceLoaded();
	void Restart();
	void SERVER_ActivateStates(const TArray<struct FSMActivateStateTransaction>& StateTransactions);
	void SERVER_FullSync(const struct FSMFullSyncTransaction& FullSyncTransaction);
	void SERVER_Initialize(const struct FSMInitializeTransaction& Transaction);
	void SERVER_RequestFullSync(bool bForceFullRefresh);
	void SERVER_Shutdown(const struct FSMTransaction_Base& Transaction);
	void SERVER_Start(const struct FSMTransaction_Base& Transaction);
	void SERVER_Stop(const struct FSMTransaction_Base& Transaction);
	void SERVER_TakeTransitions(const TArray<struct FSMTransitionTransaction>& TransitionTransactions);
	void SERVER_Update(float DeltaTime);
	void SetCanInstanceNetworkTick(bool bCanEverTick_0);
	void Shutdown();
	void Start();
	void Stop();
	void Update(float DeltaSeconds);

	class UObject* GetContextForInitialization() const;
	class USMInstance* GetInstance() const;
	class AActor* GetTopMostParentActor() const;
	bool IsInitialized() const;
	bool IsStateMachineActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineComponent">();
	}
	static class USMStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateMachineComponent>();
	}
};
static_assert(alignof(USMStateMachineComponent) == 0x000008, "Wrong alignment on USMStateMachineComponent");
static_assert(sizeof(USMStateMachineComponent) == 0x000208, "Wrong size on USMStateMachineComponent");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineInitializedEvent) == 0x0000B8, "Member 'USMStateMachineComponent::OnStateMachineInitializedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStartedEvent) == 0x0000C8, "Member 'USMStateMachineComponent::OnStateMachineStartedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineUpdatedEvent) == 0x0000D8, "Member 'USMStateMachineComponent::OnStateMachineUpdatedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStoppedEvent) == 0x0000E8, "Member 'USMStateMachineComponent::OnStateMachineStoppedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineShutdownEvent) == 0x0000F8, "Member 'USMStateMachineComponent::OnStateMachineShutdownEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineTransitionTakenEvent) == 0x000108, "Member 'USMStateMachineComponent::OnStateMachineTransitionTakenEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStateChangedEvent) == 0x000118, "Member 'USMStateMachineComponent::OnStateMachineStateChangedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStateStartedEvent) == 0x000128, "Member 'USMStateMachineComponent::OnStateMachineStateStartedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, CurrentActorChannels) == 0x000138, "Member 'USMStateMachineComponent::CurrentActorChannels' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, StateMachineClass) == 0x0001B0, "Member 'USMStateMachineComponent::StateMachineClass' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, StateChangeAuthority) == 0x0001B9, "Member 'USMStateMachineComponent::StateChangeAuthority' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkTransitionConfiguration) == 0x0001BA, "Member 'USMStateMachineComponent::NetworkTransitionConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkTickConfiguration) == 0x0001BB, "Member 'USMStateMachineComponent::NetworkTickConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkStateExecution) == 0x0001BC, "Member 'USMStateMachineComponent::NetworkStateExecution' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkStateConfiguration) == 0x0001BD, "Member 'USMStateMachineComponent::NetworkStateConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkTransitionEnteredConfiguration) == 0x0001BF, "Member 'USMStateMachineComponent::NetworkTransitionEnteredConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, ServerNetUpdateFrequency) == 0x0001C4, "Member 'USMStateMachineComponent::ServerNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, ClientNetUpdateFrequency) == 0x0001C8, "Member 'USMStateMachineComponent::ClientNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, TransitionResetTimeSeconds) == 0x0001D0, "Member 'USMStateMachineComponent::TransitionResetTimeSeconds' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, MaxTimeToWaitForTransitionUpdate) == 0x0001D4, "Member 'USMStateMachineComponent::MaxTimeToWaitForTransitionUpdate' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, ComponentToCopy) == 0x0001D8, "Member 'USMStateMachineComponent::ComponentToCopy' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, R_Instance) == 0x0001E8, "Member 'USMStateMachineComponent::R_Instance' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, InstanceTemplate) == 0x0001F0, "Member 'USMStateMachineComponent::InstanceTemplate' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, TickInterval) == 0x0001FC, "Member 'USMStateMachineComponent::TickInterval' has a wrong offset!");

// Class SMSystem.SMStateMachineInstance
// 0x0008 (0x00B0 - 0x00A8)
class USMStateMachineInstance final : public USMStateInstance_Base
{
public:
	bool                                          bWaitForEndState;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReuseCurrentState;                                // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReuseIfNotEndState;                               // 0x00AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetReuseCurrentState(const bool bValue);
	void SetReuseIfNotEndState(const bool bValue);
	void SetWaitForEndState(const bool bValue);

	void GetActiveStates(TArray<class USMStateInstance_Base*>* ActiveStates) const;
	void GetAllStateInstances(TArray<class USMStateInstance_Base*>* StateInstances) const;
	class USMStateInstance_Base* GetContainedStateByName(const class FString& StateName) const;
	void GetEntryStates(TArray<class USMStateInstance_Base*>* EntryStates) const;
	bool GetReuseCurrentState() const;
	bool GetReuseIfNotEndState() const;
	class USMInstance* GetStateMachineReference() const;
	bool GetWaitForEndState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineInstance">();
	}
	static class USMStateMachineInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateMachineInstance>();
	}
};
static_assert(alignof(USMStateMachineInstance) == 0x000008, "Wrong alignment on USMStateMachineInstance");
static_assert(sizeof(USMStateMachineInstance) == 0x0000B0, "Wrong size on USMStateMachineInstance");
static_assert(offsetof(USMStateMachineInstance, bWaitForEndState) == 0x0000A8, "Member 'USMStateMachineInstance::bWaitForEndState' has a wrong offset!");
static_assert(offsetof(USMStateMachineInstance, bReuseCurrentState) == 0x0000A9, "Member 'USMStateMachineInstance::bReuseCurrentState' has a wrong offset!");
static_assert(offsetof(USMStateMachineInstance, bReuseIfNotEndState) == 0x0000AA, "Member 'USMStateMachineInstance::bReuseIfNotEndState' has a wrong offset!");

// Class SMSystem.SMTransitionInstance
// 0x0068 (0x00B0 - 0x0048)
class USMTransitionInstance final : public USMNodeInstance
{
public:
	int32                                         PriorityOrder;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEvaluate;                                      // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEvaluateFromEvent;                             // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEvalWithStartState;                            // 0x004E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFastTransition;                                   // 0x004F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           LinkedSequenceTag;                                 // 0x0050(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSMBlendSetting                        BlendSettings;                                     // 0x0058(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           FastLinkedSequenceTag;                             // 0x0078(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSMBlendSetting                        FastBlendSettings;                                 // 0x0080(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class USMTransitionInstance* TransitionInstance)> OnTransitionEnteredEvent; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool EvaluateFromManuallyBoundEvent();
	void SetBlendSetting(const struct FSMBlendSetting& Value);
	void SetCanEvaluate(const bool bValue);
	void SetCanEvaluateFromEvent(const bool bValue);
	void SetCanEvalWithStartState(const bool bValue);
	void SetFastTransitionFlag(bool bValue);
	void SetLinkSequenceTag(const struct FGameplayTag& Value);
	void SetPriorityOrder(const int32 Value);

	bool DoesTransitionPass() const;
	const struct FSMBlendSetting GetBlendSetting() const;
	bool GetCanEvaluate() const;
	bool GetCanEvaluateFromEvent() const;
	bool GetCanEvalWithStartState() const;
	class USMStateInstance_Base* GetDestinationStateForActiveTransition() const;
	const struct FSMBlendSetting GetFastBlendSetting() const;
	struct FGameplayTag GetFastLinkSequenceTag() const;
	bool GetFastTransitionFlag() const;
	struct FGameplayTag GetLinkSequenceTag() const;
	class USMStateInstance_Base* GetNextStateInstance() const;
	class USMStateInstance_Base* GetPreviousStateInstance() const;
	int32 GetPriorityOrder() const;
	const struct FDateTime GetServerTimestamp() const;
	class USMStateInstance_Base* GetSourceStateForActiveTransition() const;
	void GetTransitionInfo(struct FSMTransitionInfo* Transition) const;
	bool IsTransitionFromAnyState() const;
	bool IsTransitionFromLinkState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMTransitionInstance">();
	}
	static class USMTransitionInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMTransitionInstance>();
	}
};
static_assert(alignof(USMTransitionInstance) == 0x000008, "Wrong alignment on USMTransitionInstance");
static_assert(sizeof(USMTransitionInstance) == 0x0000B0, "Wrong size on USMTransitionInstance");
static_assert(offsetof(USMTransitionInstance, PriorityOrder) == 0x000048, "Member 'USMTransitionInstance::PriorityOrder' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, bCanEvaluate) == 0x00004C, "Member 'USMTransitionInstance::bCanEvaluate' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, bCanEvaluateFromEvent) == 0x00004D, "Member 'USMTransitionInstance::bCanEvaluateFromEvent' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, bCanEvalWithStartState) == 0x00004E, "Member 'USMTransitionInstance::bCanEvalWithStartState' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, bFastTransition) == 0x00004F, "Member 'USMTransitionInstance::bFastTransition' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, LinkedSequenceTag) == 0x000050, "Member 'USMTransitionInstance::LinkedSequenceTag' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, BlendSettings) == 0x000058, "Member 'USMTransitionInstance::BlendSettings' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, FastLinkedSequenceTag) == 0x000078, "Member 'USMTransitionInstance::FastLinkedSequenceTag' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, FastBlendSettings) == 0x000080, "Member 'USMTransitionInstance::FastBlendSettings' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, OnTransitionEnteredEvent) == 0x0000A0, "Member 'USMTransitionInstance::OnTransitionEnteredEvent' has a wrong offset!");

// Class SMSystem.SMBlueprintUtils
// 0x0000 (0x0028 - 0x0028)
class USMBlueprintUtils final : public UBlueprintFunctionLibrary
{
public:
	static class USMInstance* CreateStateMachineInstanceFromTemplate(TSubclassOf<class USMInstance> StateMachineClass, class UObject* Context, class USMInstance* Template, bool bInitializeNow);
	static class USMInstance* K2_CreateStateMachineInstance(TSubclassOf<class USMInstance> StateMachineClass, class UObject* Context, bool bInitializeNow);
	static class USMInstance* K2_CreateStateMachineInstanceFromObject(class UObject* InObj, class UObject* Context, bool bInitializeNow);
	static class USMInstance* K2_CreateStateMachineInstancePure(TSubclassOf<class USMInstance> StateMachineClass, class UObject* Context, bool bInitializeNow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMBlueprintUtils">();
	}
	static class USMBlueprintUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMBlueprintUtils>();
	}
};
static_assert(alignof(USMBlueprintUtils) == 0x000008, "Wrong alignment on USMBlueprintUtils");
static_assert(sizeof(USMBlueprintUtils) == 0x000028, "Wrong size on USMBlueprintUtils");

}

