#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UIPF

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function UIPF.UIPFActor.Init
// 0x0001 (0x0001 - 0x0000)
struct UIPFActor_Init final
{
public:
	bool                                          bFromManual;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFActor_Init) == 0x000001, "Wrong alignment on UIPFActor_Init");
static_assert(sizeof(UIPFActor_Init) == 0x000001, "Wrong size on UIPFActor_Init");
static_assert(offsetof(UIPFActor_Init, bFromManual) == 0x000000, "Member 'UIPFActor_Init::bFromManual' has a wrong offset!");

// Function UIPF.UIPFActor.SkeletonSleep
// 0x0010 (0x0010 - 0x0000)
struct UIPFActor_SkeletonSleep final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   bone;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFActor_SkeletonSleep) == 0x000008, "Wrong alignment on UIPFActor_SkeletonSleep");
static_assert(sizeof(UIPFActor_SkeletonSleep) == 0x000010, "Wrong size on UIPFActor_SkeletonSleep");
static_assert(offsetof(UIPFActor_SkeletonSleep, Comp) == 0x000000, "Member 'UIPFActor_SkeletonSleep::Comp' has a wrong offset!");
static_assert(offsetof(UIPFActor_SkeletonSleep, bone) == 0x000008, "Member 'UIPFActor_SkeletonSleep::bone' has a wrong offset!");

// Function UIPF.UIPFImpulse.InitializeImpulse
// 0x000C (0x000C - 0x0000)
struct UIPFImpulse_InitializeImpulse final
{
public:
	float                                         ImpulseRadius;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingTruePhys;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingShaderInt;                                    // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseStrength;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFImpulse_InitializeImpulse) == 0x000004, "Wrong alignment on UIPFImpulse_InitializeImpulse");
static_assert(sizeof(UIPFImpulse_InitializeImpulse) == 0x00000C, "Wrong size on UIPFImpulse_InitializeImpulse");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, ImpulseRadius) == 0x000000, "Member 'UIPFImpulse_InitializeImpulse::ImpulseRadius' has a wrong offset!");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, UsingTruePhys) == 0x000004, "Member 'UIPFImpulse_InitializeImpulse::UsingTruePhys' has a wrong offset!");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, UsingShaderInt) == 0x000005, "Member 'UIPFImpulse_InitializeImpulse::UsingShaderInt' has a wrong offset!");
static_assert(offsetof(UIPFImpulse_InitializeImpulse, ImpulseStrength) == 0x000008, "Member 'UIPFImpulse_InitializeImpulse::ImpulseStrength' has a wrong offset!");

// Function UIPF.UIPFInteractor.GetCustomLocation
// 0x0018 (0x0018 - 0x0000)
struct UIPFInteractor_GetCustomLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFInteractor_GetCustomLocation) == 0x000008, "Wrong alignment on UIPFInteractor_GetCustomLocation");
static_assert(sizeof(UIPFInteractor_GetCustomLocation) == 0x000018, "Wrong size on UIPFInteractor_GetCustomLocation");
static_assert(offsetof(UIPFInteractor_GetCustomLocation, ReturnValue) == 0x000000, "Member 'UIPFInteractor_GetCustomLocation::ReturnValue' has a wrong offset!");

// Function UIPF.UIPFInteractor.GetCustomVelocity
// 0x0020 (0x0020 - 0x0000)
struct UIPFInteractor_GetCustomVelocity final
{
public:
	struct FVector4                               ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFInteractor_GetCustomVelocity) == 0x000010, "Wrong alignment on UIPFInteractor_GetCustomVelocity");
static_assert(sizeof(UIPFInteractor_GetCustomVelocity) == 0x000020, "Wrong size on UIPFInteractor_GetCustomVelocity");
static_assert(offsetof(UIPFInteractor_GetCustomVelocity, ReturnValue) == 0x000000, "Member 'UIPFInteractor_GetCustomVelocity::ReturnValue' has a wrong offset!");

// Function UIPF.UIPFInteractor.GetUIPFManagerToRegister
// 0x0008 (0x0008 - 0x0000)
struct UIPFInteractor_GetUIPFManagerToRegister final
{
public:
	class AUIPFManager*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFInteractor_GetUIPFManagerToRegister) == 0x000008, "Wrong alignment on UIPFInteractor_GetUIPFManagerToRegister");
static_assert(sizeof(UIPFInteractor_GetUIPFManagerToRegister) == 0x000008, "Wrong size on UIPFInteractor_GetUIPFManagerToRegister");
static_assert(offsetof(UIPFInteractor_GetUIPFManagerToRegister, ReturnValue) == 0x000000, "Member 'UIPFInteractor_GetUIPFManagerToRegister::ReturnValue' has a wrong offset!");

// Function UIPF.UIPFInteractor.ManuallyActivateFoliage
// 0x0100 (0x0100 - 0x0000)
struct UIPFInteractor_ManuallyActivateFoliage final
{
public:
	bool                                          WithImpulse;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x00F8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFInteractor_ManuallyActivateFoliage) == 0x000008, "Wrong alignment on UIPFInteractor_ManuallyActivateFoliage");
static_assert(sizeof(UIPFInteractor_ManuallyActivateFoliage) == 0x000100, "Wrong size on UIPFInteractor_ManuallyActivateFoliage");
static_assert(offsetof(UIPFInteractor_ManuallyActivateFoliage, WithImpulse) == 0x000000, "Member 'UIPFInteractor_ManuallyActivateFoliage::WithImpulse' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_ManuallyActivateFoliage, ImpulseStrength) == 0x000004, "Member 'UIPFInteractor_ManuallyActivateFoliage::ImpulseStrength' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_ManuallyActivateFoliage, Hit) == 0x000008, "Member 'UIPFInteractor_ManuallyActivateFoliage::Hit' has a wrong offset!");

// Function UIPF.UIPFInteractor.OnDeactivationEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct UIPFInteractor_OnDeactivationEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFInteractor_OnDeactivationEndOverlap) == 0x000008, "Wrong alignment on UIPFInteractor_OnDeactivationEndOverlap");
static_assert(sizeof(UIPFInteractor_OnDeactivationEndOverlap) == 0x000020, "Wrong size on UIPFInteractor_OnDeactivationEndOverlap");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OverlappedComponent) == 0x000000, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OtherActor) == 0x000008, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OtherComp) == 0x000010, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(UIPFInteractor_OnDeactivationEndOverlap, OtherBodyIndex) == 0x000018, "Member 'UIPFInteractor_OnDeactivationEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function UIPF.UIPFManager.SetGlobalUIPFInteractive
// 0x0010 (0x0010 - 0x0000)
struct UIPFManager_SetGlobalUIPFInteractive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValue;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFManager_SetGlobalUIPFInteractive) == 0x000008, "Wrong alignment on UIPFManager_SetGlobalUIPFInteractive");
static_assert(sizeof(UIPFManager_SetGlobalUIPFInteractive) == 0x000010, "Wrong size on UIPFManager_SetGlobalUIPFInteractive");
static_assert(offsetof(UIPFManager_SetGlobalUIPFInteractive, WorldContextObject) == 0x000000, "Member 'UIPFManager_SetGlobalUIPFInteractive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIPFManager_SetGlobalUIPFInteractive, InValue) == 0x000008, "Member 'UIPFManager_SetGlobalUIPFInteractive::InValue' has a wrong offset!");

// Function UIPF.UIPFManager.DrawUIPFMaterialtoRenderTarget
// 0x0018 (0x0018 - 0x0000)
struct UIPFManager_DrawUIPFMaterialtoRenderTarget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFManager_DrawUIPFMaterialtoRenderTarget) == 0x000008, "Wrong alignment on UIPFManager_DrawUIPFMaterialtoRenderTarget");
static_assert(sizeof(UIPFManager_DrawUIPFMaterialtoRenderTarget) == 0x000018, "Wrong size on UIPFManager_DrawUIPFMaterialtoRenderTarget");
static_assert(offsetof(UIPFManager_DrawUIPFMaterialtoRenderTarget, WorldContextObject) == 0x000000, "Member 'UIPFManager_DrawUIPFMaterialtoRenderTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIPFManager_DrawUIPFMaterialtoRenderTarget, TextureRenderTarget) == 0x000008, "Member 'UIPFManager_DrawUIPFMaterialtoRenderTarget::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(UIPFManager_DrawUIPFMaterialtoRenderTarget, Material) == 0x000010, "Member 'UIPFManager_DrawUIPFMaterialtoRenderTarget::Material' has a wrong offset!");

// Function UIPF.UIPFManager.FoliageForceAtLocation
// 0x0050 (0x0050 - 0x0000)
struct UIPFManager_FoliageForceAtLocation final
{
public:
	class UObject*                                Interactor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fStrength;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fSizePercent;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImpulse;                                        // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TypeIndex;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingRadius;                                        // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawVelDirection;                                 // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFManager_FoliageForceAtLocation) == 0x000008, "Wrong alignment on UIPFManager_FoliageForceAtLocation");
static_assert(sizeof(UIPFManager_FoliageForceAtLocation) == 0x000050, "Wrong size on UIPFManager_FoliageForceAtLocation");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, Interactor) == 0x000000, "Member 'UIPFManager_FoliageForceAtLocation::Interactor' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, fStrength) == 0x000008, "Member 'UIPFManager_FoliageForceAtLocation::fStrength' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, fSizePercent) == 0x00000C, "Member 'UIPFManager_FoliageForceAtLocation::fSizePercent' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, HitLocation) == 0x000010, "Member 'UIPFManager_FoliageForceAtLocation::HitLocation' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, HitDirection) == 0x000028, "Member 'UIPFManager_FoliageForceAtLocation::HitDirection' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, bIsImpulse) == 0x000040, "Member 'UIPFManager_FoliageForceAtLocation::bIsImpulse' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, TypeIndex) == 0x000044, "Member 'UIPFManager_FoliageForceAtLocation::TypeIndex' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, RingRadius) == 0x000048, "Member 'UIPFManager_FoliageForceAtLocation::RingRadius' has a wrong offset!");
static_assert(offsetof(UIPFManager_FoliageForceAtLocation, bDrawVelDirection) == 0x00004C, "Member 'UIPFManager_FoliageForceAtLocation::bDrawVelDirection' has a wrong offset!");

// Function UIPF.UIPFManager.ForceAppliedAtLocation
// 0x0020 (0x0020 - 0x0000)
struct UIPFManager_ForceAppliedAtLocation final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIPFManager_ForceAppliedAtLocation) == 0x000008, "Wrong alignment on UIPFManager_ForceAppliedAtLocation");
static_assert(sizeof(UIPFManager_ForceAppliedAtLocation) == 0x000020, "Wrong size on UIPFManager_ForceAppliedAtLocation");
static_assert(offsetof(UIPFManager_ForceAppliedAtLocation, Loc) == 0x000000, "Member 'UIPFManager_ForceAppliedAtLocation::Loc' has a wrong offset!");
static_assert(offsetof(UIPFManager_ForceAppliedAtLocation, Strength) == 0x000018, "Member 'UIPFManager_ForceAppliedAtLocation::Strength' has a wrong offset!");

// Function UIPF.UIPFManager.ImpulseAtLocation
// 0x0020 (0x0020 - 0x0000)
struct UIPFManager_ImpulseAtLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseDiameter;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStrength;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFManager_ImpulseAtLocation) == 0x000008, "Wrong alignment on UIPFManager_ImpulseAtLocation");
static_assert(sizeof(UIPFManager_ImpulseAtLocation) == 0x000020, "Wrong size on UIPFManager_ImpulseAtLocation");
static_assert(offsetof(UIPFManager_ImpulseAtLocation, Location) == 0x000000, "Member 'UIPFManager_ImpulseAtLocation::Location' has a wrong offset!");
static_assert(offsetof(UIPFManager_ImpulseAtLocation, ImpulseDiameter) == 0x000018, "Member 'UIPFManager_ImpulseAtLocation::ImpulseDiameter' has a wrong offset!");
static_assert(offsetof(UIPFManager_ImpulseAtLocation, ImpulseStrength) == 0x00001C, "Member 'UIPFManager_ImpulseAtLocation::ImpulseStrength' has a wrong offset!");

// Function UIPF.UIPFManager.UpdateInteractorLocation
// 0x0020 (0x0020 - 0x0000)
struct UIPFManager_UpdateInteractorLocation final
{
public:
	int32                                         InteractorID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIPFManager_UpdateInteractorLocation) == 0x000008, "Wrong alignment on UIPFManager_UpdateInteractorLocation");
static_assert(sizeof(UIPFManager_UpdateInteractorLocation) == 0x000020, "Wrong size on UIPFManager_UpdateInteractorLocation");
static_assert(offsetof(UIPFManager_UpdateInteractorLocation, InteractorID) == 0x000000, "Member 'UIPFManager_UpdateInteractorLocation::InteractorID' has a wrong offset!");
static_assert(offsetof(UIPFManager_UpdateInteractorLocation, HitLocation) == 0x000008, "Member 'UIPFManager_UpdateInteractorLocation::HitLocation' has a wrong offset!");

}

