#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: WwiseExtension

#include "Basic.hpp"

#include "Niagara_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "WwiseExtension_structs.hpp"


namespace SDK
{

// Class WwiseExtension.NiagaraDataInterfaceAkEvent
// 0x0010 (0x0048 - 0x0038)
class UNiagaraDataInterfaceAkEvent final : public UNiagaraDataInterface
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPostCountPerTick;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleEndOfEvent(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraDataInterfaceAkEvent">();
	}
	static class UNiagaraDataInterfaceAkEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraDataInterfaceAkEvent>();
	}
};
static_assert(alignof(UNiagaraDataInterfaceAkEvent) == 0x000008, "Wrong alignment on UNiagaraDataInterfaceAkEvent");
static_assert(sizeof(UNiagaraDataInterfaceAkEvent) == 0x000048, "Wrong size on UNiagaraDataInterfaceAkEvent");
static_assert(offsetof(UNiagaraDataInterfaceAkEvent, Event) == 0x000038, "Member 'UNiagaraDataInterfaceAkEvent::Event' has a wrong offset!");
static_assert(offsetof(UNiagaraDataInterfaceAkEvent, MaxPostCountPerTick) == 0x000040, "Member 'UNiagaraDataInterfaceAkEvent::MaxPostCountPerTick' has a wrong offset!");

// Class WwiseExtension.NiagaraDataInterfaceAkRtpc
// 0x0008 (0x0040 - 0x0038)
class UNiagaraDataInterfaceAkRtpc final : public UNiagaraDataInterface
{
public:
	class UAkRtpc*                                AkRtpc;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraDataInterfaceAkRtpc">();
	}
	static class UNiagaraDataInterfaceAkRtpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraDataInterfaceAkRtpc>();
	}
};
static_assert(alignof(UNiagaraDataInterfaceAkRtpc) == 0x000008, "Wrong alignment on UNiagaraDataInterfaceAkRtpc");
static_assert(sizeof(UNiagaraDataInterfaceAkRtpc) == 0x000040, "Wrong size on UNiagaraDataInterfaceAkRtpc");
static_assert(offsetof(UNiagaraDataInterfaceAkRtpc, AkRtpc) == 0x000038, "Member 'UNiagaraDataInterfaceAkRtpc::AkRtpc' has a wrong offset!");

// Class WwiseExtension.SplineSoundComponent
// 0x0000 (0x06C0 - 0x06C0)
class USplineSoundComponent final : public USplineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineSoundComponent">();
	}
	static class USplineSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplineSoundComponent>();
	}
};
static_assert(alignof(USplineSoundComponent) == 0x000010, "Wrong alignment on USplineSoundComponent");
static_assert(sizeof(USplineSoundComponent) == 0x0006C0, "Wrong size on USplineSoundComponent");

// Class WwiseExtension.WwiseExtensionSettings
// 0x0000 (0x0028 - 0x0028)
class UWwiseExtensionSettings final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WwiseExtensionSettings">();
	}
	static class UWwiseExtensionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWwiseExtensionSettings>();
	}
};
static_assert(alignof(UWwiseExtensionSettings) == 0x000008, "Wrong alignment on UWwiseExtensionSettings");
static_assert(sizeof(UWwiseExtensionSettings) == 0x000028, "Wrong size on UWwiseExtensionSettings");

// Class WwiseExtension.X6AkAmbientSound
// 0x0000 (0x03E8 - 0x03E8)
class AX6AkAmbientSound final : public AAkAmbientSound
{
public:
	void X6StartAmbientSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AkAmbientSound">();
	}
	static class AX6AkAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AX6AkAmbientSound>();
	}
};
static_assert(alignof(AX6AkAmbientSound) == 0x000008, "Wrong alignment on AX6AkAmbientSound");
static_assert(sizeof(AX6AkAmbientSound) == 0x0003E8, "Wrong size on AX6AkAmbientSound");

// Class WwiseExtension.AkEventProxy
// 0x0100 (0x0128 - 0x0028)
class UAkEventProxy : public UObject
{
public:
	TMulticastInlineDelegate<void(class UAkEventProxy* AsyncProxy, EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> X6PostEventCallback; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UAkEventProxy* AsyncProxy, int32 PlayingID)> X6PostEventCompleted; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> PostEventCallback; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsVaildX6Callback : 1;                            // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AkComponentCache;                                  // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkParameters                          AkParametersCache;                                 // 0x0068(0x0098)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventCache;                                      // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDurationTime();
	uint32 GetProxyID();
	float GetStartTime();
	void OnPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnPostEventCompleted(int32 InLinkID);
	void PostEventCompletedTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkEventProxy">();
	}
	static class UAkEventProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkEventProxy>();
	}
};
static_assert(alignof(UAkEventProxy) == 0x000008, "Wrong alignment on UAkEventProxy");
static_assert(sizeof(UAkEventProxy) == 0x000128, "Wrong size on UAkEventProxy");
static_assert(offsetof(UAkEventProxy, X6PostEventCallback) == 0x000028, "Member 'UAkEventProxy::X6PostEventCallback' has a wrong offset!");
static_assert(offsetof(UAkEventProxy, X6PostEventCompleted) == 0x000038, "Member 'UAkEventProxy::X6PostEventCompleted' has a wrong offset!");
static_assert(offsetof(UAkEventProxy, PostEventCallback) == 0x000048, "Member 'UAkEventProxy::PostEventCallback' has a wrong offset!");
static_assert(offsetof(UAkEventProxy, PlayingID) == 0x000058, "Member 'UAkEventProxy::PlayingID' has a wrong offset!");
static_assert(offsetof(UAkEventProxy, AkComponentCache) == 0x000060, "Member 'UAkEventProxy::AkComponentCache' has a wrong offset!");
static_assert(offsetof(UAkEventProxy, AkParametersCache) == 0x000068, "Member 'UAkEventProxy::AkParametersCache' has a wrong offset!");
static_assert(offsetof(UAkEventProxy, AkEventCache) == 0x000100, "Member 'UAkEventProxy::AkEventCache' has a wrong offset!");

// Class WwiseExtension.AkBlueprintProxy
// 0x0028 (0x0150 - 0x0128)
class UAkBlueprintProxy final : public UAkEventProxy
{
public:
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkBlueprintProxy">();
	}
	static class UAkBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkBlueprintProxy>();
	}
};
static_assert(alignof(UAkBlueprintProxy) == 0x000008, "Wrong alignment on UAkBlueprintProxy");
static_assert(sizeof(UAkBlueprintProxy) == 0x000150, "Wrong size on UAkBlueprintProxy");

// Class WwiseExtension.X6AkBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UX6AkBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAkEventProxy* CreatePostEventProxyObject(class UAkAudioEvent* AkEvent, class AActor* EventActor, int32 CallbackMask, bool bIsAsync, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static class UAkEventProxy* CreatePostEventProxyObjectAtLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, int32 CallbackMask, const struct FVector& Location, const struct FRotator& Orientation, bool bIsAsync, EX6AkAudioContext AudioContext);
	static class UAkEventProxy* CreatePostEventProxyObjectWithComponent(class UAkAudioEvent* AkEvent, class UAkComponent* AkComponent, int32 CallbackMask, bool bIsAsync, EX6AkAudioContext AudioContext);
	static TSoftObjectPtr<class UAkSwitchValue> GetSurfaceTypeSwitchValue(class UObject* WorldContextObject, EPhysicalSurface InSurfaceType);
	static void PlayRunStepSoundEffectWithSwitch(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class USceneComponent* AttachToComponent, const class FName& AttachName, const TArray<TSoftObjectPtr<class UObject>>& InSwitchSoftRefs, bool bAllowAutoDestory);
	static bool SetJobMgrMaxActiveWorkers(EAkJobType JobType, int64 MaxNumActiveWorkers);
	static bool SetMaxNumVoicesLimit(int32 MaxNumberVoices);
	static void StopSoundByLocation(class UObject* WorldContextObject, const struct FVector& Location);
	static bool X6ExecuteActionOnEvent(class UAkAudioEvent* InAkEvent, EAkActionOnEventType InActionType, class AActor* InActor, int32 InTransitionDuration, EAkCurveInterpolation InFadeCurve, int32 InPlayingID);
	static bool X6ExecuteActionOnPlayingID(EAkActionOnEventType InActionType, int32 InPlayingID, int32 InTransitionDuration, EAkCurveInterpolation InFadeCurve);
	static class UAkComponent* X6GetAkComponent(class USceneComponent* AttachToComponent, bool* ComponentCreated, bool bAllowAutoDestory, class FName AttachPointName, EAttachmentRule AttachmentRule);
	static void X6PostEvent(class UAkAudioEvent* AkEvent, class AActor* EventActor, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static void X6PostEvent2D(class UAkAudioEvent* AkEvent, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources);
	static void X6PostEventAsync(class UAkAudioEvent* AkEvent, class AActor* EventActor, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static void X6PostEventAsync2D(class UAkAudioEvent* AkEvent, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo);
	static void X6PostEventAsyncAtLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, int32* PlayingID, const struct FVector& Location, const struct FRotator& Orientation, const struct FLatentActionInfo& LatentInfo, EX6AkAudioContext AudioContext);
	static void X6PostEventAsyncWithComponent(class UAkAudioEvent* AkEvent, class UAkComponent* AkComponent, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo, EX6AkAudioContext AudioContext);
	static void X6PostEventAtLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, int32* PlayingID, const struct FVector& Location, const struct FRotator& Orientation, EX6AkAudioContext AudioContext);
	static void X6PostEventSoftRef(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class AActor* EventActor, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static void X6PostEventSoftRef2D(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo);
	static void X6PostEventSoftRefAsync(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class AActor* EventActor, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static void X6PostEventSoftRefAsync2D(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo);
	static void X6PostEventSoftRefAsyncAtLocation(class UObject* WorldContextObject, TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, int32* PlayingID, const struct FVector& Location, const struct FRotator& Orientation, const struct FLatentActionInfo& LatentInfo, EX6AkAudioContext AudioContext);
	static void X6PostEventSoftRefAsyncWithComponent(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class UAkComponent* AkComponent, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo, EX6AkAudioContext AudioContext);
	static void X6PostEventSoftRefAtLocation(class UObject* WorldContextObject, TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, int32* PlayingID, const struct FVector& Location, const struct FRotator& Orientation, const struct FLatentActionInfo& LatentInfo, EX6AkAudioContext AudioContext);
	static void X6PostEventSoftRefWithComponent(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class UAkComponent* AkComponent, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const struct FLatentActionInfo& LatentInfo, EX6AkAudioContext AudioContext);
	static void X6PostEventWithComponent(class UAkAudioEvent* AkEvent, class UAkComponent* AkComponent, int32* PlayingID, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, EX6AkAudioContext AudioContext);
	static bool X6SeekEvent(class UAkAudioEvent* InAkEvent, class AActor* InActor, float InSeekPercent, int32 InPlayingID);
	static bool X6SeekEventWithComponent(class UAkAudioEvent* InAkEvent, class UAkComponent* InAkComponent, float InSeekPercent, int32 InPlayingID);
	static void X6SetAkAudioSession(EAkAudioSessionCategory AudioSessionCategory, EAkAudioSessionBehaviorOption AudioSessionBehavior);
	static void X6SetAkAudioSessionCategory(EAkAudioSessionCategory AudioSessionCategory);
	static void X6SetAudioListenerOverride(class UObject* WorldContextObject, float InListenerOffset, bool bDebugListenerTransform);
	static bool X6SetImageSource(int64 InSrcId, const struct FAkImageSourceSettings& InInfo, const class FString& InName, class UAkAuxBus* InAuxBus, class AActor* InActor);
	static void X6SetOfflineRendering(bool bEnable);
	static void X6SetState(class UAkStateValue* StateValue);
	static void X6SetStateSoftRef(TSoftObjectPtr<class UAkStateValue> AkStateSoftRef);
	static void X6SetSwitch(class UAkSwitchValue* SwitchValue, class AActor* Actor);
	static void X6SetSwitchSoftRef(TSoftObjectPtr<class UAkSwitchValue> AkSwitchSoftRef, class AActor* Actor);
	static void X6SetSwitchWithComponent(class UAkSwitchValue* SwitchValue, class UAkComponent* AkComponent);
	static void X6SimplePostEventSoftRef(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class AActor* EventActor, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static void X6SimplePostEventSoftRef2D(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef);
	static void X6SimplePostEventSoftRefAsync(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class AActor* EventActor, bool bAutoDestory, EX6AkAudioContext AudioContext);
	static void X6SimplePostEventSoftRefAsync2D(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef);
	static void X6SimplePostEventSoftRefAsyncAtLocation(class UObject* WorldContextObject, TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, const struct FVector& Location, const struct FRotator& Orientation, EX6AkAudioContext AudioContext);
	static void X6SimplePostEventSoftRefAsyncWithComponent(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class UAkComponent* AkComponent, EX6AkAudioContext AudioContext);
	static void X6SimplePostEventSoftRefAtLocation(class UObject* WorldContextObject, TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, const struct FVector& Location, const struct FRotator& Orientation, EX6AkAudioContext AudioContext);
	static void X6SimplePostEventSoftRefWithComponent(TSoftObjectPtr<class UAkAudioEvent> AkEventSoftRef, class UAkComponent* AkComponent, EX6AkAudioContext AudioContext);
	static void X6StopSound(class AActor* InActor);
	static void X6Suspend(bool bRenderAnyway);
	static void X6WakeupFromSuspend();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AkBlueprintLibrary">();
	}
	static class UX6AkBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AkBlueprintLibrary>();
	}
};
static_assert(alignof(UX6AkBlueprintLibrary) == 0x000008, "Wrong alignment on UX6AkBlueprintLibrary");
static_assert(sizeof(UX6AkBlueprintLibrary) == 0x000028, "Wrong size on UX6AkBlueprintLibrary");

// Class WwiseExtension.X6AkManager
// 0x0148 (0x0178 - 0x0030)
class UX6AkManager final : public UGameInstanceSubsystem
{
public:
	TArray<class UAkEventProxy*>                  ArrProxy;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FAkEventDebugInfo& AkEventDebugInfo)> AkDebugInfoChanged; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FAkEventActionDebugInfo& AkEventActionDebugInfo)> AkEventActionDebugInfo; // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x58];                                      // 0x0060(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FManagedAkEventInfo>            ManagedAkEventInfos;                               // 0x00B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<uint64, struct FManagedAkGroupInfo>      ManagedAkGroupMap;                                 // 0x00C8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x60];                                     // 0x0118(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AkErrorOutput(const class FString& InErrorString, uint32 InPlayingID, uint64 InGameObjectID);
	void DeinitializeFootstepSoundConfig();
	TArray<struct FAkEventDebugInfo> GetAllAkEventDebugInfos();
	void InitializeFootstepSoundConfig(const class UDataTable* InDataTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X6AkManager">();
	}
	static class UX6AkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX6AkManager>();
	}
};
static_assert(alignof(UX6AkManager) == 0x000008, "Wrong alignment on UX6AkManager");
static_assert(sizeof(UX6AkManager) == 0x000178, "Wrong size on UX6AkManager");
static_assert(offsetof(UX6AkManager, ArrProxy) == 0x000030, "Member 'UX6AkManager::ArrProxy' has a wrong offset!");
static_assert(offsetof(UX6AkManager, AkDebugInfoChanged) == 0x000040, "Member 'UX6AkManager::AkDebugInfoChanged' has a wrong offset!");
static_assert(offsetof(UX6AkManager, AkEventActionDebugInfo) == 0x000050, "Member 'UX6AkManager::AkEventActionDebugInfo' has a wrong offset!");
static_assert(offsetof(UX6AkManager, ManagedAkEventInfos) == 0x0000B8, "Member 'UX6AkManager::ManagedAkEventInfos' has a wrong offset!");
static_assert(offsetof(UX6AkManager, ManagedAkGroupMap) == 0x0000C8, "Member 'UX6AkManager::ManagedAkGroupMap' has a wrong offset!");

}

